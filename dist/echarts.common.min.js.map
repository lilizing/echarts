{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///echarts.common.min.js","webpack:///webpack/bootstrap e2f5d11b7ea9dedb1522?96a2","webpack:///./index.common.js","webpack:///./~/zrender/lib/core/util.js?10f4","webpack:///./lib/echarts.js?e6e0","webpack:///./lib/util/graphic.js?9184","webpack:///./lib/util/number.js?f4a1","webpack:///./~/zrender/lib/core/vector.js?6654","webpack:///./~/zrender/lib/graphic/Path.js?c119","webpack:///./lib/util/model.js?e40b","webpack:///./~/zrender/lib/core/BoundingRect.js?76f6","webpack:///./lib/util/format.js?a0a6","webpack:///./lib/model/Model.js?c24b","webpack:///./~/zrender/lib/core/env.js?9ccc","webpack:///./lib/model/Component.js?4968","webpack:///./lib/util/layout.js?fd92","webpack:///./lib/data/List.js?a3f0","webpack:///./lib/model/Series.js?7862","webpack:///./~/zrender/lib/contain/text.js?3a43","webpack:///./~/zrender/lib/core/curve.js?9511","webpack:///./~/zrender/lib/tool/color.js?284f","webpack:///./~/zrender/lib/core/matrix.js?97a2","webpack:///./~/zrender/lib/mixin/Eventful.js?223b","webpack:///./lib/util/clazz.js?7f2c","webpack:///./lib/coord/axisHelper.js?db6e","webpack:///./lib/CoordinateSystem.js?d208","webpack:///./~/zrender/lib/core/event.js?24ff","webpack:///./lib/component/toolbox/featureManager.js?434a","webpack:///./lib/util/symbol.js?714b","webpack:///./lib/view/Chart.js?81ad","webpack:///./~/zrender/lib/core/PathProxy.js?69e9","webpack:///./~/zrender/lib/graphic/Gradient.js?5165","webpack:///./lib/data/helper/completeDimensions.js?9dc8","webpack:///./lib/model/mixin/makeStyleMapper.js?ad94","webpack:///./lib/scale/Scale.js?fcd6","webpack:///./~/zrender/lib/config.js?2861","webpack:///./~/zrender/lib/container/Group.js?8d57","webpack:///./lib/chart/helper/createListFromArray.js?a2b3","webpack:///./lib/component/grid.js?6810","webpack:///./~/zrender/lib/graphic/Displayable.js?5c45","webpack:///./lib/scale/Interval.js?a2bb","webpack:///./lib/chart/helper/SymbolDraw.js?9ca8","webpack:///./lib/component/dataZoom/DataZoomModel.js?18e1","webpack:///./lib/component/dataZoom/DataZoomView.js?d264","webpack:///./lib/coord/Axis.js?0aab","webpack:///./lib/util/component.js?aafc","webpack:///./~/zrender/lib/core/timsort.js?0a74","webpack:///./lib/data/DataDiffer.js?84f6","webpack:///./lib/visual/symbol.js?c9ef","webpack:///./~/zrender/lib/core/log.js?26a2","webpack:///./~/zrender/lib/graphic/Image.js?bf1b","webpack:///./lib/chart/helper/Symbol.js?4e27","webpack:///./lib/component/axis/AxisBuilder.js?0a10","webpack:///./lib/coord/axisModelCommonMixin.js?e4d6","webpack:///./lib/coord/axisModelCreator.js?bf3f","webpack:///./lib/coord/cartesian/AxisModel.js?818f","webpack:///./lib/coord/cartesian/Grid.js?05e4","webpack:///./lib/layout/points.js?b5cd","webpack:///./lib/model/mixin/colorPalette.js?ee06","webpack:///./lib/view/Component.js?a404","webpack:///./~/zrender/lib/Element.js?325b","webpack:///./~/zrender/lib/animation/Animator.js?d2b9","webpack:///./~/zrender/lib/animation/requestAnimationFrame.js?6d88","webpack:///./~/zrender/lib/contain/util.js?0031","webpack:///./~/zrender/lib/core/guid.js?f0e4","webpack:///./~/zrender/lib/graphic/Pattern.js?a97e","webpack:///./~/zrender/lib/graphic/Style.js?22d9","webpack:///./~/zrender/lib/graphic/helper/poly.js?788c","webpack:///./lib/component/helper/selectableMixin.js?6edb","webpack:///./lib/component/marker/MarkerModel.js?1d58","webpack:///./lib/component/marker/MarkerView.js?f27b","webpack:///./lib/component/marker/markerHelper.js?6102","webpack:///./lib/processor/dataFilter.js?190d","webpack:///./lib/visual/dataColor.js?8fc7","webpack:///./~/zrender/lib/core/bbox.js?1b56","webpack:///./~/zrender/lib/graphic/Text.js?3244","webpack:///./~/zrender/lib/graphic/mixin/RectText.js?94ea","webpack:///./~/zrender/lib/zrender.js?5dcd","webpack:///./lib/action/createDataSelectAction.js?6a00","webpack:///./lib/component/helper/RoamController.js?87ff","webpack:///./lib/component/helper/sliderMove.js?1439","webpack:///./lib/coord/axisDefault.js?767d","webpack:///./lib/coord/axisModelZoomMixin.js?6df9","webpack:///./lib/util/throttle.js?9761","webpack:///./~/zrender/lib/contain/line.js?4326","webpack:///./~/zrender/lib/contain/quadratic.js?f589","webpack:///./~/zrender/lib/contain/windingLine.js?625a","webpack:///./~/zrender/lib/graphic/LinearGradient.js?4250","webpack:///./~/zrender/lib/mixin/Transformable.js?f61b","webpack:///./lib/ExtensionAPI.js?024b","webpack:///./lib/chart/bar.js?a725","webpack:///./lib/chart/bar/BarSeries.js?3b85","webpack:///./lib/chart/bar/BarView.js?9f5d","webpack:///./lib/chart/bar/barItemStyle.js?da00","webpack:///./lib/chart/helper/Line.js?aeb0","webpack:///./lib/chart/helper/LineDraw.js?8de8","webpack:///./lib/chart/line.js?8f10","webpack:///./lib/chart/line/LineSeries.js?c09a","webpack:///./lib/chart/line/LineView.js?c76c","webpack:///./lib/chart/line/lineAnimationDiff.js?ed41","webpack:///./lib/chart/line/poly.js?c10a","webpack:///./lib/chart/pie.js?a050","webpack:///./lib/chart/pie/PieSeries.js?2c87","webpack:///./lib/chart/pie/PieView.js?6515","webpack:///./lib/chart/pie/labelLayout.js?c38b","webpack:///./lib/chart/pie/pieLayout.js?ebc4","webpack:///./lib/component/axis.js?7b6c","webpack:///./lib/component/axis/AxisView.js?a70c","webpack:///./lib/component/dataZoom/dataZoomAction.js?7a1c","webpack:///./lib/component/dataZoom/dataZoomProcessor.js?4e8e","webpack:///./lib/component/dataZoom/helper.js?5bc4","webpack:///./lib/component/dataZoom/history.js?790f","webpack:///./lib/component/dataZoom/typeDefaulter.js?99f9","webpack:///./lib/component/helper/BrushController.js?d34f","webpack:///./lib/component/helper/brushHelper.js?9a46","webpack:///./lib/component/helper/interactionMutex.js?f1a5","webpack:///./lib/component/helper/listComponent.js?9abc","webpack:///./lib/coord/cartesian/Axis2D.js?5107","webpack:///./lib/coord/cartesian/Cartesian.js?b907","webpack:///./lib/coord/cartesian/Cartesian2D.js?c5a5","webpack:///./lib/coord/cartesian/GridModel.js?9110","webpack:///./lib/coord/cartesian/axisLabelInterval.js?cb6f","webpack:///./lib/layout/barGrid.js?6b5f","webpack:///./lib/loading/default.js?7c3a","webpack:///./lib/model/Global.js?1c6f","webpack:///./lib/model/OptionManager.js?ce4b","webpack:///./lib/model/globalDefault.js?507f","webpack:///./lib/model/mixin/areaStyle.js?2e6d","webpack:///./lib/model/mixin/boxLayout.js?3478","webpack:///./lib/model/mixin/itemStyle.js?3f71","webpack:///./lib/model/mixin/lineStyle.js?0fa2","webpack:///./lib/model/mixin/textStyle.js?140e","webpack:///./lib/preprocessor/backwardCompat.js?0937","webpack:///./lib/preprocessor/helper/compatStyle.js?e728","webpack:///./lib/processor/dataSample.js?d230","webpack:///./lib/scale/Log.js?26a9","webpack:///./lib/scale/Ordinal.js?4c4b","webpack:///./lib/scale/Time.js?495f","webpack:///./lib/visual/seriesColor.js?1cd6","webpack:///./~/zrender/lib/Handler.js?fbeb","webpack:///./~/zrender/lib/Layer.js?f586","webpack:///./~/zrender/lib/Painter.js?ee99","webpack:///./~/zrender/lib/Storage.js?7e93","webpack:///./~/zrender/lib/animation/Animation.js?8743","webpack:///./~/zrender/lib/animation/Clip.js?fef9","webpack:///./~/zrender/lib/animation/easing.js?64b6","webpack:///./~/zrender/lib/contain/arc.js?7367","webpack:///./~/zrender/lib/contain/cubic.js?b90e","webpack:///./~/zrender/lib/contain/path.js?2e7f","webpack:///./~/zrender/lib/core/GestureMgr.js?00fd","webpack:///./~/zrender/lib/core/LRU.js?018e","webpack:///./~/zrender/lib/dom/HandlerProxy.js?2fc7","webpack:///./~/zrender/lib/graphic/CompoundPath.js?8636","webpack:///./~/zrender/lib/graphic/RadialGradient.js?895e","webpack:///./~/zrender/lib/graphic/helper/roundRect.js?418d","webpack:///./~/zrender/lib/graphic/helper/smoothBezier.js?2713","webpack:///./~/zrender/lib/graphic/helper/smoothSpline.js?a17c","webpack:///./~/zrender/lib/graphic/shape/Arc.js?2994","webpack:///./~/zrender/lib/graphic/shape/BezierCurve.js?f5c4","webpack:///./~/zrender/lib/graphic/shape/Circle.js?076e","webpack:///./~/zrender/lib/graphic/shape/Line.js?7728","webpack:///./~/zrender/lib/graphic/shape/Polygon.js?d37d","webpack:///./~/zrender/lib/graphic/shape/Polyline.js?3cdb","webpack:///./~/zrender/lib/graphic/shape/Rect.js?3b3d","webpack:///./~/zrender/lib/graphic/shape/Ring.js?b71c","webpack:///./~/zrender/lib/graphic/shape/Sector.js?9767","webpack:///./~/zrender/lib/mixin/Animatable.js?35cb","webpack:///./~/zrender/lib/mixin/Draggable.js?fbca","webpack:///./~/zrender/lib/tool/path.js?dc4b","webpack:///./~/zrender/lib/tool/transformPath.js?ddb2","webpack:///./~/zrender/lib/vml/core.js?18b5","webpack:///./lib/chart/helper/LargeSymbolDraw.js?a94c","webpack:///./lib/chart/helper/LinePath.js?e799","webpack:///./lib/chart/scatter.js?16ba","webpack:///./lib/chart/scatter/ScatterSeries.js?8307","webpack:///./lib/chart/scatter/ScatterView.js?f539","webpack:///./lib/component/dataZoom.js?3602","webpack:///./lib/component/dataZoom/AxisProxy.js?0428","webpack:///./lib/component/dataZoom/InsideZoomModel.js?77b0","webpack:///./lib/component/dataZoom/InsideZoomView.js?1d6c","webpack:///./lib/component/dataZoom/SelectZoomModel.js?58a3","webpack:///./lib/component/dataZoom/SelectZoomView.js?6553","webpack:///./lib/component/dataZoom/SliderZoomModel.js?a828","webpack:///./lib/component/dataZoom/SliderZoomView.js?ec48","webpack:///./lib/component/dataZoom/roams.js?6b09","webpack:///./lib/component/dataZoomSelect.js?a7ef","webpack:///./lib/component/legend.js?10db","webpack:///./lib/component/legend/LegendModel.js?d95a","webpack:///./lib/component/legend/LegendView.js?f0eb","webpack:///./lib/component/legend/legendAction.js?b147","webpack:///./lib/component/legend/legendFilter.js?838e","webpack:///./lib/component/markArea.js?a2d0","webpack:///./lib/component/markLine.js?bb6a","webpack:///./lib/component/markPoint.js?e04f","webpack:///./lib/component/marker/MarkAreaModel.js?ad98","webpack:///./lib/component/marker/MarkAreaView.js?02b7","webpack:///./lib/component/marker/MarkLineModel.js?ef8d","webpack:///./lib/component/marker/MarkLineView.js?e278","webpack:///./lib/component/marker/MarkPointModel.js?9d07","webpack:///./lib/component/marker/MarkPointView.js?2616","webpack:///./lib/component/title.js?d8c5","webpack:///./lib/component/toolbox.js?c564","webpack:///./lib/component/toolbox/ToolboxModel.js?ff1f","webpack:///./lib/component/toolbox/ToolboxView.js?d6c4","webpack:///./lib/component/toolbox/feature/DataView.js?f1dd","webpack:///./lib/component/toolbox/feature/DataZoom.js?5c36","webpack:///./lib/component/toolbox/feature/MagicType.js?5698","webpack:///./lib/component/toolbox/feature/Restore.js?b468","webpack:///./lib/component/toolbox/feature/SaveAsImage.js?11a5","webpack:///./lib/component/tooltip.js?55cc","webpack:///./lib/component/tooltip/TooltipContent.js?66b5","webpack:///./lib/component/tooltip/TooltipModel.js?1389","webpack:///./lib/component/tooltip/TooltipView.js?89dc","webpack:///./~/process/browser.js?82e4","webpack:///./~/zrender/lib/vml/Painter.js?b055","webpack:///./~/zrender/lib/vml/graphic.js?88f1","webpack:///./~/zrender/lib/vml/vml.js?d630"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","clone","source","result","typeStr","objToString","i","len","length","TYPED_ARRAY","constructor","from","BUILTIN_OBJECT","isDom","key","hasOwnProperty","merge","target","overwrite","isObject","targetProp","sourceProp","isArray","isBuildInObject","mergeAll","targetAndSources","extend","defaults","overlay","createCanvas","document","createElement","getContext","_ctx","util","indexOf","array","value","inherits","clazz","baseClazz","F","clazzPrototype","prototype","prop","superClass","mixin","isArrayLike","data","each","obj","cb","context","forEach","nativeForEach","map","nativeMap","push","reduce","memo","nativeReduce","filter","nativeFilter","find","bind","func","args","nativeSlice","arguments","apply","concat","curry","isFunction","isString","type","nodeType","ownerDocument","retrieve","values","slice","Function","assert","condition","message","Error","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","Object","toString","arrayProto","Array","noop","createRegisterEventWithLowercaseName","method","eventName","handler","toLowerCase","Eventful","MessageCenter","ECharts","dom","theme","opts","prioritySortFunc","a","b","prio","themeStorage","group","_dom","_zr","zrender","init","renderer","devicePixelRatio","width","height","_theme","zrUtil","_chartsViews","_chartsMap","_componentsViews","_componentsMap","_api","ExtensionAPI","_coordSysMgr","CoordinateSystemManager","_messageCenter","_initEvents","resize","_pendingActions","timsort","visualFuncs","dataProcessorFuncs","animation","on","_onframe","doConvertPixel","methodName","finder","ecModel","_model","coordSysList","getCoordinateSystems","modelUtil","parseFinder","coordSys","toggleHighlight","payload","eachComponent","mainType","query","seriesModel","index","chartView","__viewId","__alive","invokeUpdateMethod","api","component","componentModel","__model","updateZ","eachSeries","idx","chart","updateProgressiveAndBlend","updateHoverLayerStatus","prepareView","isComponent","viewList","viewMap","zr","componentType","model","viewId","view","classType","ComponentModel","parseClassType","Clazz","ComponentView","getClass","main","sub","ChartView","add","__id","remove","dispose","splice","processData","process","stackSeriesData","stackedDataMap","series","stack","get","getData","previousStack","stackedOn","doLayout","visual","isLayout","doVisualEncoding","clearColorPalette","doRender","componentView","render","silent","storage","elCount","traverse","el","isGroup","env","node","useHoverLayer","ignore","frameDrawNum","needProgressive","progressive","Math","floor","stopAnimation","blendMode","setStyle","z","zlevel","enableConnect","updateConnectedChartsStatus","charts","status","otherChart","STATUS_KEY","STATUS_PENDING","STATUS_UPDATING","STATUS_UPDATED","eventActionMap","actionType","eventType","event","connectedGroups","action","makeActionFromEvent","otherCharts","instances","dispatchAction","GlobalModel","OptionManager","SeriesModel","graphic","colorTool","PRIORITY_PROCESSOR_FILTER","PRIORITY_PROCESSOR_STATISTIC","PRIORITY_VISUAL_LAYOUT","PRIORITY_VISUAL_GLOBAL","PRIORITY_VISUAL_CHART","PRIORITY_VISUAL_COMPONENT","PRIORITY_VISUAL_BRUSH","IN_MAIN_PROCESS","HAS_GRADIENT_OR_PATTERN_BG","OPTION_UPDATED","off","one","echartsProto","updateMethods","prepareAndUpdate","getDom","getZr","setOption","option","notMerge","lazyUpdate","optionManager","optionPreprocessorFuncs","refreshImmediately","_flushPendingActions","setTheme","console","log","getModel","getOption","getWidth","getHeight","getRenderedCanvas","canvasSupported","pixelRatio","backgroundColor","list","getDisplayList","painter","getDataURL","excludeComponents","excludesComponentViews","self","url","toDataURL","getConnectedDataURL","groupId","mathMin","min","mathMax","max","MAX_NUMBER","Infinity","left","top","right","bottom","canvasList","dpr","canvas","boundingRect","getBoundingClientRect","targetCanvas","item","img","Image","style","x","y","image","convertToPixel","convertFromPixel","containPixel","models","coordinateSystem","containPoint","getVisual","visualType","defaultMainType","dataIndexInside","indexOfRawIndex","dataIndex","getItemVisual","update","coordSysMgr","restoreData","create","isSingleCanvas","configLayer","clearColor","colorArr","parse","stringify","colorStops","background","updateView","clearAllVisual","updateVisual","updateLayout","highlight","downplay","optionChanged","resetOption","_loadingFX","showLoading","name","cfg","hideLoading","loadingEffects","eventObj","actionWrap","actions","actionInfo","updateMethod","payloads","batched","batch","eventObjBatch","isHighlightOrDownplay","batchItem","trigger","pendingActions","shift","MOUSE_EVENT_NAMES","eveName","e","params","dataModel","getSeriesByIndex","seriesIndex","getDataParams","dataType","eventData","isDisposed","_disposed","clear","idBase","Date","groupIdBase","DOM_ATTRIBUTE_KEY","echarts","version","dependencies","setAttribute","connect","disConnect","getInstanceByDom","getAttribute","getInstanceById","registerTheme","registerPreprocessor","preprocessorFunc","registerProcessor","priority","processorFunc","registerAction","registerCoordinateSystem","CoordinateSystem","register","registerLayout","layoutFunc","registerVisual","visualFunc","registerLoading","loadingFx","extendComponentModel","extendComponentView","extendSeriesModel","replace","extendChartView","setCanvasCreator","creator","List","Model","number","format","matrix","vector","color","PRIORITY","PROCESSOR","FILTER","STATISTIC","VISUAL","LAYOUT","GLOBAL","CHART","COMPONENT","BRUSH","hasFillOrStroke","fillOrStroke","liftColor","lift","cacheElementStl","__hoverStlDirty","stroke","fill","hoverStyle","__hoverStl","normalStyle","__normalStl","doSingleEnterHover","__isHover","__zr","addHover","z2","doSingleLeaveHover","normalStl","removeHover","doEnterHover","child","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","props","animatableModel","animationEnabled","ifEnableAnimation","getShallow","postfix","duration","animationEasing","animationDelay","animateTo","attr","pathTool","round","Path","Group","Text","Circle","Sector","Ring","Polygon","Polyline","Rect","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","BoundingRect","extendShape","extendPath","pathData","extendFromString","makePath","rect","layout","path","createFromString","getBoundingRect","aspect","cx","cy","resizePath","mergePath","applyTransform","pathRect","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","shape","lineWidth","x1","x2","y1","y2","subPixelOptimizeRect","originX","originY","originWidth","originHeight","position","positiveOrNegative","doubledPosition","setHoverStyle","setText","textStyle","labelModel","labelPosition","labelColor","textStyleModel","textDistance","textFont","getFont","textPosition","textFill","getTextColor","updateProps","initProps","getTransform","ancestor","mat","identity","mul","getLocalTransform","parent","vertex","transform","invert","transformDirection","direction","hBase","abs","vBase","groupTransition","g1","g2","getElMap","g","elMap","anid","getAnimatableProps","rotation","elMap1","oldEl","newProp","_trim","str","RADIAN_EPSILON","linearMap","val","domain","range","clamp","subDomain","subRange","parsePercent","percent","all","match","parseFloat","NaN","precision","toFixed","asc","arr","sort","getPrecision","isNaN","count","getPrecisionSafe","dotIndex","getPixelPrecision","dataExtent","pixelExtent","LN10","dataQuantity","sizeQuantity","MAX_SAFE_INTEGER","remRadian","radian","pi2","PI","isRadianAroundZero","parseDate","ret","quantity","pow","nice","nf","exp10","f","ArrayCtor","Float32Array","out","copy","v","set","v1","v2","scaleAndAdd","sqrt","lenSquare","div","dot","scale","s","normalize","d","distance","distanceSquare","negate","lerp","t","lengthSquare","dist","distSquare","Displayable","PathProxy","pathContain","Pattern","getCanvasPattern","__dirtyPath","strokeContainThreshold","brush","ctx","prevEl","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","__dirty","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","setScale","beginPath","setLineDashOffset","buildPath","rebuildPath","restoreTransform","text","drawRectText","shapeCfg","inBundle","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","w","lineScale","strokeNoScale","getLineScale","contain","localPos","transformCoordToLocal","containStroke","dirty","dirtyPath","refresh","__clipTarget","animateShape","loop","animate","attrKV","setShape","Sub","extendFrom","defaultShape","thisShape","has","formatUtil","nubmerUtil","normalizeToArray","defaultEmphasis","opt","subOpts","emphasisOpt","emphasis","normalOpt","normal","subOptName","LABEL_OPTIONS","getDataItemValue","dataItem","isDataItemOption","converDataValue","dimInfo","dimType","isFinite","createDataFormatModel","dataFormatMixin","subType","seriesName","rawValue","getRawValue","rawDataIndex","getRawIndex","getName","itemOpt","getRawDataItem","componentSubType","seriesType","$vars","getFormattedLabel","dimIndex","itemModel","getItemModel","formatter","formatTpl","formatTooltip","mappingToExists","exists","newCptOptions","exist","cptOption","isIdInner","compressBatches","batchA","batchB","makeMap","sourceBatch","otherMap","seriesId","dataIndices","otherDataIndices","j","lenj","mapToArray","isData","mapA","mapB","queryDataIndex","indexOfName","parsedKey","queryType","queryParam","queryComponents","vec2","v2ApplyTransform","union","other","lt","rb","lb","rt","maxX","maxY","sx","sy","translate","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","numberUtil","textContain","addCommas","split","toCamelCase","group1","toUpperCase","normalizeCssArray","encodeHTML","String","TPL_VAR_ALIAS","wrapVar","varName","seriesIdx","tpl","paramsList","seriesLen","alias","k","s2d","formatTime","date","getFullYear","M","getMonth","getDate","h","getHours","getMinutes","getSeconds","capitalFirst","charAt","substr","truncateText","parentModel","clazzUtil","mergeOption","ignoreParent","thisParentModel","isEmpty","Ctor","setReadOnly","properties","enableClassExtend","detect","ua","os","browser","firefox","ie","edge","weChat","test","touchEventsSupported","window","pointerEventsSupported","navigator","userAgent","getDependencies","deps","getClassesByMainType","arrayPush","componentUtil","componentIndex","defaultOption","dependentModels","uid","layoutMode","$constructor","extraOpt","getUID","mergeDefaultAndTheme","inputPositionParams","getLayoutParams","themeModel","getTheme","getDefaultOption","mergeLayoutParam","optionUpdated","newCptOption","isInit","optList","Class","__defaultOption","getReferringComponents","enableClassManagement","registerWhenExtend","enableSubTypeDefaulter","enableTopologicalTravel","boxLayout","orient","gap","maxWidth","maxHeight","currentLineMaxSize","eachChild","nextX","nextY","nextChild","childAt","nextChildRect","moveX","newline","moveY","LOCATION_PARAMS","box","vbox","hbox","getAvailableSize","positionInfo","containerRect","margin","containerWidth","containerHeight","getLayoutRect","verticalMargin","horizontalMargin","positionGroup","groupRect","targetOption","newOption","names","newParams","newValueCount","merged","mergedValueCount","enoughParamNumber","ignoreSize","hasProp","hasValue","hNames","vNames","hResult","vResult","copyLayoutParams","global","normalizeDimensions","dimensions","cloneListForMapAndSample","original","excludeDimensions","allDimensions","getDimensionInfo","hostModel","transferProperties","_storage","originalStorage","dim","dimStore","UNDEFINED","globalObj","Float64Array","Int32Array","dataCtors","float","int","ordinal","time","DataDiffer","TRANSFERABLE_PROPERTIES","__wrappedMethods","propName","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","stackable","_dimensionInfos","indices","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","_extent","listProto","hasItemOption","getDimension","initData","nameList","dimValueGetter","size","dimensionInfoMap","idList","nameRepeatCount","DataCtor","dimName","dimStorage","stackedValue","getValues","getDataExtent","dimData","dimExtent","getSum","sum","rawIndex","mid","indexOfNearest","maxDistance","nearestIdx","minDist","Number","MAX_VALUE","diff","rawIdx","getId","dims","dimSize","filterSelf","newIndices","keep","mapArray","tmpRetValue","retValue","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","setVisual","setLayout","getLayout","getItemLayout","setItemLayout","clearItemLayouts","itemVisual","setItemVisual","setItemDataAndSeriesIndex","setItemGraphicEl","getItemGraphicEl","eachItemGraphicEl","cloneShallow","dimensionInfoList","wrapMethod","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","colorPaletteMixin","legendDataProvider","visualColorAccessPath","_dataBeforeProcessed","getInitialData","_data","label","fillDataTextStyle","newSeriesOption","getLinkedData","setData","getRawData","coordDimToDataDim","coordDim","dataDimToCoordDim","dataDim","getBaseAxis","multipleSeries","formatArrayValue","valStr","join","formattedValue","colorEl","getColorFromPalette","scope","getAxisTooltipDataIndex","getTooltipPosition","getTextWidth","textWidthCache","textLines","l","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getTextRect","textAlign","textBaseline","textLineLen","lineHeight","adjustTextPositionOnRect","textRect","textHeight","halfHeight","ellipsis","options","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","font","isAroundZero","EPSILON","isNotAroundZero","cubicAt","p0","p1","p2","p3","onet","cubicDerivativeAt","cubicRootAt","roots","A","B","C","n","t1","disc","K","t2","discSqrt","mathSqrt","Y1","Y2","mathPow","ONE_THIRD","T","theta","acos","ASqrt","tmp","cos","THREE_SQRT","sin","t3","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","x0","y0","x3","y3","prev","next","d1","d2","interval","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseInt","parseCssFloat","cssHueToRgb","m1","m2","colorStr","kCSSColorTable","op","ep","fname","alpha","pop","hsla2rgba","iv","hsla","rgba","rgba2hsla","H","S","R","G","vMin","vMax","delta","L","deltaR","deltaG","deltaB","level","toHex","fastMapToColor","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","out0","out1","out2","out3","out4","out5","rotate","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","arrySlice","_$handlers","_h","isSilent","newList","argLen","triggerWithContext","superCall","superApply","TYPE_DELIMITER","IS_CONTAINER","RootClass","mandatoryMethods","proto","ExtendedClass","entity","makeContainer","container","registerClass","componentTypeMain","throwWhenNotFound","o","hasClass","getAllClassMainTypes","types","hasSubTypes","originalExtend","OrdinalScale","IntervalScale","Scale","axisHelper","getScaleExtent","axis","originalExtent","getExtent","span","getMin","getMax","crossZero","getNeedCrossZero","boundaryGap","fixMin","fixMax","niceScaleExtent","extent","splitNumber","base","setExtent","niceExtent","minInterval","getInterval","intervalScale","origin","setInterval","createScaleByModel","axisType","getCategories","ifAxisCrossZero","getAxisLabelInterval","tickCoords","labels","isAxisHorizontal","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","step","tickCoord","getFormattedLabels","labelFormatter","getTicksLabels","ticks","getTicks","tick","getLabel","_coordinateSystems","coordinateSystemCreators","coordinateSystems","creater","coordinateSystemCreator","clientToLocal","calculate","defaultGetZrXY","layerX","offsetX","zrX","zrY","layerY","offsetY","clientX","clientY","normalizeEvent","isTouch","touch","targetTouches","changedTouches","zrDelta","wheelDelta","detail","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","stop","preventDefault","stopPropagation","cancelBubble","returnValue","Dispatcher","features","ctor","Triangle","moveTo","lineTo","closePath","Diamond","Pin","r","dy","angle","asin","dx","tanX","tanY","arc","cpLen","cpLen2","bezierCurveTo","Arrow","symbolCtors","line","roundRect","square","circle","diamond","pin","arrow","triangle","symbolShapeMakers","symbolBuildProxies","Symbol","symbolType","beforeBrush","textVerticalAlign","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","symbolUtil","createSymbol","symbolPath","setColor","Chart","elSetState","state","childCount","dataIdx","removeAll","chartProto","curve","bbox","CMD","Q","Z","min2","max2","mathCos","mathSin","mathAbs","hasTypedArray","_len","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","addData","exceedUnit","_needsDash","_dashedLineTo","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","startAngle","endAngle","anticlockwise","arcTo","radius","toStatic","lineDashSum","offset","appendPath","appendSize","appendPathData","cmd","_expandData","_prevCmd","newData","dash","dashSum","nDash","bezierLen","tmpLen","xi","yi","fromLine","fromCubic","fromQuadratic","rx","ry","fromArc","ux","uy","dTheta","psi","fs","scaleX","scaleY","isEllipse","Gradient","addColorStop","completeDimensions","defaultNames","extraPrefix","value0","retrieveValue","guessOrdinal","excludes","_interval","scaleProto","unionExtent","start","end","thisExtent","config","debugMode","Element","_children","__storage","children","childOfName","_doAdd","addBefore","nextSibling","addToMap","addChildrenToStorage","delFromMap","delChildrenFromStorage","includeChildren","tmpRect","tmpMat","invisible","childRect","firstDataNotNull","ifNeedCompleteOrdinalData","sampleItem","createListFromArray","coordSysName","creators","registeredCoordSys","axesInfo","categoryIndex","createNameList","categories","categoryAxesModels","isStackable","getDimTypeByAxis","categoryAxisModel","categoryDim","dataLen","cartesian2d","axesModels","xAxisModel","yAxisModel","xAxisType","yAxisType","isXAxisCateogry","isYAxisCategory","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","geo","gridModel","getRect","getItemStyle","xAxis","yAxis","grid","Style","__clipPaths","RectText","draggable","dragging","culling","cursor","rectHover","afterBrush","rectContain","coord","animateStyle","useStyle","mathFloor","mathCeil","roundingErrorFix","niceTicks","_niceExtent","safeLimit","reverse","expandSize","SymbolDraw","symbolCtor","_symbolCtor","symbolNeedsDraw","isIgnore","point","symbolDrawProto","updateData","oldData","SymbolCtor","seriesScope","itemStyle","hoverItemStyle","symbolRotate","symbolOffset","hoverAnimation","hoverLabelModel","newIdx","symbolEl","oldIdx","fadeOut","execute","enableAnimation","retrieveRaw","processRangeProp","percentProp","valueProp","rawOption","thisOption","helper","AxisProxy","eachAxisDim","DataZoomModel","xAxisIndex","yAxisIndex","filterMode","throttle","startValue","endValue","_dataIntervalByAxis","_dataInfo","_axisProxies","_autoThrottle","doInit","realtime","_setDefaultThrottle","_resetTarget","_giveAxisProxies","axisProxies","eachTargetAxis","dimNames","axisIndex","dataZoomModel","axisModel","axisProxy","__dzAxisProxy","autoMode","_judgeAutoMode","axisIndexName","_autoSetAxisIndex","_autoSetOrient","hasIndexSpecified","autoAxisIndex","axisIndices","axisModels","_isSeriesHasAllAxesTypeOf","axisId","is","seriesAxisIndex","globalOption","animationDurationUpdate","getFirstTargetAxisModel","firstAxisModel","callback","getAxisProxy","setRawRange","getPercentRange","findRepresentativeAxisProxy","getDataPercentWindow","getValueRange","axisDimName","getDataValueWindow","hostedBy","getTargetInfo","save","coordModel","store","coordIndex","cartesians","polars","getComponent","axisName","fixExtentWithBands","nTick","normalizedExtent","Axis","inverse","onBand","containData","dataToCoord","coordToData","getTicksCoords","alignWithLabel","bands","getBands","coords","getLabelsCoords","getBandWidth","axisExtent","DELIMITER","random","subTypeDefaulters","registerSubTypeDefaulter","defaulter","determineSubType","dependencyGetter","makeDepndencyGraph","fullNameList","graph","noEntryList","thisItem","createDependencyGraphItem","originalDeps","availableDeps","getAvailableDependencies","entryCount","dependentName","predecessor","thatItem","successor","dep","topologicalTravel","targetNameList","removeEdge","succComponentType","removeEdgeAndAdd","targetNameSet","currComponentType","currVertex","isInTargetNameSet","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","defaultKeyGetter","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","keyArr","keyGetter","existence","_add","_update","_remove","oldDataIndexMap","newDataIndexMap","oldDataKeyArr","newDataKeyArr","unshift","defaultSymbolType","legendSymbol","eachRawSeriesByType","symbolSize","symbol","isSeriesFiltered","itemSymbolType","itemSymbolSize","ZImage","LRU","globalImageCache","src","_image","cachedImgObj","onload","pending","put","sWidth","sHeight","drawImage","normalizeSymbolSize","driftSymbol","drift","symbolProto","_createSymbol","_symbolType","stopSymbolAnimation","toLastFrame","getSymbolPath","getScale","setZ","setDraggable","_updateCommon","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","elStyle","opacity","valueDim","onEmphasis","ratio","onNormal","makeAxisEventDataBase","innerTextLayout","textRotation","verticalAlign","rotationDiff","endTextLayout","textRotate","onLeft","tooltipOpt","show","AxisBuilder","labelOffset","nameDirection","tickDirection","labelDirection","dumbGroup","updateTransform","_transform","_dumbGroup","hasBuilder","builders","getGroup","axisLine","pt1","pt2","lineCap","getLineStyle","axisTick","tickModel","lineStyleModel","tickLen","tickInterval","labelInterval","ticksCoords","ifIgnoreOnTick","axisLabel","isTwoLabelOverlapped","current","firstRect","nextRect","axisLabelShow","labelMargin","labelRotation","labelLayout","categoryData","textEls","triggerEvent","itemTextStyleModel","textColor","pos","labelBeforeFormat","textEl","targetType","decomposeTransform","firstLabel","nextLabel","lastLabel","prevLabel","nameLocation","gapSignal","nameRotation","axisNameAvailableWidth","truncateOpt","truncatedText","formatterParams","__fullText","__truncatedText","tooltip","content","rawTick","axisDefault","AXIS_TYPES","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","getAxisType","axisDim","axisModelCreator","AxisModel","resetRange","findGridModel","extraOption","isAxisUsedInTheGrid","getLabelUnionRect","labelCount","isLabelIgnored","singleRect","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","updateAxisTransfrom","coordBase","axisExtentSum","toGlobalCoord","toLocalCoord","findAxesModels","axesTypes","isCartesian2D","Cartesian2D","Axis2D","gridProto","ifAxisCanNotOnZero","otherAxisDim","axes","axesMap","_updateScale","onZero","adjustAxes","axesList","isHorizontal","gridRect","getBoxLayoutParams","labelUnionRect","getAxis","axesMapOnDim","getCartesian","coordList","_findConvertTarget","cartesian","dataToPoint","pointToData","coordsList","createAxisCreator","axisPosition","axisPositionUsed","isCategory","axesCount","addAxis","grids","eachSeriesByType","_colorIdx","_colorNameMap","colorIdx","colorNameMap","colorPalette","Component","componentProto","guid","Transformable","Animatable","clipPath","beforeUpdate","afterUpdate","hide","setClipPath","addSelfToZr","removeClipPath","removeSelfFromZr","animators","addAnimator","removeAnimator","defaultGetter","defaultSetter","interpolateNumber","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isArraySame","catmullRomInterpolateArray","catmullRomInterpolate","v0","cloneValue","rgba2String","createTrackClip","animator","easing","oneTrackDone","keyframes","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","lastValue","_target","lastFrame","lastFramePercent","onframe","frame","clip","Clip","life","_loop","delay","_delay","ondestroy","Animator","_tracks","_clipCount","_doneList","_onframeList","_clipList","when","tracks","during","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","forwardToLast","clipList","removeClip","done","getClips","requestAnimationFrame","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","setTimeout","PI2","normalizeRadian","idStart","repeat","_canvasPattern","createPattern","createLinearGradient","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","shadowBlur","shadowOffsetX","shadowOffsetY","textStroke","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","newStyle","styleProto","smoothSpline","smoothBezier","points","smooth","controlPoints","smoothConstraint","cp1","cp2","updateSelectedMap","targetList","_selectTargetMap","targetMap","select","selectedMode","selected","unSelect","toggleSelected","isSelected","fillLabel","MarkerModel","createdBySelf","hostSeries","__hostSeries","newOpt","modelPropName","markerOpt","markerModel","html","markerGroupMap","__keep","markerModelKey","renderSeries","hasXOrY","hasXAndY","valueAxisDim","markerTypeCalculatorWithExtent","mlType","otherDataDim","targetDataDim","otherCoordIndex","targetCoordIndex","coordArr","numCalculate","markerTypeCalculator","average","dataTransform","axisInfo","getAxisInfo","baseAxis","valueAxis","baseDataDim","valueDataDim","radiusAxis","angleAxis","valueIndex","getOtherAxis","dataFilter","legendModels","findComponents","paletteScope","dataAll","idxMap","filteredIdx","singleDataColor","extremity","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","fillText","strokeText","maxValue","lastIndexOf","align","baseline","shadowColor","textShadowColor","restore","delInstance","Handler","Storage","Animation","HandlerProxy","useVML","painterCtors","ZRender","getInstance","registerPainter","rendererType","vml","handerProxy","getViewportRoot","stage","flush","_needsRefresh","oldDelFromMap","oldAddToMap","elId","addRoot","delRoot","zLevel","_needsRefreshHover","refreshHoverImmediately","refreshHover","clearHover","clearAnimation","pathToImage","setCursorStyle","cursorStyle","eventHandler","actionInfos","mousedown","containsPoint","_x","_y","_dragging","mousemove","eventTool","gestureEvent","interactionMutex","isTaken","oldX","oldY","mouseup","mousewheel","zoomDelta","zoom","pinch","pinchScale","pinchX","pinchY","zoomX","zoomY","zoomLimit","newZoom","zoomMin","zoomMax","zoomScale","RoamController","mousedownHandler","mousemoveHandler","mouseupHandler","mousewheelHandler","pinchHandler","setContainsPoint","enable","controlType","disable","isDragging","isPinching","_pinching","handleEnds","mode","handleIndex","getRealDelta","handleMinMax","nameRotate","nameTruncate","nameTextStyle","nameGap","lineStyle","inside","fontSize","splitLine","splitArea","areaStyle","categoryAxis","timeAxis","logAxis","logBase","rangeStart","rangeEnd","setRange","lib","ORIGIN_METHOD","RATE","THROTTLE_TYPE","fn","debounce","exec","lastExec","getTime","timer","currCall","lastCall","clearTimeout","createOrUpdate","fnAttr","throttleType","originFn","lastThrottleType","lastRate","_l","_a","_b","_s","dir","x_","globalCoord","mIdentity","transformableProto","needLocalTransform","parentHasTransform","invTransform","tmpTransform","atan2","transformCoordToGlobal","chartInstance","echartsAPIList","barLayoutGrid","getMarkerPosition","pt","offsetIndex","brushSelector","legendHoverLink","barMinHeight","fixLayoutWithLineWidth","signX","signY","coordinateSystemType","_renderOnCartesian","createRect","barBorderWidthQuery","rectShape","animateProperty","animateTarget","newIndex","oldIndex","_updateStyle","setLabel","labelText","labelPositionOutside","itemStyleModel","getBarItemStyle","rectStyle","getBorderLineDash","makeSymbolTypeKey","symbolCategory","lineData","createLine","LinePath","setLinePoints","targetShape","cpx1","cpy1","updateSymbolAndLabelBeforeLineUpdate","lineGroup","symbolFrom","symbolTo","invScale","parentNode","fromPos","pointAt","toPos","tangent","tangentAt","__position","halfPercent","cp","__verticalAlign","__textAlign","_createLine","SYMBOL_CATEGORIES","lineProto","linePoints","_updateCommonStl","hoverLineStyle","visualColor","visualOpacity","defaultLabelColor","defaultText","showLabel","hoverShowLabel","rawVal","textStyleHoverModel","linePath","isPointNaN","lineNeedsDraw","pts","LineDraw","_ctor","LineGroup","lineDrawProto","oldLineData","_lineData","LineCtor","clipOverflow","smoothMonotone","showSymbol","showAllSymbol","connectNulls","sampling","hoverLayerThreshold","isPointsSame","points1","points2","getSmooth","getAxisExtentWithGap","getGlobalExtent","halfBandWidth","sign","getStackedOnPoints","valueStart","baseDataOffset","stackedOnSameSign","stackedData","createGridClipShape","hasAnimation","xExtent","yExtent","createPolarClipShape","getAngleAxis","getRadiusAxis","radiusExtent","angleExtent","RADIAN","r0","clockwise","createClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","nextPt","stepPt","middle","stepPt2","getVisualGradient","visualMetaList","visualMeta","stops","firstStop","lastStop","stopsSpan","gradient","lineAnimationDiff","polyHelper","symbolDraw","_symbolDraw","_lineGroup","areaStyleModel","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","polygon","_polygon","isAreaChart","stackedOnPoints","isSymbolIgnore","_getSymbolIgnoreFunc","__temp","_step","_newPolygon","_stackedOnPoints","_points","_updateAnimation","_newPolyline","lineJoin","stackedOnSmooth","getAreaStyle","stackedOnSeries","getAxesByScale","stackedOnCurrent","stackedOnNext","__points","updatedDataInfo","diffStatus","idx1","ptIdx","getStackedOnPoint","diffData","diffResult","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","diffItem","pointAdded","currentPt","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","isPointNull","drawSegment","segLen","allLen","smoothMin","smoothMax","prevIdx","v2Copy","cp0","nextIdx","nextP","ratioNextSeg","prevP","lenPrevSeg","lenNextSeg","getBoundingBox","ptMin","ptMax","stackedOnBBox","dataSelectableMixin","PieSeries","_defaultLabelLine","labelLine","labelLineNormalOpt","labelLineEmphasisOpt","center","minAngle","selectedOffset","avoidLabelOverlap","borderWidth","updateDataSelected","toggleItemSelected","midAngle","PiePiece","hoverIgnore","normalIgnore","sector","getLabelStyle","isLabelInside","piePieceProto","firstCreate","sectorShape","_updateLabel","labelHoverModel","labelLineModel","labelLineHoverModel","Pie","sectorGroup","_sectorGroup","isFirstRender","onSectorClick","piePiece","_createClipPath","itemLayout","adjustSingleSide","viewWidth","viewHeight","shiftDown","shiftUp","changeX","isDownList","lastDeltaX","deltaY","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textX","textY","labelLineLen","labelLineLen2","labelRotate","unitRadian","roseType","restAngle","valueSumLargerThanMinAngle","currentAngle","layoutAxis","getZero","theAxis","rawAxisPosition","rectBound","axisOffset","posMap","dirMap","getLabelInterval","axisBuilderAttrs","selfBuilderAttrs","AxisView","oldAxisGroup","_axisGroup","axisBuilder","_splitLine","splitLineModel","lineColors","lineInterval","lineCount","colorIndex","_splitArea","splitAreaModel","areaColors","prevX","prevY","areaInterval","linkedNodesFinder","createLinkedNodesFinder","effectedModels","nodes","resetSingleAxis","reset","filterSingleAxis","filterData","percentRange","valueRange","AXIS_DIMS","createNameEach","attrs","capitalNames","capitalAttrs","nameObj","capital","forEachNode","forEachEdgeType","edgeIdGetter","isNodeAbsorded","isLinked","hasLink","edgeType","edgeId","records","absorb","sourceNode","processSingleNode","existsLink","giveStore","ATTR","history","newSnapshot","dataZoomId","snapshot","head","BrushController","_brushType","_brushOption","_panels","_track","_covers","_creatingCover","_creatingPanel","_enableGlobalPan","_uid","baseUID","_handlers","mouseHandlers","doEnableBrush","controller","brushOption","take","MUTEX_RESOURCE_KEY","brushType","DEFAULT_BRUSH_OPT","doDisableBrush","release","createCover","cover","coverRenderers","__brushOption","endCreating","creatingCover","coverRenderer","getCoverRenderer","updateCoverShape","COVER_Z","updateCoverAfterCreation","updateCommon","getPanelByPoint","panels","panel","pn","getPanelByCover","panelId","clearCovers","covers","originalLength","areas","isEnd","removeOnClick","shouldShowCover","track","UNSELECT_THRESHOLD","getTrackEnds","tail","createBaseRectCover","doDrift","edgeNames","makeStyle","ondragend","updateBaseRect","localRange","brushStyle","handleSize","MIN_RESIZE_LINE_WIDTH","xa","ya","x2a","y2a","widtha","heighta","updateRectShape","transformable","mainEl","globalDir","getGlobalDirection","CURSOR_MAP","pointsToRect","clipByPanel","formatRectRange","localDirection","inverseMap","driftRect","toRectRange","fromRectRange","rectRange","localDelta","toLocalDelta","namePart","ind","DIRECTION_MAP","driftPolygon","thisGroup","localD","localZero","panelRect","xmin","ymin","xmax","ymax","resetCursor","inCover","rawE","mainShapeContain","updateCoverByMouse","eventParams","thisBrushOption","brushMode","__brushPanelId","coverBrushOption","getCreatingRange","handleDragEnd","getLineRenderer","xyIndex","localTrack","ends","otherExtent","brushWidth","ne","sw","nw","se","enableBrush","setPanels","panelOpts","oldPanels","newPanels","panelOpt","mount","enableGlobalPan","eachCover","updateCovers","brushOptionList","getKey","tmpIdPrefix","oldGetKey","addOrUpdate","newBrushOption","oldCovers","newCovers","unmount","lineX","lineY","formatMinMax","minMax","findCoordInfo","area","coordInfoList","isGlobal","COMPONENT_NAMES","indexAttr","axisConvert","to","coordInfo","coordRange","PANEL_ID_SPLIT","COORD_CONVERTS","parseOutputRanges","rangesCoordInfo","coordConvert","parseInputRanges","brushModel","makePanelOpts","geoIndex","makeCoordInfoList","componentName","componentIndices","cInfo","aCoordSys","controlSeries","xminymin","xmaxymax","getStore","resourceKey","userKey","uKey","addBackground","padding","axisLabelInterval","coordExtent","_labelInterval","dimAxisMapper","_axes","Cartesian","_dimList","getAxes","scaleType","_dataCoordConvert","input","dimList","output","axisX","axisY","dataToPoints","containLabel","borderColor","getSeriesStackId","getAxisKey","calBarWidthAndOffset","barSeries","columnsMap","bandWidth","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","stacks","stackId","barWidth","barMaxWidth","barGap","barCategoryGap","barGapPercent","autoWidth","column","lastColumn","widthSum","barWidthAndOffset","getSeriesByType","lastStackCoords","lastStackCoordsOrigin","columnLayoutInfo","columnOffset","columnWidth","valueAxisStart","lastCoord","lastCoordOrigin","maskColor","mask","labelRect","mergeTheme","themeItem","initBase","baseOption","OPTION_INNER_KEY","_seriesIndices","globalDefault","getComponentsByTypes","componentsMap","makeKeyInfo","mapResult","idMap","existCpt","keyInfo","idNum","existComponent","createSeriesIndices","seriesModels","filterBySubType","components","cpt","assertSeriesInitialized","_optionManager","mountOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","mediaOption","visitComponent","newCptOptionList","resultItem","ComponentModelClass","newCptTypes","componentOption","cpts","isIdArray","isNameArray","getQueryCond","q","idAttr","nameAttr","doFilter","queryCond","queryResult","getSeriesByName","oneSeries","getSeries","rawSeriesIndex","eachRawSeries","filterSeries","filteredSeries","componentTypes","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","parseRawOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","media","singleMedia","preProcess","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","matched","QUERY_REG","operator","realAttr","real","expect","indicesEquals","indices1","indices2","oldOption","newCptOpt","oldCptOpt","oldOptionBackup","newParsedOption","isRecreate","optionBackup","timelineModel","getCurrentIndex","platform","fontFamily","fontStyle","fontWeight","animationDuration","animationEasingUpdate","animationThreshold","progressiveThreshold","lineType","getLineDash","dotSize","dashSize","gTextStyleModel","compatLayoutProperties","LAYOUT_PROPERTIES","compatStyle","COMPATITABLE_COMPONENTS","COMPATITABLE_SERIES","seriesOpt","clockWise","pointerColor","dataRange","visualMap","compatItemStyle","itemStyleOpt","POSSIBLE_STYLES","normalItemStyleOpt","emphasisItemStyleOpt","markPoint","markLine","mpData","mlData","samplers","nearest","indexSampler","sampler","fixRoundingError","originalVal","intervalScaleProto","mathLog","LogScale","_originalScale","originalScale","powVal","__fixMin","__fixMax","approxTickNum","err","rank","ONE_SECOND","ONE_MINUTE","ONE_HOUR","ONE_DAY","bisect","TimeScale","stepLvl","_stepLvl","approxInterval","scaleLevelsLen","scaleLevels","yearSpan","yearStep","encodeColor","colorAccessPath","makeEventPacket","eveType","zrByTouch","EmptyProxy","isHover","displayable","Draggable","handlerNames","proxy","painterRoot","_hovered","_lastTouchMoment","_lastX","_lastY","hovered","findHover","lastHovered","setCursor","dispatchToElement","mouseout","innerDom","element","toElement","relatedTarget","dispatch","eventArgs","targetEl","eventPacket","eachOtherLayer","layer","exclude","_downel","_upel","returnFalse","createDom","newDom","newDomStyle","Layer","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","initContext","createBackBuffer","clearAll","haveMotionBLur","clearRect","clearColorGradientOrPattern","__canvasGradient","fillRect","parseInt10","isLayerValid","isBuildin","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","clipPaths","prevClipPaths","doClip","createRoot","domRoot","cssText","MAX_PROGRESSIVE_LAYER_NUMBER","Painter","singleCanvas","nodeName","_opts","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","_getSize","_domRoot","appendChild","_createPathToImage","_progressiveLayers","_hoverlayer","_hoverElements","paintAll","_paintList","_startProgessive","__hoverMir","elMirror","__from","hoverElements","hoverLayer","displayableSortFunc","getLayer","originalEl","_doPaintEl","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuildinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","imageLayer","displayList","whIdx","wh","cwh","plt","prb","stl","defaultView","getComputedStyle","_pathToImage","pathTransform","ImageShape","imgShape","me","shapeCompareFunc","_elements","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","_updateAndAddDisplayable","elements","_renderList","_clips","_running","_time","_pausedTime","_pauseStart","_paused","clips","deferredEvents","deferredClips","_needsRemove","fire","_startLoop","pause","resume","_life","_initialized","onrestart","easingFuncs","globalTime","_startTime","easingFunc","schedule","restart","remainder","arg","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","windingQuadratic","y_","windingArc","containPath","isStroke","windingLine","cubic","quadratic","pointPair","eventUtil","GestureMgr","recognize","_doTrack","_recognize","touches","trackItem","recognizers","gestureInfo","pinchEnd","pinchPre","pinchCenter","LinkedList","linkedListProto","insert","entry","Entry","insertEntry","maxSize","_list","_map","_maxSize","LRUProto","leastUsedEntry","eventNameFix","processGesture","gestureMgr","_gestureMgr","setTouchTimer","instance","_touching","_touchTimer","useTouchEvent","initDomHandler","makeMouseHandler","touchHandlerNames","domHandlers","mouseHandlerNames","HandlerDomProxy","mountHandlers","TOUCH_CLICK_DELAY","touchstart","touchmove","touchend","click","handlerDomProxyProto","paths","_updatePathDirty","r1","r2","r3","r4","total","v2Min","v2Max","v2Scale","v2Distance","v2Add","isLoop","constraint","prevPoint","nextPoint","cps","d0","interpolate","segs","w2","w3","unitX","unitY","someVectorAt","isTangent","cpx2","cpy2","curveTool","roundRectHelper","animatingShape","pathSplitted","_animateToShallow","objShallow","propertyCount","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","dropTarget","lastDropTarget","_dropTarget","processArc","fa","psiDeg","xp","yp","lambda","cxp","cyp","vAngle","u","vRatio","createPathProxyFromString","cs","cc","RegExp","prevCmd","cpx","cpy","ctlPtx","ctlPty","createPathOptions","pathProxy","transformPath","vMag","pathEls","pathList","pathEl","pathBundle","nPoint","mathAtan2","createNode","urn","win","doc","vmlInited","namespaces","zrvml","tagName","initVML","styleSheets","createStyleSheet","addRule","LargeSymbolDraw","_symbolEl","LargeSymbolPath","sizes","symbolProxy","symbolProxyShape","findDataIndex","largeSymbolProto","isLine","straightLineProto","bezierCurveProto","large","largeThreshold","_normalSymbolDraw","_largeSymbolDraw","largeSymbolDraw","normalSymbolDraw","calculateDataExtent","seriesData","seriesExtent","calculateDataWindow","getAxisModel","percentExtent","percentWindow","valueWindow","fixExtendByAxis","boundValue","boundPercent","axisMax","setAxisModel","isRestore","_percentWindow","_valueWindow","isFull","invalidPrecision","useOrigin","_dimName","_axisIndex","_dataExtent","_dataZoomModel","getTargetSeriesModels","getOtherAxisModel","coordSysIndexName","isCartesian","foundOtherAxisModel","otherAxisModel","dataWindow","isInWindow","zoomLock","fixRange","bound","DataZoomView","sliderMove","roams","InsideZoomView","_range","shouldRecordRange","targetInfo","allCoordIds","generateCoordId","coordId","operations","throttleRate","panGetRange","_onPan","zoomGetRange","_onZoom","unregister","newX","newY","directionInfo","getDirectionInfo","percentDelta","signal","pixel","pixelLength","mouseX","mouseY","percentPoint","pixelStart","oldPoint","newPoint","pointToCoord","SliderZoomModel","dataBackground","fillerColor","handleIcon","handleStyle","labelPrecision","showDetail","showDataShadow","getOtherDim","thisDim","DEFAULT_LOCATION_EDGE_GAP","DEFAULT_FRAME_BORDER_WIDTH","DEFAULT_FILLER_SIZE","HORIZONTAL","VERTICAL","LABEL_GAP","SHOW_DATA_SHADOW_SERIES_TYPE","SliderZoomView","_displayables","_orient","_handleEnds","_size","_handleWidth","_handleHeight","_location","_dataShadowInfo","_buildView","_updateView","_resetLocation","_resetInterval","barGroup","_renderBackground","_renderHandle","_renderDataShadow","_positionGroup","coordRect","_findCoordRect","ecSize","layoutParams","layoutRect","location","targetAxisModel","otherAxisInverse","_getViewExtent","info","_prepareDataShadowInfo","otherDim","getShadowDim","otherDataExtent","otherOffset","lastIsEmpty","otherShadowExtent","thisShadowExtent","areaPoints","thisCoord","stride","otherCoord","thisAxis","displaybles","handles","handleLabels","filler","_onDragMove","ondragstart","_showDataInfo","_onDragEnd","onmouseover","onmouseout","iconStr","bRect","handleColor","viewExtent","_updateInterval","viewExtend","handleInterval","handle","handleHeight","_updateDataInfo","barTransform","textPoint","orderedHandleEnds","labelTexts","dataInterval","_formatLabel","valueStr","showOrHide","_applyBarTransform","_dispatchZoomAction","createController","dataZoomInfo","newRecord","onPan","onZoom","cleanStore","record","wrapAndDispatch","getRange","dataZoomInfos","theDataZoomId","theCoordId","LegendModel","_updateData","legendData","hasSelected","availableNames","_availableNames","itemGap","itemWidth","itemHeight","inactiveColor","dispatchSelectAction","dispatchHighlightAction","dataName","dispatchDownplayAction","symbolCreator","listComponentHelper","_symbolTypeStore","legendModel","selectMode","itemAlign","legendDrawedMap","legendSymbolType","itemGroup","_createItem","itemIcon","tooltipModel","legendGlobalTooltipModel","hitRect","legendIndex","legendSelectActionHandler","selectedMap","isToggleSelect","isItemSelected","markArea","isInifinity","ifMarkLineHasOnlyDim","fromCoord","toCoord","otherDimIndex","markAreaFilter","markerHelper","getSingleMarkerEndPoint","xPx","yPx","createList","maModel","coordDimsInfos","areaData","optData","markAreaTransform","colorUtil","ltCoord","rbCoord","dimPermutations","markAreaModel","areaGroupMap","polygonGroup","__data","defaultValue","markLineFilter","updateSingleMarkerEndLayout","isFrom","mlModel","fromData","toData","markLineTransform","mlFrom","mlTo","markLineModel","__to","updateDataVisualAndLayout","lineDrawMap","lineDraw","lineColor","fromSymbolSize","fromSymbol","toSymbolSize","toSymbol","updateMarkerLayout","mpModel","dataOpt","markPointModel","symbolDrawMap","subtext","subtarget","subtextStyle","titleModel","subtextStyleModel","subText","subTextEl","link","sublink","open","layoutOption","alignStyle","featureManager","ToolboxModel","feature","featureOpt","featureName","Feature","itemSize","showTitle","iconStyle","isUserFeatureName","toolboxModel","featureNames","oldName","featureOpts","featureModel","onclick","unusable","createIconPaths","setIconStatus","iconName","iconPaths","iconStatus","iconStyleModel","icons","getIcons","titles","icon","title","__title","_features","_featureNames","titleText","needPutOnTop","topOffset","groupSeries","seriesGroupByCategoryAxis","otherSeries","meta","assembleSeriesWithCategoryAxis","tables","headers","columns","lines","ITEM_SPLITER","items","BLOCK_SPLITER","assembleOtherSeries","vals","getContentFromModel","trim","isTSVFormat","block","firstLine","parseTSVContents","tsv","tsvLines","itemSplitRegex","header","parseListContents","hasName","parseContents","blockMetaList","blocks","blockMeta","axisKey","DataView","tryMergeDataOption","originalData","newVal","readOnly","optionToContent","contentToOption","lang","textareaColor","textareaBorderColor","buttonColor","buttonTextColor","close","viewMain","textarea","htmlOrDom","buttonContainer","buttonStyle","closeButton","refreshButton","keyCode","which","selectionStart","selectionEnd","substring","clientHeight","newSeriesOptList","DataZoom","_brushController","_onBrush","_isZoomActive","retrieveAxisSetting","setting","updateBackBtnStatus","updateZoomBtnStatus","zoomActive","dataZoomSelectActive","brushHelper","xAxisHas","yAxisHas","DATA_ZOOM_ID_BASE","back","handlers","nextActive","setBatch","findDataZoom","dzModel","dataZoomIndex","rangesCoordInfoList","axisNames","addForAxis","dataZoomOpt","axisIndicesName","givenAxisIndices","forEachComponent","axisOpt","$fromToolbox","dataZoomOpts","dataZoom","toolboxOpt","toolbox","MagicType","bar","tiled","availableIcons","seriesOptGenreator","radioTypes","generateNewSeriesTypes","newSeriesOpt","radio","currentType","Restore","SaveAsImage","$a","download","href","MouseEvent","evt","bubbles","cancelable","dispatchEvent","tab","write","assembleTransition","transitionCurve","transitionText","vendors","vendorPrefix","assembleFont","assembleCssText","transitionDuration","zrColor","borderName","camelCase","TooltipContent","_container","_show","_hideTimeout","onmouseenter","enterable","_inContent","onmousemove","onmouseleave","hideLater","_hideDelay","compromiseMobile","tooltipContentEl","contains","gCssText","currentStyle","setContent","isShow","showContent","triggerOn","alwaysShowContent","showDelay","hideDelay","borderRadius","extraCssText","axisPointer","crossStyle","shadowStyle","dataEqual","makeLineShape","makeRectShape","makeSectorShape","refixTooltipPosition","clientWidth","calcTooltipPosition","domWidth","domHeight","rectWidth","rectHeight","updatePosition","positionExpr","ifSeriesSupportAxisTrigger","_axisPointers","tooltipContent","_tooltipContent","_manuallyShowTip","_manuallyHideTip","_tooltipModel","_ecModel","_lastHover","_alwaysShowContent","_seriesGroupByAxis","_prepareAxisTriggerData","crossText","_crossText","_refreshUpdateTimeout","_tryShow","_mousemove","_hide","_showTimeout","_series","seriesGroupByAxis","globalTrigger","_showAxisTooltip","_ticket","_hideAxisPointer","_resetLastHover","_showItemTooltipContent","subTooltipModel","defaultHtml","asyncTicket","_showTooltipContent","axisPointerModel","axisPointerType","_showAxisPointer","allNotShow","seriesCoordSysSameAxis","allCoordSys","contentNotChange","lastHover","valIndex","_showSinglePointer","_showPolarPointer","_showCartesianPointer","_dispatchAndShowSeriesTooltipContent","moveGridLine","pointerEl","_getPointerElement","moveAnimation","moveGridShadow","_updateCrossText","otherAxis","single","moveSingleLine","movePolarLine","mouseCoord","coordToPoint","movePolarShadow","crossStyleModel","pointerModel","initShape","axisPointers","pointerType","styleModel","isShadow","elementType","seriesList","rootTooltipModel","baseDimIndex","payloadBatch","firstDataIndex","seriesTooltipModel","ticket","cbTicket","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","run","Item","nextTick","argv","versions","addListener","once","removeListener","removeAllListeners","emit","binding","cwd","chdir","umask","VMLPainter","vmlCore","vmlViewport","vmlRoot","_vmlRoot","_vmlViewport","onRemove","onAdd","_firstPaint","createMethodNotSupport","zrLog","__alreadyNotVisible","brushVML","_getWidth","_getHeight","vmlViewportStyle","paddingLeft","paddingRight","paddingTop","paddingBottom","notSupportedMethods","comma","imageTransformPrefix","Z2","ZLEVEL_BASE","Z_BASE","initRootElStyle","coordsize","coordorigin","encodeHtmlAttribute","rgb2Str","append","getZIndex","setColorAndOpacity","getColorAndAlpha","updateFillNode","zrEl","gradientType","focus","expansion","cs1","cs2","colorAndAlphaList","colorAndAlpha","color1","color2","opacity1","opacity2","focusposition","updateStrokeNode","dashstyle","updateFillAndStroke","vmlEl","isFill","getElementsByTagName","pathDataToString","cmdStr","_vmlEl","needTransform","strokeEl","weight","zIndex","removeRectText","appendRectText","isImage","ow","oh","_imageSrc","_imageWidth","_imageHeight","imageRuntimeStyle","runtimeStyle","oldRuntimeWidth","oldRuntimeHeight","dw","dh","sh","hasCrop","vmlElStyle","hasRotation","transformFilter","imageEl","_imageEl","cropEl","_cropEl","imageELStyle","tmpImage","overflow","cropElStyle","filterStr","textMeasureEl","DEFAULT_STYLE_NORMAL","fontStyleCache","fontStyleCacheCount","MAX_FONT_CACHE_SIZE","fontEl","getFontStyle","fontString","variant","fontVariant","family","body","ex","createTextNode","offsetWidth","fromTextEl","textPathEl","skewEl","textVmlEl","_textVmlEl","textpathok","textVmlElStyle","string"],"mappings":"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","file":"echarts.common.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"echarts\"] = factory();\n\telse\n\t\troot[\"echarts\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"echarts\"] = factory();\n\telse\n\t\troot[\"echarts\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!*************************!*\\\n  !*** ./index.common.js ***!\n  \\*************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Export echarts as CommonJS module\n\t */\n\tmodule.exports = __webpack_require__(/*! ./lib/echarts */ 2);\n\t\n\t__webpack_require__(/*! ./lib/chart/line */ 96);\n\t__webpack_require__(/*! ./lib/chart/bar */ 90);\n\t__webpack_require__(/*! ./lib/chart/pie */ 101);\n\t__webpack_require__(/*! ./lib/chart/scatter */ 176);\n\t__webpack_require__(/*! ./lib/component/tooltip */ 212);\n\t__webpack_require__(/*! ./lib/component/legend */ 189);\n\t\n\t__webpack_require__(/*! ./lib/component/grid */ 36);\n\t__webpack_require__(/*! ./lib/component/title */ 203);\n\t\n\t__webpack_require__(/*! ./lib/component/markPoint */ 196);\n\t__webpack_require__(/*! ./lib/component/markLine */ 195);\n\t__webpack_require__(/*! ./lib/component/markArea */ 194);\n\t__webpack_require__(/*! ./lib/component/dataZoom */ 179);\n\t__webpack_require__(/*! ./lib/component/toolbox */ 204);\n\t\n\t__webpack_require__(/*! zrender/lib/vml/vml */ 220);\n\n/***/ },\n/* 1 */\n/*!************************************!*\\\n  !*** ./~/zrender/lib/core/util.js ***!\n  \\************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/core/util\n\t */\n\t\n\t\n\t    // mergeDate\n\t    var BUILTIN_OBJECT = {\n\t        '[object Function]': 1,\n\t        '[object RegExp]': 1,\n\t        '[object Date]': 1,\n\t        '[object Error]': 1,\n\t        '[object CanvasGradient]': 1,\n\t        '[object CanvasPattern]': 1,\n\t        // For node-canvas\n\t        '[object Image]': 1,\n\t        '[object Canvas]': 1\n\t    };\n\t\n\t    var TYPED_ARRAY = {\n\t        '[object Int8Array]': 1,\n\t        '[object Uint8Array]': 1,\n\t        '[object Uint8ClampedArray]': 1,\n\t        '[object Int16Array]': 1,\n\t        '[object Uint16Array]': 1,\n\t        '[object Int32Array]': 1,\n\t        '[object Uint32Array]': 1,\n\t        '[object Float32Array]': 1,\n\t        '[object Float64Array]': 1\n\t    };\n\t\n\t    var objToString = Object.prototype.toString;\n\t\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t\n\t    /**\n\t     * Those data types can be cloned:\n\t     *     Plain object, Array, TypedArray, number, string, null, undefined.\n\t     * Those data types will be assgined using the orginal data:\n\t     *     BUILTIN_OBJECT\n\t     * Instance of user defined class will be cloned to a plain object, without\n\t     * properties in prototype.\n\t     * Other data types is not supported (not sure what will happen).\n\t     *\n\t     * Caution: do not support clone Date, for performance consideration.\n\t     * (There might be a large number of date in `series.data`).\n\t     * So date should not be modified in and out of echarts.\n\t     *\n\t     * @param {*} source\n\t     * @return {*} new\n\t     */\n\t    function clone(source) {\n\t        if (source == null || typeof source != 'object') {\n\t            return source;\n\t        }\n\t\n\t        var result = source;\n\t        var typeStr = objToString.call(source);\n\t\n\t        if (typeStr === '[object Array]') {\n\t            result = [];\n\t            for (var i = 0, len = source.length; i < len; i++) {\n\t                result[i] = clone(source[i]);\n\t            }\n\t        }\n\t        else if (TYPED_ARRAY[typeStr]) {\n\t            result = source.constructor.from(source);\n\t        }\n\t        else if (!BUILTIN_OBJECT[typeStr] && !isDom(source)) {\n\t            result = {};\n\t            for (var key in source) {\n\t                if (source.hasOwnProperty(key)) {\n\t                    result[key] = clone(source[key]);\n\t                }\n\t            }\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t\n\t                if (isObject(sourceProp)\n\t                    && isObject(targetProp)\n\t                    && !isArray(sourceProp)\n\t                    && !isArray(targetProp)\n\t                    && !isDom(sourceProp)\n\t                    && !isDom(targetProp)\n\t                    && !isBuildInObject(sourceProp)\n\t                    && !isBuildInObject(targetProp)\n\t                ) {\n\t                    // merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                }\n\t                else if (overwrite || !(key in target)) {\n\t                    // overwritetrue\n\t                    // NOTE target[key] \n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolen} [overlay=false]\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)\n\t                && (overlay ? source[key] != null : target[key] == null)\n\t            ) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    function createCanvas() {\n\t        return document.createElement('canvas');\n\t    }\n\t    // FIXME\n\t    var _ctx;\n\t    function getContext() {\n\t        if (!_ctx) {\n\t            // Use util.createCanvas instead of createCanvas\n\t            // because createCanvas may be overwritten in different environment\n\t            _ctx = util.createCanvas().getContext('2d');\n\t        }\n\t        return _ctx;\n\t    }\n\t\n\t    /**\n\t     * index\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /**\n\t     * \n\t     *\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} clazz \n\t     * @param {Function} baseClazz \n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {}\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t\n\t        defaults(target, source, overlay);\n\t    }\n\t\n\t    /**\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (! data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        }\n\t        else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        }\n\t        else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        }\n\t        else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || (!!value && type == 'object');\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuildInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)];\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return typeof value === 'object'\n\t            && typeof value.nodeType === 'number'\n\t            && typeof value.ownerDocument === 'object';\n\t    }\n\t\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * @memberOf module:zrender/core/util\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t\n\t    var util = {\n\t        inherits: inherits,\n\t        mixin: mixin,\n\t        clone: clone,\n\t        merge: merge,\n\t        mergeAll: mergeAll,\n\t        extend: extend,\n\t        defaults: defaults,\n\t        getContext: getContext,\n\t        createCanvas: createCanvas,\n\t        indexOf: indexOf,\n\t        slice: slice,\n\t        find: find,\n\t        isArrayLike: isArrayLike,\n\t        each: each,\n\t        map: map,\n\t        reduce: reduce,\n\t        filter: filter,\n\t        bind: bind,\n\t        curry: curry,\n\t        isArray: isArray,\n\t        isString: isString,\n\t        isObject: isObject,\n\t        isFunction: isFunction,\n\t        isBuildInObject: isBuildInObject,\n\t        isDom: isDom,\n\t        retrieve: retrieve,\n\t        assert: assert,\n\t        noop: function () {}\n\t    };\n\t    module.exports = util;\n\t\n\n\n/***/ },\n/* 2 */\n/*!************************!*\\\n  !*** ./lib/echarts.js ***!\n  \\************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Enable DEV mode when using source code without build. which has no __DEV__ variable\n\t// In build process 'typeof __DEV__' will be replace with 'boolean'\n\t// So this code will be removed or disabled anyway after built.\n\tif (false) {\n\t    // In browser\n\t    if (typeof window !== 'undefined') {\n\t        window.__DEV__ = true;\n\t    }\n\t    // In node\n\t    else if (typeof global !== 'undefined') {\n\t        global.__DEV__ = true;\n\t    }\n\t}\n\t\n\t/*!\n\t * ECharts, a javascript interactive chart library.\n\t *\n\t * Copyright (c) 2015, Baidu Inc.\n\t * All rights reserved.\n\t *\n\t * LICENSE\n\t * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n\t */\n\t\n\t/**\n\t * @module echarts\n\t */\n\t\n\t\n\t    var env = __webpack_require__(/*! zrender/lib/core/env */ 11);\n\t\n\t    var GlobalModel = __webpack_require__(/*! ./model/Global */ 124);\n\t    var ExtensionAPI = __webpack_require__(/*! ./ExtensionAPI */ 89);\n\t    var CoordinateSystemManager = __webpack_require__(/*! ./CoordinateSystem */ 23);\n\t    var OptionManager = __webpack_require__(/*! ./model/OptionManager */ 125);\n\t\n\t    var ComponentModel = __webpack_require__(/*! ./model/Component */ 12);\n\t    var SeriesModel = __webpack_require__(/*! ./model/Series */ 15);\n\t\n\t    var ComponentView = __webpack_require__(/*! ./view/Component */ 57);\n\t    var ChartView = __webpack_require__(/*! ./view/Chart */ 27);\n\t    var graphic = __webpack_require__(/*! ./util/graphic */ 3);\n\t    var modelUtil = __webpack_require__(/*! ./util/model */ 7);\n\t\n\t    var zrender = __webpack_require__(/*! zrender */ 76);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var colorTool = __webpack_require__(/*! zrender/lib/tool/color */ 18);\n\t    var Eventful = __webpack_require__(/*! zrender/lib/mixin/Eventful */ 20);\n\t    var timsort = __webpack_require__(/*! zrender/lib/core/timsort */ 44);\n\t\n\t    var each = zrUtil.each;\n\t\n\t    var PRIORITY_PROCESSOR_FILTER = 1000;\n\t    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\t\n\t\n\t    var PRIORITY_VISUAL_LAYOUT = 1000;\n\t    var PRIORITY_VISUAL_GLOBAL = 2000;\n\t    var PRIORITY_VISUAL_CHART = 3000;\n\t    var PRIORITY_VISUAL_COMPONENT = 4000;\n\t    var PRIORITY_VISUAL_BRUSH = 5000;\n\t\n\t    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n\t    // where they must not be invoked nestedly, except the only case: invoke\n\t    // dispatchAction with updateMethod \"none\" in main process.\n\t    // This flag is used to carry out this rule.\n\t    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n\t    var IN_MAIN_PROCESS = '__flag_in_main_process';\n\t    var HAS_GRADIENT_OR_PATTERN_BG = '_hasGradientOrPatternBg';\n\t\n\t\n\t    var OPTION_UPDATED = '_optionUpdated';\n\t\n\t    function createRegisterEventWithLowercaseName(method) {\n\t        return function (eventName, handler, context) {\n\t            // Event name is all lowercase\n\t            eventName = eventName && eventName.toLowerCase();\n\t            Eventful.prototype[method].call(this, eventName, handler, context);\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @module echarts~MessageCenter\n\t     */\n\t    function MessageCenter() {\n\t        Eventful.call(this);\n\t    }\n\t    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n\t    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n\t    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n\t    zrUtil.mixin(MessageCenter, Eventful);\n\t\n\t    /**\n\t     * @module echarts~ECharts\n\t     */\n\t    function ECharts (dom, theme, opts) {\n\t        opts = opts || {};\n\t\n\t        // Get theme by name\n\t        if (typeof theme === 'string') {\n\t            theme = themeStorage[theme];\n\t        }\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id;\n\t        /**\n\t         * Group id\n\t         * @type {string}\n\t         */\n\t        this.group;\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         * @private\n\t         */\n\t        this._dom = dom;\n\t        /**\n\t         * @type {module:zrender/ZRender}\n\t         * @private\n\t         */\n\t        this._zr = zrender.init(dom, {\n\t            renderer: opts.renderer || 'canvas',\n\t            devicePixelRatio: opts.devicePixelRatio,\n\t            width: opts.width,\n\t            height: opts.height\n\t        });\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._theme = zrUtil.clone(theme);\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsViews = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsMap = {};\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsViews = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t\n\t        /**\n\t         * @type {module:echarts/ExtensionAPI}\n\t         * @private\n\t         */\n\t        this._api = new ExtensionAPI(this);\n\t\n\t        /**\n\t         * @type {module:echarts/CoordinateSystem}\n\t         * @private\n\t         */\n\t        this._coordSysMgr = new CoordinateSystemManager();\n\t\n\t        Eventful.call(this);\n\t\n\t        /**\n\t         * @type {module:echarts~MessageCenter}\n\t         * @private\n\t         */\n\t        this._messageCenter = new MessageCenter();\n\t\n\t        // Init mouse events\n\t        this._initEvents();\n\t\n\t        // In case some people write `window.onresize = chart.resize`\n\t        this.resize = zrUtil.bind(this.resize, this);\n\t\n\t        // Can't dispatch action during rendering procedure\n\t        this._pendingActions = [];\n\t        // Sort on demand\n\t        function prioritySortFunc(a, b) {\n\t            return a.prio - b.prio;\n\t        }\n\t        timsort(visualFuncs, prioritySortFunc);\n\t        timsort(dataProcessorFuncs, prioritySortFunc);\n\t\n\t        this._zr.animation.on('frame', this._onframe, this);\n\t    }\n\t\n\t    var echartsProto = ECharts.prototype;\n\t\n\t    echartsProto._onframe = function () {\n\t        // Lazy update\n\t        if (this[OPTION_UPDATED]) {\n\t\n\t            this[IN_MAIN_PROCESS] = true;\n\t\n\t            updateMethods.prepareAndUpdate.call(this);\n\t\n\t            this[IN_MAIN_PROCESS] = false;\n\t\n\t            this[OPTION_UPDATED] = false;\n\t        }\n\t    };\n\t    /**\n\t     * @return {HTMLDomElement}\n\t     */\n\t    echartsProto.getDom = function () {\n\t        return this._dom;\n\t    };\n\t\n\t    /**\n\t     * @return {module:zrender~ZRender}\n\t     */\n\t    echartsProto.getZr = function () {\n\t        return this._zr;\n\t    };\n\t\n\t    /**\n\t     * @param {Object} option\n\t     * @param {boolean} notMerge\n\t     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.\n\t     */\n\t    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n\t        if (false) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = true;\n\t\n\t        if (!this._model || notMerge) {\n\t            var optionManager = new OptionManager(this._api);\n\t            var theme = this._theme;\n\t            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n\t            ecModel.init(null, null, theme, optionManager);\n\t        }\n\t\n\t        this._model.setOption(option, optionPreprocessorFuncs);\n\t\n\t        if (lazyUpdate) {\n\t            this[OPTION_UPDATED] = true;\n\t        }\n\t        else {\n\t            updateMethods.prepareAndUpdate.call(this);\n\t            this._zr.refreshImmediately();\n\t            this[OPTION_UPDATED] = false;\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = false;\n\t\n\t        this._flushPendingActions();\n\t    };\n\t\n\t    /**\n\t     * @DEPRECATED\n\t     */\n\t    echartsProto.setTheme = function () {\n\t        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n\t    };\n\t\n\t    /**\n\t     * @return {module:echarts/model/Global}\n\t     */\n\t    echartsProto.getModel = function () {\n\t        return this._model;\n\t    };\n\t\n\t    /**\n\t     * @return {Object}\n\t     */\n\t    echartsProto.getOption = function () {\n\t        return this._model && this._model.getOption();\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getWidth = function () {\n\t        return this._zr.getWidth();\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getHeight = function () {\n\t        return this._zr.getHeight();\n\t    };\n\t\n\t    /**\n\t     * Get canvas which has all thing rendered\n\t     * @param {Object} opts\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getRenderedCanvas = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        opts = opts || {};\n\t        opts.pixelRatio = opts.pixelRatio || 1;\n\t        opts.backgroundColor = opts.backgroundColor\n\t            || this._model.get('backgroundColor');\n\t        var zr = this._zr;\n\t        var list = zr.storage.getDisplayList();\n\t        // Stop animations\n\t        zrUtil.each(list, function (el) {\n\t            el.stopAnimation(true);\n\t        });\n\t        return zr.painter.getRenderedCanvas(opts);\n\t    };\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getDataURL = function (opts) {\n\t        opts = opts || {};\n\t        var excludeComponents = opts.excludeComponents;\n\t        var ecModel = this._model;\n\t        var excludesComponentViews = [];\n\t        var self = this;\n\t\n\t        each(excludeComponents, function (componentType) {\n\t            ecModel.eachComponent({\n\t                mainType: componentType\n\t            }, function (component) {\n\t                var view = self._componentsMap[component.__viewId];\n\t                if (!view.group.ignore) {\n\t                    excludesComponentViews.push(view);\n\t                    view.group.ignore = true;\n\t                }\n\t            });\n\t        });\n\t\n\t        var url = this.getRenderedCanvas(opts).toDataURL(\n\t            'image/' + (opts && opts.type || 'png')\n\t        );\n\t\n\t        each(excludesComponentViews, function (view) {\n\t            view.group.ignore = false;\n\t        });\n\t        return url;\n\t    };\n\t\n\t\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getConnectedDataURL = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        var groupId = this.group;\n\t        var mathMin = Math.min;\n\t        var mathMax = Math.max;\n\t        var MAX_NUMBER = Infinity;\n\t        if (connectedGroups[groupId]) {\n\t            var left = MAX_NUMBER;\n\t            var top = MAX_NUMBER;\n\t            var right = -MAX_NUMBER;\n\t            var bottom = -MAX_NUMBER;\n\t            var canvasList = [];\n\t            var dpr = (opts && opts.pixelRatio) || 1;\n\t\n\t            zrUtil.each(instances, function (chart, id) {\n\t                if (chart.group === groupId) {\n\t                    var canvas = chart.getRenderedCanvas(\n\t                        zrUtil.clone(opts)\n\t                    );\n\t                    var boundingRect = chart.getDom().getBoundingClientRect();\n\t                    left = mathMin(boundingRect.left, left);\n\t                    top = mathMin(boundingRect.top, top);\n\t                    right = mathMax(boundingRect.right, right);\n\t                    bottom = mathMax(boundingRect.bottom, bottom);\n\t                    canvasList.push({\n\t                        dom: canvas,\n\t                        left: boundingRect.left,\n\t                        top: boundingRect.top\n\t                    });\n\t                }\n\t            });\n\t\n\t            left *= dpr;\n\t            top *= dpr;\n\t            right *= dpr;\n\t            bottom *= dpr;\n\t            var width = right - left;\n\t            var height = bottom - top;\n\t            var targetCanvas = zrUtil.createCanvas();\n\t            targetCanvas.width = width;\n\t            targetCanvas.height = height;\n\t            var zr = zrender.init(targetCanvas);\n\t\n\t            each(canvasList, function (item) {\n\t                var img = new graphic.Image({\n\t                    style: {\n\t                        x: item.left * dpr - left,\n\t                        y: item.top * dpr - top,\n\t                        image: item.dom\n\t                    }\n\t                });\n\t                zr.add(img);\n\t            });\n\t            zr.refreshImmediately();\n\t\n\t            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n\t        }\n\t        else {\n\t            return this.getDataURL(opts);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Convert from logical coordinate system to pixel coordinate system.\n\t     * See CoordinateSystem#convertToPixel.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            geoIndex / geoId, geoName,\n\t     *            bmapIndex / bmapId / bmapName,\n\t     *            xAxisIndex / xAxisId / xAxisName,\n\t     *            yAxisIndex / yAxisId / yAxisName,\n\t     *            gridIndex / gridId / gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     * @param {Array|number} value\n\t     * @return {Array|number} result\n\t     */\n\t    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\t\n\t    /**\n\t     * Convert from pixel coordinate system to logical coordinate system.\n\t     * See CoordinateSystem#convertFromPixel.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            geoIndex / geoId / geoName,\n\t     *            bmapIndex / bmapId / bmapName,\n\t     *            xAxisIndex / xAxisId / xAxisName,\n\t     *            yAxisIndex / yAxisId / yAxisName\n\t     *            gridIndex / gridId / gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     * @param {Array|number} value\n\t     * @return {Array|number} result\n\t     */\n\t    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\t\n\t    function doConvertPixel(methodName, finder, value) {\n\t        var ecModel = this._model;\n\t        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n\t        var result;\n\t\n\t        finder = modelUtil.parseFinder(ecModel, finder);\n\t\n\t        for (var i = 0; i < coordSysList.length; i++) {\n\t            var coordSys = coordSysList[i];\n\t            if (coordSys[methodName]\n\t                && (result = coordSys[methodName](ecModel, finder, value)) != null\n\t            ) {\n\t                return result;\n\t            }\n\t        }\n\t\n\t        if (false) {\n\t            console.warn(\n\t                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n\t            );\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Is the specified coordinate systems or components contain the given pixel point.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            geoIndex / geoId / geoName,\n\t     *            bmapIndex / bmapId / bmapName,\n\t     *            xAxisIndex / xAxisId / xAxisName,\n\t     *            yAxisIndex / yAxisId / yAxisName\n\t     *            gridIndex / gridId / gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     * @param {Array|number} value\n\t     * @return {boolean} result\n\t     */\n\t    echartsProto.containPixel = function (finder, value) {\n\t        var ecModel = this._model;\n\t        var result;\n\t\n\t        finder = modelUtil.parseFinder(ecModel, finder);\n\t\n\t        zrUtil.each(finder, function (models, key) {\n\t            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n\t                var coordSys = model.coordinateSystem;\n\t                if (coordSys && coordSys.containPoint) {\n\t                    result |= !!coordSys.containPoint(value);\n\t                }\n\t                else if (key === 'seriesModels') {\n\t                    var view = this._chartsMap[model.__viewId];\n\t                    if (view && view.containPoint) {\n\t                        result |= view.containPoint(value, model);\n\t                    }\n\t                    else {\n\t                        if (false) {\n\t                            console.warn(key + ': ' + (view\n\t                                ? 'The found component do not support containPoint.'\n\t                                : 'No view mapping to the found component.'\n\t                            ));\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    if (false) {\n\t                        console.warn(key + ': containPoint is not supported');\n\t                    }\n\t                }\n\t            }, this);\n\t        }, this);\n\t\n\t        return !!result;\n\t    };\n\t\n\t    /**\n\t     * Get visual from series or data.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'series', means {seriesIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            dataIndex / dataIndexInside\n\t     *        }\n\t     *        If dataIndex is not specified, series visual will be fetched,\n\t     *        but not data item visual.\n\t     *        If all of seriesIndex, seriesId, seriesName are not specified,\n\t     *        visual will be fetched from first series.\n\t     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n\t     */\n\t    echartsProto.getVisual = function (finder, visualType) {\n\t        var ecModel = this._model;\n\t\n\t        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\t\n\t        var seriesModel = finder.seriesModel;\n\t\n\t        if (false) {\n\t            if (!seriesModel) {\n\t                console.warn('There is no specified seires model');\n\t            }\n\t        }\n\t\n\t        var data = seriesModel.getData();\n\t\n\t        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n\t            ? finder.dataIndexInside\n\t            : finder.hasOwnProperty('dataIndex')\n\t            ? data.indexOfRawIndex(finder.dataIndex)\n\t            : null;\n\t\n\t        return dataIndexInside != null\n\t            ? data.getItemVisual(dataIndexInside, visualType)\n\t            : data.getVisual(visualType);\n\t    };\n\t\n\t\n\t    var updateMethods = {\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        update: function (payload) {\n\t            // console.time && console.time('update');\n\t\n\t            var ecModel = this._model;\n\t            var api = this._api;\n\t            var coordSysMgr = this._coordSysMgr;\n\t            var zr = this._zr;\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            // Fixme First time update ?\n\t            ecModel.restoreData();\n\t\n\t            // TODO\n\t            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n\t            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\t\n\t            // Create new coordinate system each update\n\t            // In LineView may save the old coordinate system and use it to get the orignal point\n\t            coordSysMgr.create(this._model, this._api);\n\t\n\t            processData.call(this, ecModel, api);\n\t\n\t            stackSeriesData.call(this, ecModel);\n\t\n\t            coordSysMgr.update(ecModel, api);\n\t\n\t            doVisualEncoding.call(this, ecModel, payload);\n\t\n\t            doRender.call(this, ecModel, payload);\n\t\n\t            // Set background\n\t            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\t\n\t            var painter = zr.painter;\n\t            // TODO all use clearColor ?\n\t            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n\t                zr.configLayer(0, {\n\t                    clearColor: backgroundColor\n\t                });\n\t            }\n\t            else {\n\t                // In IE8\n\t                if (!env.canvasSupported) {\n\t                    var colorArr = colorTool.parse(backgroundColor);\n\t                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n\t                    if (colorArr[3] === 0) {\n\t                        backgroundColor = 'transparent';\n\t                    }\n\t                }\n\t                if (backgroundColor.colorStops || backgroundColor.image) {\n\t                    // Gradient background\n\t                    // FIXME Fixed layer\n\t                    zr.configLayer(0, {\n\t                        clearColor: backgroundColor\n\t                    });\n\t                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\t\n\t                    this._dom.style.background = 'transparent';\n\t                }\n\t                else {\n\t                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n\t                        zr.configLayer(0, {\n\t                            clearColor: null\n\t                        });\n\t                    }\n\t                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\t\n\t                    this._dom.style.background = backgroundColor;\n\t                }\n\t            }\n\t\n\t            // console.time && console.timeEnd('update');\n\t        },\n\t\n\t        // PENDING\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        updateView: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                seriesModel.getData().clearAllVisual();\n\t            });\n\t\n\t            doVisualEncoding.call(this, ecModel, payload);\n\t\n\t            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        updateVisual: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                seriesModel.getData().clearAllVisual();\n\t            });\n\t\n\t            doVisualEncoding.call(this, ecModel, payload);\n\t\n\t            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        updateLayout: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            doLayout.call(this, ecModel, payload);\n\t\n\t            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        highlight: function (payload) {\n\t            toggleHighlight.call(this, 'highlight', payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        downplay: function (payload) {\n\t            toggleHighlight.call(this, 'downplay', payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        prepareAndUpdate: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            prepareView.call(this, 'component', ecModel);\n\t\n\t            prepareView.call(this, 'chart', ecModel);\n\t\n\t            updateMethods.update.call(this, payload);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {Object} payload\n\t     * @private\n\t     */\n\t    function toggleHighlight(method, payload) {\n\t        var ecModel = this._model;\n\t\n\t        // dispatchAction before setOption\n\t        if (!ecModel) {\n\t            return;\n\t        }\n\t\n\t        ecModel.eachComponent(\n\t            {mainType: 'series', query: payload},\n\t            function (seriesModel, index) {\n\t                var chartView = this._chartsMap[seriesModel.__viewId];\n\t                if (chartView && chartView.__alive) {\n\t                    chartView[method](\n\t                        seriesModel, ecModel, this._api, payload\n\t                    );\n\t                }\n\t            },\n\t            this\n\t        );\n\t    }\n\t\n\t    /**\n\t     * Resize the chart\n\t     * @param {Object} opts\n\t     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     */\n\t    echartsProto.resize = function (opts) {\n\t        if (false) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = true;\n\t\n\t        this._zr.resize(opts);\n\t\n\t        var optionChanged = this._model && this._model.resetOption('media');\n\t        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);\n\t\n\t        // Resize loading effect\n\t        this._loadingFX && this._loadingFX.resize();\n\t\n\t        this[IN_MAIN_PROCESS] = false;\n\t\n\t        this._flushPendingActions();\n\t    };\n\t\n\t    /**\n\t     * Show loading effect\n\t     * @param  {string} [name='default']\n\t     * @param  {Object} [cfg]\n\t     */\n\t    echartsProto.showLoading = function (name, cfg) {\n\t        if (zrUtil.isObject(name)) {\n\t            cfg = name;\n\t            name = '';\n\t        }\n\t        name = name || 'default';\n\t\n\t        this.hideLoading();\n\t        if (!loadingEffects[name]) {\n\t            if (false) {\n\t                console.warn('Loading effects ' + name + ' not exists.');\n\t            }\n\t            return;\n\t        }\n\t        var el = loadingEffects[name](this._api, cfg);\n\t        var zr = this._zr;\n\t        this._loadingFX = el;\n\t\n\t        zr.add(el);\n\t    };\n\t\n\t    /**\n\t     * Hide loading effect\n\t     */\n\t    echartsProto.hideLoading = function () {\n\t        this._loadingFX && this._zr.remove(this._loadingFX);\n\t        this._loadingFX = null;\n\t    };\n\t\n\t    /**\n\t     * @param {Object} eventObj\n\t     * @return {Object}\n\t     */\n\t    echartsProto.makeActionFromEvent = function (eventObj) {\n\t        var payload = zrUtil.extend({}, eventObj);\n\t        payload.type = eventActionMap[eventObj.type];\n\t        return payload;\n\t    };\n\t\n\t    /**\n\t     * @pubilc\n\t     * @param {Object} payload\n\t     * @param {string} [payload.type] Action type\n\t     * @param {boolean} [silent=false] Whether trigger event.\n\t     */\n\t    echartsProto.dispatchAction = function (payload, silent) {\n\t        var actionWrap = actions[payload.type];\n\t        if (!actionWrap) {\n\t            return;\n\t        }\n\t\n\t        var actionInfo = actionWrap.actionInfo;\n\t        var updateMethod = actionInfo.update || 'update';\n\t\n\t        // if (__DEV__) {\n\t        //     zrUtil.assert(\n\t        //         !this[IN_MAIN_PROCESS],\n\t        //         '`dispatchAction` should not be called during main process.'\n\t        //         + 'unless updateMathod is \"none\".'\n\t        //     );\n\t        // }\n\t\n\t        // May dispatchAction in rendering procedure\n\t        if (this[IN_MAIN_PROCESS]) {\n\t            this._pendingActions.push(payload);\n\t            return;\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = true;\n\t\n\t        var payloads = [payload];\n\t        var batched = false;\n\t        // Batch action\n\t        if (payload.batch) {\n\t            batched = true;\n\t            payloads = zrUtil.map(payload.batch, function (item) {\n\t                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n\t                item.batch = null;\n\t                return item;\n\t            });\n\t        }\n\t\n\t        var eventObjBatch = [];\n\t        var eventObj;\n\t        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';\n\t        for (var i = 0; i < payloads.length; i++) {\n\t            var batchItem = payloads[i];\n\t            // Action can specify the event by return it.\n\t            eventObj = actionWrap.action(batchItem, this._model);\n\t            // Emit event outside\n\t            eventObj = eventObj || zrUtil.extend({}, batchItem);\n\t            // Convert type to eventType\n\t            eventObj.type = actionInfo.event || eventObj.type;\n\t            eventObjBatch.push(eventObj);\n\t\n\t            // Highlight and downplay are special.\n\t            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);\n\t        }\n\t\n\t        if (updateMethod !== 'none' && !isHighlightOrDownplay) {\n\t            // Still dirty\n\t            if (this[OPTION_UPDATED]) {\n\t                // FIXME Pass payload ?\n\t                updateMethods.prepareAndUpdate.call(this, payload);\n\t                this[OPTION_UPDATED] = false;\n\t            }\n\t            else {\n\t                updateMethods[updateMethod].call(this, payload);\n\t            }\n\t        }\n\t\n\t        // Follow the rule of action batch\n\t        if (batched) {\n\t            eventObj = {\n\t                type: actionInfo.event || payload.type,\n\t                batch: eventObjBatch\n\t            };\n\t        }\n\t        else {\n\t            eventObj = eventObjBatch[0];\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = false;\n\t\n\t        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n\t\n\t        this._flushPendingActions();\n\t\n\t    };\n\t\n\t    echartsProto._flushPendingActions = function () {\n\t        var pendingActions = this._pendingActions;\n\t        while (pendingActions.length) {\n\t            var payload = pendingActions.shift();\n\t            this.dispatchAction(payload);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Register event\n\t     * @method\n\t     */\n\t    echartsProto.on = createRegisterEventWithLowercaseName('on');\n\t    echartsProto.off = createRegisterEventWithLowercaseName('off');\n\t    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\t\n\t    /**\n\t     * @param {string} methodName\n\t     * @private\n\t     */\n\t    function invokeUpdateMethod(methodName, ecModel, payload) {\n\t        var api = this._api;\n\t\n\t        // Update all components\n\t        each(this._componentsViews, function (component) {\n\t            var componentModel = component.__model;\n\t            component[methodName](componentModel, ecModel, api, payload);\n\t\n\t            updateZ(componentModel, component);\n\t        }, this);\n\t\n\t        // Upate all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chart = this._chartsMap[seriesModel.__viewId];\n\t            chart[methodName](seriesModel, ecModel, api, payload);\n\t\n\t            updateZ(seriesModel, chart);\n\t\n\t            updateProgressiveAndBlend(seriesModel, chart);\n\t        }, this);\n\t\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t    }\n\t\n\t    /**\n\t     * Prepare view instances of charts and components\n\t     * @param  {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function prepareView(type, ecModel) {\n\t        var isComponent = type === 'component';\n\t        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n\t        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n\t        var zr = this._zr;\n\t\n\t        for (var i = 0; i < viewList.length; i++) {\n\t            viewList[i].__alive = false;\n\t        }\n\t\n\t        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n\t            if (isComponent) {\n\t                if (componentType === 'series') {\n\t                    return;\n\t                }\n\t            }\n\t            else {\n\t                model = componentType;\n\t            }\n\t\n\t            // Consider: id same and type changed.\n\t            var viewId = model.id + '_' + model.type;\n\t            var view = viewMap[viewId];\n\t            if (!view) {\n\t                var classType = ComponentModel.parseClassType(model.type);\n\t                var Clazz = isComponent\n\t                    ? ComponentView.getClass(classType.main, classType.sub)\n\t                    : ChartView.getClass(classType.sub);\n\t                if (Clazz) {\n\t                    view = new Clazz();\n\t                    view.init(ecModel, this._api);\n\t                    viewMap[viewId] = view;\n\t                    viewList.push(view);\n\t                    zr.add(view.group);\n\t                }\n\t                else {\n\t                    // Error\n\t                    return;\n\t                }\n\t            }\n\t\n\t            model.__viewId = viewId;\n\t            view.__alive = true;\n\t            view.__id = viewId;\n\t            view.__model = model;\n\t        }, this);\n\t\n\t        for (var i = 0; i < viewList.length;) {\n\t            var view = viewList[i];\n\t            if (!view.__alive) {\n\t                zr.remove(view.group);\n\t                view.dispose(ecModel, this._api);\n\t                viewList.splice(i, 1);\n\t                delete viewMap[view.__id];\n\t            }\n\t            else {\n\t                i++;\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Processor data in each series\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function processData(ecModel, api) {\n\t        each(dataProcessorFuncs, function (process) {\n\t            process.func(ecModel, api);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    function stackSeriesData(ecModel) {\n\t        var stackedDataMap = {};\n\t        ecModel.eachSeries(function (series) {\n\t            var stack = series.get('stack');\n\t            var data = series.getData();\n\t            if (stack && data.type === 'list') {\n\t                var previousStack = stackedDataMap[stack];\n\t                if (previousStack) {\n\t                    data.stackedOn = previousStack;\n\t                }\n\t                stackedDataMap[stack] = data;\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Layout before each chart render there series, special visual encoding stage\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doLayout(ecModel, payload) {\n\t        var api = this._api;\n\t        each(visualFuncs, function (visual) {\n\t            if (visual.isLayout) {\n\t                visual.func(ecModel, api, payload);\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Encode visual infomation from data after data processing\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doVisualEncoding(ecModel, payload) {\n\t        var api = this._api;\n\t        ecModel.clearColorPalette();\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            seriesModel.clearColorPalette();\n\t        });\n\t        each(visualFuncs, function (visual) {\n\t            visual.func(ecModel, api, payload);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Render each chart and component\n\t     * @private\n\t     */\n\t    function doRender(ecModel, payload) {\n\t        var api = this._api;\n\t        // Render all components\n\t        each(this._componentsViews, function (componentView) {\n\t            var componentModel = componentView.__model;\n\t            componentView.render(componentModel, ecModel, api, payload);\n\t\n\t            updateZ(componentModel, componentView);\n\t        }, this);\n\t\n\t        each(this._chartsViews, function (chart) {\n\t            chart.__alive = false;\n\t        }, this);\n\t\n\t        // Render all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chartView = this._chartsMap[seriesModel.__viewId];\n\t            chartView.__alive = true;\n\t            chartView.render(seriesModel, ecModel, api, payload);\n\t\n\t            chartView.group.silent = !!seriesModel.get('silent');\n\t\n\t            updateZ(seriesModel, chartView);\n\t\n\t            updateProgressiveAndBlend(seriesModel, chartView);\n\t\n\t        }, this);\n\t\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t\n\t        // Remove groups of unrendered charts\n\t        each(this._chartsViews, function (chart) {\n\t            if (!chart.__alive) {\n\t                chart.remove(ecModel, api);\n\t            }\n\t        }, this);\n\t    }\n\t\n\t    var MOUSE_EVENT_NAMES = [\n\t        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n\t        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n\t    ];\n\t    /**\n\t     * @private\n\t     */\n\t    echartsProto._initEvents = function () {\n\t        each(MOUSE_EVENT_NAMES, function (eveName) {\n\t            this._zr.on(eveName, function (e) {\n\t                var ecModel = this.getModel();\n\t                var el = e.target;\n\t                var params;\n\t\n\t                // no e.target when 'globalout'.\n\t                if (eveName === 'globalout') {\n\t                    params = {};\n\t                }\n\t                else if (el && el.dataIndex != null) {\n\t                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n\t                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n\t                }\n\t                // If element has custom eventData of components\n\t                else if (el && el.eventData) {\n\t                    params = zrUtil.extend({}, el.eventData);\n\t                }\n\t\n\t                if (params) {\n\t                    params.event = e;\n\t                    params.type = eveName;\n\t                    this.trigger(eveName, params);\n\t                }\n\t\n\t            }, this);\n\t        }, this);\n\t\n\t        each(eventActionMap, function (actionType, eventType) {\n\t            this._messageCenter.on(eventType, function (event) {\n\t                this.trigger(eventType, event);\n\t            }, this);\n\t        }, this);\n\t    };\n\t\n\t    /**\n\t     * @return {boolean}\n\t     */\n\t    echartsProto.isDisposed = function () {\n\t        return this._disposed;\n\t    };\n\t\n\t    /**\n\t     * Clear\n\t     */\n\t    echartsProto.clear = function () {\n\t        this.setOption({ series: [] }, true);\n\t    };\n\t    /**\n\t     * Dispose instance\n\t     */\n\t    echartsProto.dispose = function () {\n\t        if (this._disposed) {\n\t            if (false) {\n\t                console.warn('Instance ' + this.id + ' has been disposed');\n\t            }\n\t            return;\n\t        }\n\t        this._disposed = true;\n\t\n\t        var api = this._api;\n\t        var ecModel = this._model;\n\t\n\t        each(this._componentsViews, function (component) {\n\t            component.dispose(ecModel, api);\n\t        });\n\t        each(this._chartsViews, function (chart) {\n\t            chart.dispose(ecModel, api);\n\t        });\n\t\n\t        // Dispose after all views disposed\n\t        this._zr.dispose();\n\t\n\t        delete instances[this.id];\n\t    };\n\t\n\t    zrUtil.mixin(ECharts, Eventful);\n\t\n\t    function updateHoverLayerStatus(zr, ecModel) {\n\t        var storage = zr.storage;\n\t        var elCount = 0;\n\t        storage.traverse(function (el) {\n\t            if (!el.isGroup) {\n\t                elCount++;\n\t            }\n\t        });\n\t        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n\t            storage.traverse(function (el) {\n\t                if (!el.isGroup) {\n\t                    el.useHoverLayer = true;\n\t                }\n\t            });\n\t        }\n\t    }\n\t    /**\n\t     * Update chart progressive and blend.\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateProgressiveAndBlend(seriesModel, chartView) {\n\t        // Progressive configuration\n\t        var elCount = 0;\n\t        chartView.group.traverse(function (el) {\n\t            if (el.type !== 'group' && !el.ignore) {\n\t                elCount++;\n\t            }\n\t        });\n\t        var frameDrawNum = +seriesModel.get('progressive');\n\t        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n\t        if (needProgressive) {\n\t            chartView.group.traverse(function (el) {\n\t                // FIXME marker and other components\n\t                if (!el.isGroup) {\n\t                    el.progressive = needProgressive ?\n\t                        Math.floor(elCount++ / frameDrawNum) : -1;\n\t                    if (needProgressive) {\n\t                        el.stopAnimation(true);\n\t                    }\n\t                }\n\t            });\n\t        }\n\t\n\t        // Blend configration\n\t        var blendMode = seriesModel.get('blendMode') || null;\n\t        if (false) {\n\t            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n\t                console.warn('Only canvas support blendMode');\n\t            }\n\t        }\n\t        chartView.group.traverse(function (el) {\n\t            // FIXME marker and other components\n\t            if (!el.isGroup) {\n\t                el.setStyle('blend', blendMode);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateZ(model, view) {\n\t        var z = model.get('z');\n\t        var zlevel = model.get('zlevel');\n\t        // Set z and zlevel\n\t        view.group.traverse(function (el) {\n\t            if (el.type !== 'group') {\n\t                z != null && (el.z = z);\n\t                zlevel != null && (el.zlevel = zlevel);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var actions = [];\n\t\n\t    /**\n\t     * Map eventType to actionType\n\t     * @type {Object}\n\t     */\n\t    var eventActionMap = {};\n\t\n\t    /**\n\t     * Data processor functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var dataProcessorFuncs = [];\n\t\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var optionPreprocessorFuncs = [];\n\t\n\t    /**\n\t     * Visual encoding functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var visualFuncs = [];\n\t    /**\n\t     * Theme storage\n\t     * @type {Object.<key, Object>}\n\t     */\n\t    var themeStorage = {};\n\t    /**\n\t     * Loading effects\n\t     */\n\t    var loadingEffects = {};\n\t\n\t\n\t    var instances = {};\n\t    var connectedGroups = {};\n\t\n\t    var idBase = new Date() - 0;\n\t    var groupIdBase = new Date() - 0;\n\t    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\t    /**\n\t     * @alias module:echarts\n\t     */\n\t    var echarts = {\n\t        /**\n\t         * @type {number}\n\t         */\n\t        version: '3.3.1',\n\t        dependencies: {\n\t            zrender: '3.2.1'\n\t        }\n\t    };\n\t\n\t    function enableConnect(chart) {\n\t\n\t        var STATUS_PENDING = 0;\n\t        var STATUS_UPDATING = 1;\n\t        var STATUS_UPDATED = 2;\n\t        var STATUS_KEY = '__connectUpdateStatus';\n\t        function updateConnectedChartsStatus(charts, status) {\n\t            for (var i = 0; i < charts.length; i++) {\n\t                var otherChart = charts[i];\n\t                otherChart[STATUS_KEY] = status;\n\t            }\n\t        }\n\t        zrUtil.each(eventActionMap, function (actionType, eventType) {\n\t            chart._messageCenter.on(eventType, function (event) {\n\t                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n\t                    var action = chart.makeActionFromEvent(event);\n\t                    var otherCharts = [];\n\t\n\t                    zrUtil.each(instances, function (otherChart) {\n\t                        if (otherChart !== chart && otherChart.group === chart.group) {\n\t                            otherCharts.push(otherChart);\n\t                        }\n\t                    });\n\t\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n\t                    each(otherCharts, function (otherChart) {\n\t                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n\t                            otherChart.dispatchAction(action);\n\t                        }\n\t                    });\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n\t                }\n\t            });\n\t        });\n\t\n\t    }\n\t    /**\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} [theme]\n\t     * @param {Object} opts\n\t     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n\t     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n\t     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n\t     *                              Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n\t     *                               Can be 'auto' (the same as null/undefined)\n\t     */\n\t    echarts.init = function (dom, theme, opts) {\n\t        if (false) {\n\t            // Check version\n\t            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n\t                throw new Error(\n\t                    'ZRender ' + zrender.version\n\t                    + ' is too old for ECharts ' + echarts.version\n\t                    + '. Current version need ZRender '\n\t                    + echarts.dependencies.zrender + '+'\n\t                );\n\t            }\n\t            if (!dom) {\n\t                throw new Error('Initialize failed: invalid dom.');\n\t            }\n\t            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n\t                console.warn('Can\\'t get dom width or height');\n\t            }\n\t        }\n\t\n\t        var chart = new ECharts(dom, theme, opts);\n\t        chart.id = 'ec_' + idBase++;\n\t        instances[chart.id] = chart;\n\t\n\t        dom.setAttribute &&\n\t            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\t\n\t        enableConnect(chart);\n\t\n\t        return chart;\n\t    };\n\t\n\t    /**\n\t     * @return {string|Array.<module:echarts~ECharts>} groupId\n\t     */\n\t    echarts.connect = function (groupId) {\n\t        // Is array of charts\n\t        if (zrUtil.isArray(groupId)) {\n\t            var charts = groupId;\n\t            groupId = null;\n\t            // If any chart has group\n\t            zrUtil.each(charts, function (chart) {\n\t                if (chart.group != null) {\n\t                    groupId = chart.group;\n\t                }\n\t            });\n\t            groupId = groupId || ('g_' + groupIdBase++);\n\t            zrUtil.each(charts, function (chart) {\n\t                chart.group = groupId;\n\t            });\n\t        }\n\t        connectedGroups[groupId] = true;\n\t        return groupId;\n\t    };\n\t\n\t    /**\n\t     * @return {string} groupId\n\t     */\n\t    echarts.disConnect = function (groupId) {\n\t        connectedGroups[groupId] = false;\n\t    };\n\t\n\t    /**\n\t     * Dispose a chart instance\n\t     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n\t     */\n\t    echarts.dispose = function (chart) {\n\t        if (zrUtil.isDom(chart)) {\n\t            chart = echarts.getInstanceByDom(chart);\n\t        }\n\t        else if (typeof chart === 'string') {\n\t            chart = instances[chart];\n\t        }\n\t        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n\t            chart.dispose();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param  {HTMLDomElement} dom\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceByDom = function (dom) {\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n\t        return instances[key];\n\t    };\n\t    /**\n\t     * @param {string} key\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceById = function (key) {\n\t        return instances[key];\n\t    };\n\t\n\t    /**\n\t     * Register theme\n\t     */\n\t    echarts.registerTheme = function (name, theme) {\n\t        themeStorage[name] = theme;\n\t    };\n\t\n\t    /**\n\t     * Register option preprocessor\n\t     * @param {Function} preprocessorFunc\n\t     */\n\t    echarts.registerPreprocessor = function (preprocessorFunc) {\n\t        optionPreprocessorFuncs.push(preprocessorFunc);\n\t    };\n\t\n\t    /**\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} processorFunc\n\t     */\n\t    echarts.registerProcessor = function (priority, processorFunc) {\n\t        if (typeof priority === 'function') {\n\t            processorFunc = priority;\n\t            priority = PRIORITY_PROCESSOR_FILTER;\n\t        }\n\t        if (false) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown processor priority');\n\t            }\n\t        }\n\t        dataProcessorFuncs.push({\n\t            prio: priority,\n\t            func: processorFunc\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Usage:\n\t     * registerAction('someAction', 'someEvent', function () { ... });\n\t     * registerAction('someAction', function () { ... });\n\t     * registerAction(\n\t     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n\t     *     function () { ... }\n\t     * );\n\t     *\n\t     * @param {(string|Object)} actionInfo\n\t     * @param {string} actionInfo.type\n\t     * @param {string} [actionInfo.event]\n\t     * @param {string} [actionInfo.update]\n\t     * @param {string} [eventName]\n\t     * @param {Function} action\n\t     */\n\t    echarts.registerAction = function (actionInfo, eventName, action) {\n\t        if (typeof eventName === 'function') {\n\t            action = eventName;\n\t            eventName = '';\n\t        }\n\t        var actionType = zrUtil.isObject(actionInfo)\n\t            ? actionInfo.type\n\t            : ([actionInfo, actionInfo = {\n\t                event: eventName\n\t            }][0]);\n\t\n\t        // Event name is all lowercase\n\t        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n\t        eventName = actionInfo.event;\n\t\n\t        if (!actions[actionType]) {\n\t            actions[actionType] = {action: action, actionInfo: actionInfo};\n\t        }\n\t        eventActionMap[eventName] = actionType;\n\t    };\n\t\n\t    /**\n\t     * @param {string} type\n\t     * @param {*} CoordinateSystem\n\t     */\n\t    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n\t        CoordinateSystemManager.register(type, CoordinateSystem);\n\t    };\n\t\n\t    /**\n\t     * Layout is a special stage of visual encoding\n\t     * Most visual encoding like color are common for different chart\n\t     * But each chart has it's own layout algorithm\n\t     *\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} layoutFunc\n\t     */\n\t    echarts.registerLayout = function (priority, layoutFunc) {\n\t        if (typeof priority === 'function') {\n\t            layoutFunc = priority;\n\t            priority = PRIORITY_VISUAL_LAYOUT;\n\t        }\n\t        if (false) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown layout priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: layoutFunc,\n\t            isLayout: true\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @param {number} [priority=3000]\n\t     * @param {Function} visualFunc\n\t     */\n\t    echarts.registerVisual = function (priority, visualFunc) {\n\t        if (typeof priority === 'function') {\n\t            visualFunc = priority;\n\t            priority = PRIORITY_VISUAL_CHART;\n\t        }\n\t        if (false) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown visual priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: visualFunc\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @param {string} name\n\t     */\n\t    echarts.registerLoading = function (name, loadingFx) {\n\t        loadingEffects[name] = loadingFx;\n\t    };\n\t\n\t\n\t    var parseClassType = ComponentModel.parseClassType;\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentModel = function (opts, superClass) {\n\t        var Clazz = ComponentModel;\n\t        if (superClass) {\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentView = function (opts, superClass) {\n\t        var Clazz = ComponentView;\n\t        if (superClass) {\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendSeriesModel = function (opts, superClass) {\n\t        var Clazz = SeriesModel;\n\t        if (superClass) {\n\t            superClass = 'series.' + superClass.replace('series.', '');\n\t            var classType = parseClassType(superClass);\n\t            Clazz = SeriesModel.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendChartView = function (opts, superClass) {\n\t        var Clazz = ChartView;\n\t        if (superClass) {\n\t            superClass.replace('series.', '');\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ChartView.getClass(classType.main, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * ZRender need a canvas context to do measureText.\n\t     * But in node environment canvas may be created by node-canvas.\n\t     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n\t     *\n\t     * Be careful of using it in the browser.\n\t     *\n\t     * @param {Function} creator\n\t     * @example\n\t     *     var Canvas = require('canvas');\n\t     *     var echarts = require('echarts');\n\t     *     echarts.setCanvasCreator(function () {\n\t     *         // Small size is enough.\n\t     *         return new Canvas(32, 32);\n\t     *     });\n\t     */\n\t    echarts.setCanvasCreator = function (creator) {\n\t        zrUtil.createCanvas = creator;\n\t    };\n\t\n\t    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, __webpack_require__(/*! ./visual/seriesColor */ 138));\n\t    echarts.registerPreprocessor(__webpack_require__(/*! ./preprocessor/backwardCompat */ 132));\n\t    echarts.registerLoading('default', __webpack_require__(/*! ./loading/default */ 123));\n\t\n\t    // Default action\n\t    echarts.registerAction({\n\t        type: 'highlight',\n\t        event: 'highlight',\n\t        update: 'highlight'\n\t    }, zrUtil.noop);\n\t    echarts.registerAction({\n\t        type: 'downplay',\n\t        event: 'downplay',\n\t        update: 'downplay'\n\t    }, zrUtil.noop);\n\t\n\t\n\t    // --------\n\t    // Exports\n\t    // --------\n\t    //\n\t    echarts.List = __webpack_require__(/*! ./data/List */ 14);\n\t    echarts.Model = __webpack_require__(/*! ./model/Model */ 10);\n\t\n\t    echarts.graphic = __webpack_require__(/*! ./util/graphic */ 3);\n\t    echarts.number = __webpack_require__(/*! ./util/number */ 4);\n\t    echarts.format = __webpack_require__(/*! ./util/format */ 9);\n\t    echarts.matrix = __webpack_require__(/*! zrender/lib/core/matrix */ 19);\n\t    echarts.vector = __webpack_require__(/*! zrender/lib/core/vector */ 5);\n\t    echarts.color = __webpack_require__(/*! zrender/lib/tool/color */ 18);\n\t\n\t    echarts.util = {};\n\t    each([\n\t            'map', 'each', 'filter', 'indexOf', 'inherits',\n\t            'reduce', 'filter', 'bind', 'curry', 'isArray',\n\t            'isString', 'isObject', 'isFunction', 'extend', 'defaults'\n\t        ],\n\t        function (name) {\n\t            echarts.util[name] = zrUtil[name];\n\t        }\n\t    );\n\t\n\t    // PRIORITY\n\t    echarts.PRIORITY = {\n\t        PROCESSOR: {\n\t            FILTER: PRIORITY_PROCESSOR_FILTER,\n\t            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n\t        },\n\t        VISUAL: {\n\t            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n\t            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n\t            CHART: PRIORITY_VISUAL_CHART,\n\t            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n\t            BRUSH: PRIORITY_VISUAL_BRUSH\n\t        }\n\t    };\n\t\n\t    module.exports = echarts;\n\n\n/***/ },\n/* 3 */\n/*!*****************************!*\\\n  !*** ./lib/util/graphic.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var pathTool = __webpack_require__(/*! zrender/lib/tool/path */ 168);\n\t    var round = Math.round;\n\t    var Path = __webpack_require__(/*! zrender/lib/graphic/Path */ 6);\n\t    var colorTool = __webpack_require__(/*! zrender/lib/tool/color */ 18);\n\t    var matrix = __webpack_require__(/*! zrender/lib/core/matrix */ 19);\n\t    var vector = __webpack_require__(/*! zrender/lib/core/vector */ 5);\n\t    var Gradient = __webpack_require__(/*! zrender/lib/graphic/Gradient */ 29);\n\t\n\t    var graphic = {};\n\t\n\t    graphic.Group = __webpack_require__(/*! zrender/lib/container/Group */ 34);\n\t\n\t    graphic.Image = __webpack_require__(/*! zrender/lib/graphic/Image */ 48);\n\t\n\t    graphic.Text = __webpack_require__(/*! zrender/lib/graphic/Text */ 74);\n\t\n\t    graphic.Circle = __webpack_require__(/*! zrender/lib/graphic/shape/Circle */ 159);\n\t\n\t    graphic.Sector = __webpack_require__(/*! zrender/lib/graphic/shape/Sector */ 165);\n\t\n\t    graphic.Ring = __webpack_require__(/*! zrender/lib/graphic/shape/Ring */ 164);\n\t\n\t    graphic.Polygon = __webpack_require__(/*! zrender/lib/graphic/shape/Polygon */ 161);\n\t\n\t    graphic.Polyline = __webpack_require__(/*! zrender/lib/graphic/shape/Polyline */ 162);\n\t\n\t    graphic.Rect = __webpack_require__(/*! zrender/lib/graphic/shape/Rect */ 163);\n\t\n\t    graphic.Line = __webpack_require__(/*! zrender/lib/graphic/shape/Line */ 160);\n\t\n\t    graphic.BezierCurve = __webpack_require__(/*! zrender/lib/graphic/shape/BezierCurve */ 158);\n\t\n\t    graphic.Arc = __webpack_require__(/*! zrender/lib/graphic/shape/Arc */ 157);\n\t\n\t    graphic.CompoundPath = __webpack_require__(/*! zrender/lib/graphic/CompoundPath */ 152);\n\t\n\t    graphic.LinearGradient = __webpack_require__(/*! zrender/lib/graphic/LinearGradient */ 87);\n\t\n\t    graphic.RadialGradient = __webpack_require__(/*! zrender/lib/graphic/RadialGradient */ 153);\n\t\n\t    graphic.BoundingRect = __webpack_require__(/*! zrender/lib/core/BoundingRect */ 8);\n\t\n\t    /**\n\t     * Extend shape with parameters\n\t     */\n\t    graphic.extendShape = function (opts) {\n\t        return Path.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * Extend path\n\t     */\n\t    graphic.extendPath = function (pathData, opts) {\n\t        return pathTool.extendFromString(pathData, opts);\n\t    };\n\t\n\t    /**\n\t     * Create a path element from path data string\n\t     * @param {string} pathData\n\t     * @param {Object} opts\n\t     * @param {module:zrender/core/BoundingRect} rect\n\t     * @param {string} [layout=cover] 'center' or 'cover'\n\t     */\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\n\t        var path = pathTool.createFromString(pathData, opts);\n\t        var boundingRect = path.getBoundingRect();\n\t        if (rect) {\n\t            var aspect = boundingRect.width / boundingRect.height;\n\t\n\t            if (layout === 'center') {\n\t                // Set rect to center, keep width / height ratio.\n\t                var width = rect.height * aspect;\n\t                var height;\n\t                if (width <= rect.width) {\n\t                    height = rect.height;\n\t                }\n\t                else {\n\t                    width = rect.width;\n\t                    height = width / aspect;\n\t                }\n\t                var cx = rect.x + rect.width / 2;\n\t                var cy = rect.y + rect.height / 2;\n\t\n\t                rect.x = cx - width / 2;\n\t                rect.y = cy - height / 2;\n\t                rect.width = width;\n\t                rect.height = height;\n\t            }\n\t\n\t            this.resizePath(path, rect);\n\t        }\n\t        return path;\n\t    };\n\t\n\t    graphic.mergePath = pathTool.mergePath,\n\t\n\t    /**\n\t     * Resize a path to fit the rect\n\t     * @param {module:zrender/graphic/Path} path\n\t     * @param {Object} rect\n\t     */\n\t    graphic.resizePath = function (path, rect) {\n\t        if (!path.applyTransform) {\n\t            return;\n\t        }\n\t\n\t        var pathRect = path.getBoundingRect();\n\t\n\t        var m = pathRect.calculateTransform(rect);\n\t\n\t        path.applyTransform(m);\n\t    };\n\t\n\t    /**\n\t     * Sub pixel optimize line for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x1]\n\t     * @param {number} [param.shape.y1]\n\t     * @param {number} [param.shape.x2]\n\t     * @param {number} [param.shape.y2]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeLine = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n\t        }\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n\t        }\n\t        return param;\n\t    };\n\t\n\t    /**\n\t     * Sub pixel optimize rect for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x]\n\t     * @param {number} [param.shape.y]\n\t     * @param {number} [param.shape.width]\n\t     * @param {number} [param.shape.height]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeRect = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t        var originX = shape.x;\n\t        var originY = shape.y;\n\t        var originWidth = shape.width;\n\t        var originHeight = shape.height;\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n\t        shape.width = Math.max(\n\t            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n\t            originWidth === 0 ? 0 : 1\n\t        );\n\t        shape.height = Math.max(\n\t            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n\t            originHeight === 0 ? 0 : 1\n\t        );\n\t        return param;\n\t    };\n\t\n\t    /**\n\t     * Sub pixel optimize for canvas\n\t     *\n\t     * @param {number} position Coordinate, such as x, y\n\t     * @param {number} lineWidth Should be nonnegative integer.\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\n\t     * @return {number} Optimized position.\n\t     */\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\n\t        // otherwise line will be fuzzy in canvas.\n\t        var doubledPosition = round(position * 2);\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0\n\t            ? doubledPosition / 2\n\t            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n\t    };\n\t\n\t    function hasFillOrStroke(fillOrStroke) {\n\t        return fillOrStroke != null && fillOrStroke != 'none';\n\t    }\n\t\n\t    function liftColor(color) {\n\t        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    function cacheElementStl(el) {\n\t        if (el.__hoverStlDirty) {\n\t            var stroke = el.style.stroke;\n\t            var fill = el.style.fill;\n\t\n\t            // Create hoverStyle on mouseover\n\t            var hoverStyle = el.__hoverStl;\n\t            hoverStyle.fill = hoverStyle.fill\n\t                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n\t            hoverStyle.stroke = hoverStyle.stroke\n\t                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\t\n\t            var normalStyle = {};\n\t            for (var name in hoverStyle) {\n\t                if (hoverStyle.hasOwnProperty(name)) {\n\t                    normalStyle[name] = el.style[name];\n\t                }\n\t            }\n\t\n\t            el.__normalStl = normalStyle;\n\t\n\t            el.__hoverStlDirty = false;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    function doSingleEnterHover(el) {\n\t        if (el.__isHover) {\n\t            return;\n\t        }\n\t\n\t        cacheElementStl(el);\n\t\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n\t        }\n\t        else {\n\t            el.setStyle(el.__hoverStl);\n\t            el.z2 += 1;\n\t        }\n\t\n\t        el.__isHover = true;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function doSingleLeaveHover(el) {\n\t        if (!el.__isHover) {\n\t            return;\n\t        }\n\t\n\t        var normalStl = el.__normalStl;\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.removeHover(el);\n\t        }\n\t        else {\n\t            normalStl && el.setStyle(normalStl);\n\t            el.z2 -= 1;\n\t        }\n\t\n\t        el.__isHover = false;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function doEnterHover(el) {\n\t        el.type === 'group'\n\t            ? el.traverse(function (child) {\n\t                if (child.type !== 'group') {\n\t                    doSingleEnterHover(child);\n\t                }\n\t            })\n\t            : doSingleEnterHover(el);\n\t    }\n\t\n\t    function doLeaveHover(el) {\n\t        el.type === 'group'\n\t            ? el.traverse(function (child) {\n\t                if (child.type !== 'group') {\n\t                    doSingleLeaveHover(child);\n\t                }\n\t            })\n\t            : doSingleLeaveHover(el);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function setElementHoverStl(el, hoverStl) {\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n\t        // Often used when item group has a label element and it's hoverStyle is different\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\n\t        el.__hoverStlDirty = true;\n\t\n\t        if (el.__isHover) {\n\t            cacheElementStl(el);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOver() {\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doEnterHover(this);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOut() {\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doLeaveHover(this);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function enterEmphasis() {\n\t        this.__isEmphasis = true;\n\t        doEnterHover(this);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function leaveEmphasis() {\n\t        this.__isEmphasis = false;\n\t        doLeaveHover(this);\n\t    }\n\t\n\t    /**\n\t     * Set hover style of element\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} [hoverStyle]\n\t     */\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\n\t        el.type === 'group'\n\t            ? el.traverse(function (child) {\n\t                if (child.type !== 'group') {\n\t                    setElementHoverStl(child, hoverStyle);\n\t                }\n\t            })\n\t            : setElementHoverStl(el, hoverStyle);\n\t        // Remove previous bound handlers\n\t        el.on('mouseover', onElementMouseOver)\n\t          .on('mouseout', onElementMouseOut);\n\t\n\t        // Emphasis, normal can be triggered manually\n\t        el.on('emphasis', enterEmphasis)\n\t          .on('normal', leaveEmphasis);\n\t    };\n\t\n\t    /**\n\t     * Set text option in the style\n\t     * @param {Object} textStyle\n\t     * @param {module:echarts/model/Model} labelModel\n\t     * @param {string} color\n\t     */\n\t    graphic.setText = function (textStyle, labelModel, color) {\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        zrUtil.extend(textStyle, {\n\t            textDistance: labelModel.getShallow('distance') || 5,\n\t            textFont: textStyleModel.getFont(),\n\t            textPosition: labelPosition,\n\t            textFill: textStyleModel.getTextColor() || labelColor\n\t        });\n\t    };\n\t\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n\t        if (typeof dataIndex === 'function') {\n\t            cb = dataIndex;\n\t            dataIndex = null;\n\t        }\n\t        var animationEnabled = animatableModel\n\t            && (\n\t                animatableModel.ifEnableAnimation\n\t                ? animatableModel.ifEnableAnimation()\n\t                // Directly use animation property\n\t                : animatableModel.getShallow('animation')\n\t            );\n\t\n\t        if (animationEnabled) {\n\t            var postfix = isUpdate ? 'Update' : '';\n\t            var duration = animatableModel\n\t                && animatableModel.getShallow('animationDuration' + postfix);\n\t            var animationEasing = animatableModel\n\t                && animatableModel.getShallow('animationEasing' + postfix);\n\t            var animationDelay = animatableModel\n\t                && animatableModel.getShallow('animationDelay' + postfix);\n\t            if (typeof animationDelay === 'function') {\n\t                animationDelay = animationDelay(dataIndex);\n\t            }\n\t            duration > 0\n\t                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n\t                : (el.attr(props), cb && cb());\n\t        }\n\t        else {\n\t            el.attr(props);\n\t            cb && cb();\n\t        }\n\t    }\n\t    /**\n\t     * Update graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} [cb]\n\t     * @example\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n\t     *     // Or\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, function () { console.log('Animation done!'); });\n\t     */\n\t    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t\n\t    /**\n\t     * Init graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} cb\n\t     */\n\t    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t\n\t    /**\n\t     * Get transform matrix of target (param target),\n\t     * in coordinate of its ancestor (param ancestor)\n\t     *\n\t     * @param {module:zrender/mixin/Transformable} target\n\t     * @param {module:zrender/mixin/Transformable} [ancestor]\n\t     */\n\t    graphic.getTransform = function (target, ancestor) {\n\t        var mat = matrix.identity([]);\n\t\n\t        while (target && target !== ancestor) {\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\n\t            target = target.parent;\n\t        }\n\t\n\t        return mat;\n\t    };\n\t\n\t    /**\n\t     * Apply transform to an vertex.\n\t     * @param {Array.<number>} vertex [x, y]\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {Array.<number>} [x, y]\n\t     */\n\t    graphic.applyTransform = function (vertex, transform, invert) {\n\t        if (invert) {\n\t            transform = matrix.invert([], transform);\n\t        }\n\t        return vector.applyTransform([], vertex, transform);\n\t    };\n\t\n\t    /**\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n\t     */\n\t    graphic.transformDirection = function (direction, transform, invert) {\n\t\n\t        // Pick a base, ensure that transform result will not be (0, 0).\n\t        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n\t            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n\t        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n\t            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\t\n\t        var vertex = [\n\t            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n\t            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n\t        ];\n\t\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\n\t\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n\t            ? (vertex[0] > 0 ? 'right' : 'left')\n\t            : (vertex[1] > 0 ? 'bottom' : 'top');\n\t    };\n\t\n\t    /**\n\t     * Apply group transition animation from g1 to g2\n\t     */\n\t    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n\t        if (!g1 || !g2) {\n\t            return;\n\t        }\n\t\n\t        function getElMap(g) {\n\t            var elMap = {};\n\t            g.traverse(function (el) {\n\t                if (!el.isGroup && el.anid) {\n\t                    elMap[el.anid] = el;\n\t                }\n\t            });\n\t            return elMap;\n\t        }\n\t        function getAnimatableProps(el) {\n\t            var obj = {\n\t                position: vector.clone(el.position),\n\t                rotation: el.rotation\n\t            };\n\t            if (el.shape) {\n\t                obj.shape = zrUtil.extend({}, el.shape);\n\t            }\n\t            return obj;\n\t        }\n\t        var elMap1 = getElMap(g1);\n\t\n\t        g2.traverse(function (el) {\n\t            if (!el.isGroup && el.anid) {\n\t                var oldEl = elMap1[el.anid];\n\t                if (oldEl) {\n\t                    var newProp = getAnimatableProps(el);\n\t                    el.attr(getAnimatableProps(oldEl));\n\t                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n\t                }\n\t                // else {\n\t                //     if (el.previousProps) {\n\t                //         graphic.updateProps\n\t                //     }\n\t                // }\n\t            }\n\t        });\n\t    };\n\t\n\t    module.exports = graphic;\n\n\n/***/ },\n/* 4 */\n/*!****************************!*\\\n  !*** ./lib/util/number.js ***!\n  \\****************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * \n\t * @module echarts/util/number\n\t */\n\t\n\t\n\t\n\t    var number = {};\n\t\n\t    var RADIAN_EPSILON = 1e-4;\n\t\n\t    function _trim(str) {\n\t        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n\t    }\n\t\n\t    /**\n\t     * Linear mapping a value from domain to range\n\t     * @memberOf module:echarts/util/number\n\t     * @param  {(number|Array.<number>)} val\n\t     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n\t     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n\t     * @param  {boolean} clamp\n\t     * @return {(number|Array.<number>}\n\t     */\n\t    number.linearMap = function (val, domain, range, clamp) {\n\t        var subDomain = domain[1] - domain[0];\n\t        var subRange = range[1] - range[0];\n\t\n\t        if (subDomain === 0) {\n\t            return subRange === 0\n\t                ? range[0]\n\t                : (range[0] + range[1]) / 2;\n\t        }\n\t\n\t        // Avoid accuracy problem in edge, such as\n\t        // 146.39 - 62.83 === 83.55999999999999.\n\t        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n\t        // It is a little verbose for efficiency considering this method\n\t        // is a hotspot.\n\t        if (clamp) {\n\t            if (subDomain > 0) {\n\t                if (val <= domain[0]) {\n\t                    return range[0];\n\t                }\n\t                else if (val >= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            }\n\t            else {\n\t                if (val >= domain[0]) {\n\t                    return range[0];\n\t                }\n\t                else if (val <= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            if (val === domain[0]) {\n\t                return range[0];\n\t            }\n\t            if (val === domain[1]) {\n\t                return range[1];\n\t            }\n\t        }\n\t\n\t        return (val - domain[0]) / subDomain * subRange + range[0];\n\t    };\n\t\n\t    /**\n\t     * Convert a percent string to absolute number.\n\t     * Returns NaN if percent is not a valid string or number\n\t     * @memberOf module:echarts/util/number\n\t     * @param {string|number} percent\n\t     * @param {number} all\n\t     * @return {number}\n\t     */\n\t    number.parsePercent = function(percent, all) {\n\t        switch (percent) {\n\t            case 'center':\n\t            case 'middle':\n\t                percent = '50%';\n\t                break;\n\t            case 'left':\n\t            case 'top':\n\t                percent = '0%';\n\t                break;\n\t            case 'right':\n\t            case 'bottom':\n\t                percent = '100%';\n\t                break;\n\t        }\n\t        if (typeof percent === 'string') {\n\t            if (_trim(percent).match(/%$/)) {\n\t                return parseFloat(percent) / 100 * all;\n\t            }\n\t\n\t            return parseFloat(percent);\n\t        }\n\t\n\t        return percent == null ? NaN : +percent;\n\t    };\n\t\n\t    /**\n\t     * Fix rounding error of float numbers\n\t     * @param {number} x\n\t     * @return {number}\n\t     */\n\t    number.round = function (x, precision) {\n\t        if (precision == null) {\n\t            precision = 10;\n\t        }\n\t        // Avoid range error\n\t        precision = Math.min(Math.max(0, precision), 20);\n\t        return +(+x).toFixed(precision);\n\t    };\n\t\n\t    number.asc = function (arr) {\n\t        arr.sort(function (a, b) {\n\t            return a - b;\n\t        });\n\t        return arr;\n\t    };\n\t\n\t    /**\n\t     * Get precision\n\t     * @param {number} val\n\t     */\n\t    number.getPrecision = function (val) {\n\t        val = +val;\n\t        if (isNaN(val)) {\n\t            return 0;\n\t        }\n\t        // It is much faster than methods converting number to string as follows\n\t        //      var tmp = val.toString();\n\t        //      return tmp.length - 1 - tmp.indexOf('.');\n\t        // especially when precision is low\n\t        var e = 1;\n\t        var count = 0;\n\t        while (Math.round(val * e) / e !== val) {\n\t            e *= 10;\n\t            count++;\n\t        }\n\t        return count;\n\t    };\n\t\n\t    number.getPrecisionSafe = function (val) {\n\t        var str = val.toString();\n\t        var dotIndex = str.indexOf('.');\n\t        if (dotIndex < 0) {\n\t            return 0;\n\t        }\n\t        return str.length - 1 - dotIndex;\n\t    };\n\t\n\t    /**\n\t     * @param {Array.<number>} dataExtent\n\t     * @param {Array.<number>} pixelExtent\n\t     * @return {number}  precision\n\t     */\n\t    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n\t        var log = Math.log;\n\t        var LN10 = Math.LN10;\n\t        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n\t        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n\t        return Math.max(\n\t            -dataQuantity + sizeQuantity,\n\t            0\n\t        );\n\t    };\n\t\n\t    // Number.MAX_SAFE_INTEGER, ie do not support.\n\t    number.MAX_SAFE_INTEGER = 9007199254740991;\n\t\n\t    /**\n\t     * To 0 - 2 * PI, considering negative radian.\n\t     * @param {number} radian\n\t     * @return {number}\n\t     */\n\t    number.remRadian = function (radian) {\n\t        var pi2 = Math.PI * 2;\n\t        return (radian % pi2 + pi2) % pi2;\n\t    };\n\t\n\t    /**\n\t     * @param {type} radian\n\t     * @return {boolean}\n\t     */\n\t    number.isRadianAroundZero = function (val) {\n\t        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n\t    };\n\t\n\t    /**\n\t     * @param {string|Date|number} value\n\t     * @return {Date} date\n\t     */\n\t    number.parseDate = function (value) {\n\t        if (value instanceof Date) {\n\t            return value;\n\t        }\n\t        else if (typeof value === 'string') {\n\t            // Treat as ISO format. See issue #3623\n\t            var ret = new Date(value);\n\t            if (isNaN(+ret)) {\n\t                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n\t                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n\t            }\n\t            return ret;\n\t        }\n\t\n\t        return new Date(Math.round(value));\n\t    };\n\t\n\t    /**\n\t     * Quantity of a number. e.g. 0.1, 1, 10, 100\n\t     * @param  {number} val\n\t     * @return {number}\n\t     */\n\t    number.quantity = function (val) {\n\t        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n\t    };\n\t\n\t    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t    /**\n\t     * find a nice number approximately equal to x. Round the number if round = true, take ceiling if round = false\n\t     * The primary observation is that the nicest numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n\t     * @param  {number} val\n\t     * @param  {boolean} round\n\t     * @return {number}\n\t     */\n\t    number.nice = function (val, round) {\n\t        var exp10 = number.quantity(val);\n\t        var f = val / exp10; // between 1 and 10\n\t        var nf;\n\t        if (round) {\n\t            if (f < 1.5) { nf = 1; }\n\t            else if (f < 2.5) { nf = 2; }\n\t            else if (f < 4) { nf = 3; }\n\t            else if (f < 7) { nf = 5; }\n\t            else { nf = 10; }\n\t        }\n\t        else {\n\t            if (f < 1) { nf = 1; }\n\t            else if (f < 2) { nf = 2; }\n\t            else if (f < 3) { nf = 3; }\n\t            else if (f < 5) { nf = 5; }\n\t            else { nf = 10; }\n\t        }\n\t        return nf * exp10;\n\t    };\n\t\n\t    module.exports = number;\n\n\n/***/ },\n/* 5 */\n/*!**************************************!*\\\n  !*** ./~/zrender/lib/core/vector.js ***!\n  \\**************************************/\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * \n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t        /**\n\t         * \n\t         * @param {number} [x=0]\n\t         * @param {number} [y=0]\n\t         * @return {Vector2}\n\t         */\n\t        create: function (x, y) {\n\t            var out = new ArrayCtor(2);\n\t            if (x == null) {\n\t                x = 0;\n\t            }\n\t            if (y == null) {\n\t                y = 0;\n\t            }\n\t            out[0] = x;\n\t            out[1] = y;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        copy: function (out, v) {\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        clone: function (v) {\n\t            var out = new ArrayCtor(2);\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {number} a\n\t         * @param {number} b\n\t         * @return {Vector2} \n\t         */\n\t        set: function (out, a, b) {\n\t            out[0] = a;\n\t            out[1] = b;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        add: function (out, v1, v2) {\n\t            out[0] = v1[0] + v2[0];\n\t            out[1] = v1[1] + v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} a\n\t         */\n\t        scaleAndAdd: function (out, v1, v2, a) {\n\t            out[0] = v1[0] + v2[0] * a;\n\t            out[1] = v1[1] + v2[1] * a;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        sub: function (out, v1, v2) {\n\t            out[0] = v1[0] - v2[0];\n\t            out[1] = v1[1] - v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        len: function (v) {\n\t            return Math.sqrt(this.lenSquare(v));\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        lenSquare: function (v) {\n\t            return v[0] * v[0] + v[1] * v[1];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        mul: function (out, v1, v2) {\n\t            out[0] = v1[0] * v2[0];\n\t            out[1] = v1[1] * v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        div: function (out, v1, v2) {\n\t            out[0] = v1[0] / v2[0];\n\t            out[1] = v1[1] / v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        dot: function (v1, v2) {\n\t            return v1[0] * v2[0] + v1[1] * v2[1];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {number} s\n\t         */\n\t        scale: function (out, v, s) {\n\t            out[0] = v[0] * s;\n\t            out[1] = v[1] * s;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        normalize: function (out, v) {\n\t            var d = vector.len(v);\n\t            if (d === 0) {\n\t                out[0] = 0;\n\t                out[1] = 0;\n\t            }\n\t            else {\n\t                out[0] = v[0] / d;\n\t                out[1] = v[1] / d;\n\t            }\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distance: function (v1, v2) {\n\t            return Math.sqrt(\n\t                (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n\t            );\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distanceSquare: function (v1, v2) {\n\t            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        negate: function (out, v) {\n\t            out[0] = -v[0];\n\t            out[1] = -v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} t\n\t         */\n\t        lerp: function (out, v1, v2, t) {\n\t            out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t            out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {Vector2} m\n\t         */\n\t        applyTransform: function (out, v, m) {\n\t            var x = v[0];\n\t            var y = v[1];\n\t            out[0] = m[0] * x + m[2] * y + m[4];\n\t            out[1] = m[1] * x + m[3] * y + m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        min: function (out, v1, v2) {\n\t            out[0] = Math.min(v1[0], v2[0]);\n\t            out[1] = Math.min(v1[1], v2[1]);\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        max: function (out, v1, v2) {\n\t            out[0] = Math.max(v1[0], v2[0]);\n\t            out[1] = Math.max(v1[1], v2[1]);\n\t            return out;\n\t        }\n\t    };\n\t\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t\n\t    module.exports = vector;\n\t\n\n\n/***/ },\n/* 6 */\n/*!***************************************!*\\\n  !*** ./~/zrender/lib/graphic/Path.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Path element\n\t * @module zrender/graphic/Path\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(/*! ./Displayable */ 37);\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t    var PathProxy = __webpack_require__(/*! ../core/PathProxy */ 28);\n\t    var pathContain = __webpack_require__(/*! ../contain/path */ 148);\n\t\n\t    var Pattern = __webpack_require__(/*! ./Pattern */ 63);\n\t    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\t\n\t    var abs = Math.abs;\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = new PathProxy();\n\t    }\n\t\n\t    Path.prototype = {\n\t\n\t        constructor: Path,\n\t\n\t        type: 'path',\n\t\n\t        __dirtyPath: true,\n\t\n\t        strokeContainThreshold: 5,\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var path = this.path;\n\t            var hasStroke = style.hasStroke();\n\t            var hasFill = style.hasFill();\n\t            var fill = style.fill;\n\t            var stroke = style.stroke;\n\t            var hasFillGradient = hasFill && !!(fill.colorStops);\n\t            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n\t            var hasFillPattern = hasFill && !!(fill.image);\n\t            var hasStrokePattern = hasStroke && !!(stroke.image);\n\t\n\t            style.bind(ctx, this, prevEl);\n\t            this.setTransform(ctx);\n\t\n\t            if (this.__dirty) {\n\t                var rect = this.getBoundingRect();\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFillGradient) {\n\t                    this._fillGradient = style.getGradient(ctx, fill, rect);\n\t                }\n\t                if (hasStrokeGradient) {\n\t                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t                }\n\t            }\n\t            // Use the gradient or pattern\n\t            if (hasFillGradient) {\n\t                // PENDING If may have affect the state\n\t                ctx.fillStyle = this._fillGradient;\n\t            }\n\t            else if (hasFillPattern) {\n\t                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t            }\n\t            if (hasStrokeGradient) {\n\t                ctx.strokeStyle = this._strokeGradient;\n\t            }\n\t            else if (hasStrokePattern) {\n\t                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t            }\n\t\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t\n\t            // Update path sx, sy\n\t            var scale = this.getGlobalScale();\n\t            path.setScale(scale[0], scale[1]);\n\t\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath || (\n\t                lineDash && !ctxLineDash && hasStroke\n\t            )) {\n\t                path = this.path.beginPath(ctx);\n\t\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t\n\t                this.buildPath(path, this.shape, false);\n\t\n\t                // Clear path dirty flag\n\t                this.__dirtyPath = false;\n\t            }\n\t            else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t\n\t            hasFill && path.fill(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t\n\t            hasStroke && path.stroke(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                // PENDING\n\t                // Remove lineDash\n\t                ctx.setLineDash([]);\n\t            }\n\t\n\t\n\t            this.restoreTransform(ctx);\n\t\n\t            // Draw rect text\n\t            if (style.text != null) {\n\t                // var rect = this.getBoundingRect();\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t\n\t        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n\t        // Like in circle\n\t        buildPath: function (ctx, shapeCfg, inBundle) {},\n\t\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            var needsUpdateRect = !rect;\n\t            if (needsUpdateRect) {\n\t                var path = this.path;\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape, false);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            this._rect = rect;\n\t\n\t            if (style.hasStroke()) {\n\t                // Needs update rect with stroke lineWidth when\n\t                // 1. Element changes scale or lineWidth\n\t                // 2. Shape is changed\n\t                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t                if (this.__dirty || needsUpdateRect) {\n\t                    rectWithStroke.copy(rect);\n\t                    // FIXME Must after updateTransform\n\t                    var w = style.lineWidth;\n\t                    // PENDING, Min line width is needed when line is horizontal or vertical\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t\n\t                    // Only add extra hover lineWidth when there are no fill\n\t                    if (!style.hasFill()) {\n\t                        w = Math.max(w, this.strokeContainThreshold || 4);\n\t                    }\n\t                    // Consider line width\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        rectWithStroke.width += w / lineScale;\n\t                        rectWithStroke.height += w / lineScale;\n\t                        rectWithStroke.x -= w / lineScale / 2;\n\t                        rectWithStroke.y -= w / lineScale / 2;\n\t                    }\n\t                }\n\t\n\t                // Return rect with stroke\n\t                return rectWithStroke;\n\t            }\n\t\n\t            return rect;\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (style.hasStroke()) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!style.hasFill()) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(\n\t                            pathData, lineWidth / lineScale, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (style.hasFill()) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t\n\t        /**\n\t         * @param  {boolean} dirtyPath\n\t         */\n\t        dirty: function (dirtyPath) {\n\t            if (dirtyPath == null) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t\n\t            this.__dirty = true;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Alias for animate('shape')\n\t         * @param {boolean} loop\n\t         */\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t\n\t        // Overwrite attrKV\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t                this.__dirtyPath = true;\n\t                this._rect = null;\n\t            }\n\t            else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        if (key.hasOwnProperty(name)) {\n\t                            shape[name] = key[name];\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n\t                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n\t                : 1;\n\t        }\n\t    };\n\t\n\t    /**\n\t     *  Path element, \n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (\n\t                        ! thisShape.hasOwnProperty(name)\n\t                        && defaultShape.hasOwnProperty(name)\n\t                    ) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t\n\t        zrUtil.inherits(Sub, Path);\n\t\n\t        // FIXME  extend position, rotation \n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t\n\t        return Sub;\n\t    };\n\t\n\t    zrUtil.inherits(Path, Displayable);\n\t\n\t    module.exports = Path;\n\n\n/***/ },\n/* 7 */\n/*!***************************!*\\\n  !*** ./lib/util/model.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var formatUtil = __webpack_require__(/*! ./format */ 9);\n\t    var nubmerUtil = __webpack_require__(/*! ./number */ 4);\n\t    var Model = __webpack_require__(/*! ../model/Model */ 10);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var modelUtil = {};\n\t\n\t    /**\n\t     * If value is not array, then translate it to array.\n\t     * @param  {*} value\n\t     * @return {Array} [value] or value\n\t     */\n\t    modelUtil.normalizeToArray = function (value) {\n\t        return value instanceof Array\n\t            ? value\n\t            : value == null\n\t            ? []\n\t            : [value];\n\t    };\n\t\n\t    /**\n\t     * Sync default option between normal and emphasis like `position` and `show`\n\t     * In case some one will write code like\n\t     *     label: {\n\t     *         normal: {\n\t     *             show: false,\n\t     *             position: 'outside',\n\t     *             textStyle: {\n\t     *                 fontSize: 18\n\t     *             }\n\t     *         },\n\t     *         emphasis: {\n\t     *             show: true\n\t     *         }\n\t     *     }\n\t     * @param {Object} opt\n\t     * @param {Array.<string>} subOpts\n\t     */\n\t     modelUtil.defaultEmphasis = function (opt, subOpts) {\n\t        if (opt) {\n\t            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n\t            var normalOpt = opt.normal = opt.normal || {};\n\t\n\t            // Default emphasis option from normal\n\t            zrUtil.each(subOpts, function (subOptName) {\n\t                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n\t                if (val != null) {\n\t                    emphasisOpt[subOptName] = val;\n\t                }\n\t            });\n\t        }\n\t    };\n\t\n\t    modelUtil.LABEL_OPTIONS = ['position', 'show', 'textStyle', 'distance', 'formatter'];\n\t\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method retieves value from data.\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     * @return {number|string|Date|Array.<number|string|Date>}\n\t     */\n\t    modelUtil.getDataItemValue = function (dataItem) {\n\t        // Performance sensitive.\n\t        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n\t    };\n\t\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method determine if dataItem has extra option besides value\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     */\n\t    modelUtil.isDataItemOption = function (dataItem) {\n\t        return zrUtil.isObject(dataItem)\n\t            && !(dataItem instanceof Array);\n\t            // // markLine data can be array\n\t            // && !(dataItem[0] && zrUtil.isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n\t    };\n\t\n\t    /**\n\t     * This helper method convert value in data.\n\t     * @param {string|number|Date} value\n\t     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n\t     */\n\t    modelUtil.converDataValue = function (value, dimInfo) {\n\t        // Performance sensitive.\n\t        var dimType = dimInfo && dimInfo.type;\n\t        if (dimType === 'ordinal') {\n\t            return value;\n\t        }\n\t\n\t        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n\t            value = +nubmerUtil.parseDate(value);\n\t        }\n\t\n\t        // dimType defaults 'number'.\n\t        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n\t        // parse to NaN.\n\t        return (value == null || value === '')\n\t            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n\t    };\n\t\n\t    /**\n\t     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Object} opt\n\t     * @param {string} [opt.seriesIndex]\n\t     * @param {Object} [opt.name]\n\t     * @param {Object} [opt.mainType]\n\t     * @param {Object} [opt.subType]\n\t     */\n\t    modelUtil.createDataFormatModel = function (data, opt) {\n\t        var model = new Model();\n\t        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n\t        model.seriesIndex = opt.seriesIndex;\n\t        model.name = opt.name || '';\n\t        model.mainType = opt.mainType;\n\t        model.subType = opt.subType;\n\t\n\t        model.getData = function () {\n\t            return data;\n\t        };\n\t        return model;\n\t    };\n\t\n\t    // PENDING A little ugly\n\t    modelUtil.dataFormatMixin = {\n\t        /**\n\t         * Get params for formatter\n\t         * @param {number} dataIndex\n\t         * @param {string} [dataType]\n\t         * @return {Object}\n\t         */\n\t        getDataParams: function (dataIndex, dataType) {\n\t            var data = this.getData(dataType);\n\t\n\t            var seriesIndex = this.seriesIndex;\n\t            var seriesName = this.name;\n\t\n\t            var rawValue = this.getRawValue(dataIndex, dataType);\n\t            var rawDataIndex = data.getRawIndex(dataIndex);\n\t            var name = data.getName(dataIndex, true);\n\t            var itemOpt = data.getRawDataItem(dataIndex);\n\t\n\t            return {\n\t                componentType: this.mainType,\n\t                componentSubType: this.subType,\n\t                seriesType: this.mainType === 'series' ? this.subType : null,\n\t                seriesIndex: seriesIndex,\n\t                seriesName: seriesName,\n\t                name: name,\n\t                dataIndex: rawDataIndex,\n\t                data: itemOpt,\n\t                dataType: dataType,\n\t                value: rawValue,\n\t                color: data.getItemVisual(dataIndex, 'color'),\n\t\n\t                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n\t                $vars: ['seriesName', 'name', 'value']\n\t            };\n\t        },\n\t\n\t        /**\n\t         * Format label\n\t         * @param {number} dataIndex\n\t         * @param {string} [status='normal'] 'normal' or 'emphasis'\n\t         * @param {string} [dataType]\n\t         * @param {number} [dimIndex]\n\t         * @return {string}\n\t         */\n\t        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n\t            status = status || 'normal';\n\t            var data = this.getData(dataType);\n\t            var itemModel = data.getItemModel(dataIndex);\n\t\n\t            var params = this.getDataParams(dataIndex, dataType);\n\t            if (dimIndex != null && (params.value instanceof Array)) {\n\t                params.value = params.value[dimIndex];\n\t            }\n\t\n\t            var formatter = itemModel.get(['label', status, 'formatter']);\n\t\n\t            if (typeof formatter === 'function') {\n\t                params.status = status;\n\t                return formatter(params);\n\t            }\n\t            else if (typeof formatter === 'string') {\n\t                return formatUtil.formatTpl(formatter, params);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get raw value in option\n\t         * @param {number} idx\n\t         * @param {string} [dataType]\n\t         * @return {Object}\n\t         */\n\t        getRawValue: function (idx, dataType) {\n\t            var data = this.getData(dataType);\n\t            var dataItem = data.getRawDataItem(idx);\n\t            if (dataItem != null) {\n\t                return (zrUtil.isObject(dataItem) && !(dataItem instanceof Array))\n\t                    ? dataItem.value : dataItem;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Should be implemented.\n\t         * @param {number} dataIndex\n\t         * @param {boolean} [multipleSeries=false]\n\t         * @param {number} [dataType]\n\t         * @return {string} tooltip string\n\t         */\n\t        formatTooltip: zrUtil.noop\n\t    };\n\t\n\t    /**\n\t     * Mapping to exists for merge.\n\t     *\n\t     * @public\n\t     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n\t     * @param {Object|Array.<Object>} newCptOptions\n\t     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n\t     *                          which order is the same as exists.\n\t     */\n\t    modelUtil.mappingToExists = function (exists, newCptOptions) {\n\t        // Mapping by the order by original option (but not order of\n\t        // new option) in merge mode. Because we should ensure\n\t        // some specified index (like xAxisIndex) is consistent with\n\t        // original option, which is easy to understand, espatially in\n\t        // media query. And in most case, merge option is used to\n\t        // update partial option but not be expected to change order.\n\t        newCptOptions = (newCptOptions || []).slice();\n\t\n\t        var result = zrUtil.map(exists || [], function (obj, index) {\n\t            return {exist: obj};\n\t        });\n\t\n\t        // Mapping by id or name if specified.\n\t        zrUtil.each(newCptOptions, function (cptOption, index) {\n\t            if (!zrUtil.isObject(cptOption)) {\n\t                return;\n\t            }\n\t\n\t            // id has highest priority.\n\t            for (var i = 0; i < result.length; i++) {\n\t                if (!result[i].option // Consider name: two map to one.\n\t                    && cptOption.id != null\n\t                    && result[i].exist.id === cptOption.id + ''\n\t                ) {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t\n\t            for (var i = 0; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option // Consider name: two map to one.\n\t                    // Can not match when both ids exist but different.\n\t                    && (exist.id == null || cptOption.id == null)\n\t                    && cptOption.name != null\n\t                    && !modelUtil.isIdInner(cptOption)\n\t                    && !modelUtil.isIdInner(exist)\n\t                    && exist.name === cptOption.name + ''\n\t                ) {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t        });\n\t\n\t        // Otherwise mapping by index.\n\t        zrUtil.each(newCptOptions, function (cptOption, index) {\n\t            if (!zrUtil.isObject(cptOption)) {\n\t                return;\n\t            }\n\t\n\t            var i = 0;\n\t            for (; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option\n\t                    && !modelUtil.isIdInner(exist)\n\t                    // Caution:\n\t                    // Do not overwrite id. But name can be overwritten,\n\t                    // because axis use name as 'show label text'.\n\t                    // 'exist' always has id and name and we dont\n\t                    // need to check it.\n\t                    && cptOption.id == null\n\t                ) {\n\t                    result[i].option = cptOption;\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (i >= result.length) {\n\t                result.push({option: cptOption});\n\t            }\n\t        });\n\t\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * @public\n\t     * @param {Object} cptOption\n\t     * @return {boolean}\n\t     */\n\t    modelUtil.isIdInner = function (cptOption) {\n\t        return zrUtil.isObject(cptOption)\n\t            && cptOption.id\n\t            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n\t    };\n\t\n\t    /**\n\t     * A helper for removing duplicate items between batchA and batchB,\n\t     * and in themselves, and categorize by series.\n\t     *\n\t     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n\t     */\n\t    modelUtil.compressBatches = function (batchA, batchB) {\n\t        var mapA = {};\n\t        var mapB = {};\n\t\n\t        makeMap(batchA || [], mapA);\n\t        makeMap(batchB || [], mapB, mapA);\n\t\n\t        return [mapToArray(mapA), mapToArray(mapB)];\n\t\n\t        function makeMap(sourceBatch, map, otherMap) {\n\t            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n\t                var seriesId = sourceBatch[i].seriesId;\n\t                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n\t                var otherDataIndices = otherMap && otherMap[seriesId];\n\t\n\t                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n\t                    var dataIndex = dataIndices[j];\n\t\n\t                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n\t                        otherDataIndices[dataIndex] = null;\n\t                    }\n\t                    else {\n\t                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        function mapToArray(map, isData) {\n\t            var result = [];\n\t            for (var i in map) {\n\t                if (map.hasOwnProperty(i) && map[i] != null) {\n\t                    if (isData) {\n\t                        result.push(+i);\n\t                    }\n\t                    else {\n\t                        var dataIndices = mapToArray(map[i], true);\n\t                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n\t                    }\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n\t     *                         each of which can be Array or primary type.\n\t     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n\t     */\n\t    modelUtil.queryDataIndex = function (data, payload) {\n\t        if (payload.dataIndexInside != null) {\n\t            return payload.dataIndexInside;\n\t        }\n\t        else if (payload.dataIndex != null) {\n\t            return zrUtil.isArray(payload.dataIndex)\n\t                ? zrUtil.map(payload.dataIndex, function (value) {\n\t                    return data.indexOfRawIndex(value);\n\t                })\n\t                : data.indexOfRawIndex(payload.dataIndex);\n\t        }\n\t        else if (payload.name != null) {\n\t            return zrUtil.isArray(payload.name)\n\t                ? zrUtil.map(payload.name, function (value) {\n\t                    return data.indexOfName(value);\n\t                })\n\t                : data.indexOfName(payload.name);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex, seriesId, seriesName,\n\t     *            geoIndex, geoId, goeName,\n\t     *            bmapIndex, bmapId, bmapName,\n\t     *            xAxisIndex, xAxisId, xAxisName,\n\t     *            yAxisIndex, yAxisId, yAxisName,\n\t     *            gridIndex, gridId, gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     *        Each properties can be number|string|Array.<number>|Array.<string>\n\t     *        For example, a finder could be\n\t     *        {\n\t     *            seriesIndex: 3,\n\t     *            geoId: ['aa', 'cc'],\n\t     *            gridName: ['xx', 'rr']\n\t     *        }\n\t     * @param {Object} [opt]\n\t     * @param {string} [opt.defaultMainType]\n\t     * @return {Object} result like:\n\t     *        {\n\t     *            seriesModels: [seriesModel1, seriesModel2],\n\t     *            seriesModel: seriesModel1, // The first model\n\t     *            geoModels: [geoModel1, geoModel2],\n\t     *            geoModel: geoModel1, // The first model\n\t     *            ...\n\t     *        }\n\t     */\n\t    modelUtil.parseFinder = function (ecModel, finder, opt) {\n\t        if (zrUtil.isString(finder)) {\n\t            var obj = {};\n\t            obj[finder + 'Index'] = 0;\n\t            finder = obj;\n\t        }\n\t\n\t        var defaultMainType = opt && opt.defaultMainType;\n\t        if (defaultMainType\n\t            && !has(finder, defaultMainType + 'Index')\n\t            && !has(finder, defaultMainType + 'Id')\n\t            && !has(finder, defaultMainType + 'Name')\n\t        ) {\n\t            finder[defaultMainType + 'Index'] = 0;\n\t        }\n\t\n\t        var result = {};\n\t\n\t        zrUtil.each(finder, function (value, key) {\n\t            var value = finder[key];\n\t\n\t            // Exclude 'dataIndex' and other illgal keys.\n\t            if (key === 'dataIndex' || key === 'dataIndexInside') {\n\t                result[key] = value;\n\t                return;\n\t            }\n\t\n\t            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n\t            var mainType = parsedKey[1];\n\t            var queryType = parsedKey[2];\n\t\n\t            if (!mainType || !queryType) {\n\t                return;\n\t            }\n\t\n\t            var queryParam = {mainType: mainType};\n\t            queryParam[queryType.toLowerCase()] = value;\n\t            var models = ecModel.queryComponents(queryParam);\n\t            result[mainType + 'Models'] = models;\n\t            result[mainType + 'Model'] = models[0];\n\t        });\n\t\n\t        return result;\n\t    };\n\t\n\t    function has(obj, prop) {\n\t        return obj && obj.hasOwnProperty(prop);\n\t    }\n\t\n\t    module.exports = modelUtil;\n\n\n/***/ },\n/* 8 */\n/*!********************************************!*\\\n  !*** ./~/zrender/lib/core/BoundingRect.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(/*! ./vector */ 5);\n\t    var matrix = __webpack_require__(/*! ./matrix */ 19);\n\t\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t\n\t        if (width < 0) {\n\t            x = x + width;\n\t            width = -width;\n\t        }\n\t        if (height < 0) {\n\t            y = y + height;\n\t            height = -height;\n\t        }\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t\n\t    BoundingRect.prototype = {\n\t\n\t        constructor: BoundingRect,\n\t\n\t        /**\n\t         * @param {module:echarts/core/BoundingRect} other\n\t         */\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t\n\t            this.width = mathMax(\n\t                    other.x + other.width,\n\t                    this.x + this.width\n\t                ) - x;\n\t            this.height = mathMax(\n\t                    other.y + other.height,\n\t                    this.y + this.height\n\t                ) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} m\n\t         * @methods\n\t         */\n\t        applyTransform: (function () {\n\t            var lt = [];\n\t            var rb = [];\n\t            var lb = [];\n\t            var rt = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                lt[0] = lb[0] = this.x;\n\t                lt[1] = rt[1] = this.y;\n\t                rb[0] = rt[0] = this.x + this.width;\n\t                rb[1] = lb[1] = this.y + this.height;\n\t\n\t                v2ApplyTransform(lt, lt, m);\n\t                v2ApplyTransform(rb, rb, m);\n\t                v2ApplyTransform(lb, lb, m);\n\t                v2ApplyTransform(rt, rt, m);\n\t\n\t                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n\t                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n\t                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n\t                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n\t                this.width = maxX - this.x;\n\t                this.height = maxY - this.y;\n\t            };\n\t        })(),\n\t\n\t        /**\n\t         * Calculate matrix of transforming from self to target rect\n\t         * @param  {module:zrender/core/BoundingRect} b\n\t         * @return {Array.<number>}\n\t         */\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t\n\t            var m = matrix.create();\n\t\n\t            // \n\t            matrix.translate(m, m, [-a.x, -a.y]);\n\t            matrix.scale(m, m, [sx, sy]);\n\t            matrix.translate(m, m, [b.x, b.y]);\n\t\n\t            return m;\n\t        },\n\t\n\t        /**\n\t         * @param {(module:echarts/core/BoundingRect|Object)} b\n\t         * @return {boolean}\n\t         */\n\t        intersect: function (b) {\n\t            if (!b) {\n\t                return false;\n\t            }\n\t\n\t            if (!(b instanceof BoundingRect)) {\n\t                // Normalize negative width/height.\n\t                b = BoundingRect.create(b);\n\t            }\n\t\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t\n\t            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x\n\t                && x <= (rect.x + rect.width)\n\t                && y >= rect.y\n\t                && y <= (rect.y + rect.height);\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/core/BoundingRect}\n\t         */\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t\n\t        /**\n\t         * Copy from another rect\n\t         */\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        },\n\t\n\t        plain: function () {\n\t            return {\n\t                x: this.x,\n\t                y: this.y,\n\t                width: this.width,\n\t                height: this.height\n\t            };\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {Object|module:zrender/core/BoundingRect} rect\n\t     * @param {number} rect.x\n\t     * @param {number} rect.y\n\t     * @param {number} rect.width\n\t     * @param {number} rect.height\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    BoundingRect.create = function (rect) {\n\t        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n\t    };\n\t\n\t    module.exports = BoundingRect;\n\n\n/***/ },\n/* 9 */\n/*!****************************!*\\\n  !*** ./lib/util/format.js ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var numberUtil = __webpack_require__(/*! ./number */ 4);\n\t    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 16);\n\t\n\t    var formatUtil = {};\n\t    /**\n\t     * ,\n\t     * @type {string|number} x\n\t     */\n\t    formatUtil.addCommas = function (x) {\n\t        if (isNaN(x)) {\n\t            return '-';\n\t        }\n\t        x = (x + '').split('.');\n\t        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n\t               + (x.length > 1 ? ('.' + x[1]) : '');\n\t    };\n\t\n\t    /**\n\t     * @param {string} str\n\t     * @return {string} str\n\t     */\n\t    formatUtil.toCamelCase = function (str) {\n\t        return str.toLowerCase().replace(/-(.)/g, function(match, group1) {\n\t            return group1.toUpperCase();\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Normalize css liked array configuration\n\t     * e.g.\n\t     *  3 => [3, 3, 3, 3]\n\t     *  [4, 2] => [4, 2, 4, 2]\n\t     *  [4, 3, 2] => [4, 3, 2, 3]\n\t     * @param {number|Array.<number>} val\n\t     */\n\t    formatUtil.normalizeCssArray = function (val) {\n\t        var len = val.length;\n\t        if (typeof (val) === 'number') {\n\t            return [val, val, val, val];\n\t        }\n\t        else if (len === 2) {\n\t            // vertical | horizontal\n\t            return [val[0], val[1], val[0], val[1]];\n\t        }\n\t        else if (len === 3) {\n\t            // top | horizontal | bottom\n\t            return [val[0], val[1], val[2], val[1]];\n\t        }\n\t        return val;\n\t    };\n\t\n\t    formatUtil.encodeHTML = function (source) {\n\t        return String(source)\n\t            .replace(/&/g, '&amp;')\n\t            .replace(/</g, '&lt;')\n\t            .replace(/>/g, '&gt;')\n\t            .replace(/\"/g, '&quot;')\n\t            .replace(/'/g, '&#39;');\n\t    };\n\t\n\t    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\t\n\t    var wrapVar = function (varName, seriesIdx) {\n\t        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n\t    };\n\t\n\t    /**\n\t     * Template formatter\n\t     * @param  {string} tpl\n\t     * @param  {Array.<Object>|Object} paramsList\n\t     * @return {string}\n\t     */\n\t    formatUtil.formatTpl = function (tpl, paramsList) {\n\t        if (!zrUtil.isArray(paramsList)) {\n\t            paramsList = [paramsList];\n\t        }\n\t        var seriesLen = paramsList.length;\n\t        if (!seriesLen) {\n\t            return '';\n\t        }\n\t\n\t        var $vars = paramsList[0].$vars || [];\n\t        for (var i = 0; i < $vars.length; i++) {\n\t            var alias = TPL_VAR_ALIAS[i];\n\t            tpl = tpl.replace(wrapVar(alias),  wrapVar(alias, 0));\n\t        }\n\t        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n\t            for (var k = 0; k < $vars.length; k++) {\n\t                tpl = tpl.replace(\n\t                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n\t                    paramsList[seriesIdx][$vars[k]]\n\t                );\n\t            }\n\t        }\n\t\n\t        return tpl;\n\t    };\n\t\n\t\n\t    /**\n\t     * @param {string} str\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    var s2d = function (str) {\n\t        return str < 10 ? ('0' + str) : str;\n\t    };\n\t\n\t    /**\n\t     * ISO Date format\n\t     * @param {string} tpl\n\t     * @param {number} value\n\t     * @inner\n\t     */\n\t    formatUtil.formatTime = function (tpl, value) {\n\t        if (tpl === 'week'\n\t            || tpl === 'month'\n\t            || tpl === 'quarter'\n\t            || tpl === 'half-year'\n\t            || tpl === 'year'\n\t        ) {\n\t            tpl = 'MM-dd\\nyyyy';\n\t        }\n\t\n\t        var date = numberUtil.parseDate(value);\n\t        var y = date.getFullYear();\n\t        var M = date.getMonth() + 1;\n\t        var d = date.getDate();\n\t        var h = date.getHours();\n\t        var m = date.getMinutes();\n\t        var s = date.getSeconds();\n\t\n\t        tpl = tpl.replace('MM', s2d(M))\n\t            .toLowerCase()\n\t            .replace('yyyy', y)\n\t            .replace('yy', y % 100)\n\t            .replace('dd', s2d(d))\n\t            .replace('d', d)\n\t            .replace('hh', s2d(h))\n\t            .replace('h', h)\n\t            .replace('mm', s2d(m))\n\t            .replace('m', m)\n\t            .replace('ss', s2d(s))\n\t            .replace('s', s);\n\t\n\t        return tpl;\n\t    };\n\t\n\t    /**\n\t     * Capital first\n\t     * @param {string} str\n\t     * @return {string}\n\t     */\n\t    formatUtil.capitalFirst = function (str) {\n\t        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n\t    };\n\t\n\t    formatUtil.truncateText = textContain.truncateText;\n\t\n\t    module.exports = formatUtil;\n\n\n/***/ },\n/* 10 */\n/*!****************************!*\\\n  !*** ./lib/model/Model.js ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/model/Model\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 21);\n\t\n\t    /**\n\t     * @alias module:echarts/model/Model\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} [parentModel]\n\t     * @param {module:echarts/model/Global} [ecModel]\n\t     */\n\t    function Model(option, parentModel, ecModel) {\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         * @readOnly\n\t         */\n\t        this.parentModel = parentModel;\n\t\n\t        /**\n\t         * @type {module:echarts/model/Global}\n\t         * @readOnly\n\t         */\n\t        this.ecModel = ecModel;\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        this.option = option;\n\t\n\t        // Simple optimization\n\t        // if (this.init) {\n\t        //     if (arguments.length <= 4) {\n\t        //         this.init(option, parentModel, ecModel, extraOpt);\n\t        //     }\n\t        //     else {\n\t        //         this.init.apply(this, arguments);\n\t        //     }\n\t        // }\n\t    }\n\t\n\t    Model.prototype = {\n\t\n\t        constructor: Model,\n\t\n\t        /**\n\t         * Model \n\t         * @param {Object} option\n\t         */\n\t        init: null,\n\t\n\t        /**\n\t         *  Option merge\n\t         */\n\t        mergeOption: function (option) {\n\t            zrUtil.merge(this.option, option, true);\n\t        },\n\t\n\t        /**\n\t         * @param {string} path\n\t         * @param {boolean} [ignoreParent=false]\n\t         * @return {*}\n\t         */\n\t        get: function (path, ignoreParent) {\n\t            if (!path) {\n\t                return this.option;\n\t            }\n\t\n\t            if (typeof path === 'string') {\n\t                path = path.split('.');\n\t            }\n\t\n\t            var obj = this.option;\n\t            var parentModel = this.parentModel;\n\t            for (var i = 0; i < path.length; i++) {\n\t                // Ignore empty\n\t                if (!path[i]) {\n\t                    continue;\n\t                }\n\t                // obj could be number/string/... (like 0)\n\t                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\n\t                if (obj == null) {\n\t                    break;\n\t                }\n\t            }\n\t            if (obj == null && parentModel && !ignoreParent) {\n\t                obj = parentModel.get(path);\n\t            }\n\t            return obj;\n\t        },\n\t\n\t        /**\n\t         * @param {string} key\n\t         * @param {boolean} [ignoreParent=false]\n\t         * @return {*}\n\t         */\n\t        getShallow: function (key, ignoreParent) {\n\t            var option = this.option;\n\t\n\t            var val = option == null ? option : option[key];\n\t            var parentModel = this.parentModel;\n\t            if (val == null && parentModel && !ignoreParent) {\n\t                val = parentModel.getShallow(key);\n\t            }\n\t            return val;\n\t        },\n\t\n\t        /**\n\t         * @param {string} path\n\t         * @param {module:echarts/model/Model} [parentModel]\n\t         * @return {module:echarts/model/Model}\n\t         */\n\t        getModel: function (path, parentModel) {\n\t            var obj = this.get(path, true);\n\t            var thisParentModel = this.parentModel;\n\t            var model = new Model(\n\t                obj, parentModel || (thisParentModel && thisParentModel.getModel(path)),\n\t                this.ecModel\n\t            );\n\t            return model;\n\t        },\n\t\n\t        /**\n\t         * If model has option\n\t         */\n\t        isEmpty: function () {\n\t            return this.option == null;\n\t        },\n\t\n\t        restoreData: function () {},\n\t\n\t        // Pending\n\t        clone: function () {\n\t            var Ctor = this.constructor;\n\t            return new Ctor(zrUtil.clone(this.option));\n\t        },\n\t\n\t        setReadOnly: function (properties) {\n\t            clazzUtil.setReadOnly(this, properties);\n\t        }\n\t    };\n\t\n\t    // Enable Model.extend.\n\t    clazzUtil.enableClassExtend(Model);\n\t\n\t    var mixin = zrUtil.mixin;\n\t    mixin(Model, __webpack_require__(/*! ./mixin/lineStyle */ 130));\n\t    mixin(Model, __webpack_require__(/*! ./mixin/areaStyle */ 127));\n\t    mixin(Model, __webpack_require__(/*! ./mixin/textStyle */ 131));\n\t    mixin(Model, __webpack_require__(/*! ./mixin/itemStyle */ 129));\n\t\n\t    module.exports = Model;\n\n\n/***/ },\n/* 11 */\n/*!***********************************!*\\\n  !*** ./~/zrender/lib/core/env.js ***!\n  \\***********************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * echarts\n\t *\n\t * @desc echartsCanvasJavascript\n\t * @author firede[firede@firede.us]\n\t * @desc thanks zepto.\n\t */\n\t\n\t    var env = {};\n\t    if (typeof navigator === 'undefined') {\n\t        // In node\n\t        env = {\n\t            browser: {},\n\t            os: {},\n\t            node: true,\n\t            // Assume canvas is supported\n\t            canvasSupported: true\n\t        };\n\t    }\n\t    else {\n\t        env = detect(navigator.userAgent);\n\t    }\n\t\n\t    module.exports = env;\n\t\n\t    // Zepto.js\n\t    // (c) 2010-2013 Thomas Fuchs\n\t    // Zepto.js may be freely distributed under the MIT license.\n\t\n\t    function detect(ua) {\n\t        var os = {};\n\t        var browser = {};\n\t        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t        // var touchpad = webos && ua.match(/TouchPad/);\n\t        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t        // var playbook = ua.match(/PlayBook/);\n\t        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n\t        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n\t            // IE 11 Trident/7.0; rv:11.0\n\t            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\t\n\t        var weChat = (/micromessenger/i).test(ua);\n\t\n\t        // Todo: clean this up with a better OS/browser seperation:\n\t        // - discern (more) between multiple browsers on android\n\t        // - decide if kindle fire in silk mode is android or not\n\t        // - Firefox on Android doesn't specify the Android version\n\t        // - possibly devide in os, device and browser hashes\n\t\n\t        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t\n\t        // if (android) os.android = true, os.version = android[2];\n\t        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t        // if (webos) os.webos = true, os.version = webos[2];\n\t        // if (touchpad) os.touchpad = true;\n\t        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t        // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t        // if (playbook) browser.playbook = true;\n\t        // if (kindle) os.kindle = true, os.version = kindle[1];\n\t        // if (silk) browser.silk = true, browser.version = silk[1];\n\t        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t        if (firefox) {\n\t            browser.firefox = true;\n\t            browser.version = firefox[1];\n\t        }\n\t        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t        // if (webview) browser.webview = true;\n\t\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t\n\t        if (edge) {\n\t            browser.edge = true;\n\t            browser.version = edge[1];\n\t        }\n\t\n\t        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n\t        // not be set on win phone. So we do not consider Win Phone.\n\t        if (weChat) {\n\t            browser.weChat = true;\n\t        }\n\t\n\t        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t\n\t        return {\n\t            browser: browser,\n\t            os: os,\n\t            node: false,\n\t            // canvas\n\t            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n\t            canvasSupported : document.createElement('canvas').getContext ? true : false,\n\t            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n\t            // works on most browsers\n\t            // IE10/11 does not support touch event, and MS Edge supports them but not by\n\t            // default, so we dont check navigator.maxTouchPoints for them here.\n\t            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t            // <http://caniuse.com/#search=pointer%20event>.\n\t            pointerEventsSupported: 'onpointerdown' in window\n\t                // Firefox supports pointer but not by default,\n\t                // only MS browsers are reliable on pointer events currently.\n\t                && (browser.edge || (browser.ie && browser.version >= 10))\n\t        };\n\t    }\n\n\n/***/ },\n/* 12 */\n/*!********************************!*\\\n  !*** ./lib/model/Component.js ***!\n  \\********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Component model\n\t *\n\t * @module echarts/model/Component\n\t */\n\t\n\t\n\t    var Model = __webpack_require__(/*! ./Model */ 10);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var arrayPush = Array.prototype.push;\n\t    var componentUtil = __webpack_require__(/*! ../util/component */ 43);\n\t    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 21);\n\t    var layout = __webpack_require__(/*! ../util/layout */ 13);\n\t\n\t    /**\n\t     * @alias module:echarts/model/Component\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {module:echarts/model/Model} ecModel\n\t     */\n\t    var ComponentModel = Model.extend({\n\t\n\t        type: 'component',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {string}\n\t         */\n\t        id: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {string}\n\t         */\n\t        mainType: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {string}\n\t         */\n\t        subType: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {number}\n\t         */\n\t        componentIndex: 0,\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        defaultOption: null,\n\t\n\t        /**\n\t         * @type {module:echarts/model/Global}\n\t         * @readOnly\n\t         */\n\t        ecModel: null,\n\t\n\t        /**\n\t         * key: componentType\n\t         * value:  Component model list, can not be null.\n\t         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n\t         * @readOnly\n\t         */\n\t        dependentModels: [],\n\t\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        uid: null,\n\t\n\t        /**\n\t         * Support merge layout params.\n\t         * Only support 'box' now (left/right/top/bottom/width/height).\n\t         * @type {string|Object} Object can be {ignoreSize: true}\n\t         * @readOnly\n\t         */\n\t        layoutMode: null,\n\t\n\t        $constructor: function (option, parentModel, ecModel, extraOpt) {\n\t            Model.call(this, option, parentModel, ecModel, extraOpt);\n\t\n\t            this.uid = componentUtil.getUID('componentModel');\n\t        },\n\t\n\t\n\t        init: function (option, parentModel, ecModel, extraOpt) {\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t        },\n\t\n\t        mergeDefaultAndTheme: function (option, ecModel) {\n\t            var layoutMode = this.layoutMode;\n\t            var inputPositionParams = layoutMode\n\t                ? layout.getLayoutParams(option) : {};\n\t\n\t            var themeModel = ecModel.getTheme();\n\t            zrUtil.merge(option, themeModel.get(this.mainType));\n\t            zrUtil.merge(option, this.getDefaultOption());\n\t\n\t            if (layoutMode) {\n\t                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t            }\n\t        },\n\t\n\t        mergeOption: function (option, extraOpt) {\n\t            zrUtil.merge(this.option, option, true);\n\t\n\t            var layoutMode = this.layoutMode;\n\t            if (layoutMode) {\n\t                layout.mergeLayoutParam(this.option, option, layoutMode);\n\t            }\n\t        },\n\t\n\t        // Hooker after init or mergeOption\n\t        optionUpdated: function (newCptOption, isInit) {},\n\t\n\t        getDefaultOption: function () {\n\t            if (!this.hasOwnProperty('__defaultOption')) {\n\t                var optList = [];\n\t                var Class = this.constructor;\n\t                while (Class) {\n\t                    var opt = Class.prototype.defaultOption;\n\t                    opt && optList.push(opt);\n\t                    Class = Class.superClass;\n\t                }\n\t\n\t                var defaultOption = {};\n\t                for (var i = optList.length - 1; i >= 0; i--) {\n\t                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n\t                }\n\t                this.__defaultOption = defaultOption;\n\t            }\n\t            return this.__defaultOption;\n\t        },\n\t\n\t        getReferringComponents: function (mainType) {\n\t            return this.ecModel.queryComponents({\n\t                mainType: mainType,\n\t                index: this.get(mainType + 'Index', true),\n\t                id: this.get(mainType + 'Id', true)\n\t            });\n\t        }\n\t\n\t    });\n\t\n\t    // Reset ComponentModel.extend, add preConstruct.\n\t    // clazzUtil.enableClassExtend(\n\t    //     ComponentModel,\n\t    //     function (option, parentModel, ecModel, extraOpt) {\n\t    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n\t    //         zrUtil.extend(this, extraOpt);\n\t\n\t    //         this.uid = componentUtil.getUID('componentModel');\n\t\n\t    //         // this.setReadOnly([\n\t    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n\t    //         //     'dependentModels', 'componentIndex'\n\t    //         // ]);\n\t    //     }\n\t    // );\n\t\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(\n\t        ComponentModel, {registerWhenExtend: true}\n\t    );\n\t    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\t\n\t    // Add capability of ComponentModel.topologicalTravel.\n\t    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\t\n\t    function getDependencies(componentType) {\n\t        var deps = [];\n\t        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n\t            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n\t        });\n\t        // Ensure main type\n\t        return zrUtil.map(deps, function (type) {\n\t            return clazzUtil.parseClassType(type).main;\n\t        });\n\t    }\n\t\n\t    zrUtil.mixin(ComponentModel, __webpack_require__(/*! ./mixin/boxLayout */ 128));\n\t\n\t    module.exports = ComponentModel;\n\n\n/***/ },\n/* 13 */\n/*!****************************!*\\\n  !*** ./lib/util/layout.js ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Layout helpers for each component positioning\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var BoundingRect = __webpack_require__(/*! zrender/lib/core/BoundingRect */ 8);\n\t    var numberUtil = __webpack_require__(/*! ./number */ 4);\n\t    var formatUtil = __webpack_require__(/*! ./format */ 9);\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var each = zrUtil.each;\n\t\n\t    var layout = {};\n\t\n\t    var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n\t\n\t    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n\t        var x = 0;\n\t        var y = 0;\n\t        if (maxWidth == null) {\n\t            maxWidth = Infinity;\n\t        }\n\t        if (maxHeight == null) {\n\t            maxHeight = Infinity;\n\t        }\n\t        var currentLineMaxSize = 0;\n\t        group.eachChild(function (child, idx) {\n\t            var position = child.position;\n\t            var rect = child.getBoundingRect();\n\t            var nextChild = group.childAt(idx + 1);\n\t            var nextChildRect = nextChild && nextChild.getBoundingRect();\n\t            var nextX;\n\t            var nextY;\n\t            if (orient === 'horizontal') {\n\t                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n\t                nextX = x + moveX;\n\t                // Wrap when width exceeds maxWidth or meet a `newline` group\n\t                if (nextX > maxWidth || child.newline) {\n\t                    x = 0;\n\t                    nextX = moveX;\n\t                    y += currentLineMaxSize + gap;\n\t                    currentLineMaxSize = rect.height;\n\t                }\n\t                else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n\t                }\n\t            }\n\t            else {\n\t                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n\t                nextY = y + moveY;\n\t                // Wrap when width exceeds maxHeight or meet a `newline` group\n\t                if (nextY > maxHeight || child.newline) {\n\t                    x += currentLineMaxSize + gap;\n\t                    y = 0;\n\t                    nextY = moveY;\n\t                    currentLineMaxSize = rect.width;\n\t                }\n\t                else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n\t                }\n\t            }\n\t\n\t            if (child.newline) {\n\t                return;\n\t            }\n\t\n\t            position[0] = x;\n\t            position[1] = y;\n\t\n\t            orient === 'horizontal'\n\t                ? (x = nextX + gap)\n\t                : (y = nextY + gap);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * VBox or HBox layouting\n\t     * @param {string} orient\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.box = boxLayout;\n\t\n\t    /**\n\t     * VBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\t\n\t    /**\n\t     * HBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\t\n\t    /**\n\t     * If x or x2 is not specified or 'center' 'left' 'right',\n\t     * the width would be as long as possible.\n\t     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n\t     * the height would be as long as possible.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.x]\n\t     * @param {number|string} [positionInfo.y]\n\t     * @param {number|string} [positionInfo.x2]\n\t     * @param {number|string} [positionInfo.y2]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     * @return {Object} {width, height}\n\t     */\n\t    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t\n\t        var x = parsePercent(positionInfo.x, containerWidth);\n\t        var y = parsePercent(positionInfo.y, containerHeight);\n\t        var x2 = parsePercent(positionInfo.x2, containerWidth);\n\t        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\t\n\t        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n\t        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n\t        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n\t        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\t\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t\n\t        return {\n\t            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n\t            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Parse position info.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {number|string} [positionInfo.width]\n\t     * @param {number|string} [positionInfo.height]\n\t     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n\t     * @param {Object} containerRect\n\t     * @param {string|number} [margin]\n\t     *\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    layout.getLayoutRect = function (\n\t        positionInfo, containerRect, margin\n\t    ) {\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t\n\t        var left = parsePercent(positionInfo.left, containerWidth);\n\t        var top = parsePercent(positionInfo.top, containerHeight);\n\t        var right = parsePercent(positionInfo.right, containerWidth);\n\t        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n\t        var width = parsePercent(positionInfo.width, containerWidth);\n\t        var height = parsePercent(positionInfo.height, containerHeight);\n\t\n\t        var verticalMargin = margin[2] + margin[0];\n\t        var horizontalMargin = margin[1] + margin[3];\n\t        var aspect = positionInfo.aspect;\n\t\n\t        // If width is not specified, calculate width from left and right\n\t        if (isNaN(width)) {\n\t            width = containerWidth - right - horizontalMargin - left;\n\t        }\n\t        if (isNaN(height)) {\n\t            height = containerHeight - bottom - verticalMargin - top;\n\t        }\n\t\n\t        // If width and height are not given\n\t        // 1. Graph should not exceeds the container\n\t        // 2. Aspect must be keeped\n\t        // 3. Graph should take the space as more as possible\n\t        if (isNaN(width) && isNaN(height)) {\n\t            if (aspect > containerWidth / containerHeight) {\n\t                width = containerWidth * 0.8;\n\t            }\n\t            else {\n\t                height = containerHeight * 0.8;\n\t            }\n\t        }\n\t\n\t        if (aspect != null) {\n\t            // Calculate width or height with given aspect\n\t            if (isNaN(width)) {\n\t                width = aspect * height;\n\t            }\n\t            if (isNaN(height)) {\n\t                height = width / aspect;\n\t            }\n\t        }\n\t\n\t        // If left is not specified, calculate left from right and width\n\t        if (isNaN(left)) {\n\t            left = containerWidth - right - width - horizontalMargin;\n\t        }\n\t        if (isNaN(top)) {\n\t            top = containerHeight - bottom - height - verticalMargin;\n\t        }\n\t\n\t        // Align left and top\n\t        switch (positionInfo.left || positionInfo.right) {\n\t            case 'center':\n\t                left = containerWidth / 2 - width / 2 - margin[3];\n\t                break;\n\t            case 'right':\n\t                left = containerWidth - width - horizontalMargin;\n\t                break;\n\t        }\n\t        switch (positionInfo.top || positionInfo.bottom) {\n\t            case 'middle':\n\t            case 'center':\n\t                top = containerHeight / 2 - height / 2 - margin[0];\n\t                break;\n\t            case 'bottom':\n\t                top = containerHeight - height - verticalMargin;\n\t                break;\n\t        }\n\t        // If something is wrong and left, top, width, height are calculated as NaN\n\t        left = left || 0;\n\t        top = top || 0;\n\t        if (isNaN(width)) {\n\t            // Width may be NaN if only one value is given except width\n\t            width = containerWidth - left - (right || 0);\n\t        }\n\t        if (isNaN(height)) {\n\t            // Height may be NaN if only one value is given except height\n\t            height = containerHeight - top - (bottom || 0);\n\t        }\n\t\n\t        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n\t        rect.margin = margin;\n\t        return rect;\n\t    };\n\t\n\t    /**\n\t     * Position group of component in viewport\n\t     *  Group position is specified by either\n\t     *  {left, top}, {right, bottom}\n\t     *  If all properties exists, right and bottom will be igonred.\n\t     *\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     */\n\t    layout.positionGroup = function (\n\t        group, positionInfo, containerRect, margin\n\t    ) {\n\t        var groupRect = group.getBoundingRect();\n\t\n\t        positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {\n\t            width: groupRect.width,\n\t            height: groupRect.height\n\t        });\n\t\n\t        positionInfo = layout.getLayoutRect(\n\t            positionInfo, containerRect, margin\n\t        );\n\t\n\t        group.attr('position', [\n\t            positionInfo.x - groupRect.x,\n\t            positionInfo.y - groupRect.y\n\t        ]);\n\t    };\n\t\n\t    /**\n\t     * Consider Case:\n\t     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n\t     * through setOption or media query, using normal zrUtil.merge will cause\n\t     * {right: 0} does not take effect.\n\t     *\n\t     * @example\n\t     * ComponentModel.extend({\n\t     *     init: function () {\n\t     *         ...\n\t     *         var inputPositionParams = layout.getLayoutParams(option);\n\t     *         this.mergeOption(inputPositionParams);\n\t     *     },\n\t     *     mergeOption: function (newOption) {\n\t     *         newOption && zrUtil.merge(thisOption, newOption, true);\n\t     *         layout.mergeLayoutParam(thisOption, newOption);\n\t     *     }\n\t     * });\n\t     *\n\t     * @param {Object} targetOption\n\t     * @param {Object} newOption\n\t     * @param {Object|string} [opt]\n\t     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n\t     */\n\t    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n\t        !zrUtil.isObject(opt) && (opt = {});\n\t        var hNames = ['width', 'left', 'right']; // Order by priority.\n\t        var vNames = ['height', 'top', 'bottom']; // Order by priority.\n\t        var hResult = merge(hNames);\n\t        var vResult = merge(vNames);\n\t\n\t        copy(hNames, targetOption, hResult);\n\t        copy(vNames, targetOption, vResult);\n\t\n\t        function merge(names) {\n\t            var newParams = {};\n\t            var newValueCount = 0;\n\t            var merged = {};\n\t            var mergedValueCount = 0;\n\t            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\t\n\t            each(names, function (name) {\n\t                merged[name] = targetOption[name];\n\t            });\n\t            each(names, function (name) {\n\t                // Consider case: newOption.width is null, which is\n\t                // set by user for removing width setting.\n\t                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n\t                hasValue(newParams, name) && newValueCount++;\n\t                hasValue(merged, name) && mergedValueCount++;\n\t            });\n\t\n\t            // Case: newOption: {width: ..., right: ...},\n\t            // or targetOption: {right: ...} and newOption: {width: ...},\n\t            // There is no conflict when merged only has params count\n\t            // little than enoughParamNumber.\n\t            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n\t                return merged;\n\t            }\n\t            // Case: newOption: {width: ..., right: ...},\n\t            // Than we can make sure user only want those two, and ignore\n\t            // all origin params in targetOption.\n\t            else if (newValueCount >= enoughParamNumber) {\n\t                return newParams;\n\t            }\n\t            else {\n\t                // Chose another param from targetOption by priority.\n\t                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n\t                for (var i = 0; i < names.length; i++) {\n\t                    var name = names[i];\n\t                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n\t                        newParams[name] = targetOption[name];\n\t                        break;\n\t                    }\n\t                }\n\t                return newParams;\n\t            }\n\t        }\n\t\n\t        function hasProp(obj, name) {\n\t            return obj.hasOwnProperty(name);\n\t        }\n\t\n\t        function hasValue(obj, name) {\n\t            return obj[name] != null && obj[name] !== 'auto';\n\t        }\n\t\n\t        function copy(names, target, source) {\n\t            each(names, function (name) {\n\t                target[name] = source[name];\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.getLayoutParams = function (source) {\n\t        return layout.copyLayoutParams({}, source);\n\t    };\n\t\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.copyLayoutParams = function (target, source) {\n\t        source && target && each(LOCATION_PARAMS, function (name) {\n\t            source.hasOwnProperty(name) && (target[name] = source[name]);\n\t        });\n\t        return target;\n\t    };\n\t\n\t    module.exports = layout;\n\n\n/***/ },\n/* 14 */\n/*!**************************!*\\\n  !*** ./lib/data/List.js ***!\n  \\**************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * List for data storage\n\t * @module echarts/data/List\n\t */\n\t\n\t\n\t    var UNDEFINED = 'undefined';\n\t    var globalObj = typeof window === 'undefined' ? global : window;\n\t    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n\t        ? Array : globalObj.Float64Array;\n\t    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n\t        ? Array : globalObj.Int32Array;\n\t\n\t    var dataCtors = {\n\t        'float': Float64Array,\n\t        'int': Int32Array,\n\t        // Ordinal data type can be string or int\n\t        'ordinal': Array,\n\t        'number': Array,\n\t        'time': Array\n\t    };\n\t\n\t    var Model = __webpack_require__(/*! ../model/Model */ 10);\n\t    var DataDiffer = __webpack_require__(/*! ./DataDiffer */ 45);\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var modelUtil = __webpack_require__(/*! ../util/model */ 7);\n\t    var isObject = zrUtil.isObject;\n\t\n\t    var TRANSFERABLE_PROPERTIES = [\n\t        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n\t    ];\n\t\n\t    var transferProperties = function (a, b) {\n\t        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n\t            if (b.hasOwnProperty(propName)) {\n\t                a[propName] = b[propName];\n\t            }\n\t        });\n\t\n\t        a.__wrappedMethods = b.__wrappedMethods;\n\t    };\n\t\n\t    /**\n\t     * @constructor\n\t     * @alias module:echarts/data/List\n\t     *\n\t     * @param {Array.<string>} dimensions\n\t     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n\t     * @param {module:echarts/model/Model} hostModel\n\t     */\n\t    var List = function (dimensions, hostModel) {\n\t\n\t        dimensions = dimensions || ['x', 'y'];\n\t\n\t        var dimensionInfos = {};\n\t        var dimensionNames = [];\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimensionName;\n\t            var dimensionInfo = {};\n\t            if (typeof dimensions[i] === 'string') {\n\t                dimensionName = dimensions[i];\n\t                dimensionInfo = {\n\t                    name: dimensionName,\n\t                    stackable: false,\n\t                    // Type can be 'float', 'int', 'number'\n\t                    // Default is number, Precision of float may not enough\n\t                    type: 'number'\n\t                };\n\t            }\n\t            else {\n\t                dimensionInfo = dimensions[i];\n\t                dimensionName = dimensionInfo.name;\n\t                dimensionInfo.type = dimensionInfo.type || 'number';\n\t            }\n\t            dimensionNames.push(dimensionName);\n\t            dimensionInfos[dimensionName] = dimensionInfo;\n\t        }\n\t        /**\n\t         * @readOnly\n\t         * @type {Array.<string>}\n\t         */\n\t        this.dimensions = dimensionNames;\n\t\n\t        /**\n\t         * Infomation of each data dimension, like data type.\n\t         * @type {Object}\n\t         */\n\t        this._dimensionInfos = dimensionInfos;\n\t\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.hostModel = hostModel;\n\t\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.dataType;\n\t\n\t        /**\n\t         * Indices stores the indices of data subset after filtered.\n\t         * This data subset will be used in chart.\n\t         * @type {Array.<number>}\n\t         * @readOnly\n\t         */\n\t        this.indices = [];\n\t\n\t        /**\n\t         * Data storage\n\t         * @type {Object.<key, TypedArray|Array>}\n\t         * @private\n\t         */\n\t        this._storage = {};\n\t\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._nameList = [];\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._idList = [];\n\t        /**\n\t         * Models of data option is stored sparse for optimizing memory cost\n\t         * @type {Array.<module:echarts/model/Model>}\n\t         * @private\n\t         */\n\t        this._optionModels = [];\n\t\n\t        /**\n\t         * @param {module:echarts/data/List}\n\t         */\n\t        this.stackedOn = null;\n\t\n\t        /**\n\t         * Global visual properties after visual coding\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._visual = {};\n\t\n\t        /**\n\t         * Globel layout properties.\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._layout = {};\n\t\n\t        /**\n\t         * Item visual properties after visual coding\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemVisuals = [];\n\t\n\t        /**\n\t         * Item layout properties after layout\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemLayouts = [];\n\t\n\t        /**\n\t         * Graphic elemnents\n\t         * @type {Array.<module:zrender/Element>}\n\t         * @private\n\t         */\n\t        this._graphicEls = [];\n\t\n\t        /**\n\t         * @type {Array.<Array|Object>}\n\t         * @private\n\t         */\n\t        this._rawData;\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._extent;\n\t    };\n\t\n\t    var listProto = List.prototype;\n\t\n\t    listProto.type = 'list';\n\t    /**\n\t     * If each data item has it's own option\n\t     * @type {boolean}\n\t     */\n\t    listProto.hasItemOption = true;\n\t\n\t    /**\n\t     * Get dimension name\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     * @return {string} Concrete dim name.\n\t     */\n\t    listProto.getDimension = function (dim) {\n\t        if (!isNaN(dim)) {\n\t            dim = this.dimensions[dim] || dim;\n\t        }\n\t        return dim;\n\t    };\n\t    /**\n\t     * Get type and stackable info of particular dimension\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     */\n\t    listProto.getDimensionInfo = function (dim) {\n\t        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n\t    };\n\t\n\t    /**\n\t     * Initialize from data\n\t     * @param {Array.<Object|number|Array>} data\n\t     * @param {Array.<string>} [nameList]\n\t     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n\t     */\n\t    listProto.initData = function (data, nameList, dimValueGetter) {\n\t        data = data || [];\n\t\n\t        if (false) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t\n\t        this._rawData = data;\n\t\n\t        // Clear\n\t        var storage = this._storage = {};\n\t        var indices = this.indices = [];\n\t\n\t        var dimensions = this.dimensions;\n\t        var size = data.length;\n\t        var dimensionInfoMap = this._dimensionInfos;\n\t\n\t        var idList = [];\n\t        var nameRepeatCount = {};\n\t\n\t        nameList = nameList || [];\n\t\n\t        // Init storage\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimInfo = dimensionInfoMap[dimensions[i]];\n\t            var DataCtor = dataCtors[dimInfo.type];\n\t            storage[dimensions[i]] = new DataCtor(size);\n\t        }\n\t\n\t        var self = this;\n\t        if (!dimValueGetter) {\n\t            self.hasItemOption = false;\n\t        }\n\t        // Default dim value getter\n\t        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n\t            var value = modelUtil.getDataItemValue(dataItem);\n\t            // If any dataItem is like { value: 10 }\n\t            if (modelUtil.isDataItemOption(dataItem)) {\n\t                self.hasItemOption = true;\n\t            }\n\t            return modelUtil.converDataValue(\n\t                (value instanceof Array)\n\t                    ? value[dimIndex]\n\t                    // If value is a single number or something else not array.\n\t                    : value,\n\t                dimensionInfoMap[dimName]\n\t            );\n\t        };\n\t\n\t        for (var idx = 0; idx < data.length; idx++) {\n\t            var dataItem = data[idx];\n\t            // Each data item is value\n\t            // [1, 2]\n\t            // 2\n\t            // Bar chart, line chart which uses category axis\n\t            // only gives the 'y' value. 'x' value is the indices of cateogry\n\t            // Use a tempValue to normalize the value to be a (x, y) value\n\t\n\t            // Store the data by dimensions\n\t            for (var k = 0; k < dimensions.length; k++) {\n\t                var dim = dimensions[k];\n\t                var dimStorage = storage[dim];\n\t                // PENDING NULL is empty or zero\n\t                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n\t            }\n\t\n\t            indices.push(idx);\n\t        }\n\t\n\t        // Use the name in option and create id\n\t        for (var i = 0; i < data.length; i++) {\n\t            if (!nameList[i]) {\n\t                if (data[i] && data[i].name != null) {\n\t                    nameList[i] = data[i].name;\n\t                }\n\t            }\n\t            var name = nameList[i] || '';\n\t            // Try using the id in option\n\t            var id = data[i] && data[i].id;\n\t\n\t            if (!id && name) {\n\t                // Use name as id and add counter to avoid same name\n\t                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n\t                id = name;\n\t                if (nameRepeatCount[name] > 0) {\n\t                    id += '__ec__' + nameRepeatCount[name];\n\t                }\n\t                nameRepeatCount[name]++;\n\t            }\n\t            id && (idList[i] = id);\n\t        }\n\t\n\t        this._nameList = nameList;\n\t        this._idList = idList;\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    listProto.count = function () {\n\t        return this.indices.length;\n\t    };\n\t\n\t    /**\n\t     * Get value. Return NaN if idx is out of range.\n\t     * @param {string} dim Dim must be concrete name.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.get = function (dim, idx, stack) {\n\t        var storage = this._storage;\n\t        var dataIndex = this.indices[idx];\n\t\n\t        // If value not exists\n\t        if (dataIndex == null) {\n\t            return NaN;\n\t        }\n\t\n\t        var value = storage[dim] && storage[dim][dataIndex];\n\t        // FIXME ordinal data type is not stackable\n\t        if (stack) {\n\t            var dimensionInfo = this._dimensionInfos[dim];\n\t            if (dimensionInfo && dimensionInfo.stackable) {\n\t                var stackedOn = this.stackedOn;\n\t                while (stackedOn) {\n\t                    // Get no stacked data of stacked on\n\t                    var stackedValue = stackedOn.get(dim, idx);\n\t                    // Considering positive stack, negative stack and empty data\n\t                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n\t                        || (value <= 0 && stackedValue < 0) // Negative stack\n\t                    ) {\n\t                        value += stackedValue;\n\t                    }\n\t                    stackedOn = stackedOn.stackedOn;\n\t                }\n\t            }\n\t        }\n\t        return value;\n\t    };\n\t\n\t    /**\n\t     * Get value for multi dimensions.\n\t     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.getValues = function (dimensions, idx, stack) {\n\t        var values = [];\n\t\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            stack = idx;\n\t            idx = dimensions;\n\t            dimensions = this.dimensions;\n\t        }\n\t\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            values.push(this.get(dimensions[i], idx, stack));\n\t        }\n\t\n\t        return values;\n\t    };\n\t\n\t    /**\n\t     * If value is NaN. Inlcuding '-'\n\t     * @param {string} dim\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.hasValue = function (idx) {\n\t        var dimensions = this.dimensions;\n\t        var dimensionInfos = this._dimensionInfos;\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            if (\n\t                // Ordinal type can be string or number\n\t                dimensionInfos[dimensions[i]].type !== 'ordinal'\n\t                && isNaN(this.get(dimensions[i], idx))\n\t            ) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t\n\t    /**\n\t     * Get extent of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getDataExtent = function (dim, stack) {\n\t        dim = this.getDimension(dim);\n\t        var dimData = this._storage[dim];\n\t        var dimInfo = this.getDimensionInfo(dim);\n\t        stack = (dimInfo && dimInfo.stackable) && stack;\n\t        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n\t        var value;\n\t        if (dimExtent) {\n\t            return dimExtent;\n\t        }\n\t        // var dimInfo = this._dimensionInfos[dim];\n\t        if (dimData) {\n\t            var min = Infinity;\n\t            var max = -Infinity;\n\t            // var isOrdinal = dimInfo.type === 'ordinal';\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                value = this.get(dim, i, stack);\n\t                // FIXME\n\t                // if (isOrdinal && typeof value === 'string') {\n\t                //     value = zrUtil.indexOf(dimData, value);\n\t                // }\n\t                value < min && (min = value);\n\t                value > max && (max = value);\n\t            }\n\t            return (this._extent[dim + !!stack] = [min, max]);\n\t        }\n\t        else {\n\t            return [Infinity, -Infinity];\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Get sum of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getSum = function (dim, stack) {\n\t        var dimData = this._storage[dim];\n\t        var sum = 0;\n\t        if (dimData) {\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var value = this.get(dim, i, stack);\n\t                if (!isNaN(value)) {\n\t                    sum += value;\n\t                }\n\t            }\n\t        }\n\t        return sum;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index with given value\n\t     * @param {number} idx\n\t     * @param {number} value\n\t     * @return {number}\n\t     */\n\t    // FIXME Precision of float value\n\t    listProto.indexOf = function (dim, value) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t        var indices = this.indices;\n\t\n\t        if (dimData) {\n\t            for (var i = 0, len = indices.length; i < len; i++) {\n\t                var rawIndex = indices[i];\n\t                if (dimData[rawIndex] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index with given name\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfName = function (name) {\n\t        var indices = this.indices;\n\t        var nameList = this._nameList;\n\t\n\t        for (var i = 0, len = indices.length; i < len; i++) {\n\t            var rawIndex = indices[i];\n\t            if (nameList[rawIndex] === name) {\n\t                return i;\n\t            }\n\t        }\n\t\n\t        return -1;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index with given raw data index\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfRawIndex = function (rawIndex) {\n\t        // Indices are ascending\n\t        var indices = this.indices;\n\t\n\t        // If rawIndex === dataIndex\n\t        var rawDataIndex = indices[rawIndex];\n\t        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n\t            return rawIndex;\n\t        }\n\t\n\t        var left = 0;\n\t        var right = indices.length - 1;\n\t        while (left <= right) {\n\t            var mid = (left + right) / 2 | 0;\n\t            if (indices[mid] < rawIndex) {\n\t                left = mid + 1;\n\t            }\n\t            else if (indices[mid] > rawIndex) {\n\t                right = mid - 1;\n\t            }\n\t            else {\n\t                return mid;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index of nearest value\n\t     * @param {string} dim\n\t     * @param {number} value\n\t     * @param {boolean} stack If given value is after stacked\n\t     * @param {number} [maxDistance=Infinity]\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t\n\t        if (maxDistance == null) {\n\t            maxDistance = Infinity;\n\t        }\n\t\n\t        var nearestIdx = -1;\n\t        if (dimData) {\n\t            var minDist = Number.MAX_VALUE;\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var diff = value - this.get(dim, i, stack);\n\t                var dist = Math.abs(diff);\n\t                if (\n\t                    diff <= maxDistance\n\t                    && (dist < minDist\n\t                        // For the case of two data are same on xAxis, which has sequence data.\n\t                        // Show the nearest index\n\t                        // https://github.com/ecomfe/echarts/issues/2869\n\t                        || (dist === minDist && diff > 0)\n\t                    )\n\t                ) {\n\t                    minDist = dist;\n\t                    nearestIdx = i;\n\t                }\n\t            }\n\t        }\n\t        return nearestIdx;\n\t    };\n\t\n\t    /**\n\t     * Get raw data index\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawIndex = function (idx) {\n\t        var rawIdx = this.indices[idx];\n\t        return rawIdx == null ? -1 : rawIdx;\n\t    };\n\t\n\t    /**\n\t     * Get raw data item\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawDataItem = function (idx) {\n\t        return this._rawData[this.getRawIndex(idx)];\n\t    };\n\t\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getName = function (idx) {\n\t        return this._nameList[this.indices[idx]] || '';\n\t    };\n\t\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getId = function (idx) {\n\t        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n\t    };\n\t\n\t\n\t    function normalizeDimensions(dimensions) {\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            dimensions = [dimensions];\n\t        }\n\t        return dimensions;\n\t    }\n\t\n\t    /**\n\t     * Data iteration\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     *\n\t     * @example\n\t     *  list.each('x', function (x, idx) {});\n\t     *  list.each(['x', 'y'], function (x, y, idx) {});\n\t     *  list.each(function (idx) {})\n\t     */\n\t    listProto.each = function (dims, cb, stack, context) {\n\t        if (typeof dims === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dims;\n\t            dims = [];\n\t        }\n\t\n\t        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\t\n\t        var value = [];\n\t        var dimSize = dims.length;\n\t        var indices = this.indices;\n\t\n\t        context = context || this;\n\t\n\t        for (var i = 0; i < indices.length; i++) {\n\t            // Simple optimization\n\t            switch (dimSize) {\n\t                case 0:\n\t                    cb.call(context, i);\n\t                    break;\n\t                case 1:\n\t                    cb.call(context, this.get(dims[0], i, stack), i);\n\t                    break;\n\t                case 2:\n\t                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n\t                    break;\n\t                default:\n\t                    for (var k = 0; k < dimSize; k++) {\n\t                        value[k] = this.get(dims[k], i, stack);\n\t                    }\n\t                    // Index\n\t                    value[k] = i;\n\t                    cb.apply(context, value);\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Data filter\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     */\n\t    listProto.filterSelf = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t\n\t        dimensions = zrUtil.map(\n\t            normalizeDimensions(dimensions), this.getDimension, this\n\t        );\n\t\n\t        var newIndices = [];\n\t        var value = [];\n\t        var dimSize = dimensions.length;\n\t        var indices = this.indices;\n\t\n\t        context = context || this;\n\t\n\t        for (var i = 0; i < indices.length; i++) {\n\t            var keep;\n\t            // Simple optimization\n\t            if (dimSize === 1) {\n\t                keep = cb.call(\n\t                    context, this.get(dimensions[0], i, stack), i\n\t                );\n\t            }\n\t            else {\n\t                for (var k = 0; k < dimSize; k++) {\n\t                    value[k] = this.get(dimensions[k], i, stack);\n\t                }\n\t                value[k] = i;\n\t                keep = cb.apply(context, value);\n\t            }\n\t            if (keep) {\n\t                newIndices.push(indices[i]);\n\t            }\n\t        }\n\t\n\t        this.indices = newIndices;\n\t\n\t        // Reset data extent\n\t        this._extent = {};\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Data mapping to a plain array\n\t     * @param {string|Array.<string>} [dimensions]\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.mapArray = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t\n\t        var result = [];\n\t        this.each(dimensions, function () {\n\t            result.push(cb && cb.apply(this, arguments));\n\t        }, stack, context);\n\t        return result;\n\t    };\n\t\n\t    function cloneListForMapAndSample(original, excludeDimensions) {\n\t        var allDimensions = original.dimensions;\n\t        var list = new List(\n\t            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n\t            original.hostModel\n\t        );\n\t        // FIXME If needs stackedOn, value may already been stacked\n\t        transferProperties(list, original);\n\t\n\t        var storage = list._storage = {};\n\t        var originalStorage = original._storage;\n\t        // Init storage\n\t        for (var i = 0; i < allDimensions.length; i++) {\n\t            var dim = allDimensions[i];\n\t            var dimStore = originalStorage[dim];\n\t            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n\t                storage[dim] = new dimStore.constructor(\n\t                    originalStorage[dim].length\n\t                );\n\t            }\n\t            else {\n\t                // Direct reference for other dimensions\n\t                storage[dim] = originalStorage[dim];\n\t            }\n\t        }\n\t        return list;\n\t    }\n\t\n\t    /**\n\t     * Data mapping to a new List with given dimensions\n\t     * @param {string|Array.<string>} dimensions\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.map = function (dimensions, cb, stack, context) {\n\t        dimensions = zrUtil.map(\n\t            normalizeDimensions(dimensions), this.getDimension, this\n\t        );\n\t\n\t        var list = cloneListForMapAndSample(this, dimensions);\n\t        // Following properties are all immutable.\n\t        // So we can reference to the same value\n\t        var indices = list.indices = this.indices;\n\t\n\t        var storage = list._storage;\n\t\n\t        var tmpRetValue = [];\n\t        this.each(dimensions, function () {\n\t            var idx = arguments[arguments.length - 1];\n\t            var retValue = cb && cb.apply(this, arguments);\n\t            if (retValue != null) {\n\t                // a number\n\t                if (typeof retValue === 'number') {\n\t                    tmpRetValue[0] = retValue;\n\t                    retValue = tmpRetValue;\n\t                }\n\t                for (var i = 0; i < retValue.length; i++) {\n\t                    var dim = dimensions[i];\n\t                    var dimStore = storage[dim];\n\t                    var rawIdx = indices[idx];\n\t                    if (dimStore) {\n\t                        dimStore[rawIdx] = retValue[i];\n\t                    }\n\t                }\n\t            }\n\t        }, stack, context);\n\t\n\t        return list;\n\t    };\n\t\n\t    /**\n\t     * Large data down sampling on given dimension\n\t     * @param {string} dimension\n\t     * @param {number} rate\n\t     * @param {Function} sampleValue\n\t     * @param {Function} sampleIndex Sample index for name and id\n\t     */\n\t    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n\t        var list = cloneListForMapAndSample(this, [dimension]);\n\t        var storage = this._storage;\n\t        var targetStorage = list._storage;\n\t\n\t        var originalIndices = this.indices;\n\t        var indices = list.indices = [];\n\t\n\t        var frameValues = [];\n\t        var frameIndices = [];\n\t        var frameSize = Math.floor(1 / rate);\n\t\n\t        var dimStore = targetStorage[dimension];\n\t        var len = this.count();\n\t        // Copy data from original data\n\t        for (var i = 0; i < storage[dimension].length; i++) {\n\t            targetStorage[dimension][i] = storage[dimension][i];\n\t        }\n\t        for (var i = 0; i < len; i += frameSize) {\n\t            // Last frame\n\t            if (frameSize > len - i) {\n\t                frameSize = len - i;\n\t                frameValues.length = frameSize;\n\t            }\n\t            for (var k = 0; k < frameSize; k++) {\n\t                var idx = originalIndices[i + k];\n\t                frameValues[k] = dimStore[idx];\n\t                frameIndices[k] = idx;\n\t            }\n\t            var value = sampleValue(frameValues);\n\t            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n\t            // Only write value on the filtered data\n\t            dimStore[idx] = value;\n\t            indices.push(idx);\n\t        }\n\t\n\t        return list;\n\t    };\n\t\n\t    /**\n\t     * Get model of one data item.\n\t     *\n\t     * @param {number} idx\n\t     */\n\t    // FIXME Model proxy ?\n\t    listProto.getItemModel = function (idx) {\n\t        var hostModel = this.hostModel;\n\t        idx = this.indices[idx];\n\t        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n\t    };\n\t\n\t    /**\n\t     * Create a data differ\n\t     * @param {module:echarts/data/List} otherList\n\t     * @return {module:echarts/data/DataDiffer}\n\t     */\n\t    listProto.diff = function (otherList) {\n\t        var idList = this._idList;\n\t        var otherIdList = otherList && otherList._idList;\n\t        return new DataDiffer(\n\t            otherList ? otherList.indices : [], this.indices, function (idx) {\n\t                return otherIdList[idx] || (idx + '');\n\t            }, function (idx) {\n\t                return idList[idx] || (idx + '');\n\t            }\n\t        );\n\t    };\n\t    /**\n\t     * Get visual property.\n\t     * @param {string} key\n\t     */\n\t    listProto.getVisual = function (key) {\n\t        var visual = this._visual;\n\t        return visual && visual[key];\n\t    };\n\t\n\t    /**\n\t     * Set visual property\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setVisual('color', color);\n\t     *  setVisual({\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setVisual = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setVisual(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._visual = this._visual || {};\n\t        this._visual[key] = val;\n\t    };\n\t\n\t    /**\n\t     * Set layout property.\n\t     * @param {string} key\n\t     * @param {*} [val]\n\t     */\n\t    listProto.setLayout = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setLayout(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._layout[key] = val;\n\t    };\n\t\n\t    /**\n\t     * Get layout property.\n\t     * @param  {string} key.\n\t     * @return {*}\n\t     */\n\t    listProto.getLayout = function (key) {\n\t        return this._layout[key];\n\t    };\n\t\n\t    /**\n\t     * Get layout of single data item\n\t     * @param {number} idx\n\t     */\n\t    listProto.getItemLayout = function (idx) {\n\t        return this._itemLayouts[idx];\n\t    };\n\t\n\t    /**\n\t     * Set layout of single data item\n\t     * @param {number} idx\n\t     * @param {Object} layout\n\t     * @param {boolean=} [merge=false]\n\t     */\n\t    listProto.setItemLayout = function (idx, layout, merge) {\n\t        this._itemLayouts[idx] = merge\n\t            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n\t            : layout;\n\t    };\n\t\n\t    /**\n\t     * Clear all layout of single data item\n\t     */\n\t    listProto.clearItemLayouts = function () {\n\t        this._itemLayouts.length = 0;\n\t    };\n\t\n\t    /**\n\t     * Get visual property of single data item\n\t     * @param {number} idx\n\t     * @param {string} key\n\t     * @param {boolean} ignoreParent\n\t     */\n\t    listProto.getItemVisual = function (idx, key, ignoreParent) {\n\t        var itemVisual = this._itemVisuals[idx];\n\t        var val = itemVisual && itemVisual[key];\n\t        if (val == null && !ignoreParent) {\n\t            // Use global visual property\n\t            return this.getVisual(key);\n\t        }\n\t        return val;\n\t    };\n\t\n\t    /**\n\t     * Set visual property of single data item\n\t     *\n\t     * @param {number} idx\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setItemVisual(0, 'color', color);\n\t     *  setItemVisual(0, {\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setItemVisual = function (idx, key, value) {\n\t        var itemVisual = this._itemVisuals[idx] || {};\n\t        this._itemVisuals[idx] = itemVisual;\n\t\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    itemVisual[name] = key[name];\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        itemVisual[key] = value;\n\t    };\n\t\n\t    /**\n\t     * Clear itemVisuals and list visual.\n\t     */\n\t    listProto.clearAllVisual = function () {\n\t        this._visual = {};\n\t        this._itemVisuals = [];\n\t    };\n\t\n\t    var setItemDataAndSeriesIndex = function (child) {\n\t        child.seriesIndex = this.seriesIndex;\n\t        child.dataIndex = this.dataIndex;\n\t        child.dataType = this.dataType;\n\t    };\n\t    /**\n\t     * Set graphic element relative to data. It can be set as null\n\t     * @param {number} idx\n\t     * @param {module:zrender/Element} [el]\n\t     */\n\t    listProto.setItemGraphicEl = function (idx, el) {\n\t        var hostModel = this.hostModel;\n\t\n\t        if (el) {\n\t            // Add data index and series index for indexing the data by element\n\t            // Useful in tooltip\n\t            el.dataIndex = idx;\n\t            el.dataType = this.dataType;\n\t            el.seriesIndex = hostModel && hostModel.seriesIndex;\n\t            if (el.type === 'group') {\n\t                el.traverse(setItemDataAndSeriesIndex, el);\n\t            }\n\t        }\n\t\n\t        this._graphicEls[idx] = el;\n\t    };\n\t\n\t    /**\n\t     * @param {number} idx\n\t     * @return {module:zrender/Element}\n\t     */\n\t    listProto.getItemGraphicEl = function (idx) {\n\t        return this._graphicEls[idx];\n\t    };\n\t\n\t    /**\n\t     * @param {Function} cb\n\t     * @param {*} context\n\t     */\n\t    listProto.eachItemGraphicEl = function (cb, context) {\n\t        zrUtil.each(this._graphicEls, function (el, idx) {\n\t            if (el) {\n\t                cb && cb.call(context, el, idx);\n\t            }\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Shallow clone a new list except visual and layout properties, and graph elements.\n\t     * New list only change the indices.\n\t     */\n\t    listProto.cloneShallow = function () {\n\t        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n\t        var list = new List(dimensionInfoList, this.hostModel);\n\t\n\t        // FIXME\n\t        list._storage = this._storage;\n\t\n\t        transferProperties(list, this);\n\t\n\t\n\t        // Clone will not change the data extent and indices\n\t        list.indices = this.indices.slice();\n\t\n\t        if (this._extent) {\n\t            list._extent = zrUtil.extend({}, this._extent);\n\t        }\n\t\n\t        return list;\n\t    };\n\t\n\t    /**\n\t     * Wrap some method to add more feature\n\t     * @param {string} methodName\n\t     * @param {Function} injectFunction\n\t     */\n\t    listProto.wrapMethod = function (methodName, injectFunction) {\n\t        var originalMethod = this[methodName];\n\t        if (typeof originalMethod !== 'function') {\n\t            return;\n\t        }\n\t        this.__wrappedMethods = this.__wrappedMethods || [];\n\t        this.__wrappedMethods.push(methodName);\n\t        this[methodName] = function () {\n\t            var res = originalMethod.apply(this, arguments);\n\t            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n\t        };\n\t    };\n\t\n\t    // Methods that create a new list based on this list should be listed here.\n\t    // Notice that those method should `RETURN` the new list.\n\t    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n\t    // Methods that change indices of this list should be listed here.\n\t    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\t\n\t    module.exports = List;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 15 */\n/*!*****************************!*\\\n  !*** ./lib/model/Series.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var formatUtil = __webpack_require__(/*! ../util/format */ 9);\n\t    var modelUtil = __webpack_require__(/*! ../util/model */ 7);\n\t    var ComponentModel = __webpack_require__(/*! ./Component */ 12);\n\t    var colorPaletteMixin = __webpack_require__(/*! ./mixin/colorPalette */ 56);\n\t    var env = __webpack_require__(/*! zrender/lib/core/env */ 11);\n\t\n\t    var encodeHTML = formatUtil.encodeHTML;\n\t    var addCommas = formatUtil.addCommas;\n\t\n\t    var SeriesModel = ComponentModel.extend({\n\t\n\t        type: 'series.__base__',\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        seriesIndex: 0,\n\t\n\t        // coodinateSystem will be injected in the echarts/CoordinateSystem\n\t        coordinateSystem: null,\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        defaultOption: null,\n\t\n\t        /**\n\t         * Data provided for legend\n\t         * @type {Function}\n\t         */\n\t        // PENDING\n\t        legendDataProvider: null,\n\t\n\t        /**\n\t         * Access path of color for visual\n\t         */\n\t        visualColorAccessPath: 'itemStyle.normal.color',\n\t\n\t        init: function (option, parentModel, ecModel, extraOpt) {\n\t\n\t            /**\n\t             * @type {number}\n\t             * @readOnly\n\t             */\n\t            this.seriesIndex = this.componentIndex;\n\t\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t\n\t            /**\n\t             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n\t             * @private\n\t             */\n\t            this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n\t\n\t            // If we reverse the order (make this._data firstly, and then make\n\t            // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n\t            // cause this._data.graph.data !== this._data when using\n\t            // module:echarts/data/Graph or module:echarts/data/Tree.\n\t            // See module:echarts/data/helper/linkList\n\t            this._data = this._dataBeforeProcessed.cloneShallow();\n\t        },\n\t\n\t        /**\n\t         * Util for merge default and theme to option\n\t         * @param  {Object} option\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         */\n\t        mergeDefaultAndTheme: function (option, ecModel) {\n\t            zrUtil.merge(\n\t                option,\n\t                ecModel.getTheme().get(this.subType)\n\t            );\n\t            zrUtil.merge(option, this.getDefaultOption());\n\t\n\t            // Default label emphasis `position` and `show`\n\t            // FIXME Set label in mergeOption\n\t            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\t\n\t            this.fillDataTextStyle(option.data);\n\t        },\n\t\n\t        mergeOption: function (newSeriesOption, ecModel) {\n\t            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n\t            this.fillDataTextStyle(newSeriesOption.data);\n\t\n\t            var data = this.getInitialData(newSeriesOption, ecModel);\n\t            // TODO Merge data?\n\t            if (data) {\n\t                this._data = data;\n\t                this._dataBeforeProcessed = data.cloneShallow();\n\t            }\n\t        },\n\t\n\t        fillDataTextStyle: function (data) {\n\t            // Default data label emphasis `position` and `show`\n\t            // FIXME Tree structure data ?\n\t            // FIXME Performance ?\n\t            if (data) {\n\t                for (var i = 0; i < data.length; i++) {\n\t                    if (data[i] && data[i].label) {\n\t                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Init a data structure from data related option in series\n\t         * Must be overwritten\n\t         */\n\t        getInitialData: function () {},\n\t\n\t        /**\n\t         * @param {string} [dataType]\n\t         * @return {module:echarts/data/List}\n\t         */\n\t        getData: function (dataType) {\n\t            return dataType == null ? this._data : this._data.getLinkedData(dataType);\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/data/List} data\n\t         */\n\t        setData: function (data) {\n\t            this._data = data;\n\t        },\n\t\n\t        /**\n\t         * Get data before processed\n\t         * @return {module:echarts/data/List}\n\t         */\n\t        getRawData: function () {\n\t            return this._dataBeforeProcessed;\n\t        },\n\t\n\t        /**\n\t         * Coord dimension to data dimension.\n\t         *\n\t         * By default the result is the same as dimensions of series data.\n\t         * But in some series data dimensions are different from coord dimensions (i.e.\n\t         * candlestick and boxplot). Override this method to handle those cases.\n\t         *\n\t         * Coord dimension to data dimension can be one-to-many\n\t         *\n\t         * @param {string} coordDim\n\t         * @return {Array.<string>} dimensions on the axis.\n\t         */\n\t        coordDimToDataDim: function (coordDim) {\n\t            return [coordDim];\n\t        },\n\t\n\t        /**\n\t         * Convert data dimension to coord dimension.\n\t         *\n\t         * @param {string|number} dataDim\n\t         * @return {string}\n\t         */\n\t        dataDimToCoordDim: function (dataDim) {\n\t            return dataDim;\n\t        },\n\t\n\t        /**\n\t         * Get base axis if has coordinate system and has axis.\n\t         * By default use coordSys.getBaseAxis();\n\t         * Can be overrided for some chart.\n\t         * @return {type} description\n\t         */\n\t        getBaseAxis: function () {\n\t            var coordSys = this.coordinateSystem;\n\t            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n\t        },\n\t\n\t        // FIXME\n\t        /**\n\t         * Default tooltip formatter\n\t         *\n\t         * @param {number} dataIndex\n\t         * @param {boolean} [multipleSeries=false]\n\t         * @param {number} [dataType]\n\t         */\n\t        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n\t            function formatArrayValue(value) {\n\t                var result = [];\n\t\n\t                zrUtil.each(value, function (val, idx) {\n\t                    var dimInfo = data.getDimensionInfo(idx);\n\t                    var dimType = dimInfo && dimInfo.type;\n\t                    var valStr;\n\t\n\t                    if (dimType === 'ordinal') {\n\t                        valStr = val + '';\n\t                    }\n\t                    else if (dimType === 'time') {\n\t                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/mm/dd hh:mm:ss', val);\n\t                    }\n\t                    else {\n\t                        valStr = addCommas(val);\n\t                    }\n\t\n\t                    valStr && result.push(valStr);\n\t                });\n\t\n\t                return result.join(', ');\n\t            }\n\t\n\t            var data = this._data;\n\t\n\t            var value = this.getRawValue(dataIndex);\n\t            var formattedValue = zrUtil.isArray(value)\n\t                ? formatArrayValue(value) : addCommas(value);\n\t            var name = data.getName(dataIndex);\n\t            var color = data.getItemVisual(dataIndex, 'color');\n\t            var colorEl = '<span style=\"display:inline-block;margin-right:5px;'\n\t                + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n\t\n\t            var seriesName = this.name;\n\t            // FIXME\n\t            if (seriesName === '\\0-') {\n\t                // Not show '-'\n\t                seriesName = '';\n\t            }\n\t            return !multipleSeries\n\t                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl\n\t                    + (name\n\t                        ? encodeHTML(name) + ' : ' + formattedValue\n\t                        : formattedValue)\n\t                  )\n\t                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);\n\t        },\n\t\n\t        /**\n\t         * @return {boolean}\n\t         */\n\t        ifEnableAnimation: function () {\n\t            if (env.node) {\n\t                return false;\n\t            }\n\t\n\t            var animationEnabled = this.getShallow('animation');\n\t            if (animationEnabled) {\n\t                if (this.getData().count() > this.getShallow('animationThreshold')) {\n\t                    animationEnabled = false;\n\t                }\n\t            }\n\t            return animationEnabled;\n\t        },\n\t\n\t        restoreData: function () {\n\t            this._data = this._dataBeforeProcessed.cloneShallow();\n\t        },\n\t\n\t        getColorFromPalette: function (name, scope) {\n\t            var ecModel = this.ecModel;\n\t            // PENDING\n\t            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n\t            if (!color) {\n\t                color = ecModel.getColorFromPalette(name, scope);\n\t            }\n\t            return color;\n\t        },\n\t\n\t        /**\n\t         * Get data indices for show tooltip content. See tooltip.\n\t         * @abstract\n\t         * @param {Array.<string>|string} dim\n\t         * @param {Array.<number>} value\n\t         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n\t         * @return {Array.<number>} data indices.\n\t         */\n\t        getAxisTooltipDataIndex: null,\n\t\n\t        /**\n\t         * See tooltip.\n\t         * @abstract\n\t         * @param {number} dataIndex\n\t         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n\t         */\n\t        getTooltipPosition: null\n\t    });\n\t\n\t    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n\t    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\t\n\t    module.exports = SeriesModel;\n\n\n/***/ },\n/* 16 */\n/*!***************************************!*\\\n  !*** ./~/zrender/lib/contain/text.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t    var TEXT_CACHE_MAX = 5000;\n\t\n\t    var util = __webpack_require__(/*! ../core/util */ 1);\n\t    var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ 8);\n\t    var retrieve = util.retrieve;\n\t\n\t    function getTextWidth(text, textFont) {\n\t        var key = text + ':' + textFont;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // measureText  Canvas \n\t            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n\t        }\n\t\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t\n\t        return width;\n\t    }\n\t\n\t    function getTextRect(text, textFont, textAlign, textBaseline) {\n\t        var textLineLen = ((text || '') + '').split('\\n').length;\n\t\n\t        var width = getTextWidth(text, textFont);\n\t        // FIXME \n\t        var lineHeight = getTextWidth('', textFont);\n\t        var height = textLineLen * lineHeight;\n\t\n\t        var rect = new BoundingRect(0, 0, width, height);\n\t        // Text has a special line height property\n\t        rect.lineHeight = lineHeight;\n\t\n\t        switch (textBaseline) {\n\t            case 'bottom':\n\t            case 'alphabetic':\n\t                rect.y -= lineHeight;\n\t                break;\n\t            case 'middle':\n\t                rect.y -= lineHeight / 2;\n\t                break;\n\t            // case 'hanging':\n\t            // case 'top':\n\t        }\n\t\n\t        // FIXME Right to left language\n\t        switch (textAlign) {\n\t            case 'end':\n\t            case 'right':\n\t                rect.x -= rect.width;\n\t                break;\n\t            case 'center':\n\t                rect.x -= rect.width / 2;\n\t                break;\n\t            // case 'start':\n\t            // case 'left':\n\t        }\n\t\n\t        return rect;\n\t    }\n\t\n\t    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\t\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t\n\t        var textHeight = textRect.height;\n\t\n\t        var halfHeight = height / 2 - textHeight / 2;\n\t\n\t        var textAlign = 'left';\n\t\n\t        switch (textPosition) {\n\t            case 'left':\n\t                x -= distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'right':\n\t                x += distance + width;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'top':\n\t                x += width / 2;\n\t                y -= distance + textHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'bottom':\n\t                x += width / 2;\n\t                y += height + distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'inside':\n\t                x += width / 2;\n\t                y += halfHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideLeft':\n\t                x += distance;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideRight':\n\t                x += width - distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideTop':\n\t                x += width / 2;\n\t                y += distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideBottom':\n\t                x += width / 2;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideTopLeft':\n\t                x += distance;\n\t                y += distance;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideTopRight':\n\t                x += width - distance;\n\t                y += distance;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideBottomLeft':\n\t                x += distance;\n\t                y += height - textHeight - distance;\n\t                break;\n\t            case 'insideBottomRight':\n\t                x += width - distance;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'right';\n\t                break;\n\t        }\n\t\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textBaseline: 'top'\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @param  {string} text\n\t     * @param  {string} containerWidth\n\t     * @param  {string} textFont\n\t     * @param  {number} [ellipsis='...']\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minChar=0] If truncate result are less\n\t     *                  then minChar, ellipsis will not show, which is\n\t     *                  better for user hint in some cases.\n\t     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t     * @return {string}\n\t     */\n\t    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t\n\t        options = options || {};\n\t\n\t        ellipsis = retrieve(ellipsis, '...');\n\t        var maxIterations = retrieve(options.maxIterations, 2);\n\t        var minChar = retrieve(options.minChar, 0);\n\t        // FIXME\n\t        // Other languages?\n\t        var cnCharWidth = getTextWidth('', textFont);\n\t        // FIXME\n\t        // Consider proportional font?\n\t        var ascCharWidth = getTextWidth('a', textFont);\n\t        var placeholder = retrieve(options.placeholder, '');\n\t\n\t        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n\t        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\t        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t            contentWidth -= ascCharWidth;\n\t        }\n\t\n\t        var ellipsisWidth = getTextWidth(ellipsis);\n\t        if (ellipsisWidth > contentWidth) {\n\t            ellipsis = '';\n\t            ellipsisWidth = 0;\n\t        }\n\t\n\t        contentWidth = containerWidth - ellipsisWidth;\n\t\n\t        var textLines = (text + '').split('\\n');\n\t\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            var textLine = textLines[i];\n\t            var lineWidth = getTextWidth(textLine, textFont);\n\t\n\t            if (lineWidth <= containerWidth) {\n\t                continue;\n\t            }\n\t\n\t            for (var j = 0;; j++) {\n\t                if (lineWidth <= contentWidth || j >= maxIterations) {\n\t                    textLine += ellipsis;\n\t                    break;\n\t                }\n\t\n\t                var subLength = j === 0\n\t                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n\t                    : lineWidth > 0\n\t                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n\t                    : 0;\n\t\n\t                textLine = textLine.substr(0, subLength);\n\t                lineWidth = getTextWidth(textLine, textFont);\n\t            }\n\t\n\t            if (textLine === '') {\n\t                textLine = placeholder;\n\t            }\n\t\n\t            textLines[i] = textLine;\n\t        }\n\t\n\t        return textLines.join('\\n');\n\t    }\n\t\n\t    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < contentWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t\n\t    var textContain = {\n\t\n\t        getWidth: getTextWidth,\n\t\n\t        getBoundingRect: getTextRect,\n\t\n\t        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t\n\t        truncateText: truncateText,\n\t\n\t        measureText: function (text, textFont) {\n\t            var ctx = util.getContext();\n\t            ctx.font = textFont || '12px sans-serif';\n\t            return ctx.measureText(text);\n\t        }\n\t    };\n\t\n\t    module.exports = textContain;\n\n\n/***/ },\n/* 17 */\n/*!*************************************!*\\\n  !*** ./~/zrender/lib/core/curve.js ***!\n  \\*************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(/*! ./vector */ 5);\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t\n\t    var EPSILON = 1e-8;\n\t    var EPSILON_NUMERIC = 1e-4;\n\t\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t\n\t    // \n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1)\n\t             + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (\n\t            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n\t            + (p3 - p2) * t * t\n\t        );\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} \n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1  - p0);\n\t        var d = p0 - val;\n\t\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t\n\t        var n = 0;\n\t\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            }\n\t            else {\n\t                var t1 = -c / b;  //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = B * B - 4 * A * C;\n\t\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;  // t1, a is not zero\n\t                var t2 = -K / 2;  // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} \n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <=1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * \n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] \n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(\n\t        x0, y0, x1, y1, x2, y2, x3, y3,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        //  t \n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t\n\t            d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} \n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        }\n\t        else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * \n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out \n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(\n\t        x0, y0, x1, y1, x2, y2,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        //  t \n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        cubicAt: cubicAt,\n\t\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t\n\t        cubicRootAt: cubicRootAt,\n\t\n\t        cubicExtrema: cubicExtrema,\n\t\n\t        cubicSubdivide: cubicSubdivide,\n\t\n\t        cubicProjectPoint: cubicProjectPoint,\n\t\n\t        quadraticAt: quadraticAt,\n\t\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t\n\t        quadraticRootAt: quadraticRootAt,\n\t\n\t        quadraticExtremum: quadraticExtremum,\n\t\n\t        quadraticSubdivide: quadraticSubdivide,\n\t\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\n\n/***/ },\n/* 18 */\n/*!*************************************!*\\\n  !*** ./~/zrender/lib/tool/color.js ***!\n  \\*************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/tool/color\n\t */\n\t\n\t\n\t    var kCSSColorTable = {\n\t        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n\t        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n\t        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n\t        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n\t        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n\t        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n\t        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n\t        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n\t        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n\t        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n\t        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n\t        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n\t        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n\t        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n\t        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n\t        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n\t        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n\t        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n\t        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n\t        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n\t        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n\t        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n\t        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n\t        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n\t        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n\t        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n\t        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n\t        'gray': [128,128,128,1], 'green': [0,128,0,1],\n\t        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n\t        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n\t        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n\t        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n\t        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n\t        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n\t        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n\t        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n\t        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n\t        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n\t        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n\t        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n\t        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n\t        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n\t        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n\t        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n\t        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n\t        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n\t        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n\t        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n\t        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n\t        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n\t        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n\t        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n\t        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n\t        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n\t        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n\t        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n\t        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n\t        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n\t        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n\t        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n\t        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n\t        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n\t        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n\t        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n\t        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n\t        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n\t        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n\t        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n\t        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n\t        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n\t        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n\t        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n\t        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n\t        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n\t    };\n\t\n\t    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t\n\t    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t\n\t    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t\n\t    function parseCssInt(str) {  // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t\n\t    function parseCssFloat(str) {  // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        }\n\t        else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2/3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t\n\t    function lerp(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t\n\t    /**\n\t     * @param {string} colorStr\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            return kCSSColorTable[str].slice();  // dup.\n\t        }\n\t\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xfff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n\t                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n\t                    (iv & 0xf) | ((iv & 0xf) << 4),\n\t                    1\n\t                ];\n\t            }\n\t            else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xffffff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 0xff0000) >> 16,\n\t                    (iv & 0xff00) >> 8,\n\t                    iv & 0xff,\n\t                    1\n\t                ];\n\t            }\n\t\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;  // To allow case fallthrough.\n\t            switch (fname) {\n\t                case 'rgba':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n\t                // Fall through.\n\t                case 'rgb':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return [\n\t                        parseCssInt(params[0]),\n\t                        parseCssInt(params[1]),\n\t                        parseCssInt(params[2]),\n\t                        alpha\n\t                    ];\n\t                case 'hsla':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    params[3] = parseCssFloat(params[3]);\n\t                    return hsla2rgba(params);\n\t                case 'hsl':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return hsla2rgba(params);\n\t                default:\n\t                    return;\n\t            }\n\t        }\n\t\n\t        return;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla) {\n\t        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t\n\t        var rgba = [\n\t            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n\t        ];\n\t\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t\n\t        return rgba;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t\n\t        var vMin = Math.min(R, G, B); // Min. value of RGB\n\t        var vMax = Math.max(R, G, B); // Max. value of RGB\n\t        var delta = vMax - vMin; // Delta RGB value\n\t\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        }\n\t        else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            }\n\t            else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t\n\t            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n\t            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n\t            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\t\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            }\n\t            else if (G === vMax) {\n\t                H = (1 / 3) + deltaR - deltaB;\n\t            }\n\t            else if (B === vMax) {\n\t                H = (2 / 3) + deltaG - deltaR;\n\t            }\n\t\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t\n\t        var hsla = [H * 360, S, L];\n\t\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t\n\t        return hsla;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                }\n\t                else {\n\t                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>}\n\t     */\n\t    function fastMapToColor(normalizedValue, colors, out) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t        out = out || [0, 0, 0, 0];\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n\t        return out;\n\t    }\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapToColor(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t\n\t        var color = stringify(\n\t            [\n\t                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n\t            ],\n\t            'rgba'\n\t        );\n\t\n\t        return fullOutput\n\t            ? {\n\t                color: color,\n\t                leftIndex: leftIndex,\n\t                rightIndex: rightIndex,\n\t                value: value\n\t            }\n\t            : color;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color.\n\t     */\n\t    function stringify(arrColor, type) {\n\t        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t            colorStr += ',' + arrColor[3];\n\t        }\n\t        return type + '(' + colorStr + ')';\n\t    }\n\t\n\t    module.exports = {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastMapToColor: fastMapToColor,\n\t        mapToColor: mapToColor,\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t\n\t\n\n\n/***/ },\n/* 19 */\n/*!**************************************!*\\\n  !*** ./~/zrender/lib/core/matrix.js ***!\n  \\**************************************/\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t    /**\n\t     * 3x2\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t        /**\n\t         * \n\t         * @return {Float32Array|Array.<number>}\n\t         */\n\t        create : function() {\n\t            var out = new ArrayCtor(6);\n\t            matrix.identity(out);\n\t\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         */\n\t        identity : function(out) {\n\t            out[0] = 1;\n\t            out[1] = 0;\n\t            out[2] = 0;\n\t            out[3] = 1;\n\t            out[4] = 0;\n\t            out[5] = 0;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m\n\t         */\n\t        copy: function(out, m) {\n\t            out[0] = m[0];\n\t            out[1] = m[1];\n\t            out[2] = m[2];\n\t            out[3] = m[3];\n\t            out[4] = m[4];\n\t            out[5] = m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m1\n\t         * @param {Float32Array|Array.<number>} m2\n\t         */\n\t        mul : function (out, m1, m2) {\n\t            // Consider matrix.mul(m, m2, m);\n\t            // where out is the same as m2.\n\t            // So use temp variable to escape error.\n\t            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t            out[0] = out0;\n\t            out[1] = out1;\n\t            out[2] = out2;\n\t            out[3] = out3;\n\t            out[4] = out4;\n\t            out[5] = out5;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        translate : function(out, a, v) {\n\t            out[0] = a[0];\n\t            out[1] = a[1];\n\t            out[2] = a[2];\n\t            out[3] = a[3];\n\t            out[4] = a[4] + v[0];\n\t            out[5] = a[5] + v[1];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {number} rad\n\t         */\n\t        rotate : function(out, a, rad) {\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t            var st = Math.sin(rad);\n\t            var ct = Math.cos(rad);\n\t\n\t            out[0] = aa * ct + ab * st;\n\t            out[1] = -aa * st + ab * ct;\n\t            out[2] = ac * ct + ad * st;\n\t            out[3] = -ac * st + ct * ad;\n\t            out[4] = ct * atx + st * aty;\n\t            out[5] = ct * aty - st * atx;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        scale : function(out, a, v) {\n\t            var vx = v[0];\n\t            var vy = v[1];\n\t            out[0] = a[0] * vx;\n\t            out[1] = a[1] * vy;\n\t            out[2] = a[2] * vx;\n\t            out[3] = a[3] * vy;\n\t            out[4] = a[4] * vx;\n\t            out[5] = a[5] * vy;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         */\n\t        invert : function(out, a) {\n\t\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t\n\t            var det = aa * ad - ab * ac;\n\t            if (!det) {\n\t                return null;\n\t            }\n\t            det = 1.0 / det;\n\t\n\t            out[0] = ad * det;\n\t            out[1] = -ab * det;\n\t            out[2] = -ac * det;\n\t            out[3] = aa * det;\n\t            out[4] = (ac * aty - ad * atx) * det;\n\t            out[5] = (ab * atx - aa * aty) * det;\n\t            return out;\n\t        }\n\t    };\n\t\n\t    module.exports = matrix;\n\t\n\n\n/***/ },\n/* 20 */\n/*!*****************************************!*\\\n  !*** ./~/zrender/lib/mixin/Eventful.js ***!\n  \\*****************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * \n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var arrySlice = Array.prototype.slice;\n\t\n\t    /**\n\t     * \n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t\n\t    Eventful.prototype = {\n\t\n\t        constructor: Eventful,\n\t\n\t        /**\n\t         * trigger\n\t         *\n\t         * @param {string} event \n\t         * @param {Function} handler \n\t         * @param {Object} context\n\t         */\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {string} event \n\t         * @param {Function} handler \n\t         * @param {Object} [context]\n\t         */\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {string}  event\n\t         * @return {boolean}\n\t         */\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {string} event \n\t         * @param {Function} [handler] \n\t         */\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            }\n\t            else {\n\t                delete _h[event];\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         *\n\t         * @param {string} type \n\t         */\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(_h[i]['ctx']);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * context, context\n\t         * @param {string} type \n\t         */\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(ctx);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(ctx, args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(ctx, args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(ctx, args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    //  onxxxx \n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrag\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t\n\t    module.exports = Eventful;\n\t\n\n\n/***/ },\n/* 21 */\n/*!***************************!*\\\n  !*** ./lib/util/clazz.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var clazz = {};\n\t\n\t    var TYPE_DELIMITER = '.';\n\t    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n\t    /**\n\t     * @public\n\t     */\n\t    var parseClassType = clazz.parseClassType = function (componentType) {\n\t        var ret = {main: '', sub: ''};\n\t        if (componentType) {\n\t            componentType = componentType.split(TYPE_DELIMITER);\n\t            ret.main = componentType[0] || '';\n\t            ret.sub = componentType[1] || '';\n\t        }\n\t        return ret;\n\t    };\n\t    /**\n\t     * @public\n\t     */\n\t    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\t\n\t        RootClass.$constructor = RootClass;\n\t        RootClass.extend = function (proto) {\n\t\n\t            if (false) {\n\t                zrUtil.each(mandatoryMethods, function (method) {\n\t                    if (!proto[method]) {\n\t                        console.warn(\n\t                            'Method `' + method + '` should be implemented'\n\t                            + (proto.type ? ' in ' + proto.type : '') + '.'\n\t                        );\n\t                    }\n\t                });\n\t            }\n\t\n\t            var superClass = this;\n\t            var ExtendedClass = function () {\n\t                if (!proto.$constructor) {\n\t                    superClass.apply(this, arguments);\n\t                }\n\t                else {\n\t                    proto.$constructor.apply(this, arguments);\n\t                }\n\t            };\n\t\n\t            zrUtil.extend(ExtendedClass.prototype, proto);\n\t\n\t            ExtendedClass.extend = this.extend;\n\t            ExtendedClass.superCall = superCall;\n\t            ExtendedClass.superApply = superApply;\n\t            zrUtil.inherits(ExtendedClass, this);\n\t            ExtendedClass.superClass = superClass;\n\t\n\t            return ExtendedClass;\n\t        };\n\t    };\n\t\n\t    // superCall should have class info, which can not be fetch from 'this'.\n\t    // Consider this case:\n\t    // class A has method f,\n\t    // class B inherits class A, overrides method f, f call superApply('f'),\n\t    // class C inherits class B, do not overrides method f,\n\t    // then when method of class C is called, dead loop occured.\n\t    function superCall(context, methodName) {\n\t        var args = zrUtil.slice(arguments, 2);\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t\n\t    function superApply(context, methodName, args) {\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t\n\t    /**\n\t     * @param {Object} entity\n\t     * @param {Object} options\n\t     * @param {boolean} [options.registerWhenExtend]\n\t     * @public\n\t     */\n\t    clazz.enableClassManagement = function (entity, options) {\n\t        options = options || {};\n\t\n\t        /**\n\t         * Component model classes\n\t         * key: componentType,\n\t         * value:\n\t         *     componentClass, when componentType is 'xxx'\n\t         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n\t         * @type {Object}\n\t         */\n\t        var storage = {};\n\t\n\t        entity.registerClass = function (Clazz, componentType) {\n\t            if (componentType) {\n\t                componentType = parseClassType(componentType);\n\t\n\t                if (!componentType.sub) {\n\t                    if (false) {\n\t                        if (storage[componentType.main]) {\n\t                            console.warn(componentType.main + ' exists.');\n\t                        }\n\t                    }\n\t                    storage[componentType.main] = Clazz;\n\t                }\n\t                else if (componentType.sub !== IS_CONTAINER) {\n\t                    var container = makeContainer(componentType);\n\t                    container[componentType.sub] = Clazz;\n\t                }\n\t            }\n\t            return Clazz;\n\t        };\n\t\n\t        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\n\t            var Clazz = storage[componentTypeMain];\n\t\n\t            if (Clazz && Clazz[IS_CONTAINER]) {\n\t                Clazz = subType ? Clazz[subType] : null;\n\t            }\n\t\n\t            if (throwWhenNotFound && !Clazz) {\n\t                throw new Error(\n\t                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\n\t                );\n\t            }\n\t\n\t            return Clazz;\n\t        };\n\t\n\t        entity.getClassesByMainType = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t\n\t            var result = [];\n\t            var obj = storage[componentType.main];\n\t\n\t            if (obj && obj[IS_CONTAINER]) {\n\t                zrUtil.each(obj, function (o, type) {\n\t                    type !== IS_CONTAINER && result.push(o);\n\t                });\n\t            }\n\t            else {\n\t                result.push(obj);\n\t            }\n\t\n\t            return result;\n\t        };\n\t\n\t        entity.hasClass = function (componentType) {\n\t            // Just consider componentType.main.\n\t            componentType = parseClassType(componentType);\n\t            return !!storage[componentType.main];\n\t        };\n\t\n\t        /**\n\t         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n\t         */\n\t        entity.getAllClassMainTypes = function () {\n\t            var types = [];\n\t            zrUtil.each(storage, function (obj, type) {\n\t                types.push(type);\n\t            });\n\t            return types;\n\t        };\n\t\n\t        /**\n\t         * If a main type is container and has sub types\n\t         * @param  {string}  mainType\n\t         * @return {boolean}\n\t         */\n\t        entity.hasSubTypes = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t            var obj = storage[componentType.main];\n\t            return obj && obj[IS_CONTAINER];\n\t        };\n\t\n\t        entity.parseClassType = parseClassType;\n\t\n\t        function makeContainer(componentType) {\n\t            var container = storage[componentType.main];\n\t            if (!container || !container[IS_CONTAINER]) {\n\t                container = storage[componentType.main] = {};\n\t                container[IS_CONTAINER] = true;\n\t            }\n\t            return container;\n\t        }\n\t\n\t        if (options.registerWhenExtend) {\n\t            var originalExtend = entity.extend;\n\t            if (originalExtend) {\n\t                entity.extend = function (proto) {\n\t                    var ExtendedClass = originalExtend.call(this, proto);\n\t                    return entity.registerClass(ExtendedClass, proto.type);\n\t                };\n\t            }\n\t        }\n\t\n\t        return entity;\n\t    };\n\t\n\t    /**\n\t     * @param {string|Array.<string>} properties\n\t     */\n\t    clazz.setReadOnly = function (obj, properties) {\n\t        // FIXME It seems broken in IE8 simulation of IE11\n\t        // if (!zrUtil.isArray(properties)) {\n\t        //     properties = properties != null ? [properties] : [];\n\t        // }\n\t        // zrUtil.each(properties, function (prop) {\n\t        //     var value = obj[prop];\n\t\n\t        //     Object.defineProperty\n\t        //         && Object.defineProperty(obj, prop, {\n\t        //             value: value, writable: false\n\t        //         });\n\t        //     zrUtil.isArray(obj[prop])\n\t        //         && Object.freeze\n\t        //         && Object.freeze(obj[prop]);\n\t        // });\n\t    };\n\t\n\t    module.exports = clazz;\n\n\n/***/ },\n/* 22 */\n/*!*********************************!*\\\n  !*** ./lib/coord/axisHelper.js ***!\n  \\*********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var OrdinalScale = __webpack_require__(/*! ../scale/Ordinal */ 136);\n\t    var IntervalScale = __webpack_require__(/*! ../scale/Interval */ 38);\n\t    __webpack_require__(/*! ../scale/Time */ 137);\n\t    __webpack_require__(/*! ../scale/Log */ 135);\n\t    var Scale = __webpack_require__(/*! ../scale/Scale */ 32);\n\t\n\t    var numberUtil = __webpack_require__(/*! ../util/number */ 4);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 16);\n\t    var axisHelper = {};\n\t\n\t    /**\n\t     * Get axis scale extent before niced.\n\t     */\n\t    axisHelper.getScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var originalExtent = scale.getExtent();\n\t        var span = originalExtent[1] - originalExtent[0];\n\t        if (scale.type === 'ordinal') {\n\t            // If series has no data, scale extent may be wrong\n\t            if (!isFinite(span)) {\n\t                return [0, 0];\n\t            }\n\t            else {\n\t                return originalExtent;\n\t            }\n\t        }\n\t        var min = model.getMin ? model.getMin() : model.get('min');\n\t        var max = model.getMax ? model.getMax() : model.get('max');\n\t        var crossZero = model.getNeedCrossZero\n\t            ? model.getNeedCrossZero() : !model.get('scale');\n\t        var boundaryGap = model.get('boundaryGap');\n\t        if (!zrUtil.isArray(boundaryGap)) {\n\t            boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n\t        }\n\t        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n\t        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n\t        var fixMin = true;\n\t        var fixMax = true;\n\t        // Add boundary gap\n\t        if (min == null) {\n\t            min = originalExtent[0] - boundaryGap[0] * span;\n\t            fixMin = false;\n\t        }\n\t        if (max == null) {\n\t            max = originalExtent[1] + boundaryGap[1] * span;\n\t            fixMax = false;\n\t        }\n\t        if (min === 'dataMin') {\n\t            min = originalExtent[0];\n\t        }\n\t        if (max === 'dataMax') {\n\t            max = originalExtent[1];\n\t        }\n\t        // Evaluate if axis needs cross zero\n\t        if (crossZero) {\n\t            // Axis is over zero and min is not set\n\t            if (min > 0 && max > 0 && !fixMin) {\n\t                min = 0;\n\t            }\n\t            // Axis is under zero and max is not set\n\t            if (min < 0 && max < 0 && !fixMax) {\n\t                max = 0;\n\t            }\n\t        }\n\t        return [min, max];\n\t    };\n\t\n\t    axisHelper.niceScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var extent = axisHelper.getScaleExtent(axis, model);\n\t        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;\n\t        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;\n\t        var splitNumber = model.get('splitNumber');\n\t\n\t        if (scale.type === 'log') {\n\t            scale.base = model.get('logBase');\n\t        }\n\t\n\t        scale.setExtent(extent[0], extent[1]);\n\t        scale.niceExtent(splitNumber, fixMin, fixMax);\n\t\n\t        // Use minInterval to constraint the calculated interval.\n\t        // If calculated interval is less than minInterval. increase the interval quantity until\n\t        // it is larger than minInterval.\n\t        // For example:\n\t        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n\t        //  an integer axis.\n\t        var minInterval = model.get('minInterval');\n\t        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n\t            var interval = scale.getInterval();\n\t            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n\t            // while (interval < minInterval) {\n\t            //     var quantity = numberUtil.quantity(interval);\n\t            //     interval = quantity * 10;\n\t            //     scaleQuantity *= 10;\n\t            // }\n\t            extent = scale.getExtent();\n\t            var origin = (extent[1] + extent[0]) / 2;\n\t            scale.setExtent(\n\t                intervalScale * (extent[0] - origin) + origin,\n\t                intervalScale * (extent[1] - origin) + origin\n\t            );\n\t            scale.niceExtent(splitNumber);\n\t        }\n\t\n\t        // If some one specified the min, max. And the default calculated interval\n\t        // is not good enough. He can specify the interval. It is often appeared\n\t        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n\t        // to be 60.\n\t        // FIXME\n\t        var interval = model.get('interval');\n\t        if (interval != null) {\n\t            scale.setInterval && scale.setInterval(interval);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {module:echarts/model/Model} model\n\t     * @param {string} [axisType] Default retrieve from model.type\n\t     * @return {module:echarts/scale/*}\n\t     */\n\t    axisHelper.createScaleByModel = function(model, axisType) {\n\t        axisType = axisType || model.get('type');\n\t        if (axisType) {\n\t            switch (axisType) {\n\t                // Buildin scale\n\t                case 'category':\n\t                    return new OrdinalScale(\n\t                        model.getCategories(), [Infinity, -Infinity]\n\t                    );\n\t                case 'value':\n\t                    return new IntervalScale();\n\t                // Extended scale, like time and log\n\t                default:\n\t                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Check if the axis corss 0\n\t     */\n\t    axisHelper.ifAxisCrossZero = function (axis) {\n\t        var dataExtent = axis.scale.getExtent();\n\t        var min = dataExtent[0];\n\t        var max = dataExtent[1];\n\t        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n\t    };\n\t\n\t    /**\n\t     * @param {Array.<number>} tickCoords In axis self coordinate.\n\t     * @param {Array.<string>} labels\n\t     * @param {string} font\n\t     * @param {boolean} isAxisHorizontal\n\t     * @return {number}\n\t     */\n\t    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n\t        // FIXME\n\t        // axislabelhorizontalvertical.\n\t\n\t        var textSpaceTakenRect;\n\t        var autoLabelInterval = 0;\n\t        var accumulatedLabelInterval = 0;\n\t\n\t        var step = 1;\n\t        if (labels.length > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.floor(labels.length / 40);\n\t        }\n\t\n\t        for (var i = 0; i < tickCoords.length; i += step) {\n\t            var tickCoord = tickCoords[i];\n\t            var rect = textContain.getBoundingRect(\n\t                labels[i], font, 'center', 'top'\n\t            );\n\t            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n\t            // FIXME Magic number 1.5\n\t            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n\t            if (!textSpaceTakenRect) {\n\t                textSpaceTakenRect = rect.clone();\n\t            }\n\t            // There is no space for current label;\n\t            else if (textSpaceTakenRect.intersect(rect)) {\n\t                accumulatedLabelInterval++;\n\t                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n\t            }\n\t            else {\n\t                textSpaceTakenRect.union(rect);\n\t                // Reset\n\t                accumulatedLabelInterval = 0;\n\t            }\n\t        }\n\t        if (autoLabelInterval === 0 && step > 1) {\n\t            return step;\n\t        }\n\t        return (autoLabelInterval + 1) * step - 1;\n\t    };\n\t\n\t    /**\n\t     * @param {Object} axis\n\t     * @param {Function} labelFormatter\n\t     * @return {Array.<string>}\n\t     */\n\t    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n\t        var scale = axis.scale;\n\t        var labels = scale.getTicksLabels();\n\t        var ticks = scale.getTicks();\n\t        if (typeof labelFormatter === 'string') {\n\t            labelFormatter = (function (tpl) {\n\t                return function (val) {\n\t                    return tpl.replace('{value}', val);\n\t                };\n\t            })(labelFormatter);\n\t            return zrUtil.map(labels, labelFormatter);\n\t        }\n\t        else if (typeof labelFormatter === 'function') {\n\t            return zrUtil.map(ticks, function (tick, idx) {\n\t                return labelFormatter(\n\t                    axis.type === 'category' ? scale.getLabel(tick) : tick,\n\t                    idx\n\t                );\n\t            }, this);\n\t        }\n\t        else {\n\t            return labels;\n\t        }\n\t    };\n\t\n\t    module.exports = axisHelper;\n\n\n/***/ },\n/* 23 */\n/*!*********************************!*\\\n  !*** ./lib/CoordinateSystem.js ***!\n  \\*********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    /**\n\t     * Interface of Coordinate System Class\n\t     *\n\t     * create:\n\t     *     @param {module:echarts/model/Global} ecModel\n\t     *     @param {module:echarts/ExtensionAPI} api\n\t     *     @return {Object} coordinate system instance\n\t     *\n\t     * update:\n\t     *     @param {module:echarts/model/Global} ecModel\n\t     *     @param {module:echarts/ExtensionAPI} api\n\t     *\n\t     * convertToPixel:\n\t     * convertFromPixel:\n\t     *     These two methods is also responsible for determine whether this\n\t     *     coodinate system is applicable to the given `finder`.\n\t     *     Each coordinate system will be tried, util one returns none\n\t     *     null/undefined value.\n\t     *     @param {module:echarts/model/Global} ecModel\n\t     *     @param {Object} finder\n\t     *     @param {Array|number} value\n\t     *     @return {Array|number} convert result.\n\t     *\n\t     * containPoint:\n\t     *     @param {Array.<number>} point In pixel coordinate system.\n\t     *     @return {boolean}\n\t     */\n\t\n\t    var coordinateSystemCreators = {};\n\t\n\t    function CoordinateSystemManager() {\n\t\n\t        this._coordinateSystems = [];\n\t    }\n\t\n\t    CoordinateSystemManager.prototype = {\n\t\n\t        constructor: CoordinateSystemManager,\n\t\n\t        create: function (ecModel, api) {\n\t            var coordinateSystems = [];\n\t            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n\t                var list = creater.create(ecModel, api);\n\t                coordinateSystems = coordinateSystems.concat(list || []);\n\t            });\n\t\n\t            this._coordinateSystems = coordinateSystems;\n\t        },\n\t\n\t        update: function (ecModel, api) {\n\t            zrUtil.each(this._coordinateSystems, function (coordSys) {\n\t                // FIXME MUST have\n\t                coordSys.update && coordSys.update(ecModel, api);\n\t            });\n\t        },\n\t\n\t        getCoordinateSystems: function () {\n\t            return this._coordinateSystems.slice();\n\t        }\n\t    };\n\t\n\t    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n\t        coordinateSystemCreators[type] = coordinateSystemCreator;\n\t    };\n\t\n\t    CoordinateSystemManager.get = function (type) {\n\t        return coordinateSystemCreators[type];\n\t    };\n\t\n\t    module.exports = CoordinateSystemManager;\n\n\n/***/ },\n/* 24 */\n/*!*************************************!*\\\n  !*** ./~/zrender/lib/core/event.js ***!\n  \\*************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/core/event\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t */\n\t\n\t\n\t    var Eventful = __webpack_require__(/*! ../mixin/Eventful */ 20);\n\t    var env = __webpack_require__(/*! ./env */ 11);\n\t\n\t    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\t\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n\t    }\n\t\n\t    // `calculate` is optional, default false\n\t    function clientToLocal(el, e, out, calculate) {\n\t        out = out || {};\n\t\n\t        // According to the W3C Working Draft, offsetX and offsetY should be relative\n\t        // to the padding edge of the target element. The only browser using this convention\n\t        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n\t        // not support the properties.\n\t        // (see http://www.jacklmoore.com/notes/mouse-position/)\n\t        // In zr painter.dom, padding edge equals to border edge.\n\t\n\t        // FIXME\n\t        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n\t        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n\t        // is too complex. So css-transfrom dont support in this case temporarily.\n\t        if (calculate || !env.canvasSupported) {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n\t        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n\t        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n\t        // zoom-factor, overflow / opacity layers, transforms ...)\n\t        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n\t        // <https://bugs.jquery.com/ticket/8523#comment:14>\n\t        // BTW3, In ff, offsetX/offsetY is always 0.\n\t        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n\t            out.zrX = e.layerX;\n\t            out.zrY = e.layerY;\n\t        }\n\t        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n\t        else if (e.offsetX != null) {\n\t            out.zrX = e.offsetX;\n\t            out.zrY = e.offsetY;\n\t        }\n\t        // For some other device, e.g., IOS safari.\n\t        else {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t\n\t        return out;\n\t    }\n\t\n\t    function defaultGetZrXY(el, e, out) {\n\t        // This well-known method below does not support css transform.\n\t        var box = getBoundingClientRect(el);\n\t        out.zrX = e.clientX - box.left;\n\t        out.zrY = e.clientY - box.top;\n\t    }\n\t\n\t    /**\n\t     * domtouch.\n\t     * `calculate` is optional, default false.\n\t     */\n\t    function normalizeEvent(el, e, calculate) {\n\t\n\t        e = e || window.event;\n\t\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t        if (!isTouch) {\n\t            clientToLocal(el, e, e, calculate);\n\t            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        }\n\t        else {\n\t            var touch = eventType != 'touchend'\n\t                ? e.targetTouches[0]\n\t                : e.changedTouches[0];\n\t            touch && clientToLocal(el, touch, e, calculate);\n\t        }\n\t\n\t        return e;\n\t    }\n\t\n\t    function addEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.addEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.attachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    function removeEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.removeEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.detachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event\n\t     */\n\t    var stop = isDomLevel2\n\t        ? function (e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            e.cancelBubble = true;\n\t        }\n\t        : function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t\n\t    module.exports = {\n\t        clientToLocal: clientToLocal,\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t\n\t        stop: stop,\n\t        // \n\t        Dispatcher: Eventful\n\t    };\n\t\n\n\n/***/ },\n/* 25 */\n/*!*************************************************!*\\\n  !*** ./lib/component/toolbox/featureManager.js ***!\n  \\*************************************************/\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t\n\t    var features = {};\n\t\n\t    module.exports = {\n\t        register: function (name, ctor) {\n\t            features[name] = ctor;\n\t        },\n\t\n\t        get: function (name) {\n\t            return features[name];\n\t        }\n\t    };\n\n\n/***/ },\n/* 26 */\n/*!****************************!*\\\n  !*** ./lib/util/symbol.js ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Symbol factory\n\t\n\t\n\t    var graphic = __webpack_require__(/*! ./graphic */ 3);\n\t    var BoundingRect = __webpack_require__(/*! zrender/lib/core/BoundingRect */ 8);\n\t\n\t    /**\n\t     * Triangle shape\n\t     * @inner\n\t     */\n\t    var Triangle = graphic.extendShape({\n\t        type: 'triangle',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t        buildPath: function (path, shape) {\n\t            var cx = shape.cx;\n\t            var cy = shape.cy;\n\t            var width = shape.width / 2;\n\t            var height = shape.height / 2;\n\t            path.moveTo(cx, cy - height);\n\t            path.lineTo(cx + width, cy + height);\n\t            path.lineTo(cx - width, cy + height);\n\t            path.closePath();\n\t        }\n\t    });\n\t    /**\n\t     * Diamond shape\n\t     * @inner\n\t     */\n\t    var Diamond = graphic.extendShape({\n\t        type: 'diamond',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t        buildPath: function (path, shape) {\n\t            var cx = shape.cx;\n\t            var cy = shape.cy;\n\t            var width = shape.width / 2;\n\t            var height = shape.height / 2;\n\t            path.moveTo(cx, cy - height);\n\t            path.lineTo(cx + width, cy);\n\t            path.lineTo(cx, cy + height);\n\t            path.lineTo(cx - width, cy);\n\t            path.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Pin shape\n\t     * @inner\n\t     */\n\t    var Pin = graphic.extendShape({\n\t        type: 'pin',\n\t        shape: {\n\t            // x, y on the cusp\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (path, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var w = shape.width / 5 * 3;\n\t            // Height must be larger than width\n\t            var h = Math.max(w, shape.height);\n\t            var r = w / 2;\n\t\n\t            // Dist on y with tangent point and circle center\n\t            var dy = r * r / (h - r);\n\t            var cy = y - h + r + dy;\n\t            var angle = Math.asin(dy / r);\n\t            // Dist on x with tangent point and circle center\n\t            var dx = Math.cos(angle) * r;\n\t\n\t            var tanX = Math.sin(angle);\n\t            var tanY = Math.cos(angle);\n\t\n\t            path.arc(\n\t                x, cy, r,\n\t                Math.PI - angle,\n\t                Math.PI * 2 + angle\n\t            );\n\t\n\t            var cpLen = r * 0.6;\n\t            var cpLen2 = r * 0.7;\n\t            path.bezierCurveTo(\n\t                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n\t                x, y - cpLen2,\n\t                x, y\n\t            );\n\t            path.bezierCurveTo(\n\t                x, y - cpLen2,\n\t                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n\t                x - dx, cy + dy\n\t            );\n\t            path.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Arrow shape\n\t     * @inner\n\t     */\n\t    var Arrow = graphic.extendShape({\n\t\n\t        type: 'arrow',\n\t\n\t        shape: {\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var height = shape.height;\n\t            var width = shape.width;\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var dx = width / 3 * 2;\n\t            ctx.moveTo(x, y);\n\t            ctx.lineTo(x + dx, y + height);\n\t            ctx.lineTo(x, y + height / 4 * 3);\n\t            ctx.lineTo(x - dx, y + height);\n\t            ctx.lineTo(x, y);\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Map of path contructors\n\t     * @type {Object.<string, module:zrender/graphic/Path>}\n\t     */\n\t    var symbolCtors = {\n\t        line: graphic.Line,\n\t\n\t        rect: graphic.Rect,\n\t\n\t        roundRect: graphic.Rect,\n\t\n\t        square: graphic.Rect,\n\t\n\t        circle: graphic.Circle,\n\t\n\t        diamond: Diamond,\n\t\n\t        pin: Pin,\n\t\n\t        arrow: Arrow,\n\t\n\t        triangle: Triangle\n\t    };\n\t\n\t    var symbolShapeMakers = {\n\t\n\t        line: function (x, y, w, h, shape) {\n\t            // FIXME\n\t            shape.x1 = x;\n\t            shape.y1 = y + h / 2;\n\t            shape.x2 = x + w;\n\t            shape.y2 = y + h / 2;\n\t        },\n\t\n\t        rect: function (x, y, w, h, shape) {\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        roundRect: function (x, y, w, h, shape) {\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = w;\n\t            shape.height = h;\n\t            shape.r = Math.min(w, h) / 4;\n\t        },\n\t\n\t        square: function (x, y, w, h, shape) {\n\t            var size = Math.min(w, h);\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = size;\n\t            shape.height = size;\n\t        },\n\t\n\t        circle: function (x, y, w, h, shape) {\n\t            // Put circle in the center of square\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.r = Math.min(w, h) / 2;\n\t        },\n\t\n\t        diamond: function (x, y, w, h, shape) {\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        pin: function (x, y, w, h, shape) {\n\t            shape.x = x + w / 2;\n\t            shape.y = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        arrow: function (x, y, w, h, shape) {\n\t            shape.x = x + w / 2;\n\t            shape.y = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        triangle: function (x, y, w, h, shape) {\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        }\n\t    };\n\t\n\t    var symbolBuildProxies = {};\n\t    for (var name in symbolCtors) {\n\t        if (symbolCtors.hasOwnProperty(name)) {\n\t            symbolBuildProxies[name] = new symbolCtors[name]();\n\t        }\n\t    }\n\t\n\t    var Symbol = graphic.extendShape({\n\t\n\t        type: 'symbol',\n\t\n\t        shape: {\n\t            symbolType: '',\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        beforeBrush: function () {\n\t            var style = this.style;\n\t            var shape = this.shape;\n\t            // FIXME\n\t            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n\t                style.textPosition = ['50%', '40%'];\n\t                style.textAlign = 'center';\n\t                style.textVerticalAlign = 'middle';\n\t            }\n\t        },\n\t\n\t        buildPath: function (ctx, shape, inBundle) {\n\t            var symbolType = shape.symbolType;\n\t            var proxySymbol = symbolBuildProxies[symbolType];\n\t            if (shape.symbolType !== 'none') {\n\t                if (!proxySymbol) {\n\t                    // Default rect\n\t                    symbolType = 'rect';\n\t                    proxySymbol = symbolBuildProxies[symbolType];\n\t                }\n\t                symbolShapeMakers[symbolType](\n\t                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n\t                );\n\t                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n\t            }\n\t        }\n\t    });\n\t\n\t    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n\t    var symbolPathSetColor = function (color) {\n\t        if (this.type !== 'image') {\n\t            var symbolStyle = this.style;\n\t            var symbolShape = this.shape;\n\t            if (symbolShape && symbolShape.symbolType === 'line') {\n\t                symbolStyle.stroke = color;\n\t            }\n\t            else if (this.__isEmptyBrush) {\n\t                symbolStyle.stroke = color;\n\t                symbolStyle.fill = '#fff';\n\t            }\n\t            else {\n\t                // FIXME  onlyStroke ?\n\t                symbolStyle.fill && (symbolStyle.fill = color);\n\t                symbolStyle.stroke && (symbolStyle.stroke = color);\n\t            }\n\t            this.dirty(false);\n\t        }\n\t    };\n\t\n\t    var symbolUtil = {\n\t        /**\n\t         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n\t         * @param {string} symbolType\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {number} w\n\t         * @param {number} h\n\t         * @param {string} color\n\t         */\n\t        createSymbol: function (symbolType, x, y, w, h, color) {\n\t            var isEmpty = symbolType.indexOf('empty') === 0;\n\t            if (isEmpty) {\n\t                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n\t            }\n\t            var symbolPath;\n\t\n\t            if (symbolType.indexOf('image://') === 0) {\n\t                symbolPath = new graphic.Image({\n\t                    style: {\n\t                        image: symbolType.slice(8),\n\t                        x: x,\n\t                        y: y,\n\t                        width: w,\n\t                        height: h\n\t                    }\n\t                });\n\t            }\n\t            else if (symbolType.indexOf('path://') === 0) {\n\t                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n\t            }\n\t            else {\n\t                symbolPath = new Symbol({\n\t                    shape: {\n\t                        symbolType: symbolType,\n\t                        x: x,\n\t                        y: y,\n\t                        width: w,\n\t                        height: h\n\t                    }\n\t                });\n\t            }\n\t\n\t            symbolPath.__isEmptyBrush = isEmpty;\n\t\n\t            symbolPath.setColor = symbolPathSetColor;\n\t\n\t            symbolPath.setColor(color);\n\t\n\t            return symbolPath;\n\t        }\n\t    };\n\t\n\t    module.exports = symbolUtil;\n\n\n/***/ },\n/* 27 */\n/*!***************************!*\\\n  !*** ./lib/view/Chart.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Group = __webpack_require__(/*! zrender/lib/container/Group */ 34);\n\t    var componentUtil = __webpack_require__(/*! ../util/component */ 43);\n\t    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 21);\n\t    var modelUtil = __webpack_require__(/*! ../util/model */ 7);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    function Chart() {\n\t\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewChart');\n\t    }\n\t\n\t    Chart.prototype = {\n\t\n\t        type: 'chart',\n\t\n\t        /**\n\t         * Init the chart\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         */\n\t        init: function (ecModel, api) {},\n\t\n\t        /**\n\t         * Render the chart\n\t         * @param  {module:echarts/model/Series} seriesModel\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         * @param  {Object} payload\n\t         */\n\t        render: function (seriesModel, ecModel, api, payload) {},\n\t\n\t        /**\n\t         * Highlight series or specified data item\n\t         * @param  {module:echarts/model/Series} seriesModel\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         * @param  {Object} payload\n\t         */\n\t        highlight: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n\t        },\n\t\n\t        /**\n\t         * Downplay series or specified data item\n\t         * @param  {module:echarts/model/Series} seriesModel\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         * @param  {Object} payload\n\t         */\n\t        downplay: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'normal');\n\t        },\n\t\n\t        /**\n\t         * Remove self\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         */\n\t        remove: function (ecModel, api) {\n\t            this.group.removeAll();\n\t        },\n\t\n\t        /**\n\t         * Dispose self\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         */\n\t        dispose: function () {}\n\t\n\t        /**\n\t         * The view contains the given point.\n\t         * @interface\n\t         * @param {Array.<number>} point\n\t         * @return {boolean}\n\t         */\n\t        // containPoint: function () {}\n\t\n\t    };\n\t\n\t    var chartProto = Chart.prototype;\n\t    chartProto.updateView\n\t        = chartProto.updateLayout\n\t        = chartProto.updateVisual\n\t        = function (seriesModel, ecModel, api, payload) {\n\t            this.render(seriesModel, ecModel, api, payload);\n\t        };\n\t\n\t    /**\n\t     * Set state of single element\n\t     * @param  {module:zrender/Element} el\n\t     * @param  {string} state\n\t     */\n\t    function elSetState(el, state) {\n\t        if (el) {\n\t            el.trigger(state);\n\t            if (el.type === 'group') {\n\t                for (var i = 0; i < el.childCount(); i++) {\n\t                    elSetState(el.childAt(i), state);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @param  {module:echarts/data/List} data\n\t     * @param  {Object} payload\n\t     * @param  {string} state 'normal'|'emphasis'\n\t     * @inner\n\t     */\n\t    function toggleHighlight(data, payload, state) {\n\t        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\t\n\t        if (dataIndex != null) {\n\t            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n\t                elSetState(data.getItemGraphicEl(dataIdx), state);\n\t            });\n\t        }\n\t        else {\n\t            data.eachItemGraphicEl(function (el) {\n\t                elSetState(el, state);\n\t            });\n\t        }\n\t    }\n\t\n\t    // Enable Chart.extend.\n\t    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\t\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\t\n\t    module.exports = Chart;\n\n\n/***/ },\n/* 28 */\n/*!*****************************************!*\\\n  !*** ./~/zrender/lib/core/PathProxy.js ***!\n  \\*****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Path `buildPath``ctx`, pathpathCommands\n\t *  isInsidePath boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t\n\t // TODO getTotalLength, getPointAtLength\n\t\n\t\n\t    var curve = __webpack_require__(/*! ./curve */ 17);\n\t    var vec2 = __webpack_require__(/*! ./vector */ 5);\n\t    var bbox = __webpack_require__(/*! ./bbox */ 73);\n\t    var BoundingRect = __webpack_require__(/*! ./BoundingRect */ 8);\n\t    var dpr = __webpack_require__(/*! ../config */ 33).devicePixelRatio;\n\t\n\t    var CMD = {\n\t        M: 1,\n\t        L: 2,\n\t        C: 3,\n\t        Q: 4,\n\t        A: 5,\n\t        Z: 6,\n\t        // Rect\n\t        R: 7\n\t    };\n\t\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAbs = Math.abs;\n\t\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function () {\n\t\n\t        /**\n\t         * Path data. Stored as flat array\n\t         * @type {Array.<Object>}\n\t         */\n\t        this.data = [];\n\t\n\t        this._len = 0;\n\t\n\t        this._ctx = null;\n\t\n\t        this._xi = 0;\n\t        this._yi = 0;\n\t\n\t        this._x0 = 0;\n\t        this._y0 = 0;\n\t\n\t        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t        this._ux = 0;\n\t        this._uy = 0;\n\t    };\n\t\n\t    /**\n\t     * Path\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t\n\t        constructor: PathProxy,\n\t\n\t        _lineDash: null,\n\t\n\t        _dashOffset: 0,\n\t\n\t        _dashIdx: 0,\n\t\n\t        _dashSum: 0,\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        setScale: function (sx, sy) {\n\t            this._ux = mathAbs(1 / dpr / sx) || 0;\n\t            this._uy = mathAbs(1 / dpr / sy) || 0;\n\t        },\n\t\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t\n\t        /**\n\t         * @param  {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        beginPath: function (ctx) {\n\t\n\t            this._ctx = ctx;\n\t\n\t            ctx && ctx.beginPath();\n\t\n\t            ctx && (this.dpr = ctx.dpr);\n\t\n\t            // Reset\n\t            this._len = 0;\n\t\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t\n\t                this._dashOffset = 0;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t\n\t            // x0, y0, xi, yi  _dashedXXXXTo \n\t            // xi, yi , x0, y0  closePath \n\t            //  beginPath  lineTo x0, y0 \n\t            //  lineTo dashed line  IE10- \n\t            this._x0 = x;\n\t            this._y0 = y;\n\t\n\t            this._xi = x;\n\t            this._yi = y;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        lineTo: function (x, y) {\n\t            var exceedUnit = mathAbs(x - this._xi) > this._ux\n\t                || mathAbs(y - this._yi) > this._uy\n\t                // Force draw the first segment\n\t                || this._len < 5;\n\t\n\t            this.addData(CMD.L, x, y);\n\t\n\t            if (this._ctx && exceedUnit) {\n\t                this._needsDash() ? this._dashedLineTo(x, y)\n\t                    : this._ctx.lineTo(x, y);\n\t            }\n\t            if (exceedUnit) {\n\t                this._xi = x;\n\t                this._yi = y;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @param  {number} x3\n\t         * @param  {number} y3\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n\t                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n\t                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} cx\n\t         * @param  {number} cy\n\t         * @param  {number} r\n\t         * @param  {number} startAngle\n\t         * @param  {number} endAngle\n\t         * @param  {boolean} anticlockwise\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(\n\t                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n\t            );\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._xi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Context  rebuildPath  fill\n\t         * stroke \n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t\n\t                this._dashIdx = 0;\n\t\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *\n\t         * @return {boolean}\n\t         */\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t\n\t        /**\n\t         *  Path \n\t         */\n\t        setData: function (data) {\n\t\n\t            var len = data.length;\n\t\n\t            if (! (this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t\n\t            this._len = len;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t         */\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && (this.data instanceof Float32Array)) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t\n\t        /**\n\t         *  Path \n\t         * \n\t         */\n\t        addData: function (cmd) {\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                //  Float32Array\n\t                // \n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t\n\t            this._prevCmd = cmd;\n\t        },\n\t\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * If needs js implemented dashed line\n\t         * @return {boolean}\n\t         * @private\n\t         */\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t\n\t            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n\t            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n\t                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n\t                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n\t                );\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        // Not accurate dashed line to\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t\n\t            var x;\n\t            var y;\n\t\n\t            var tmpLen = 0;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n\t                    - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n\t                    - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t\n\t            while (t <= 1) {\n\t\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y)\n\t                    : ctx.lineTo(x, y);\n\t\n\t                t += lineDash[idx] / bezierLen;\n\t\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t\n\t            // Finish the last segment and calculate the new offset\n\t            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t\n\t        /**\n\t         *  Float32Array \n\t         * Convert dynamic array to static Float32Array\n\t         */\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t\n\t                if (i == 1) {\n\t                    //  L, C, Q\n\t                    //  previous point  point\n\t                    //\n\t                    //  Arc \n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        // moveTo  subpath, \n\t                        //  closePath \n\t                        x0 = data[i++];\n\t                        y0 = data[i++];\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        min2[0] = x0;\n\t                        min2[1] = y0;\n\t                        max2[0] = x0;\n\t                        max2[1] = y0;\n\t                        break;\n\t                    case CMD.L:\n\t                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.C:\n\t                        bbox.fromCubic(\n\t                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.Q:\n\t                        bbox.fromQuadratic(\n\t                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.A:\n\t                        // TODO Arc \n\t                        var cx = data[i++];\n\t                        var cy = data[i++];\n\t                        var rx = data[i++];\n\t                        var ry = data[i++];\n\t                        var startAngle = data[i++];\n\t                        var endAngle = data[i++] + startAngle;\n\t                        // TODO Arc \n\t                        var psi = data[i++];\n\t                        var anticlockwise = 1 - data[i++];\n\t\n\t                        if (i == 1) {\n\t                            //  arc \n\t                            // \n\t                            x0 = mathCos(startAngle) * rx + cx;\n\t                            y0 = mathSin(startAngle) * ry + cy;\n\t                        }\n\t\n\t                        bbox.fromArc(\n\t                            cx, cy, rx, ry, startAngle, endAngle,\n\t                            anticlockwise, min2, max2\n\t                        );\n\t\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = data[i++];\n\t                        y0 = yi = data[i++];\n\t                        var width = data[i++];\n\t                        var height = data[i++];\n\t                        // Use fromLine\n\t                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                        break;\n\t                    case CMD.Z:\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        break;\n\t                }\n\t\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t\n\t            return new BoundingRect(\n\t                min[0], min[1], max[0] - min[0], max[1] - min[1]\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Rebuild path from current data\n\t         * Rebuild path will not consider javascript implemented line dash.\n\t         * @param {CanvasRenderingContext} ctx\n\t         */\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            var x0, y0;\n\t            var xi, yi;\n\t            var x, y;\n\t            var ux = this._ux;\n\t            var uy = this._uy;\n\t            var len = this._len;\n\t            for (var i = 0; i < len;) {\n\t                var cmd = d[i++];\n\t\n\t                if (i == 1) {\n\t                    //  L, C, Q\n\t                    //  previous point  point\n\t                    //\n\t                    //  Arc \n\t                    xi = d[i];\n\t                    yi = d[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        x0 = xi = d[i++];\n\t                        y0 = yi = d[i++];\n\t                        ctx.moveTo(xi, yi);\n\t                        break;\n\t                    case CMD.L:\n\t                        x = d[i++];\n\t                        y = d[i++];\n\t                        // Not draw too small seg between\n\t                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t                            ctx.lineTo(x, y);\n\t                            xi = x;\n\t                            yi = y;\n\t                        }\n\t                        break;\n\t                    case CMD.C:\n\t                        ctx.bezierCurveTo(\n\t                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n\t                        );\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.Q:\n\t                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.A:\n\t                        var cx = d[i++];\n\t                        var cy = d[i++];\n\t                        var rx = d[i++];\n\t                        var ry = d[i++];\n\t                        var theta = d[i++];\n\t                        var dTheta = d[i++];\n\t                        var psi = d[i++];\n\t                        var fs = d[i++];\n\t                        var r = (rx > ry) ? rx : ry;\n\t                        var scaleX = (rx > ry) ? 1 : rx / ry;\n\t                        var scaleY = (rx > ry) ? ry / rx : 1;\n\t                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t                        var endAngle = theta + dTheta;\n\t                        if (isEllipse) {\n\t                            ctx.translate(cx, cy);\n\t                            ctx.rotate(psi);\n\t                            ctx.scale(scaleX, scaleY);\n\t                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t                            ctx.scale(1 / scaleX, 1 / scaleY);\n\t                            ctx.rotate(-psi);\n\t                            ctx.translate(-cx, -cy);\n\t                        }\n\t                        else {\n\t                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t                        }\n\t\n\t                        if (i == 1) {\n\t                            //  arc \n\t                            // \n\t                            x0 = mathCos(theta) * rx + cx;\n\t                            y0 = mathSin(theta) * ry + cy;\n\t                        }\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = d[i];\n\t                        y0 = yi = d[i + 1];\n\t                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                        break;\n\t                    case CMD.Z:\n\t                        ctx.closePath();\n\t                        xi = x0;\n\t                        yi = y0;\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    PathProxy.CMD = CMD;\n\t\n\t    module.exports = PathProxy;\n\n\n/***/ },\n/* 29 */\n/*!*******************************************!*\\\n  !*** ./~/zrender/lib/graphic/Gradient.js ***!\n  \\*******************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    /**\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var Gradient = function (colorStops) {\n\t\n\t        this.colorStops = colorStops || [];\n\t    };\n\t\n\t    Gradient.prototype = {\n\t\n\t        constructor: Gradient,\n\t\n\t        addColorStop: function (offset, color) {\n\t            this.colorStops.push({\n\t\n\t                offset: offset,\n\t\n\t                color: color\n\t            });\n\t        }\n\t    };\n\t\n\t    module.exports = Gradient;\n\n\n/***/ },\n/* 30 */\n/*!***********************************************!*\\\n  !*** ./lib/data/helper/completeDimensions.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Complete dimensions by data (guess dimension).\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    /**\n\t     * Complete the dimensions array guessed from the data structure.\n\t     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n\t     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n\t     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n\t     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n\t     * @return {Array.<string>}\n\t     */\n\t    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n\t        if (!data) {\n\t            return dimensions;\n\t        }\n\t\n\t        var value0 = retrieveValue(data[0]);\n\t        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\t\n\t        defaultNames = defaultNames || [];\n\t        extraPrefix = extraPrefix || 'extra';\n\t        for (var i = 0; i < dimSize; i++) {\n\t            if (!dimensions[i]) {\n\t                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));\n\t                dimensions[i] = guessOrdinal(data, i)\n\t                    ? {type: 'ordinal', name: name}\n\t                    : name;\n\t            }\n\t        }\n\t\n\t        return dimensions;\n\t    }\n\t\n\t    // The rule should not be complex, otherwise user might not\n\t    // be able to known where the data is wrong.\n\t    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n\t        for (var i = 0, len = data.length; i < len; i++) {\n\t            var value = retrieveValue(data[i]);\n\t\n\t            if (!zrUtil.isArray(value)) {\n\t                return false;\n\t            }\n\t\n\t            var value = value[dimIndex];\n\t            if (value != null && isFinite(value)) {\n\t                return false;\n\t            }\n\t            else if (zrUtil.isString(value) && value !== '-') {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t\n\t    function retrieveValue(o) {\n\t        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n\t    }\n\t\n\t    module.exports = completeDimensions;\n\t\n\n\n/***/ },\n/* 31 */\n/*!********************************************!*\\\n  !*** ./lib/model/mixin/makeStyleMapper.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// TODO Parse shadow style\n\t// TODO Only shallow path support\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    module.exports = function (properties) {\n\t        // Normalize\n\t        for (var i = 0; i < properties.length; i++) {\n\t            if (!properties[i][1]) {\n\t               properties[i][1] = properties[i][0];\n\t            }\n\t        }\n\t        return function (excludes) {\n\t            var style = {};\n\t            for (var i = 0; i < properties.length; i++) {\n\t                var propName = properties[i][1];\n\t                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n\t                    continue;\n\t                }\n\t                var val = this.getShallow(propName);\n\t                if (val != null) {\n\t                    style[properties[i][0]] = val;\n\t                }\n\t            }\n\t            return style;\n\t        };\n\t    };\n\n\n/***/ },\n/* 32 */\n/*!****************************!*\\\n  !*** ./lib/scale/Scale.js ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * // Scale class management\n\t * @module echarts/scale/Scale\n\t */\n\t\n\t\n\t    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 21);\n\t\n\t    function Scale() {\n\t        /**\n\t         * Extent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._extent = [Infinity, -Infinity];\n\t\n\t        /**\n\t         * Step is calculated in adjustExtent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._interval = 0;\n\t\n\t        this.init && this.init.apply(this, arguments);\n\t    }\n\t\n\t    var scaleProto = Scale.prototype;\n\t\n\t    /**\n\t     * Parse input val to valid inner number.\n\t     * @param {*} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.parse = function (val) {\n\t        // Notice: This would be a trap here, If the implementation\n\t        // of this method depends on extent, and this method is used\n\t        // before extent set (like in dataZoom), it would be wrong.\n\t        // Nevertheless, parse does not depend on extent generally.\n\t        return val;\n\t    };\n\t\n\t    scaleProto.contain = function (val) {\n\t        var extent = this._extent;\n\t        return val >= extent[0] && val <= extent[1];\n\t    };\n\t\n\t    /**\n\t     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.normalize = function (val) {\n\t        var extent = this._extent;\n\t        if (extent[1] === extent[0]) {\n\t            return 0.5;\n\t        }\n\t        return (val - extent[0]) / (extent[1] - extent[0]);\n\t    };\n\t\n\t    /**\n\t     * Scale normalized value\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.scale = function (val) {\n\t        var extent = this._extent;\n\t        return val * (extent[1] - extent[0]) + extent[0];\n\t    };\n\t\n\t    /**\n\t     * Set extent from data\n\t     * @param {Array.<number>} other\n\t     */\n\t    scaleProto.unionExtent = function (other) {\n\t        var extent = this._extent;\n\t        other[0] < extent[0] && (extent[0] = other[0]);\n\t        other[1] > extent[1] && (extent[1] = other[1]);\n\t        // not setExtent because in log axis it may transformed to power\n\t        // this.setExtent(extent[0], extent[1]);\n\t    };\n\t\n\t    /**\n\t     * Get extent\n\t     * @return {Array.<number>}\n\t     */\n\t    scaleProto.getExtent = function () {\n\t        return this._extent.slice();\n\t    };\n\t\n\t    /**\n\t     * Set extent\n\t     * @param {number} start\n\t     * @param {number} end\n\t     */\n\t    scaleProto.setExtent = function (start, end) {\n\t        var thisExtent = this._extent;\n\t        if (!isNaN(start)) {\n\t            thisExtent[0] = start;\n\t        }\n\t        if (!isNaN(end)) {\n\t            thisExtent[1] = end;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @return {Array.<string>}\n\t     */\n\t    scaleProto.getTicksLabels = function () {\n\t        var labels = [];\n\t        var ticks = this.getTicks();\n\t        for (var i = 0; i < ticks.length; i++) {\n\t            labels.push(this.getLabel(ticks[i]));\n\t        }\n\t        return labels;\n\t    };\n\t\n\t    clazzUtil.enableClassExtend(Scale);\n\t    clazzUtil.enableClassManagement(Scale, {\n\t        registerWhenExtend: true\n\t    });\n\t\n\t    module.exports = Scale;\n\n\n/***/ },\n/* 33 */\n/*!*********************************!*\\\n  !*** ./~/zrender/lib/config.js ***!\n  \\*********************************/\n/***/ function(module, exports) {\n\n\t\n\t    var dpr = 1;\n\t    // If in browser environment\n\t    if (typeof window !== 'undefined') {\n\t        dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t    }\n\t    /**\n\t     * config\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t        /**\n\t         * debugcatchBrushExceptiontrue\n\t         * 0 : debug\n\t         * 1 : \n\t         * 2 : \n\t         */\n\t        debugMode: 0,\n\t\n\t        // retina \n\t        devicePixelRatio: dpr\n\t    };\n\t    module.exports = config;\n\t\n\t\n\n\n/***/ },\n/* 34 */\n/*!******************************************!*\\\n  !*** ./~/zrender/lib/container/Group.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * GroupGroup\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/lib/container/Group');\n\t *     var Circle = require('zrender/lib/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t    var Element = __webpack_require__(/*! ../Element */ 58);\n\t    var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ 8);\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        for (var key in opts) {\n\t            if (opts.hasOwnProperty(key)) {\n\t                this[key] = opts[key];\n\t            }\n\t        }\n\t\n\t        this._children = [];\n\t\n\t        this.__storage = null;\n\t\n\t        this.__dirty = true;\n\t    };\n\t\n\t    Group.prototype = {\n\t\n\t        constructor: Group,\n\t\n\t        isGroup: true,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        type: 'group',\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/container/Group#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/Element>}\n\t         */\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t\n\t        /**\n\t         *  index \n\t         * @param  {number} idx\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {string} name\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t             }\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/Element} child\n\t         */\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t\n\t                this._children.push(child);\n\t\n\t                this._doAdd(child);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *  nextSibling \n\t         * @param {module:zrender/Element} child\n\t         * @param {module:zrender/Element} nextSibling\n\t         */\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this\n\t                && nextSibling && nextSibling.parent === this) {\n\t\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t\n\t            child.parent = this;\n\t\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t\n\t                storage.addToMap(child);\n\t\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/Element} child\n\t         */\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t\n\t            child.parent = null;\n\t\n\t            if (storage) {\n\t\n\t                storage.delFromMap(child.id);\n\t\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromMap(child.id);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                // TODO\n\t                // The boundingRect cacluated by transforming original\n\t                // rect may be bigger than the actual bundingRect when rotation\n\t                // is used. (Consider a circle rotated aginst its center, where\n\t                // the actual boundingRect should be the same as that not be\n\t                // rotated.) But we can not find better approach to calculate\n\t                // actual boundingRect yet, considering performance.\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                }\n\t                else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Group, Element);\n\t\n\t    module.exports = Group;\n\n\n/***/ },\n/* 35 */\n/*!*************************************************!*\\\n  !*** ./lib/chart/helper/createListFromArray.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var List = __webpack_require__(/*! ../../data/List */ 14);\n\t    var completeDimensions = __webpack_require__(/*! ../../data/helper/completeDimensions */ 30);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var modelUtil = __webpack_require__(/*! ../../util/model */ 7);\n\t    var CoordinateSystem = __webpack_require__(/*! ../../CoordinateSystem */ 23);\n\t    var getDataItemValue = modelUtil.getDataItemValue;\n\t    var converDataValue = modelUtil.converDataValue;\n\t\n\t    function firstDataNotNull(data) {\n\t        var i = 0;\n\t        while (i < data.length && data[i] == null) {\n\t            i++;\n\t        }\n\t        return data[i];\n\t    }\n\t    function ifNeedCompleteOrdinalData(data) {\n\t        var sampleItem = firstDataNotNull(data);\n\t        return sampleItem != null\n\t            && !zrUtil.isArray(getDataItemValue(sampleItem));\n\t    }\n\t\n\t    /**\n\t     * Helper function to create a list from option data\n\t     */\n\t    function createListFromArray(data, seriesModel, ecModel) {\n\t        // If data is undefined\n\t        data = data || [];\n\t\n\t        if (false) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t\n\t        var coordSysName = seriesModel.get('coordinateSystem');\n\t        var creator = creators[coordSysName];\n\t        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n\t        // FIXME\n\t        var axesInfo = creator && creator(data, seriesModel, ecModel);\n\t        var dimensions = axesInfo && axesInfo.dimensions;\n\t        if (!dimensions) {\n\t            // Get dimensions from registered coordinate system\n\t            dimensions = (registeredCoordSys && registeredCoordSys.dimensions) || ['x', 'y'];\n\t            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n\t        }\n\t        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\t\n\t        var list = new List(dimensions, seriesModel);\n\t\n\t        var nameList = createNameList(axesInfo, data);\n\t\n\t        var categories = {};\n\t        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n\t            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t\n\t                // Use dataIndex as ordinal value in categoryAxis\n\t                return dimIndex === categoryIndex\n\t                    ? dataIndex\n\t                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n\t            }\n\t            : function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                var value = getDataItemValue(itemOpt);\n\t                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t\n\t                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n\t                if (categoryAxesModels && categoryAxesModels[dimName]) {\n\t                    // If given value is a category string\n\t                    if (typeof val === 'string') {\n\t                        // Lazy get categories\n\t                        categories[dimName] = categories[dimName]\n\t                            || categoryAxesModels[dimName].getCategories();\n\t                        val = zrUtil.indexOf(categories[dimName], val);\n\t                        if (val < 0 && !isNaN(val)) {\n\t                            // In case some one write '1', '2' istead of 1, 2\n\t                            val = +val;\n\t                        }\n\t                    }\n\t                }\n\t                return val;\n\t            };\n\t\n\t        list.hasItemOption = false;\n\t        list.initData(data, nameList, dimValueGetter);\n\t\n\t        return list;\n\t    }\n\t\n\t    function isStackable(axisType) {\n\t        return axisType !== 'category' && axisType !== 'time';\n\t    }\n\t\n\t    function getDimTypeByAxis(axisType) {\n\t        return axisType === 'category'\n\t            ? 'ordinal'\n\t            : axisType === 'time'\n\t            ? 'time'\n\t            : 'float';\n\t    }\n\t\n\t    /**\n\t     * Creaters for each coord system.\n\t     */\n\t    var creators = {\n\t\n\t        cartesian2d: function (data, seriesModel, ecModel) {\n\t\n\t            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n\t                return ecModel.queryComponents({\n\t                    mainType: name,\n\t                    index: seriesModel.get(name + 'Index'),\n\t                    id: seriesModel.get(name + 'Id')\n\t                })[0];\n\t            });\n\t            var xAxisModel = axesModels[0];\n\t            var yAxisModel = axesModels[1];\n\t\n\t            if (false) {\n\t                if (!xAxisModel) {\n\t                    throw new Error('xAxis \"' + zrUtil.retrieve(\n\t                        seriesModel.get('xAxisIndex'),\n\t                        seriesModel.get('xAxisId'),\n\t                        0\n\t                    ) + '\" not found');\n\t                }\n\t                if (!yAxisModel) {\n\t                    throw new Error('yAxis \"' + zrUtil.retrieve(\n\t                        seriesModel.get('xAxisIndex'),\n\t                        seriesModel.get('yAxisId'),\n\t                        0\n\t                    ) + '\" not found');\n\t                }\n\t            }\n\t\n\t            var xAxisType = xAxisModel.get('type');\n\t            var yAxisType = yAxisModel.get('type');\n\t\n\t            var dimensions = [\n\t                {\n\t                    name: 'x',\n\t                    type: getDimTypeByAxis(xAxisType),\n\t                    stackable: isStackable(xAxisType)\n\t                },\n\t                {\n\t                    name: 'y',\n\t                    // If two category axes\n\t                    type: getDimTypeByAxis(yAxisType),\n\t                    stackable: isStackable(yAxisType)\n\t                }\n\t            ];\n\t\n\t            var isXAxisCateogry = xAxisType === 'category';\n\t            var isYAxisCategory = yAxisType === 'category';\n\t\n\t            completeDimensions(dimensions, data, ['x', 'y', 'z']);\n\t\n\t            var categoryAxesModels = {};\n\t            if (isXAxisCateogry) {\n\t                categoryAxesModels.x = xAxisModel;\n\t            }\n\t            if (isYAxisCategory) {\n\t                categoryAxesModels.y = yAxisModel;\n\t            }\n\t            return {\n\t                dimensions: dimensions,\n\t                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n\t                categoryAxesModels: categoryAxesModels\n\t            };\n\t        },\n\t\n\t        polar: function (data, seriesModel, ecModel) {\n\t            var polarModel = ecModel.queryComponents({\n\t                mainType: 'polar',\n\t                index: seriesModel.get('polarIndex'),\n\t                id: seriesModel.get('polarId')\n\t            })[0];\n\t\n\t            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n\t            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\t\n\t            if (false) {\n\t                if (!angleAxisModel) {\n\t                    throw new Error('angleAxis option not found');\n\t                }\n\t                if (!radiusAxisModel) {\n\t                    throw new Error('radiusAxis option not found');\n\t                }\n\t            }\n\t\n\t            var radiusAxisType = radiusAxisModel.get('type');\n\t            var angleAxisType = angleAxisModel.get('type');\n\t\n\t            var dimensions = [\n\t                {\n\t                    name: 'radius',\n\t                    type: getDimTypeByAxis(radiusAxisType),\n\t                    stackable: isStackable(radiusAxisType)\n\t                },\n\t                {\n\t                    name: 'angle',\n\t                    type: getDimTypeByAxis(angleAxisType),\n\t                    stackable: isStackable(angleAxisType)\n\t                }\n\t            ];\n\t            var isAngleAxisCateogry = angleAxisType === 'category';\n\t            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\t\n\t            completeDimensions(dimensions, data, ['radius', 'angle', 'value']);\n\t\n\t            var categoryAxesModels = {};\n\t            if (isRadiusAxisCateogry) {\n\t                categoryAxesModels.radius = radiusAxisModel;\n\t            }\n\t            if (isAngleAxisCateogry) {\n\t                categoryAxesModels.angle = angleAxisModel;\n\t            }\n\t            return {\n\t                dimensions: dimensions,\n\t                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n\t                categoryAxesModels: categoryAxesModels\n\t            };\n\t        },\n\t\n\t        geo: function (data, seriesModel, ecModel) {\n\t            // TODO Region\n\t            // \n\t            return {\n\t                dimensions: completeDimensions([\n\t                    {name: 'lng'},\n\t                    {name: 'lat'}\n\t                ], data, ['lng', 'lat', 'value'])\n\t            };\n\t        }\n\t    };\n\t\n\t    function createNameList(result, data) {\n\t        var nameList = [];\n\t\n\t        var categoryDim = result && result.dimensions[result.categoryIndex];\n\t        var categoryAxisModel;\n\t        if (categoryDim) {\n\t            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n\t        }\n\t\n\t        if (categoryAxisModel) {\n\t            // FIXME Two category axis\n\t            var categories = categoryAxisModel.getCategories();\n\t            if (categories) {\n\t                var dataLen = data.length;\n\t                // Ordered data is given explicitly like\n\t                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n\t                // or given scatter data,\n\t                // pick the category\n\t                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n\t                    nameList = [];\n\t                    for (var i = 0; i < dataLen; i++) {\n\t                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n\t                    }\n\t                }\n\t                else {\n\t                    nameList = categories.slice(0);\n\t                }\n\t            }\n\t        }\n\t\n\t        return nameList;\n\t    }\n\t\n\t    module.exports = createListFromArray;\n\t\n\n\n/***/ },\n/* 36 */\n/*!*******************************!*\\\n  !*** ./lib/component/grid.js ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var graphic = __webpack_require__(/*! ../util/graphic */ 3);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var echarts = __webpack_require__(/*! ../echarts */ 2);\n\t\n\t    __webpack_require__(/*! ../coord/cartesian/Grid */ 54);\n\t\n\t    __webpack_require__(/*! ./axis */ 106);\n\t\n\t    // Grid view\n\t    echarts.extendComponentView({\n\t\n\t        type: 'grid',\n\t\n\t        render: function (gridModel, ecModel) {\n\t            this.group.removeAll();\n\t            if (gridModel.get('show')) {\n\t                this.group.add(new graphic.Rect({\n\t                    shape: gridModel.coordinateSystem.getRect(),\n\t                    style: zrUtil.defaults({\n\t                        fill: gridModel.get('backgroundColor')\n\t                    }, gridModel.getItemStyle()),\n\t                    silent: true,\n\t                    z2: -1\n\t                }));\n\t            }\n\t        }\n\t\n\t    });\n\t\n\t    echarts.registerPreprocessor(function (option) {\n\t        // Only create grid when need\n\t        if (option.xAxis && option.yAxis && !option.grid) {\n\t            option.grid = {};\n\t        }\n\t    });\n\n\n/***/ },\n/* 37 */\n/*!**********************************************!*\\\n  !*** ./~/zrender/lib/graphic/Displayable.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t\n\t    var Style = __webpack_require__(/*! ./Style */ 64);\n\t\n\t    var Element = __webpack_require__(/*! ../Element */ 58);\n\t    var RectText = __webpack_require__(/*! ./mixin/RectText */ 75);\n\t    // var Stateful = require('./mixin/Stateful');\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (\n\t                opts.hasOwnProperty(name) &&\n\t                name !== 'style'\n\t            ) {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style);\n\t\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];\n\t\n\t        // FIXME Stateful must be mixined after style is setted\n\t        // Stateful.call(this, opts);\n\t    }\n\t\n\t    Displayable.prototype = {\n\t\n\t        constructor: Displayable,\n\t\n\t        type: 'displayable',\n\t\n\t        /**\n\t         * Displayable Painter \n\t         * Dirty flag. From which painter will determine if this displayable object needs brush\n\t         * @name module:zrender/graphic/Displayable#__dirty\n\t         * @type {boolean}\n\t         */\n\t        __dirty: true,\n\t\n\t        /**\n\t         * true\n\t         * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t         * @name module:/zrender/graphic/Displayable#invisible\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        invisible: false,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z: 0,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z2: 0,\n\t\n\t        /**\n\t         * zlevelcanvas\n\t         * @name module:/zrender/graphic/Displayable#zlevel\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        zlevel: 0,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        draggable: false,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        dragging: false,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * If enable culling\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        culling: false,\n\t\n\t        /**\n\t         * Mouse cursor when hovered\n\t         * @name module:/zrender/graphic/Displayable#cursor\n\t         * @type {string}\n\t         */\n\t        cursor: 'pointer',\n\t\n\t        /**\n\t         * If hover area is bounding rect\n\t         * @name module:/zrender/graphic/Displayable#rectHover\n\t         * @type {string}\n\t         */\n\t        rectHover: false,\n\t\n\t        /**\n\t         * Render the element progressively when the value >= 0,\n\t         * usefull for large data.\n\t         * @type {number}\n\t         */\n\t        progressive: -1,\n\t\n\t        beforeBrush: function (ctx) {},\n\t\n\t        afterBrush: function (ctx) {},\n\t\n\t        /**\n\t         * \n\t         * @param {Canvas2DRenderingContext} ctx\n\t         */\n\t        // Interface\n\t        brush: function (ctx, prevEl) {},\n\t\n\t        /**\n\t         * \n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        // Interface\n\t        getBoundingRect: function () {},\n\t\n\t        /**\n\t         *  x, y \n\t         * If displayable element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t\n\t        /**\n\t         *  x, y \n\t         * If bounding rect of element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Mark displayable element dirty and refresh next frame\n\t         */\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t\n\t            this._rect = null;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * If displayable object binded any event\n\t         * @return {boolean}\n\t         */\n\t        // TODO,  bind \n\t        // isSilent: function () {\n\t        //     return !(\n\t        //         this.hoverable || this.draggable\n\t        //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t        //         || this.onmousedown || this.onmouseup || this.onclick\n\t        //         || this.ondragenter || this.ondragover || this.ondragleave\n\t        //         || this.ondrop\n\t        //     );\n\t        // },\n\t        /**\n\t         * Alias for animate('style')\n\t         * @param {boolean} loop\n\t         */\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            }\n\t            else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Use given style object\n\t         * @param  {Object} obj\n\t         */\n\t        useStyle: function (obj) {\n\t            this.style = new Style(obj);\n\t            this.dirty(false);\n\t            return this;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Displayable, Element);\n\t\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t\n\t    module.exports = Displayable;\n\n\n/***/ },\n/* 38 */\n/*!*******************************!*\\\n  !*** ./lib/scale/Interval.js ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Interval scale\n\t * @module echarts/scale/Interval\n\t */\n\t\n\t\n\t\n\t    var numberUtil = __webpack_require__(/*! ../util/number */ 4);\n\t    var formatUtil = __webpack_require__(/*! ../util/format */ 9);\n\t    var Scale = __webpack_require__(/*! ./Scale */ 32);\n\t\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t\n\t    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n\t    var roundingErrorFix = numberUtil.round;\n\t    /**\n\t     * @alias module:echarts/coord/scale/Interval\n\t     * @constructor\n\t     */\n\t    var IntervalScale = Scale.extend({\n\t\n\t        type: 'interval',\n\t\n\t        _interval: 0,\n\t\n\t        setExtent: function (start, end) {\n\t            var thisExtent = this._extent;\n\t            //start,end may be a Number like '25',so...\n\t            if (!isNaN(start)) {\n\t                thisExtent[0] = parseFloat(start);\n\t            }\n\t            if (!isNaN(end)) {\n\t                thisExtent[1] = parseFloat(end);\n\t            }\n\t        },\n\t\n\t        unionExtent: function (other) {\n\t            var extent = this._extent;\n\t            other[0] < extent[0] && (extent[0] = other[0]);\n\t            other[1] > extent[1] && (extent[1] = other[1]);\n\t\n\t            // unionExtent may called by it's sub classes\n\t            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n\t        },\n\t        /**\n\t         * Get interval\n\t         */\n\t        getInterval: function () {\n\t            if (!this._interval) {\n\t                this.niceTicks();\n\t            }\n\t            return this._interval;\n\t        },\n\t\n\t        /**\n\t         * Set interval\n\t         */\n\t        setInterval: function (interval) {\n\t            this._interval = interval;\n\t            // Dropped auto calculated niceExtent and use user setted extent\n\t            // We assume user wan't to set both interval, min, max to get a better result\n\t            this._niceExtent = this._extent.slice();\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getTicks: function () {\n\t            if (!this._interval) {\n\t                this.niceTicks();\n\t            }\n\t            var interval = this._interval;\n\t            var extent = this._extent;\n\t            var ticks = [];\n\t\n\t            // Consider this case: using dataZoom toolbox, zoom and zoom.\n\t            var safeLimit = 10000;\n\t\n\t            if (interval) {\n\t                var niceExtent = this._niceExtent;\n\t                var precision = getPrecisionSafe(interval) + 2;\n\t\n\t                if (extent[0] < niceExtent[0]) {\n\t                    ticks.push(extent[0]);\n\t                }\n\t                var tick = niceExtent[0];\n\t\n\t                while (tick <= niceExtent[1]) {\n\t                    ticks.push(tick);\n\t                    // Avoid rounding error\n\t                    tick = roundingErrorFix(tick + interval, precision);\n\t                    if (ticks.length > safeLimit) {\n\t                        return [];\n\t                    }\n\t                }\n\t                // Consider this case: the last item of ticks is smaller\n\t                // than niceExtent[1] and niceExtent[1] === extent[1].\n\t                if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceExtent[1])) {\n\t                    ticks.push(extent[1]);\n\t                }\n\t            }\n\t\n\t            return ticks;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<string>}\n\t         */\n\t        getTicksLabels: function () {\n\t            var labels = [];\n\t            var ticks = this.getTicks();\n\t            for (var i = 0; i < ticks.length; i++) {\n\t                labels.push(this.getLabel(ticks[i]));\n\t            }\n\t            return labels;\n\t        },\n\t\n\t        /**\n\t         * @param {number} n\n\t         * @return {number}\n\t         */\n\t        getLabel: function (data) {\n\t            return formatUtil.addCommas(data);\n\t        },\n\t\n\t        /**\n\t         * Update interval and extent of intervals for nice ticks\n\t         *\n\t         * @param {number} [splitNumber = 5] Desired number of ticks\n\t         */\n\t        niceTicks: function (splitNumber) {\n\t            splitNumber = splitNumber || 5;\n\t            var extent = this._extent;\n\t            var span = extent[1] - extent[0];\n\t            if (!isFinite(span)) {\n\t                return;\n\t            }\n\t            // User may set axis min 0 and data are all negative\n\t            // FIXME If it needs to reverse ?\n\t            if (span < 0) {\n\t                span = -span;\n\t                extent.reverse();\n\t            }\n\t\n\t            // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t            // var niceSpan = numberUtil.nice(span, false);\n\t            var step = roundingErrorFix(\n\t                numberUtil.nice(span / splitNumber, true),\n\t                Math.max(\n\t                    getPrecisionSafe(extent[0]),\n\t                    getPrecisionSafe(extent[1])\n\t                // extent may be [0, 1], and step should have 1 more digits.\n\t                // To make it safe we add 2 more digits\n\t                ) + 2\n\t            );\n\t\n\t            var precision = getPrecisionSafe(step) + 2;\n\t            // Niced extent inside original extent\n\t            var niceExtent = [\n\t                roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n\t                roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n\t            ];\n\t\n\t            this._interval = step;\n\t            this._niceExtent = niceExtent;\n\t        },\n\t\n\t        /**\n\t         * Nice extent.\n\t         * @param {number} [splitNumber = 5] Given approx tick number\n\t         * @param {boolean} [fixMin=false]\n\t         * @param {boolean} [fixMax=false]\n\t         */\n\t        niceExtent: function (splitNumber, fixMin, fixMax) {\n\t            var extent = this._extent;\n\t            // If extent start and end are same, expand them\n\t            if (extent[0] === extent[1]) {\n\t                if (extent[0] !== 0) {\n\t                    // Expand extent\n\t                    var expandSize = extent[0];\n\t                    // In the fowllowing case\n\t                    //      Axis has been fixed max 100\n\t                    //      Plus data are all 100 and axis extent are [100, 100].\n\t                    // Extend to the both side will cause expanded max is larger than fixed max.\n\t                    // So only expand to the smaller side.\n\t                    if (!fixMax) {\n\t                        extent[1] += expandSize / 2;\n\t                        extent[0] -= expandSize / 2;\n\t                    }\n\t                    else {\n\t                        extent[0] -= expandSize / 2;\n\t                    }\n\t                }\n\t                else {\n\t                    extent[1] = 1;\n\t                }\n\t            }\n\t            var span = extent[1] - extent[0];\n\t            // If there are no data and extent are [Infinity, -Infinity]\n\t            if (!isFinite(span)) {\n\t                extent[0] = 0;\n\t                extent[1] = 1;\n\t            }\n\t\n\t            this.niceTicks(splitNumber);\n\t\n\t            // var extent = this._extent;\n\t            var interval = this._interval;\n\t\n\t            if (!fixMin) {\n\t                extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n\t            }\n\t            if (!fixMax) {\n\t                extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n\t            }\n\t        }\n\t    });\n\t\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    IntervalScale.create = function () {\n\t        return new IntervalScale();\n\t    };\n\t\n\t    module.exports = IntervalScale;\n\t\n\n\n/***/ },\n/* 39 */\n/*!****************************************!*\\\n  !*** ./lib/chart/helper/SymbolDraw.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/chart/helper/SymbolDraw\n\t */\n\t\n\t\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var Symbol = __webpack_require__(/*! ./Symbol */ 49);\n\t\n\t    /**\n\t     * @constructor\n\t     * @alias module:echarts/chart/helper/SymbolDraw\n\t     * @param {module:zrender/graphic/Group} [symbolCtor]\n\t     */\n\t    function SymbolDraw(symbolCtor) {\n\t        this.group = new graphic.Group();\n\t\n\t        this._symbolCtor = symbolCtor || Symbol;\n\t    }\n\t\n\t    var symbolDrawProto = SymbolDraw.prototype;\n\t\n\t    function symbolNeedsDraw(data, idx, isIgnore) {\n\t        var point = data.getItemLayout(idx);\n\t        // Is an object\n\t        // if (point && point.hasOwnProperty('point')) {\n\t        //     point = point.point;\n\t        // }\n\t        return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx))\n\t                    && data.getItemVisual(idx, 'symbol') !== 'none';\n\t    }\n\t    /**\n\t     * Update symbols draw by new data\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Array.<boolean>} [isIgnore]\n\t     */\n\t    symbolDrawProto.updateData = function (data, isIgnore) {\n\t        var group = this.group;\n\t        var seriesModel = data.hostModel;\n\t        var oldData = this._data;\n\t\n\t        var SymbolCtor = this._symbolCtor;\n\t\n\t        var seriesScope = {\n\t            itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n\t            hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n\t            symbolRotate: seriesModel.get('symbolRotate'),\n\t            symbolOffset: seriesModel.get('symbolOffset'),\n\t            hoverAnimation: seriesModel.get('hoverAnimation'),\n\t\n\t            labelModel: seriesModel.getModel('label.normal'),\n\t            hoverLabelModel: seriesModel.getModel('label.emphasis')\n\t        };\n\t\n\t        data.diff(oldData)\n\t            .add(function (newIdx) {\n\t                var point = data.getItemLayout(newIdx);\n\t                if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n\t                    var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n\t                    symbolEl.attr('position', point);\n\t                    data.setItemGraphicEl(newIdx, symbolEl);\n\t                    group.add(symbolEl);\n\t                }\n\t            })\n\t            .update(function (newIdx, oldIdx) {\n\t                var symbolEl = oldData.getItemGraphicEl(oldIdx);\n\t                var point = data.getItemLayout(newIdx);\n\t                if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n\t                    group.remove(symbolEl);\n\t                    return;\n\t                }\n\t                if (!symbolEl) {\n\t                    symbolEl = new SymbolCtor(data, newIdx);\n\t                    symbolEl.attr('position', point);\n\t                }\n\t                else {\n\t                    symbolEl.updateData(data, newIdx, seriesScope);\n\t                    graphic.updateProps(symbolEl, {\n\t                        position: point\n\t                    }, seriesModel);\n\t                }\n\t\n\t                // Add back\n\t                group.add(symbolEl);\n\t\n\t                data.setItemGraphicEl(newIdx, symbolEl);\n\t            })\n\t            .remove(function (oldIdx) {\n\t                var el = oldData.getItemGraphicEl(oldIdx);\n\t                el && el.fadeOut(function () {\n\t                    group.remove(el);\n\t                });\n\t            })\n\t            .execute();\n\t\n\t        this._data = data;\n\t    };\n\t\n\t    symbolDrawProto.updateLayout = function () {\n\t        var data = this._data;\n\t        if (data) {\n\t            // Not use animation\n\t            data.eachItemGraphicEl(function (el, idx) {\n\t                var point = data.getItemLayout(idx);\n\t                el.attr('position', point);\n\t            });\n\t        }\n\t    };\n\t\n\t    symbolDrawProto.remove = function (enableAnimation) {\n\t        var group = this.group;\n\t        var data = this._data;\n\t        if (data) {\n\t            if (enableAnimation) {\n\t                data.eachItemGraphicEl(function (el) {\n\t                    el.fadeOut(function () {\n\t                        group.remove(el);\n\t                    });\n\t                });\n\t            }\n\t            else {\n\t                group.removeAll();\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = SymbolDraw;\n\n\n/***/ },\n/* 40 */\n/*!*************************************************!*\\\n  !*** ./lib/component/dataZoom/DataZoomModel.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file Data zoom model\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var env = __webpack_require__(/*! zrender/lib/core/env */ 11);\n\t    var echarts = __webpack_require__(/*! ../../echarts */ 2);\n\t    var modelUtil = __webpack_require__(/*! ../../util/model */ 7);\n\t    var helper = __webpack_require__(/*! ./helper */ 110);\n\t    var AxisProxy = __webpack_require__(/*! ./AxisProxy */ 180);\n\t    var each = zrUtil.each;\n\t    var eachAxisDim = helper.eachAxisDim;\n\t\n\t    var DataZoomModel = echarts.extendComponentModel({\n\t\n\t        type: 'dataZoom',\n\t\n\t        dependencies: [\n\t            'xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'series'\n\t        ],\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 4,                   // Higher than normal component (z: 2).\n\t            orient: null,           // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n\t            xAxisIndex: null,       // Default the first horizontal category axis.\n\t            yAxisIndex: null,       // Default the first vertical category axis.\n\t\n\t            filterMode: 'filter',   // Possible values: 'filter' or 'empty'.\n\t                                    // 'filter': data items which are out of window will be removed.\n\t                                    //           This option is applicable when filtering outliers.\n\t                                    // 'empty': data items which are out of window will be set to empty.\n\t                                    //          This option is applicable when user should not neglect\n\t                                    //          that there are some data items out of window.\n\t                                    // Taking line chart as an example, line will be broken in\n\t                                    // the filtered points when filterModel is set to 'empty', but\n\t                                    // be connected when set to 'filter'.\n\t\n\t            throttle: null,         // Dispatch action by the fixed rate, avoid frequency.\n\t                                    // default 100. Do not throttle when use null/undefined.\n\t                                    // If animation === true and animationDurationUpdate > 0,\n\t                                    // default value is 100, otherwise 20.\n\t            start: 0,               // Start percent. 0 ~ 100\n\t            end: 100,               // End percent. 0 ~ 100\n\t            startValue: null,       // Start value. If startValue specified, start is ignored.\n\t            endValue: null          // End value. If endValue specified, end is ignored.\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        init: function (option, parentModel, ecModel) {\n\t\n\t            /**\n\t             * key like x_0, y_1\n\t             * @private\n\t             * @type {Object}\n\t             */\n\t            this._dataIntervalByAxis = {};\n\t\n\t            /**\n\t             * @private\n\t             */\n\t            this._dataInfo = {};\n\t\n\t            /**\n\t             * key like x_0, y_1\n\t             * @private\n\t             */\n\t            this._axisProxies = {};\n\t\n\t            /**\n\t             * @readOnly\n\t             */\n\t            this.textStyleModel;\n\t\n\t            /**\n\t             * @private\n\t             */\n\t            this._autoThrottle = true;\n\t\n\t            var rawOption = retrieveRaw(option);\n\t\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t\n\t            this.doInit(rawOption);\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        mergeOption: function (newOption) {\n\t            var rawOption = retrieveRaw(newOption);\n\t\n\t            //FIX #2591\n\t            zrUtil.merge(this.option, newOption, true);\n\t\n\t            this.doInit(rawOption);\n\t        },\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        doInit: function (rawOption) {\n\t            var thisOption = this.option;\n\t\n\t            // Disable realtime view update if canvas is not supported.\n\t            if (!env.canvasSupported) {\n\t                thisOption.realtime = false;\n\t            }\n\t\n\t            this._setDefaultThrottle(rawOption);\n\t\n\t            processRangeProp('start', 'startValue', rawOption, thisOption);\n\t            processRangeProp('end', 'endValue', rawOption, thisOption);\n\t\n\t            this.textStyleModel = this.getModel('textStyle');\n\t\n\t            this._resetTarget();\n\t\n\t            this._giveAxisProxies();\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _giveAxisProxies: function () {\n\t            var axisProxies = this._axisProxies;\n\t\n\t            this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n\t                var axisModel = this.dependentModels[dimNames.axis][axisIndex];\n\t\n\t                // If exists, share axisProxy with other dataZoomModels.\n\t                var axisProxy = axisModel.__dzAxisProxy || (\n\t                    // Use the first dataZoomModel as the main model of axisProxy.\n\t                    axisModel.__dzAxisProxy = new AxisProxy(\n\t                        dimNames.name, axisIndex, this, ecModel\n\t                    )\n\t                );\n\t                // FIXME\n\t                // dispose __dzAxisProxy\n\t\n\t                axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _resetTarget: function () {\n\t            var thisOption = this.option;\n\t\n\t            var autoMode = this._judgeAutoMode();\n\t\n\t            eachAxisDim(function (dimNames) {\n\t                var axisIndexName = dimNames.axisIndex;\n\t                thisOption[axisIndexName] = modelUtil.normalizeToArray(\n\t                    thisOption[axisIndexName]\n\t                );\n\t            }, this);\n\t\n\t            if (autoMode === 'axisIndex') {\n\t                this._autoSetAxisIndex();\n\t            }\n\t            else if (autoMode === 'orient') {\n\t                this._autoSetOrient();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _judgeAutoMode: function () {\n\t            // Auto set only works for setOption at the first time.\n\t            // The following is user's reponsibility. So using merged\n\t            // option is OK.\n\t            var thisOption = this.option;\n\t\n\t            var hasIndexSpecified = false;\n\t            eachAxisDim(function (dimNames) {\n\t                // When user set axisIndex as a empty array, we think that user specify axisIndex\n\t                // but do not want use auto mode. Because empty array may be encountered when\n\t                // some error occured.\n\t                if (thisOption[dimNames.axisIndex] != null) {\n\t                    hasIndexSpecified = true;\n\t                }\n\t            }, this);\n\t\n\t            var orient = thisOption.orient;\n\t\n\t            if (orient == null && hasIndexSpecified) {\n\t                return 'orient';\n\t            }\n\t            else if (!hasIndexSpecified) {\n\t                if (orient == null) {\n\t                    thisOption.orient = 'horizontal';\n\t                }\n\t                return 'axisIndex';\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _autoSetAxisIndex: function () {\n\t            var autoAxisIndex = true;\n\t            var orient = this.get('orient', true);\n\t            var thisOption = this.option;\n\t\n\t            if (autoAxisIndex) {\n\t                // Find axis that parallel to dataZoom as default.\n\t                var dimNames = orient === 'vertical'\n\t                    ? {dim: 'y', axisIndex: 'yAxisIndex', axis: 'yAxis'}\n\t                    : {dim: 'x', axisIndex: 'xAxisIndex', axis: 'xAxis'};\n\t\n\t                if (this.dependentModels[dimNames.axis].length) {\n\t                    thisOption[dimNames.axisIndex] = [0];\n\t                    autoAxisIndex = false;\n\t                }\n\t            }\n\t\n\t            if (autoAxisIndex) {\n\t                // Find the first category axis as default. (consider polar)\n\t                eachAxisDim(function (dimNames) {\n\t                    if (!autoAxisIndex) {\n\t                        return;\n\t                    }\n\t                    var axisIndices = [];\n\t                    var axisModels = this.dependentModels[dimNames.axis];\n\t                    if (axisModels.length && !axisIndices.length) {\n\t                        for (var i = 0, len = axisModels.length; i < len; i++) {\n\t                            if (axisModels[i].get('type') === 'category') {\n\t                                axisIndices.push(i);\n\t                            }\n\t                        }\n\t                    }\n\t                    thisOption[dimNames.axisIndex] = axisIndices;\n\t                    if (axisIndices.length) {\n\t                        autoAxisIndex = false;\n\t                    }\n\t                }, this);\n\t            }\n\t\n\t            if (autoAxisIndex) {\n\t                // FIXME\n\t                // ec2xAxisIndexyAxisIndexscatterdataZoom\n\t                // Grid.js#getScaleByOptiontimelogaxis type\n\t\n\t                // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n\t                // dataZoom component auto adopts series that reference to\n\t                // both xAxis and yAxis which type is 'value'.\n\t                this.ecModel.eachSeries(function (seriesModel) {\n\t                    if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n\t                        eachAxisDim(function (dimNames) {\n\t                            var axisIndices = thisOption[dimNames.axisIndex];\n\t\n\t                            var axisIndex = seriesModel.get(dimNames.axisIndex);\n\t                            var axisId = seriesModel.get(dimNames.axisId);\n\t\n\t                            var axisModel = seriesModel.ecModel.queryComponents({\n\t                                mainType: dimNames.axis,\n\t                                index: axisIndex,\n\t                                id: axisId\n\t                            })[0];\n\t\n\t                            if (false) {\n\t                                if (!axisModel) {\n\t                                    throw new Error(\n\t                                        dimNames.axis + ' \"' + zrUtil.retrieve(\n\t                                            axisIndex,\n\t                                            axisId,\n\t                                            0\n\t                                        ) + '\" not found'\n\t                                    );\n\t                                }\n\t                            }\n\t                            axisIndex = axisModel.componentIndex;\n\t\n\t                            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n\t                                axisIndices.push(axisIndex);\n\t                            }\n\t                        });\n\t                    }\n\t                }, this);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _autoSetOrient: function () {\n\t            var dim;\n\t\n\t            // Find the first axis\n\t            this.eachTargetAxis(function (dimNames) {\n\t                !dim && (dim = dimNames.name);\n\t            }, this);\n\t\n\t            this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n\t            // FIXME\n\t            // seriesxAxisIndexyAxisIndex\n\t            // series.type === scatter\n\t\n\t            var is = true;\n\t            eachAxisDim(function (dimNames) {\n\t                var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n\t                var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\t\n\t                if (!axisModel || axisModel.get('type') !== axisType) {\n\t                    is = false;\n\t                }\n\t            }, this);\n\t            return is;\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _setDefaultThrottle: function (rawOption) {\n\t            // When first time user set throttle, auto throttle ends.\n\t            if (rawOption.hasOwnProperty('throttle')) {\n\t                this._autoThrottle = false;\n\t            }\n\t            if (this._autoThrottle) {\n\t                var globalOption = this.ecModel.option;\n\t                this.option.throttle =\n\t                    (globalOption.animation && globalOption.animationDurationUpdate > 0)\n\t                    ? 100 : 20;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         */\n\t        getFirstTargetAxisModel: function () {\n\t            var firstAxisModel;\n\t            eachAxisDim(function (dimNames) {\n\t                if (firstAxisModel == null) {\n\t                    var indices = this.get(dimNames.axisIndex);\n\t                    if (indices.length) {\n\t                        firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n\t                    }\n\t                }\n\t            }, this);\n\t\n\t            return firstAxisModel;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n\t         */\n\t        eachTargetAxis: function (callback, context) {\n\t            var ecModel = this.ecModel;\n\t            eachAxisDim(function (dimNames) {\n\t                each(\n\t                    this.get(dimNames.axisIndex),\n\t                    function (axisIndex) {\n\t                        callback.call(context, dimNames, axisIndex, this, ecModel);\n\t                    },\n\t                    this\n\t                );\n\t            }, this);\n\t        },\n\t\n\t        getAxisProxy: function (dimName, axisIndex) {\n\t            return this._axisProxies[dimName + '_' + axisIndex];\n\t        },\n\t\n\t        /**\n\t         * If not specified, set to undefined.\n\t         *\n\t         * @public\n\t         * @param {Object} opt\n\t         * @param {number} [opt.start]\n\t         * @param {number} [opt.end]\n\t         * @param {number} [opt.startValue]\n\t         * @param {number} [opt.endValue]\n\t         */\n\t        setRawRange: function (opt) {\n\t            each(['start', 'end', 'startValue', 'endValue'], function (name) {\n\t                // If any of those prop is null/undefined, we should alos set\n\t                // them, because only one pair between start/end and\n\t                // startValue/endValue can work.\n\t                this.option[name] = opt[name];\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @return {Array.<number>} [startPercent, endPercent]\n\t         */\n\t        getPercentRange: function () {\n\t            var axisProxy = this.findRepresentativeAxisProxy();\n\t            if (axisProxy) {\n\t                return axisProxy.getDataPercentWindow();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n\t         *\n\t         * @param {string} [axisDimName]\n\t         * @param {number} [axisIndex]\n\t         * @return {Array.<number>} [startValue, endValue]\n\t         */\n\t        getValueRange: function (axisDimName, axisIndex) {\n\t            if (axisDimName == null && axisIndex == null) {\n\t                var axisProxy = this.findRepresentativeAxisProxy();\n\t                if (axisProxy) {\n\t                    return axisProxy.getDataValueWindow();\n\t                }\n\t            }\n\t            else {\n\t                return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @return {module:echarts/component/dataZoom/AxisProxy}\n\t         */\n\t        findRepresentativeAxisProxy: function () {\n\t            // Find the first hosted axisProxy\n\t            var axisProxies = this._axisProxies;\n\t            for (var key in axisProxies) {\n\t                if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n\t                    return axisProxies[key];\n\t                }\n\t            }\n\t\n\t            // If no hosted axis find not hosted axisProxy.\n\t            // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n\t            // and the option.start or option.end settings are different. The percentRange\n\t            // should follow axisProxy.\n\t            // (We encounter this problem in toolbox data zoom.)\n\t            for (var key in axisProxies) {\n\t                if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n\t                    return axisProxies[key];\n\t                }\n\t            }\n\t        }\n\t\n\t    });\n\t\n\t    function retrieveRaw(option) {\n\t        var ret = {};\n\t        each(\n\t            ['start', 'end', 'startValue', 'endValue', 'throttle'],\n\t            function (name) {\n\t                option.hasOwnProperty(name) && (ret[name] = option[name]);\n\t            }\n\t        );\n\t        return ret;\n\t    }\n\t\n\t    function processRangeProp(percentProp, valueProp, rawOption, thisOption) {\n\t        // start/end has higher priority over startValue/endValue,\n\t        // but we should make chart.setOption({endValue: 1000}) effective,\n\t        // rather than chart.setOption({endValue: 1000, end: null}).\n\t        if (rawOption[valueProp] != null && rawOption[percentProp] == null) {\n\t            thisOption[percentProp] = null;\n\t        }\n\t        // Otherwise do nothing and use the merge result.\n\t    }\n\t\n\t    module.exports = DataZoomModel;\n\t\n\n\n/***/ },\n/* 41 */\n/*!************************************************!*\\\n  !*** ./lib/component/dataZoom/DataZoomView.js ***!\n  \\************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var ComponentView = __webpack_require__(/*! ../../view/Component */ 57);\n\t\n\t    module.exports = ComponentView.extend({\n\t\n\t        type: 'dataZoom',\n\t\n\t        render: function (dataZoomModel, ecModel, api, payload) {\n\t            this.dataZoomModel = dataZoomModel;\n\t            this.ecModel = ecModel;\n\t            this.api = api;\n\t        },\n\t\n\t        /**\n\t         * Find the first target coordinate system.\n\t         *\n\t         * @protected\n\t         * @return {Object} {\n\t         *                   cartesians: [\n\t         *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n\t         *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n\t         *                       ...\n\t         *                   ],  // cartesians must not be null/undefined.\n\t         *                   polars: [\n\t         *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n\t         *                       ...\n\t         *                   ],  // polars must not be null/undefined.\n\t         *                   axisModels: [axis0, axis1, axis2, axis3, axis4]\n\t         *                       // axisModels must not be null/undefined.\n\t         *                  }\n\t         */\n\t        getTargetInfo: function () {\n\t            var dataZoomModel = this.dataZoomModel;\n\t            var ecModel = this.ecModel;\n\t            var cartesians = [];\n\t            var polars = [];\n\t            var axisModels = [];\n\t\n\t            dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n\t                var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n\t                if (axisModel) {\n\t                    axisModels.push(axisModel);\n\t                    var coordSysName;\n\t                    var axisName = dimNames.axis;\n\t\n\t                    if (axisName === 'xAxis' || axisName === 'yAxis') {\n\t                        coordSysName = 'grid';\n\t                    }\n\t                    else if (axisName === 'angleAxis' || axisName === 'radiusAxis') {\n\t                        coordSysName = 'polar';\n\t                    }\n\t\n\t                    var coordModel = coordSysName\n\t                        ? ecModel.queryComponents({\n\t                            mainType: coordSysName,\n\t                            index: axisModel.get(coordSysName + 'Index'),\n\t                            id: axisModel.get(coordSysName + 'Id')\n\t                        })[0]\n\t                        : null;\n\t\n\t                    if (coordModel != null) {\n\t                        save(\n\t                            coordModel,\n\t                            axisModel,\n\t                            coordSysName === 'grid' ? cartesians : polars,\n\t                            coordModel.componentIndex\n\t                        );\n\t                    }\n\t                }\n\t            }, this);\n\t\n\t            function save(coordModel, axisModel, store, coordIndex) {\n\t                var item;\n\t                for (var i = 0; i < store.length; i++) {\n\t                    if (store[i].model === coordModel) {\n\t                        item = store[i];\n\t                        break;\n\t                    }\n\t                }\n\t                if (!item) {\n\t                    store.push(item = {\n\t                        model: coordModel, axisModels: [], coordIndex: coordIndex\n\t                    });\n\t                }\n\t                item.axisModels.push(axisModel);\n\t            }\n\t\n\t            return {\n\t                cartesians: cartesians,\n\t                polars: polars,\n\t                axisModels: axisModels\n\t            };\n\t        }\n\t\n\t    });\n\t\n\n\n/***/ },\n/* 42 */\n/*!***************************!*\\\n  !*** ./lib/coord/Axis.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var numberUtil = __webpack_require__(/*! ../util/number */ 4);\n\t    var linearMap = numberUtil.linearMap;\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    function fixExtentWithBands(extent, nTick) {\n\t        var size = extent[1] - extent[0];\n\t        var len = nTick;\n\t        var margin = size / len / 2;\n\t        extent[0] += margin;\n\t        extent[1] -= margin;\n\t    }\n\t\n\t    var normalizedExtent = [0, 1];\n\t    /**\n\t     * @name module:echarts/coord/CartesianAxis\n\t     * @constructor\n\t     */\n\t    var Axis = function (dim, scale, extent) {\n\t\n\t        /**\n\t         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n\t         * @type {string}\n\t         */\n\t        this.dim = dim;\n\t\n\t        /**\n\t         * Axis scale\n\t         * @type {module:echarts/coord/scale/*}\n\t         */\n\t        this.scale = scale;\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        this._extent = extent || [0, 0];\n\t\n\t        /**\n\t         * @type {boolean}\n\t         */\n\t        this.inverse = false;\n\t\n\t        /**\n\t         * Usually true when axis has a ordinal scale\n\t         * @type {boolean}\n\t         */\n\t        this.onBand = false;\n\t    };\n\t\n\t    Axis.prototype = {\n\t\n\t        constructor: Axis,\n\t\n\t        /**\n\t         * If axis extent contain given coord\n\t         * @param {number} coord\n\t         * @return {boolean}\n\t         */\n\t        contain: function (coord) {\n\t            var extent = this._extent;\n\t            var min = Math.min(extent[0], extent[1]);\n\t            var max = Math.max(extent[0], extent[1]);\n\t            return coord >= min && coord <= max;\n\t        },\n\t\n\t        /**\n\t         * If axis extent contain given data\n\t         * @param {number} data\n\t         * @return {boolean}\n\t         */\n\t        containData: function (data) {\n\t            return this.contain(this.dataToCoord(data));\n\t        },\n\t\n\t        /**\n\t         * Get coord extent.\n\t         * @return {Array.<number>}\n\t         */\n\t        getExtent: function () {\n\t            var ret = this._extent.slice();\n\t            return ret;\n\t        },\n\t\n\t        /**\n\t         * Get precision used for formatting\n\t         * @param {Array.<number>} [dataExtent]\n\t         * @return {number}\n\t         */\n\t        getPixelPrecision: function (dataExtent) {\n\t            return numberUtil.getPixelPrecision(\n\t                dataExtent || this.scale.getExtent(),\n\t                this._extent\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Set coord extent\n\t         * @param {number} start\n\t         * @param {number} end\n\t         */\n\t        setExtent: function (start, end) {\n\t            var extent = this._extent;\n\t            extent[0] = start;\n\t            extent[1] = end;\n\t        },\n\t\n\t        /**\n\t         * Convert data to coord. Data is the rank if it has a ordinal scale\n\t         * @param {number} data\n\t         * @param  {boolean} clamp\n\t         * @return {number}\n\t         */\n\t        dataToCoord: function (data, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t            data = scale.normalize(data);\n\t\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t\n\t            return linearMap(data, normalizedExtent, extent, clamp);\n\t        },\n\t\n\t        /**\n\t         * Convert coord to data. Data is the rank if it has a ordinal scale\n\t         * @param {number} coord\n\t         * @param  {boolean} clamp\n\t         * @return {number}\n\t         */\n\t        coordToData: function (coord, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t\n\t            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\t\n\t            return this.scale.scale(t);\n\t        },\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getTicksCoords: function (alignWithLabel) {\n\t            if (this.onBand && !alignWithLabel) {\n\t                var bands = this.getBands();\n\t                var coords = [];\n\t                for (var i = 0; i < bands.length; i++) {\n\t                    coords.push(bands[i][0]);\n\t                }\n\t                if (bands[i - 1]) {\n\t                    coords.push(bands[i - 1][1]);\n\t                }\n\t                return coords;\n\t            }\n\t            else {\n\t                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Coords of labels are on the ticks or on the middle of bands\n\t         * @return {Array.<number>}\n\t         */\n\t        getLabelsCoords: function () {\n\t            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t        },\n\t\n\t        /**\n\t         * Get bands.\n\t         *\n\t         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n\t         * |---1---|---2---|---3---|---4---|.\n\t         *\n\t         * @return {Array}\n\t         */\n\t         // FIXME Situation when labels is on ticks\n\t        getBands: function () {\n\t            var extent = this.getExtent();\n\t            var bands = [];\n\t            var len = this.scale.count();\n\t            var start = extent[0];\n\t            var end = extent[1];\n\t            var span = end - start;\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                bands.push([\n\t                    span * i / len + start,\n\t                    span * (i + 1) / len + start\n\t                ]);\n\t            }\n\t            return bands;\n\t        },\n\t\n\t        /**\n\t         * Get width of band\n\t         * @return {number}\n\t         */\n\t        getBandWidth: function () {\n\t            var axisExtent = this._extent;\n\t            var dataExtent = this.scale.getExtent();\n\t\n\t            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n\t            // Fix #2728, avoid NaN when only one data.\n\t            len === 0 && (len = 1);\n\t\n\t            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\t\n\t            return Math.abs(size) / len;\n\t        }\n\t    };\n\t\n\t    module.exports = Axis;\n\n\n/***/ },\n/* 43 */\n/*!*******************************!*\\\n  !*** ./lib/util/component.js ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var clazz = __webpack_require__(/*! ./clazz */ 21);\n\t\n\t    var parseClassType = clazz.parseClassType;\n\t\n\t    var base = 0;\n\t\n\t    var componentUtil = {};\n\t\n\t    var DELIMITER = '_';\n\t\n\t    /**\n\t     * @public\n\t     * @param {string} type\n\t     * @return {string}\n\t     */\n\t    componentUtil.getUID = function (type) {\n\t        // Considering the case of crossing js context,\n\t        // use Math.random to make id as unique as possible.\n\t        return [(type || ''), base++, Math.random()].join(DELIMITER);\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    componentUtil.enableSubTypeDefaulter = function (entity) {\n\t\n\t        var subTypeDefaulters = {};\n\t\n\t        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n\t            componentType = parseClassType(componentType);\n\t            subTypeDefaulters[componentType.main] = defaulter;\n\t        };\n\t\n\t        entity.determineSubType = function (componentType, option) {\n\t            var type = option.type;\n\t            if (!type) {\n\t                var componentTypeMain = parseClassType(componentType).main;\n\t                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n\t                    type = subTypeDefaulters[componentTypeMain](option);\n\t                }\n\t            }\n\t            return type;\n\t        };\n\t\n\t        return entity;\n\t    };\n\t\n\t    /**\n\t     * Topological travel on Activity Network (Activity On Vertices).\n\t     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n\t     *\n\t     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n\t     *\n\t     * If there is circle dependencey, Error will be thrown.\n\t     *\n\t     */\n\t    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\t\n\t        /**\n\t         * @public\n\t         * @param {Array.<string>} targetNameList Target Component type list.\n\t         *                                           Can be ['aa', 'bb', 'aa.xx']\n\t         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n\t         * @param {Function} callback Params: componentType, dependencies.\n\t         * @param {Object} context Scope of callback.\n\t         */\n\t        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n\t            if (!targetNameList.length) {\n\t                return;\n\t            }\n\t\n\t            var result = makeDepndencyGraph(fullNameList);\n\t            var graph = result.graph;\n\t            var stack = result.noEntryList;\n\t\n\t            var targetNameSet = {};\n\t            zrUtil.each(targetNameList, function (name) {\n\t                targetNameSet[name] = true;\n\t            });\n\t\n\t            while (stack.length) {\n\t                var currComponentType = stack.pop();\n\t                var currVertex = graph[currComponentType];\n\t                var isInTargetNameSet = !!targetNameSet[currComponentType];\n\t                if (isInTargetNameSet) {\n\t                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n\t                    delete targetNameSet[currComponentType];\n\t                }\n\t                zrUtil.each(\n\t                    currVertex.successor,\n\t                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n\t                );\n\t            }\n\t\n\t            zrUtil.each(targetNameSet, function () {\n\t                throw new Error('Circle dependency may exists');\n\t            });\n\t\n\t            function removeEdge(succComponentType) {\n\t                graph[succComponentType].entryCount--;\n\t                if (graph[succComponentType].entryCount === 0) {\n\t                    stack.push(succComponentType);\n\t                }\n\t            }\n\t\n\t            // Consider this case: legend depends on series, and we call\n\t            // chart.setOption({series: [...]}), where only series is in option.\n\t            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n\t            // not be called, but only sereis.mergeOption is called. Thus legend\n\t            // have no chance to update its local record about series (like which\n\t            // name of series is available in legend).\n\t            function removeEdgeAndAdd(succComponentType) {\n\t                targetNameSet[succComponentType] = true;\n\t                removeEdge(succComponentType);\n\t            }\n\t        };\n\t\n\t        /**\n\t         * DepndencyGraph: {Object}\n\t         * key: conponentType,\n\t         * value: {\n\t         *     successor: [conponentTypes...],\n\t         *     originalDeps: [conponentTypes...],\n\t         *     entryCount: {number}\n\t         * }\n\t         */\n\t        function makeDepndencyGraph(fullNameList) {\n\t            var graph = {};\n\t            var noEntryList = [];\n\t\n\t            zrUtil.each(fullNameList, function (name) {\n\t\n\t                var thisItem = createDependencyGraphItem(graph, name);\n\t                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\t\n\t                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n\t                thisItem.entryCount = availableDeps.length;\n\t                if (thisItem.entryCount === 0) {\n\t                    noEntryList.push(name);\n\t                }\n\t\n\t                zrUtil.each(availableDeps, function (dependentName) {\n\t                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n\t                        thisItem.predecessor.push(dependentName);\n\t                    }\n\t                    var thatItem = createDependencyGraphItem(graph, dependentName);\n\t                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n\t                        thatItem.successor.push(name);\n\t                    }\n\t                });\n\t            });\n\t\n\t            return {graph: graph, noEntryList: noEntryList};\n\t        }\n\t\n\t        function createDependencyGraphItem(graph, name) {\n\t            if (!graph[name]) {\n\t                graph[name] = {predecessor: [], successor: []};\n\t            }\n\t            return graph[name];\n\t        }\n\t\n\t        function getAvailableDependencies(originalDeps, fullNameList) {\n\t            var availableDeps = [];\n\t            zrUtil.each(originalDeps, function (dep) {\n\t                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n\t            });\n\t            return availableDeps;\n\t        }\n\t    };\n\t\n\t    module.exports = componentUtil;\n\n\n/***/ },\n/* 44 */\n/*!***************************************!*\\\n  !*** ./~/zrender/lib/core/timsort.js ***!\n  \\***************************************/\n/***/ function(module, exports) {\n\n\t// https://github.com/mziccard/node-timsort\n\t\n\t    var DEFAULT_MIN_MERGE = 32;\n\t\n\t    var DEFAULT_MIN_GALLOPING = 7;\n\t\n\t    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t\n\t    function minRunLength(n) {\n\t        var r = 0;\n\t\n\t        while (n >= DEFAULT_MIN_MERGE) {\n\t            r |= n & 1;\n\t            n >>= 1;\n\t        }\n\t\n\t        return n + r;\n\t    }\n\t\n\t    function makeAscendingRun(array, lo, hi, compare) {\n\t        var runHi = lo + 1;\n\t\n\t        if (runHi === hi) {\n\t            return 1;\n\t        }\n\t\n\t        if (compare(array[runHi++], array[lo]) < 0) {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t                runHi++;\n\t            }\n\t\n\t            reverseRun(array, lo, runHi);\n\t        }\n\t        else {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t                runHi++;\n\t            }\n\t        }\n\t\n\t        return runHi - lo;\n\t    }\n\t\n\t    function reverseRun(array, lo, hi) {\n\t        hi--;\n\t\n\t        while (lo < hi) {\n\t            var t = array[lo];\n\t            array[lo++] = array[hi];\n\t            array[hi--] = t;\n\t        }\n\t    }\n\t\n\t    function binaryInsertionSort(array, lo, hi, start, compare) {\n\t        if (start === lo) {\n\t            start++;\n\t        }\n\t\n\t        for (; start < hi; start++) {\n\t            var pivot = array[start];\n\t\n\t            var left = lo;\n\t            var right = start;\n\t            var mid;\n\t\n\t            while (left < right) {\n\t                mid = left + right >>> 1;\n\t\n\t                if (compare(pivot, array[mid]) < 0) {\n\t                    right = mid;\n\t                }\n\t                else {\n\t                    left = mid + 1;\n\t                }\n\t            }\n\t\n\t            var n = start - left;\n\t\n\t            switch (n) {\n\t                case 3:\n\t                    array[left + 3] = array[left + 2];\n\t\n\t                case 2:\n\t                    array[left + 2] = array[left + 1];\n\t\n\t                case 1:\n\t                    array[left + 1] = array[left];\n\t                    break;\n\t                default:\n\t                    while (n > 0) {\n\t                        array[left + n] = array[left + n - 1];\n\t                        n--;\n\t                    }\n\t            }\n\t\n\t            array[left] = pivot;\n\t        }\n\t    }\n\t\n\t    function gallopLeft(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) > 0) {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t        else {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) > 0) {\n\t                lastOffset = m + 1;\n\t            }\n\t            else {\n\t                offset = m;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t\n\t    function gallopRight(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) < 0) {\n\t            maxOffset = hint + 1;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t        else {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t\n\t        lastOffset++;\n\t\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) < 0) {\n\t                offset = m;\n\t            }\n\t            else {\n\t                lastOffset = m + 1;\n\t            }\n\t        }\n\t\n\t        return offset;\n\t    }\n\t\n\t    function TimSort(array, compare) {\n\t        var minGallop = DEFAULT_MIN_GALLOPING;\n\t        var length = 0;\n\t        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t        var stackLength = 0;\n\t        var runStart;\n\t        var runLength;\n\t        var stackSize = 0;\n\t\n\t        length = array.length;\n\t\n\t        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t            tmpStorageLength = length >>> 1;\n\t        }\n\t\n\t        var tmp = [];\n\t\n\t        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t\n\t        runStart = [];\n\t        runLength = [];\n\t\n\t        function pushRun(_runStart, _runLength) {\n\t            runStart[stackSize] = _runStart;\n\t            runLength[stackSize] = _runLength;\n\t            stackSize += 1;\n\t        }\n\t\n\t        function mergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t                    if (runLength[n - 1] < runLength[n + 1]) {\n\t                        n--;\n\t                    }\n\t                }\n\t                else if (runLength[n] > runLength[n + 1]) {\n\t                    break;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function forceMergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t                    n--;\n\t                }\n\t\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function mergeAt(i) {\n\t            var start1 = runStart[i];\n\t            var length1 = runLength[i];\n\t            var start2 = runStart[i + 1];\n\t            var length2 = runLength[i + 1];\n\t\n\t            runLength[i] = length1 + length2;\n\t\n\t            if (i === stackSize - 3) {\n\t                runStart[i + 1] = runStart[i + 2];\n\t                runLength[i + 1] = runLength[i + 2];\n\t            }\n\t\n\t            stackSize--;\n\t\n\t            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t            start1 += k;\n\t            length1 -= k;\n\t\n\t            if (length1 === 0) {\n\t                return;\n\t            }\n\t\n\t            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t\n\t            if (length2 === 0) {\n\t                return;\n\t            }\n\t\n\t            if (length1 <= length2) {\n\t                mergeLow(start1, length1, start2, length2);\n\t            }\n\t            else {\n\t                mergeHigh(start1, length1, start2, length2);\n\t            }\n\t        }\n\t\n\t        function mergeLow(start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length1; i++) {\n\t                tmp[i] = array[start1 + i];\n\t            }\n\t\n\t            var cursor1 = 0;\n\t            var cursor2 = start2;\n\t            var dest = start1;\n\t\n\t            array[dest++] = array[cursor2++];\n\t\n\t            if (--length2 === 0) {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t                return;\n\t            }\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t            var count1, count2, exit;\n\t\n\t            while (1) {\n\t                count1 = 0;\n\t                count2 = 0;\n\t                exit = false;\n\t\n\t                do {\n\t                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t                        array[dest++] = array[cursor2++];\n\t                        count2++;\n\t                        count1 = 0;\n\t\n\t                        if (--length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest++] = tmp[cursor1++];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        for (i = 0; i < count1; i++) {\n\t                            array[dest + i] = tmp[cursor1 + i];\n\t                        }\n\t\n\t                        dest += count1;\n\t                        cursor1 += count1;\n\t                        length1 -= count1;\n\t                        if (length1 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest++] = array[cursor2++];\n\t\n\t                    if (--length2 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[dest + i] = array[cursor2 + i];\n\t                        }\n\t\n\t                        dest += count2;\n\t                        cursor2 += count2;\n\t                        length2 -= count2;\n\t\n\t                        if (length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = tmp[cursor1++];\n\t\n\t                    if (--length1 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            minGallop < 1 && (minGallop = 1);\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t            }\n\t            else if (length1 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeLow preconditions were not respected');\n\t            }\n\t            else {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t            }\n\t        }\n\t\n\t        function mergeHigh (start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length2; i++) {\n\t                tmp[i] = array[start2 + i];\n\t            }\n\t\n\t            var cursor1 = start1 + length1 - 1;\n\t            var cursor2 = length2 - 1;\n\t            var dest = start2 + length2 - 1;\n\t            var customCursor = 0;\n\t            var customDest = 0;\n\t\n\t            array[dest--] = array[cursor1--];\n\t\n\t            if (--length1 === 0) {\n\t                customCursor = dest - (length2 - 1);\n\t\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t\n\t            while (true) {\n\t                var count1 = 0;\n\t                var count2 = 0;\n\t                var exit = false;\n\t\n\t                do {\n\t                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t                        array[dest--] = array[cursor1--];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest--] = tmp[cursor2--];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        dest -= count1;\n\t                        cursor1 -= count1;\n\t                        length1 -= count1;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor1 + 1;\n\t\n\t                        for (i = count1 - 1; i >= 0; i--) {\n\t                            array[customDest + i] = array[customCursor + i];\n\t                        }\n\t\n\t                        if (length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = tmp[cursor2--];\n\t\n\t                    if (--length2 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        dest -= count2;\n\t                        cursor2 -= count2;\n\t                        length2 -= count2;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor2 + 1;\n\t\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[customDest + i] = tmp[customCursor + i];\n\t                        }\n\t\n\t                        if (length2 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = array[cursor1--];\n\t\n\t                    if (--length1 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            if (minGallop < 1) {\n\t                minGallop = 1;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t            }\n\t            else if (length2 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeHigh preconditions were not respected');\n\t            }\n\t            else {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t            }\n\t        }\n\t\n\t        this.mergeRuns = mergeRuns;\n\t        this.forceMergeRuns = forceMergeRuns;\n\t        this.pushRun = pushRun;\n\t    }\n\t\n\t    function sort(array, compare, lo, hi) {\n\t        if (!lo) {\n\t            lo = 0;\n\t        }\n\t        if (!hi) {\n\t            hi = array.length;\n\t        }\n\t\n\t        var remaining = hi - lo;\n\t\n\t        if (remaining < 2) {\n\t            return;\n\t        }\n\t\n\t        var runLength = 0;\n\t\n\t        if (remaining < DEFAULT_MIN_MERGE) {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t            return;\n\t        }\n\t\n\t        var ts = new TimSort(array, compare);\n\t\n\t        var minRun = minRunLength(remaining);\n\t\n\t        do {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            if (runLength < minRun) {\n\t                var force = remaining;\n\t                if (force > minRun) {\n\t                    force = minRun;\n\t                }\n\t\n\t                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t                runLength = force;\n\t            }\n\t\n\t            ts.pushRun(lo, runLength);\n\t            ts.mergeRuns();\n\t\n\t            remaining -= runLength;\n\t            lo += runLength;\n\t        } while (remaining !== 0);\n\t\n\t        ts.forceMergeRuns();\n\t    }\n\t\n\t    module.exports = sort;\n\n\n/***/ },\n/* 45 */\n/*!********************************!*\\\n  !*** ./lib/data/DataDiffer.js ***!\n  \\********************************/\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t\n\t    function defaultKeyGetter(item) {\n\t        return item;\n\t    }\n\t\n\t    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n\t        this._old = oldArr;\n\t        this._new = newArr;\n\t\n\t        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n\t        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n\t    }\n\t\n\t    DataDiffer.prototype = {\n\t\n\t        constructor: DataDiffer,\n\t\n\t        /**\n\t         * Callback function when add a data\n\t         */\n\t        add: function (func) {\n\t            this._add = func;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Callback function when update a data\n\t         */\n\t        update: function (func) {\n\t            this._update = func;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Callback function when remove a data\n\t         */\n\t        remove: function (func) {\n\t            this._remove = func;\n\t            return this;\n\t        },\n\t\n\t        execute: function () {\n\t            var oldArr = this._old;\n\t            var newArr = this._new;\n\t            var oldKeyGetter = this._oldKeyGetter;\n\t            var newKeyGetter = this._newKeyGetter;\n\t\n\t            var oldDataIndexMap = {};\n\t            var newDataIndexMap = {};\n\t            var oldDataKeyArr = [];\n\t            var newDataKeyArr = [];\n\t            var i;\n\t\n\t            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n\t            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\t\n\t            // Travel by inverted order to make sure order consistency\n\t            // when duplicate keys exists (consider newDataIndex.pop() below).\n\t            // For performance consideration, these code below do not look neat.\n\t            for (i = 0; i < oldArr.length; i++) {\n\t                var key = oldDataKeyArr[i];\n\t                var idx = newDataIndexMap[key];\n\t\n\t                // idx can never be empty array here. see 'set null' logic below.\n\t                if (idx != null) {\n\t                    // Consider there is duplicate key (for example, use dataItem.name as key).\n\t                    // We should make sure every item in newArr and oldArr can be visited.\n\t                    var len = idx.length;\n\t                    if (len) {\n\t                        len === 1 && (newDataIndexMap[key] = null);\n\t                        idx = idx.unshift();\n\t                    }\n\t                    else {\n\t                        newDataIndexMap[key] = null;\n\t                    }\n\t                    this._update && this._update(idx, i);\n\t                }\n\t                else {\n\t                    this._remove && this._remove(i);\n\t                }\n\t            }\n\t\n\t            for (var i = 0; i < newDataKeyArr.length; i++) {\n\t                var key = newDataKeyArr[i];\n\t                if (newDataIndexMap.hasOwnProperty(key)) {\n\t                    var idx = newDataIndexMap[key];\n\t                    if (idx == null) {\n\t                        continue;\n\t                    }\n\t                    // idx can never be empty array here. see 'set null' logic above.\n\t                    if (!idx.length) {\n\t                        this._add && this._add(idx);\n\t                    }\n\t                    else {\n\t                        for (var j = 0, len = idx.length; j < len; j++) {\n\t                            this._add && this._add(idx[j]);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function initIndexMap(arr, map, keyArr, keyGetter) {\n\t        for (var i = 0; i < arr.length; i++) {\n\t            var key = keyGetter(arr[i], i);\n\t            var existence = map[key];\n\t            if (existence == null) {\n\t                keyArr.push(key);\n\t                map[key] = i;\n\t            }\n\t            else {\n\t                if (!existence.length) {\n\t                    map[key] = existence = [existence];\n\t                }\n\t                existence.push(i);\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = DataDiffer;\n\n\n/***/ },\n/* 46 */\n/*!******************************!*\\\n  !*** ./lib/visual/symbol.js ***!\n  \\******************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\t\n\t        // Encoding visual for all series include which is filtered for legend drawing\n\t        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t\n\t            var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n\t            var symbolSize = seriesModel.get('symbolSize');\n\t\n\t            data.setVisual({\n\t                legendSymbol: legendSymbol || symbolType,\n\t                symbol: symbolType,\n\t                symbolSize: symbolSize\n\t            });\n\t\n\t            // Only visible series has each data be visual encoded\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                if (typeof symbolSize === 'function') {\n\t                    data.each(function (idx) {\n\t                        var rawValue = seriesModel.getRawValue(idx);\n\t                        // FIXME\n\t                        var params = seriesModel.getDataParams(idx);\n\t                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n\t                    });\n\t                }\n\t                data.each(function (idx) {\n\t                    var itemModel = data.getItemModel(idx);\n\t                    var itemSymbolType = itemModel.getShallow('symbol', true);\n\t                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n\t                    // If has item symbol\n\t                    if (itemSymbolType != null) {\n\t                        data.setItemVisual(idx, 'symbol', itemSymbolType);\n\t                    }\n\t                    if (itemSymbolSize != null) {\n\t                        // PENDING Transform symbolSize ?\n\t                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n\t                    }\n\t                });\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n/* 47 */\n/*!***********************************!*\\\n  !*** ./~/zrender/lib/core/log.js ***!\n  \\***********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t        var config = __webpack_require__(/*! ../config */ 33);\n\t\n\t        /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t         */\n\t        module.exports = function() {\n\t            if (config.debugMode === 0) {\n\t                return;\n\t            }\n\t            else if (config.debugMode == 1) {\n\t                for (var k in arguments) {\n\t                    throw new Error(arguments[k]);\n\t                }\n\t            }\n\t            else if (config.debugMode > 1) {\n\t                for (var k in arguments) {\n\t                    console.log(arguments[k]);\n\t                }\n\t            }\n\t        };\n\t\n\t        /* for debug\n\t        return function(mes) {\n\t            document.getElementById('wrong-message').innerHTML =\n\t                mes + ' ' + (new Date() - 0)\n\t                + '<br/>'\n\t                + document.getElementById('wrong-message').innerHTML;\n\t        };\n\t        */\n\t    \n\n\n/***/ },\n/* 48 */\n/*!****************************************!*\\\n  !*** ./~/zrender/lib/graphic/Image.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Image element\n\t * @module zrender/graphic/Image\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(/*! ./Displayable */ 37);\n\t    var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ 8);\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t\n\t    var LRU = __webpack_require__(/*! ../core/LRU */ 150);\n\t    var globalImageCache = new LRU(50);\n\t    /**\n\t     * @alias zrender/graphic/Image\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function ZImage(opts) {\n\t        Displayable.call(this, opts);\n\t    }\n\t\n\t    ZImage.prototype = {\n\t\n\t        constructor: ZImage,\n\t\n\t        type: 'image',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var src = style.image;\n\t            var image;\n\t\n\t            // Must bind each time\n\t            style.bind(ctx, this, prevEl);\n\t            // style.image is a url string\n\t            if (typeof src === 'string') {\n\t                image = this._image;\n\t            }\n\t            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t            else {\n\t                image = src;\n\t            }\n\t            // FIXME Case create many images with src\n\t            if (!image && src) {\n\t                // Try get from global image cache\n\t                var cachedImgObj = globalImageCache.get(src);\n\t                if (!cachedImgObj) {\n\t                    // Create a new image\n\t                    image = new Image();\n\t                    image.onload = function () {\n\t                        image.onload = null;\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t                            cachedImgObj.pending[i].dirty();\n\t                        }\n\t                    };\n\t                    cachedImgObj = {\n\t                        image: image,\n\t                        pending: [this]\n\t                    };\n\t                    image.src = src;\n\t                    globalImageCache.put(src, cachedImgObj);\n\t                    this._image = image;\n\t                    return;\n\t                }\n\t                else {\n\t                    image = cachedImgObj.image;\n\t                    this._image = image;\n\t                    // Image is not complete finish, add to pending list\n\t                    if (!image.width || !image.height) {\n\t                        cachedImgObj.pending.push(this);\n\t                        return;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (image) {\n\t                // \n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\n\t                //     if (!image.complete) {\n\t                //         return;\n\t                //     }\n\t                // }\n\t                // Else is canvas\n\t\n\t                var width = style.width || image.width;\n\t                var height = style.height || image.height;\n\t                var x = style.x || 0;\n\t                var y = style.y || 0;\n\t                // \n\t                if (!image.width || !image.height) {\n\t                    return;\n\t                }\n\t\n\t                // transform\n\t                this.setTransform(ctx);\n\t\n\t\n\t                if (style.sWidth && style.sHeight) {\n\t                    var sx = style.sx || 0;\n\t                    var sy = style.sy || 0;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, style.sWidth, style.sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else if (style.sx && style.sy) {\n\t                    var sx = style.sx;\n\t                    var sy = style.sy;\n\t                    var sWidth = width - sx;\n\t                    var sHeight = height - sy;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, sWidth, sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else {\n\t                    ctx.drawImage(image, x, y, width, height);\n\t                }\n\t\n\t                // \n\t                if (style.width == null) {\n\t                    style.width = width;\n\t                }\n\t                if (style.height == null) {\n\t                    style.height = height;\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t\n\t                // Draw rect text\n\t                if (style.text != null) {\n\t                    this.drawRectText(ctx, this.getBoundingRect());\n\t                }\n\t\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (! this._rect) {\n\t                this._rect = new BoundingRect(\n\t                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n\t                );\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(ZImage, Displayable);\n\t\n\t    module.exports = ZImage;\n\n\n/***/ },\n/* 49 */\n/*!************************************!*\\\n  !*** ./lib/chart/helper/Symbol.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/chart/helper/Symbol\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var symbolUtil = __webpack_require__(/*! ../../util/symbol */ 26);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var numberUtil = __webpack_require__(/*! ../../util/number */ 4);\n\t\n\t    function normalizeSymbolSize(symbolSize) {\n\t        symbolSize = symbolSize instanceof Array\n\t            ? symbolSize.slice()\n\t            : [+symbolSize, +symbolSize];\n\t        symbolSize[0] /= 2;\n\t        symbolSize[1] /= 2;\n\t        return symbolSize;\n\t    }\n\t\n\t    /**\n\t     * @constructor\n\t     * @alias {module:echarts/chart/helper/Symbol}\n\t     * @param {module:echarts/data/List} data\n\t     * @param {number} idx\n\t     * @extends {module:zrender/graphic/Group}\n\t     */\n\t    function Symbol(data, idx, seriesScope) {\n\t        graphic.Group.call(this);\n\t\n\t        this.updateData(data, idx, seriesScope);\n\t    }\n\t\n\t    var symbolProto = Symbol.prototype;\n\t\n\t    function driftSymbol(dx, dy) {\n\t        this.parent.drift(dx, dy);\n\t    }\n\t\n\t    symbolProto._createSymbol = function (symbolType, data, idx) {\n\t        // Remove paths created before\n\t        this.removeAll();\n\t\n\t        var seriesModel = data.hostModel;\n\t        var color = data.getItemVisual(idx, 'color');\n\t\n\t        // var symbolPath = symbolUtil.createSymbol(\n\t        //     symbolType, -0.5, -0.5, 1, 1, color\n\t        // );\n\t        // If width/height are set too small (e.g., set to 1) on ios10\n\t        // and macOS Sierra, a circle stroke become a rect, no matter what\n\t        // the scale is set. So we set width/height as 2. See #4150.\n\t        var symbolPath = symbolUtil.createSymbol(\n\t            symbolType, -1, -1, 2, 2, color\n\t        );\n\t\n\t        symbolPath.attr({\n\t            z2: 100,\n\t            culling: true,\n\t            scale: [0, 0]\n\t        });\n\t        // Rewrite drift method\n\t        symbolPath.drift = driftSymbol;\n\t\n\t        var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\t\n\t        graphic.initProps(symbolPath, {\n\t            scale: size\n\t        }, seriesModel, idx);\n\t        this._symbolType = symbolType;\n\t\n\t        this.add(symbolPath);\n\t    };\n\t\n\t    /**\n\t     * Stop animation\n\t     * @param {boolean} toLastFrame\n\t     */\n\t    symbolProto.stopSymbolAnimation = function (toLastFrame) {\n\t        this.childAt(0).stopAnimation(toLastFrame);\n\t    };\n\t\n\t    /**\n\t     * Get symbol path element\n\t     */\n\t    symbolProto.getSymbolPath = function () {\n\t        return this.childAt(0);\n\t    };\n\t\n\t    /**\n\t     * Get scale(aka, current symbol size).\n\t     * Including the change caused by animation\n\t     */\n\t    symbolProto.getScale = function () {\n\t        return this.childAt(0).scale;\n\t    };\n\t\n\t    /**\n\t     * Highlight symbol\n\t     */\n\t    symbolProto.highlight = function () {\n\t        this.childAt(0).trigger('emphasis');\n\t    };\n\t\n\t    /**\n\t     * Downplay symbol\n\t     */\n\t    symbolProto.downplay = function () {\n\t        this.childAt(0).trigger('normal');\n\t    };\n\t\n\t    /**\n\t     * @param {number} zlevel\n\t     * @param {number} z\n\t     */\n\t    symbolProto.setZ = function (zlevel, z) {\n\t        var symbolPath = this.childAt(0);\n\t        symbolPath.zlevel = zlevel;\n\t        symbolPath.z = z;\n\t    };\n\t\n\t    symbolProto.setDraggable = function (draggable) {\n\t        var symbolPath = this.childAt(0);\n\t        symbolPath.draggable = draggable;\n\t        symbolPath.cursor = draggable ? 'move' : 'pointer';\n\t    };\n\t\n\t    /**\n\t     * Update symbol properties\n\t     * @param  {module:echarts/data/List} data\n\t     * @param  {number} idx\n\t     */\n\t    symbolProto.updateData = function (data, idx, seriesScope) {\n\t        this.silent = false;\n\t\n\t        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n\t        var seriesModel = data.hostModel;\n\t        var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\t        if (symbolType !== this._symbolType) {\n\t            this._createSymbol(symbolType, data, idx);\n\t        }\n\t        else {\n\t            var symbolPath = this.childAt(0);\n\t            graphic.updateProps(symbolPath, {\n\t                scale: symbolSize\n\t            }, seriesModel, idx);\n\t        }\n\t        this._updateCommon(data, idx, symbolSize, seriesScope);\n\t        this._seriesModel = seriesModel;\n\t    };\n\t\n\t    // Update common properties\n\t    var normalStyleAccessPath = ['itemStyle', 'normal'];\n\t    var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\n\t    var normalLabelAccessPath = ['label', 'normal'];\n\t    var emphasisLabelAccessPath = ['label', 'emphasis'];\n\t\n\t    symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n\t        var symbolPath = this.childAt(0);\n\t        var seriesModel = data.hostModel;\n\t        var color = data.getItemVisual(idx, 'color');\n\t\n\t        // Reset style\n\t        if (symbolPath.type !== 'image') {\n\t            symbolPath.useStyle({\n\t                strokeNoScale: true\n\t            });\n\t        }\n\t\n\t        seriesScope = seriesScope || null;\n\t\n\t        var itemStyle = seriesScope && seriesScope.itemStyle;\n\t        var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n\t        var symbolRotate = seriesScope && seriesScope.symbolRotate;\n\t        var symbolOffset = seriesScope && seriesScope.symbolOffset;\n\t        var labelModel = seriesScope && seriesScope.labelModel;\n\t        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n\t        var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n\t\n\t        if (!seriesScope || data.hasItemOption) {\n\t            var itemModel = data.getItemModel(idx);\n\t\n\t            // Color must be excluded.\n\t            // Because symbol provide setColor individually to set fill and stroke\n\t            itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n\t            hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n\t\n\t            symbolRotate = itemModel.getShallow('symbolRotate');\n\t            symbolOffset = itemModel.getShallow('symbolOffset');\n\t\n\t            labelModel = itemModel.getModel(normalLabelAccessPath);\n\t            hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n\t            hoverAnimation = itemModel.getShallow('hoverAnimation');\n\t        }\n\t        else {\n\t            hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n\t        }\n\t\n\t        var elStyle = symbolPath.style;\n\t\n\t        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\t\n\t        if (symbolOffset) {\n\t            symbolPath.attr('position', [\n\t                numberUtil.parsePercent(symbolOffset[0], symbolSize[0]),\n\t                numberUtil.parsePercent(symbolOffset[1], symbolSize[1])\n\t            ]);\n\t        }\n\t\n\t        // PENDING setColor before setStyle!!!\n\t        symbolPath.setColor(color);\n\t\n\t        symbolPath.setStyle(itemStyle);\n\t\n\t        var opacity = data.getItemVisual(idx, 'opacity');\n\t        if (opacity != null) {\n\t            elStyle.opacity = opacity;\n\t        }\n\t\n\t        // Get last value dim\n\t        var dimensions = data.dimensions.slice();\n\t        var valueDim;\n\t        var dataType;\n\t        while (dimensions.length && (\n\t            valueDim = dimensions.pop(),\n\t            dataType = data.getDimensionInfo(valueDim).type,\n\t            dataType === 'ordinal' || dataType === 'time'\n\t        )) {} // jshint ignore:line\n\t\n\t        if (valueDim != null && labelModel.getShallow('show')) {\n\t            graphic.setText(elStyle, labelModel, color);\n\t            elStyle.text = zrUtil.retrieve(\n\t                seriesModel.getFormattedLabel(idx, 'normal'),\n\t                data.get(valueDim, idx)\n\t            );\n\t        }\n\t        else {\n\t            elStyle.text = '';\n\t        }\n\t\n\t        if (valueDim != null && hoverLabelModel.getShallow('show')) {\n\t            graphic.setText(hoverItemStyle, hoverLabelModel, color);\n\t            hoverItemStyle.text = zrUtil.retrieve(\n\t                seriesModel.getFormattedLabel(idx, 'emphasis'),\n\t                data.get(valueDim, idx)\n\t            );\n\t        }\n\t        else {\n\t            hoverItemStyle.text = '';\n\t        }\n\t\n\t        var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\t\n\t        symbolPath.off('mouseover')\n\t            .off('mouseout')\n\t            .off('emphasis')\n\t            .off('normal');\n\t\n\t        symbolPath.hoverStyle = hoverItemStyle;\n\t\n\t        graphic.setHoverStyle(symbolPath);\n\t\n\t        if (hoverAnimation && seriesModel.ifEnableAnimation()) {\n\t            var onEmphasis = function() {\n\t                var ratio = size[1] / size[0];\n\t                this.animateTo({\n\t                    scale: [\n\t                        Math.max(size[0] * 1.1, size[0] + 3),\n\t                        Math.max(size[1] * 1.1, size[1] + 3 * ratio)\n\t                    ]\n\t                }, 400, 'elasticOut');\n\t            };\n\t            var onNormal = function() {\n\t                this.animateTo({\n\t                    scale: size\n\t                }, 400, 'elasticOut');\n\t            };\n\t            symbolPath.on('mouseover', onEmphasis)\n\t                .on('mouseout', onNormal)\n\t                .on('emphasis', onEmphasis)\n\t                .on('normal', onNormal);\n\t        }\n\t    };\n\t\n\t    symbolProto.fadeOut = function (cb) {\n\t        var symbolPath = this.childAt(0);\n\t        // Avoid mistaken hover when fading out\n\t        this.silent = true;\n\t        // Not show text when animating\n\t        symbolPath.style.text = '';\n\t        graphic.updateProps(symbolPath, {\n\t            scale: [0, 0]\n\t        }, this._seriesModel, this.dataIndex, cb);\n\t    };\n\t\n\t    zrUtil.inherits(Symbol, graphic.Group);\n\t\n\t    module.exports = Symbol;\n\n\n/***/ },\n/* 50 */\n/*!*******************************************!*\\\n  !*** ./lib/component/axis/AxisBuilder.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var formatUtil = __webpack_require__(/*! ../../util/format */ 9);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var Model = __webpack_require__(/*! ../../model/Model */ 10);\n\t    var numberUtil = __webpack_require__(/*! ../../util/number */ 4);\n\t    var remRadian = numberUtil.remRadian;\n\t    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n\t    var vec2 = __webpack_require__(/*! zrender/lib/core/vector */ 5);\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var retrieve = zrUtil.retrieve;\n\t\n\t    var PI = Math.PI;\n\t\n\t    function makeAxisEventDataBase(axisModel) {\n\t        var eventData = {\n\t            componentType: axisModel.mainType\n\t        };\n\t        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n\t        return eventData;\n\t    }\n\t\n\t    /**\n\t     * A final axis is translated and rotated from a \"standard axis\".\n\t     * So opt.position and opt.rotation is required.\n\t     *\n\t     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n\t     * for example: (0, 0) ------------> (0, 50)\n\t     *\n\t     * nameDirection or tickDirection or labelDirection is 1 means tick\n\t     * or label is below the standard axis, whereas is -1 means above\n\t     * the standard axis. labelOffset means offset between label and axis,\n\t     * which is useful when 'onZero', where axisLabel is in the grid and\n\t     * label in outside grid.\n\t     *\n\t     * Tips: like always,\n\t     * positive rotation represents anticlockwise, and negative rotation\n\t     * represents clockwise.\n\t     * The direction of position coordinate is the same as the direction\n\t     * of screen coordinate.\n\t     *\n\t     * Do not need to consider axis 'inverse', which is auto processed by\n\t     * axis extent.\n\t     *\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {Object} axisModel\n\t     * @param {Object} opt Standard axis parameters.\n\t     * @param {Array.<number>} opt.position [x, y]\n\t     * @param {number} opt.rotation by radian\n\t     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n\t     * @param {number} [opt.tickDirection=1] 1 or -1\n\t     * @param {number} [opt.labelDirection=1] 1 or -1\n\t     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n\t     * @param {string} [opt.axisLabelShow] default get from axisModel.\n\t     * @param {string} [opt.axisName] default get from axisModel.\n\t     * @param {number} [opt.axisNameAvailableWidth]\n\t     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n\t     * @param {number} [opt.labelInterval] Default label interval when label\n\t     *                                     interval from model is null or 'auto'.\n\t     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n\t     */\n\t    var AxisBuilder = function (axisModel, opt) {\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.opt = opt;\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.axisModel = axisModel;\n\t\n\t        // Default value\n\t        zrUtil.defaults(\n\t            opt,\n\t            {\n\t                labelOffset: 0,\n\t                nameDirection: 1,\n\t                tickDirection: 1,\n\t                labelDirection: 1,\n\t                silent: true\n\t            }\n\t        );\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.group = new graphic.Group();\n\t\n\t        // FIXME Not use a seperate text group?\n\t        var dumbGroup = new graphic.Group({\n\t            position: opt.position.slice(),\n\t            rotation: opt.rotation\n\t        });\n\t\n\t        // this.group.add(dumbGroup);\n\t        // this._dumbGroup = dumbGroup;\n\t\n\t        dumbGroup.updateTransform();\n\t        this._transform = dumbGroup.transform;\n\t\n\t        this._dumbGroup = dumbGroup;\n\t    };\n\t\n\t    AxisBuilder.prototype = {\n\t\n\t        constructor: AxisBuilder,\n\t\n\t        hasBuilder: function (name) {\n\t            return !!builders[name];\n\t        },\n\t\n\t        add: function (name) {\n\t            builders[name].call(this);\n\t        },\n\t\n\t        getGroup: function () {\n\t            return this.group;\n\t        }\n\t\n\t    };\n\t\n\t    var builders = {\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        axisLine: function () {\n\t            var opt = this.opt;\n\t            var axisModel = this.axisModel;\n\t\n\t            if (!axisModel.get('axisLine.show')) {\n\t                return;\n\t            }\n\t\n\t            var extent = this.axisModel.axis.getExtent();\n\t\n\t            var matrix = this._transform;\n\t            var pt1 = [extent[0], 0];\n\t            var pt2 = [extent[1], 0];\n\t            if (matrix) {\n\t                v2ApplyTransform(pt1, pt1, matrix);\n\t                v2ApplyTransform(pt2, pt2, matrix);\n\t            }\n\t\n\t            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t\n\t                // Id for animation\n\t                anid: 'line',\n\t\n\t                shape: {\n\t                    x1: pt1[0],\n\t                    y1: pt1[1],\n\t                    x2: pt2[0],\n\t                    y2: pt2[1]\n\t                },\n\t                style: zrUtil.extend(\n\t                    {lineCap: 'round'},\n\t                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n\t                ),\n\t                strokeContainThreshold: opt.strokeContainThreshold || 5,\n\t                silent: true,\n\t                z2: 1\n\t            })));\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        axisTick: function () {\n\t            var axisModel = this.axisModel;\n\t\n\t            if (!axisModel.get('axisTick.show')) {\n\t                return;\n\t            }\n\t\n\t            var axis = axisModel.axis;\n\t            var tickModel = axisModel.getModel('axisTick');\n\t            var opt = this.opt;\n\t\n\t            var lineStyleModel = tickModel.getModel('lineStyle');\n\t            var tickLen = tickModel.get('length');\n\t\n\t            var tickInterval = getInterval(tickModel, opt.labelInterval);\n\t            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n\t            var ticks = axis.scale.getTicks();\n\t\n\t            var pt1 = [];\n\t            var pt2 = [];\n\t            var matrix = this._transform;\n\t\n\t            for (var i = 0; i < ticksCoords.length; i++) {\n\t                // Only ordinal scale support tick interval\n\t                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n\t                     continue;\n\t                }\n\t\n\t                var tickCoord = ticksCoords[i];\n\t\n\t                pt1[0] = tickCoord;\n\t                pt1[1] = 0;\n\t                pt2[0] = tickCoord;\n\t                pt2[1] = opt.tickDirection * tickLen;\n\t\n\t                if (matrix) {\n\t                    v2ApplyTransform(pt1, pt1, matrix);\n\t                    v2ApplyTransform(pt2, pt2, matrix);\n\t                }\n\t                // Tick line, Not use group transform to have better line draw\n\t                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t\n\t                    // Id for animation\n\t                    anid: 'tick_' + ticks[i],\n\t\n\t                    shape: {\n\t                        x1: pt1[0],\n\t                        y1: pt1[1],\n\t                        x2: pt2[0],\n\t                        y2: pt2[1]\n\t                    },\n\t                    style: zrUtil.defaults(\n\t                        lineStyleModel.getLineStyle(),\n\t                        {\n\t                            stroke: axisModel.get('axisLine.lineStyle.color')\n\t                        }\n\t                    ),\n\t                    z2: 2,\n\t                    silent: true\n\t                })));\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n\t         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t         * @private\n\t         */\n\t        axisLabel: function () {\n\t            var opt = this.opt;\n\t            var axisModel = this.axisModel;\n\t            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\t\n\t            if (!show) {\n\t                return;\n\t            }\n\t\n\t            var axis = axisModel.axis;\n\t            var labelModel = axisModel.getModel('axisLabel');\n\t            var textStyleModel = labelModel.getModel('textStyle');\n\t            var labelMargin = labelModel.get('margin');\n\t            var ticks = axis.scale.getTicks();\n\t            var labels = axisModel.getFormattedLabels();\n\t\n\t            // Special label rotate.\n\t            var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n\t            // To radian.\n\t            labelRotation = labelRotation * PI / 180;\n\t\n\t            var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n\t            var categoryData = axisModel.get('data');\n\t\n\t            var textEls = [];\n\t            var silent = isSilent(axisModel);\n\t            var triggerEvent = axisModel.get('triggerEvent');\n\t\n\t            for (var i = 0; i < ticks.length; i++) {\n\t                if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {\n\t                     continue;\n\t                }\n\t\n\t                var itemTextStyleModel = textStyleModel;\n\t                if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n\t                    itemTextStyleModel = new Model(\n\t                        categoryData[i].textStyle, textStyleModel, axisModel.ecModel\n\t                    );\n\t                }\n\t                var textColor = itemTextStyleModel.getTextColor()\n\t                    || axisModel.get('axisLine.lineStyle.color');\n\t\n\t                var tickCoord = axis.dataToCoord(ticks[i]);\n\t                var pos = [\n\t                    tickCoord,\n\t                    opt.labelOffset + opt.labelDirection * labelMargin\n\t                ];\n\t                var labelBeforeFormat = axis.scale.getLabel(ticks[i]);\n\t\n\t                var textEl = new graphic.Text({\n\t\n\t                    // Id for animation\n\t                    anid: 'label_' + ticks[i],\n\t\n\t                    style: {\n\t                        text: labels[i],\n\t                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n\t                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n\t                        textFont: itemTextStyleModel.getFont(),\n\t                        fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n\t                    },\n\t                    position: pos,\n\t                    rotation: labelLayout.rotation,\n\t                    silent: silent,\n\t                    z2: 10\n\t                });\n\t\n\t                // Pack data for mouse event\n\t                if (triggerEvent) {\n\t                    textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                    textEl.eventData.targetType = 'axisLabel';\n\t                    textEl.eventData.value = labelBeforeFormat;\n\t                }\n\t\n\t\n\t                // FIXME\n\t                this._dumbGroup.add(textEl);\n\t                textEl.updateTransform();\n\t\n\t                textEls.push(textEl);\n\t                this.group.add(textEl);\n\t\n\t                textEl.decomposeTransform();\n\t            }\n\t\n\t            function isTwoLabelOverlapped(current, next) {\n\t                var firstRect = current && current.getBoundingRect().clone();\n\t                var nextRect = next && next.getBoundingRect().clone();\n\t                if (firstRect && nextRect) {\n\t                    firstRect.applyTransform(current.getLocalTransform());\n\t                    nextRect.applyTransform(next.getLocalTransform());\n\t                    return firstRect.intersect(nextRect);\n\t                }\n\t            }\n\t            if (axis.type !== 'category') {\n\t                // If min or max are user set, we need to check\n\t                // If the tick on min(max) are overlap on their neighbour tick\n\t                // If they are overlapped, we need to hide the min(max) tick label\n\t                if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {\n\t                    var firstLabel = textEls[0];\n\t                    var nextLabel = textEls[1];\n\t                    if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n\t                        firstLabel.ignore = true;\n\t                    }\n\t                }\n\t                if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {\n\t                    var lastLabel = textEls[textEls.length - 1];\n\t                    var prevLabel = textEls[textEls.length - 2];\n\t                    if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n\t                        lastLabel.ignore = true;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        axisName: function () {\n\t            var opt = this.opt;\n\t            var axisModel = this.axisModel;\n\t            var name = retrieve(opt.axisName, axisModel.get('name'));\n\t\n\t            if (!name) {\n\t                return;\n\t            }\n\t\n\t            var nameLocation = axisModel.get('nameLocation');\n\t            var nameDirection = opt.nameDirection;\n\t            var textStyleModel = axisModel.getModel('nameTextStyle');\n\t            var gap = axisModel.get('nameGap') || 0;\n\t\n\t            var extent = this.axisModel.axis.getExtent();\n\t            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n\t            var pos = [\n\t                nameLocation === 'start'\n\t                    ? extent[0] - gapSignal * gap\n\t                    : nameLocation === 'end'\n\t                    ? extent[1] + gapSignal * gap\n\t                    : (extent[0] + extent[1]) / 2, // 'middle'\n\t                // Reuse labelOffset.\n\t                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n\t            ];\n\t\n\t            var labelLayout;\n\t\n\t            var nameRotation = axisModel.get('nameRotate');\n\t            if (nameRotation != null) {\n\t                nameRotation = nameRotation * PI / 180; // To radian.\n\t            }\n\t\n\t            var axisNameAvailableWidth;\n\t\n\t            if (nameLocation === 'middle') {\n\t                labelLayout = innerTextLayout(\n\t                    opt,\n\t                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n\t                    nameDirection\n\t                );\n\t            }\n\t            else {\n\t                labelLayout = endTextLayout(\n\t                    opt, nameLocation, nameRotation || 0, extent\n\t                );\n\t\n\t                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\t                if (axisNameAvailableWidth != null) {\n\t                    axisNameAvailableWidth = Math.abs(\n\t                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n\t                    );\n\t                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n\t                }\n\t            }\n\t\n\t            var textFont = textStyleModel.getFont();\n\t\n\t            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n\t            var ellipsis = truncateOpt.ellipsis;\n\t            var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n\t            var truncatedText = (ellipsis != null && maxWidth != null)\n\t                ? formatUtil.truncateText(\n\t                    name, maxWidth, textFont, ellipsis,\n\t                    {minChar: 2, placeholder: truncateOpt.placeholder}\n\t                )\n\t                : name;\n\t\n\t            var tooltipOpt = axisModel.get('tooltip', true);\n\t\n\t            var mainType = axisModel.mainType;\n\t            var formatterParams = {\n\t                componentType: mainType,\n\t                name: name,\n\t                $vars: ['name']\n\t            };\n\t            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\t\n\t            var textEl = new graphic.Text({\n\t\n\t                // Id for animation\n\t                anid: 'name',\n\t\n\t                __fullText: name,\n\t                __truncatedText: truncatedText,\n\t\n\t                style: {\n\t                    text: truncatedText,\n\t                    textFont: textFont,\n\t                    fill: textStyleModel.getTextColor()\n\t                        || axisModel.get('axisLine.lineStyle.color'),\n\t                    textAlign: labelLayout.textAlign,\n\t                    textVerticalAlign: labelLayout.verticalAlign\n\t                },\n\t                position: pos,\n\t                rotation: labelLayout.rotation,\n\t                silent: isSilent(axisModel),\n\t                z2: 1,\n\t                tooltip: (tooltipOpt && tooltipOpt.show)\n\t                    ? zrUtil.extend({\n\t                        content: name,\n\t                        formatter: function () {\n\t                            return name;\n\t                        },\n\t                        formatterParams: formatterParams\n\t                    }, tooltipOpt)\n\t                    : null\n\t            });\n\t\n\t            if (axisModel.get('triggerEvent')) {\n\t                textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                textEl.eventData.targetType = 'axisName';\n\t                textEl.eventData.name = name;\n\t            }\n\t\n\t            // FIXME\n\t            this._dumbGroup.add(textEl);\n\t            textEl.updateTransform();\n\t\n\t            this.group.add(textEl);\n\t\n\t            textEl.decomposeTransform();\n\t        }\n\t\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function innerTextLayout(opt, textRotation, direction) {\n\t        var rotationDiff = remRadian(textRotation - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t\n\t        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        }\n\t        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        }\n\t        else {\n\t            verticalAlign = 'middle';\n\t\n\t            if (rotationDiff > 0 && rotationDiff < PI) {\n\t                textAlign = direction > 0 ? 'right' : 'left';\n\t            }\n\t            else {\n\t                textAlign = direction > 0 ? 'left' : 'right';\n\t            }\n\t        }\n\t\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function endTextLayout(opt, textPosition, textRotate, extent) {\n\t        var rotationDiff = remRadian(textRotate - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t        var inverse = extent[0] > extent[1];\n\t        var onLeft = (textPosition === 'start' && !inverse)\n\t            || (textPosition !== 'start' && inverse);\n\t\n\t        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n\t            verticalAlign = onLeft ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        }\n\t        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n\t            verticalAlign = onLeft ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        }\n\t        else {\n\t            verticalAlign = 'middle';\n\t            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n\t                textAlign = onLeft ? 'left' : 'right';\n\t            }\n\t            else {\n\t                textAlign = onLeft ? 'right' : 'left';\n\t            }\n\t        }\n\t\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function isSilent(axisModel) {\n\t        var tooltipOpt = axisModel.get('tooltip');\n\t        return axisModel.get('silent')\n\t            // Consider mouse cursor, add these restrictions.\n\t            || !(\n\t                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n\t            );\n\t    }\n\t\n\t    /**\n\t     * @static\n\t     */\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n\t        var rawTick;\n\t        var scale = axis.scale;\n\t        return scale.type === 'ordinal'\n\t            && (\n\t                typeof interval === 'function'\n\t                    ? (\n\t                        rawTick = scale.getTicks()[i],\n\t                        !interval(rawTick, scale.getLabel(rawTick))\n\t                    )\n\t                    : i % (interval + 1)\n\t            );\n\t    };\n\t\n\t    /**\n\t     * @static\n\t     */\n\t    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n\t        var interval = model.get('interval');\n\t        if (interval == null || interval == 'auto') {\n\t            interval = labelInterval;\n\t        }\n\t        return interval;\n\t    };\n\t\n\t    module.exports = AxisBuilder;\n\t\n\n\n/***/ },\n/* 51 */\n/*!*******************************************!*\\\n  !*** ./lib/coord/axisModelCommonMixin.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var axisHelper = __webpack_require__(/*! ./axisHelper */ 22);\n\t\n\t    function getName(obj) {\n\t        if (zrUtil.isObject(obj) && obj.value != null) {\n\t            return obj.value;\n\t        }\n\t        else {\n\t            return obj;\n\t        }\n\t    }\n\t    /**\n\t     * Get categories\n\t     */\n\t    function getCategories() {\n\t        return this.get('type') === 'category'\n\t            && zrUtil.map(this.get('data'), getName);\n\t    }\n\t\n\t    /**\n\t     * Format labels\n\t     * @return {Array.<string>}\n\t     */\n\t    function getFormattedLabels() {\n\t        return axisHelper.getFormattedLabels(\n\t            this.axis,\n\t            this.get('axisLabel.formatter')\n\t        );\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        getFormattedLabels: getFormattedLabels,\n\t\n\t        getCategories: getCategories\n\t    };\n\n\n/***/ },\n/* 52 */\n/*!***************************************!*\\\n  !*** ./lib/coord/axisModelCreator.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var axisDefault = __webpack_require__(/*! ./axisDefault */ 81);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var ComponentModel = __webpack_require__(/*! ../model/Component */ 12);\n\t    var layout = __webpack_require__(/*! ../util/layout */ 13);\n\t\n\t    // FIXME axisType is fixed ?\n\t    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\t\n\t    /**\n\t     * Generate sub axis model class\n\t     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n\t     * @param {module:echarts/model/Component} BaseAxisModelClass\n\t     * @param {Function} axisTypeDefaulter\n\t     * @param {Object} [extraDefaultOption]\n\t     */\n\t    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\t\n\t        zrUtil.each(AXIS_TYPES, function (axisType) {\n\t\n\t            BaseAxisModelClass.extend({\n\t\n\t                type: axisName + 'Axis.' + axisType,\n\t\n\t                mergeDefaultAndTheme: function (option, ecModel) {\n\t                    var layoutMode = this.layoutMode;\n\t                    var inputPositionParams = layoutMode\n\t                        ? layout.getLayoutParams(option) : {};\n\t\n\t                    var themeModel = ecModel.getTheme();\n\t                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n\t                    zrUtil.merge(option, this.getDefaultOption());\n\t\n\t                    option.type = axisTypeDefaulter(axisName, option);\n\t\n\t                    if (layoutMode) {\n\t                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t                    }\n\t                },\n\t\n\t                defaultOption: zrUtil.mergeAll(\n\t                    [\n\t                        {},\n\t                        axisDefault[axisType + 'Axis'],\n\t                        extraDefaultOption\n\t                    ],\n\t                    true\n\t                )\n\t            });\n\t        });\n\t\n\t        ComponentModel.registerSubTypeDefaulter(\n\t            axisName + 'Axis',\n\t            zrUtil.curry(axisTypeDefaulter, axisName)\n\t        );\n\t    };\n\n\n/***/ },\n/* 53 */\n/*!******************************************!*\\\n  !*** ./lib/coord/cartesian/AxisModel.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var ComponentModel = __webpack_require__(/*! ../../model/Component */ 12);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var axisModelCreator = __webpack_require__(/*! ../axisModelCreator */ 52);\n\t\n\t    var AxisModel = ComponentModel.extend({\n\t\n\t        type: 'cartesian2dAxis',\n\t\n\t        /**\n\t         * @type {module:echarts/coord/cartesian/Axis2D}\n\t         */\n\t        axis: null,\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        init: function () {\n\t            AxisModel.superApply(this, 'init', arguments);\n\t            this.resetRange();\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        mergeOption: function () {\n\t            AxisModel.superApply(this, 'mergeOption', arguments);\n\t            this.resetRange();\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        restoreData: function () {\n\t            AxisModel.superApply(this, 'restoreData', arguments);\n\t            this.resetRange();\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/model/Model}\n\t         */\n\t        findGridModel: function () {\n\t            return this.ecModel.queryComponents({\n\t                mainType: 'grid',\n\t                index: this.get('gridIndex'),\n\t                id: this.get('gridId')\n\t            })[0];\n\t        }\n\t\n\t    });\n\t\n\t    function getAxisType(axisDim, option) {\n\t        // Default axis with data is category axis\n\t        return option.type || (option.data ? 'category' : 'value');\n\t    }\n\t\n\t    zrUtil.merge(AxisModel.prototype, __webpack_require__(/*! ../axisModelCommonMixin */ 51));\n\t    zrUtil.merge(AxisModel.prototype, __webpack_require__(/*! ../axisModelZoomMixin */ 82));\n\t\n\t    var extraOption = {\n\t        // gridIndex: 0,\n\t        // gridId: '',\n\t\n\t        // Offset is for multiple axis on the same position\n\t        offset: 0\n\t    };\n\t\n\t    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n\t    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\t\n\t    module.exports = AxisModel;\n\n\n/***/ },\n/* 54 */\n/*!*************************************!*\\\n  !*** ./lib/coord/cartesian/Grid.js ***!\n  \\*************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Grid is a region which contains at most 4 cartesian systems\n\t *\n\t * TODO Default cartesian\n\t */\n\tvar factory = exports;\n\t\n\t    var layout = __webpack_require__(/*! ../../util/layout */ 13);\n\t    var axisHelper = __webpack_require__(/*! ../../coord/axisHelper */ 22);\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var Cartesian2D = __webpack_require__(/*! ./Cartesian2D */ 119);\n\t    var Axis2D = __webpack_require__(/*! ./Axis2D */ 117);\n\t\n\t    var each = zrUtil.each;\n\t\n\t    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n\t    var niceScaleExtent = axisHelper.niceScaleExtent;\n\t\n\t    //  GridModel, AxisModel \n\t    __webpack_require__(/*! ./GridModel */ 120);\n\t\n\t    /**\n\t     * Check if the axis is used in the specified grid\n\t     * @inner\n\t     */\n\t    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n\t        return axisModel.findGridModel() === gridModel;\n\t    }\n\t\n\t    function getLabelUnionRect(axis) {\n\t        var axisModel = axis.model;\n\t        var labels = axisModel.getFormattedLabels();\n\t        var rect;\n\t        var step = 1;\n\t        var labelCount = labels.length;\n\t        if (labelCount > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.ceil(labelCount / 40);\n\t        }\n\t        for (var i = 0; i < labelCount; i += step) {\n\t            if (!axis.isLabelIgnored(i)) {\n\t                var singleRect = axisModel.getTextRect(labels[i]);\n\t                // FIXME consider label rotate\n\t                rect ? rect.union(singleRect) : (rect = singleRect);\n\t            }\n\t        }\n\t        return rect;\n\t    }\n\t\n\t    function Grid(gridModel, ecModel, api) {\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n\t         * @private\n\t         */\n\t        this._coordsMap = {};\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n\t         * @private\n\t         */\n\t        this._coordsList = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesMap = {};\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesList = [];\n\t\n\t        this._initCartesian(gridModel, ecModel, api);\n\t\n\t        this._model = gridModel;\n\t    }\n\t\n\t    var gridProto = Grid.prototype;\n\t\n\t    gridProto.type = 'grid';\n\t\n\t    gridProto.getRect = function () {\n\t        return this._rect;\n\t    };\n\t\n\t    gridProto.update = function (ecModel, api) {\n\t\n\t        var axesMap = this._axesMap;\n\t\n\t        this._updateScale(ecModel, this._model);\n\t\n\t        function ifAxisCanNotOnZero(otherAxisDim) {\n\t            var axes = axesMap[otherAxisDim];\n\t            for (var idx in axes) {\n\t                if (axes.hasOwnProperty(idx)) {\n\t                    var axis = axes[idx];\n\t                    if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n\t                        return true;\n\t                    }\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t\n\t        each(axesMap.x, function (xAxis) {\n\t            niceScaleExtent(xAxis, xAxis.model);\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            niceScaleExtent(yAxis, yAxis.model);\n\t        });\n\t        // Fix configuration\n\t        each(axesMap.x, function (xAxis) {\n\t            // onZero can not be enabled in these two situations\n\t            // 1. When any other axis is a category axis\n\t            // 2. When any other axis not across 0 point\n\t            if (ifAxisCanNotOnZero('y')) {\n\t                xAxis.onZero = false;\n\t            }\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            if (ifAxisCanNotOnZero('x')) {\n\t                yAxis.onZero = false;\n\t            }\n\t        });\n\t\n\t        // Resize again if containLabel is enabled\n\t        // FIXME It may cause getting wrong grid size in data processing stage\n\t        this.resize(this._model, api);\n\t    };\n\t\n\t    /**\n\t     * Resize the grid\n\t     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    gridProto.resize = function (gridModel, api) {\n\t\n\t        var gridRect = layout.getLayoutRect(\n\t            gridModel.getBoxLayoutParams(), {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t\n\t        this._rect = gridRect;\n\t\n\t        var axesList = this._axesList;\n\t\n\t        adjustAxes();\n\t\n\t        // Minus label size\n\t        if (gridModel.get('containLabel')) {\n\t            each(axesList, function (axis) {\n\t                if (!axis.model.get('axisLabel.inside')) {\n\t                    var labelUnionRect = getLabelUnionRect(axis);\n\t                    if (labelUnionRect) {\n\t                        var dim = axis.isHorizontal() ? 'height' : 'width';\n\t                        var margin = axis.model.get('axisLabel.margin');\n\t                        gridRect[dim] -= labelUnionRect[dim] + margin;\n\t                        if (axis.position === 'top') {\n\t                            gridRect.y += labelUnionRect.height + margin;\n\t                        }\n\t                        else if (axis.position === 'left')  {\n\t                            gridRect.x += labelUnionRect.width + margin;\n\t                        }\n\t                    }\n\t                }\n\t            });\n\t\n\t            adjustAxes();\n\t        }\n\t\n\t        function adjustAxes() {\n\t            each(axesList, function (axis) {\n\t                var isHorizontal = axis.isHorizontal();\n\t                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n\t                var idx = axis.inverse ? 1 : 0;\n\t                axis.setExtent(extent[idx], extent[1 - idx]);\n\t                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {string} axisType\n\t     * @param {ndumber} [axisIndex]\n\t     */\n\t    gridProto.getAxis = function (axisType, axisIndex) {\n\t        var axesMapOnDim = this._axesMap[axisType];\n\t        if (axesMapOnDim != null) {\n\t            if (axisIndex == null) {\n\t                // Find first axis\n\t                for (var name in axesMapOnDim) {\n\t                    if (axesMapOnDim.hasOwnProperty(name)) {\n\t                        return axesMapOnDim[name];\n\t                    }\n\t                }\n\t            }\n\t            return axesMapOnDim[axisIndex];\n\t        }\n\t    };\n\t\n\t    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n\t        if (xAxisIndex != null && yAxisIndex != null) {\n\t            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t            return this._coordsMap[key];\n\t        }\n\t        else {\n\t            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\t            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n\t                if (coordList[i].getAxis('x').index === xAxisIndex\n\t                    || coordList[i].getAxis('y').index === yAxisIndex\n\t                ) {\n\t                    return coordList[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @implements\n\t     * see {module:echarts/CoodinateSystem}\n\t     */\n\t    gridProto.convertToPixel = function (ecModel, finder, value) {\n\t        var target = this._findConvertTarget(ecModel, finder);\n\t\n\t        return target.cartesian\n\t            ? target.cartesian.dataToPoint(value)\n\t            : target.axis\n\t            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n\t            : null;\n\t    };\n\t\n\t    /**\n\t     * @implements\n\t     * see {module:echarts/CoodinateSystem}\n\t     */\n\t    gridProto.convertFromPixel = function (ecModel, finder, value) {\n\t        var target = this._findConvertTarget(ecModel, finder);\n\t\n\t        return target.cartesian\n\t            ? target.cartesian.pointToData(value)\n\t            : target.axis\n\t            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n\t            : null;\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    gridProto._findConvertTarget = function (ecModel, finder) {\n\t        var seriesModel = finder.seriesModel;\n\t        var xAxisModel = finder.xAxisModel\n\t            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n\t        var yAxisModel = finder.yAxisModel\n\t            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n\t        var gridModel = finder.gridModel;\n\t        var coordsList = this._coordsList;\n\t        var cartesian;\n\t        var axis;\n\t\n\t        if (seriesModel) {\n\t            cartesian = seriesModel.coordinateSystem;\n\t            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n\t        }\n\t        else if (xAxisModel && yAxisModel) {\n\t            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n\t        }\n\t        else if (xAxisModel) {\n\t            axis = this.getAxis('x', xAxisModel.componentIndex);\n\t        }\n\t        else if (yAxisModel) {\n\t            axis = this.getAxis('y', yAxisModel.componentIndex);\n\t        }\n\t        // Lowest priority.\n\t        else if (gridModel) {\n\t            var grid = gridModel.coordinateSystem;\n\t            if (grid === this) {\n\t                cartesian = this._coordsList[0];\n\t            }\n\t        }\n\t\n\t        return {cartesian: cartesian, axis: axis};\n\t    };\n\t\n\t    /**\n\t     * @implements\n\t     * see {module:echarts/CoodinateSystem}\n\t     */\n\t    gridProto.containPoint = function (point) {\n\t        var coord = this._coordsList[0];\n\t        if (coord) {\n\t            return coord.containPoint(point);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Initialize cartesian coordinate systems\n\t     * @private\n\t     */\n\t    gridProto._initCartesian = function (gridModel, ecModel, api) {\n\t        var axisPositionUsed = {\n\t            left: false,\n\t            right: false,\n\t            top: false,\n\t            bottom: false\n\t        };\n\t\n\t        var axesMap = {\n\t            x: {},\n\t            y: {}\n\t        };\n\t        var axesCount = {\n\t            x: 0,\n\t            y: 0\n\t        };\n\t\n\t        /// Create axis\n\t        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n\t        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\t\n\t        if (!axesCount.x || !axesCount.y) {\n\t            // Roll back when there no either x or y axis\n\t            this._axesMap = {};\n\t            this._axesList = [];\n\t            return;\n\t        }\n\t\n\t        this._axesMap = axesMap;\n\t\n\t        /// Create cartesian2d\n\t        each(axesMap.x, function (xAxis, xAxisIndex) {\n\t            each(axesMap.y, function (yAxis, yAxisIndex) {\n\t                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t                var cartesian = new Cartesian2D(key);\n\t\n\t                cartesian.grid = this;\n\t\n\t                this._coordsMap[key] = cartesian;\n\t                this._coordsList.push(cartesian);\n\t\n\t                cartesian.addAxis(xAxis);\n\t                cartesian.addAxis(yAxis);\n\t            }, this);\n\t        }, this);\n\t\n\t        function createAxisCreator(axisType) {\n\t            return function (axisModel, idx) {\n\t                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n\t                    return;\n\t                }\n\t\n\t                var axisPosition = axisModel.get('position');\n\t                if (axisType === 'x') {\n\t                    // Fix position\n\t                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n\t                        // Default bottom of X\n\t                        axisPosition = 'bottom';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    // Fix position\n\t                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n\t                        // Default left of Y\n\t                        axisPosition = 'left';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n\t                        }\n\t                    }\n\t                }\n\t                axisPositionUsed[axisPosition] = true;\n\t\n\t                var axis = new Axis2D(\n\t                    axisType, axisHelper.createScaleByModel(axisModel),\n\t                    [0, 0],\n\t                    axisModel.get('type'),\n\t                    axisPosition\n\t                );\n\t\n\t                var isCategory = axis.type === 'category';\n\t                axis.onBand = isCategory && axisModel.get('boundaryGap');\n\t                axis.inverse = axisModel.get('inverse');\n\t\n\t                axis.onZero = axisModel.get('axisLine.onZero');\n\t\n\t                // Inject axis into axisModel\n\t                axisModel.axis = axis;\n\t\n\t                // Inject axisModel into axis\n\t                axis.model = axisModel;\n\t\n\t                // Inject grid info axis\n\t                axis.grid = this;\n\t\n\t                // Index of axis, can be used as key\n\t                axis.index = idx;\n\t\n\t                this._axesList.push(axis);\n\t\n\t                axesMap[axisType][idx] = axis;\n\t                axesCount[axisType]++;\n\t            };\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Update cartesian properties from series\n\t     * @param  {module:echarts/model/Option} option\n\t     * @private\n\t     */\n\t    gridProto._updateScale = function (ecModel, gridModel) {\n\t        // Reset scale\n\t        zrUtil.each(this._axesList, function (axis) {\n\t            axis.scale.setExtent(Infinity, -Infinity);\n\t        });\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (isCartesian2D(seriesModel)) {\n\t                var axesModels = findAxesModels(seriesModel, ecModel);\n\t                var xAxisModel = axesModels[0];\n\t                var yAxisModel = axesModels[1];\n\t\n\t                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n\t                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n\t                 ) {\n\t                    return;\n\t                }\n\t\n\t                var cartesian = this.getCartesian(\n\t                    xAxisModel.componentIndex, yAxisModel.componentIndex\n\t                );\n\t                var data = seriesModel.getData();\n\t                var xAxis = cartesian.getAxis('x');\n\t                var yAxis = cartesian.getAxis('y');\n\t\n\t                if (data.type === 'list') {\n\t                    unionExtent(data, xAxis, seriesModel);\n\t                    unionExtent(data, yAxis, seriesModel);\n\t                }\n\t            }\n\t        }, this);\n\t\n\t        function unionExtent(data, axis, seriesModel) {\n\t            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n\t                axis.scale.unionExtent(data.getDataExtent(\n\t                    dim, axis.scale.type !== 'ordinal'\n\t                ));\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function updateAxisTransfrom(axis, coordBase) {\n\t        var axisExtent = axis.getExtent();\n\t        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\t\n\t        // Fast transform\n\t        axis.toGlobalCoord = axis.dim === 'x'\n\t            ? function (coord) {\n\t                return coord + coordBase;\n\t            }\n\t            : function (coord) {\n\t                return axisExtentSum - coord + coordBase;\n\t            };\n\t        axis.toLocalCoord = axis.dim === 'x'\n\t            ? function (coord) {\n\t                return coord - coordBase;\n\t            }\n\t            : function (coord) {\n\t                return axisExtentSum - coord + coordBase;\n\t            };\n\t    }\n\t\n\t    var axesTypes = ['xAxis', 'yAxis'];\n\t    /**\n\t     * @inner\n\t     */\n\t    function findAxesModels(seriesModel, ecModel) {\n\t        return zrUtil.map(axesTypes, function (axisType) {\n\t            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\t\n\t            if (false) {\n\t                if (!axisModel) {\n\t                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n\t                        seriesModel.get(axisType + 'Index'),\n\t                        seriesModel.get(axisType + 'Id'),\n\t                        0\n\t                    ) + '\" not found');\n\t                }\n\t            }\n\t            return axisModel;\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function isCartesian2D(seriesModel) {\n\t        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n\t    }\n\t\n\t    Grid.create = function (ecModel, api) {\n\t        var grids = [];\n\t        ecModel.eachComponent('grid', function (gridModel, idx) {\n\t            var grid = new Grid(gridModel, ecModel, api);\n\t            grid.name = 'grid_' + idx;\n\t            grid.resize(gridModel, api);\n\t\n\t            gridModel.coordinateSystem = grid;\n\t\n\t            grids.push(grid);\n\t        });\n\t\n\t        // Inject the coordinateSystems into seriesModel\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (!isCartesian2D(seriesModel)) {\n\t                return;\n\t            }\n\t\n\t            var axesModels = findAxesModels(seriesModel, ecModel);\n\t            var xAxisModel = axesModels[0];\n\t            var yAxisModel = axesModels[1];\n\t\n\t            var gridModel = xAxisModel.findGridModel();\n\t\n\t            if (false) {\n\t                if (!gridModel) {\n\t                    throw new Error(\n\t                        'Grid \"' + zrUtil.retrieve(\n\t                            xAxisModel.get('gridIndex'),\n\t                            xAxisModel.get('gridId'),\n\t                            0\n\t                        ) + '\" not found'\n\t                    );\n\t                }\n\t                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {\n\t                    throw new Error('xAxis and yAxis must use the same grid');\n\t                }\n\t            }\n\t\n\t            var grid = gridModel.coordinateSystem;\n\t\n\t            seriesModel.coordinateSystem = grid.getCartesian(\n\t                xAxisModel.componentIndex, yAxisModel.componentIndex\n\t            );\n\t        });\n\t\n\t        return grids;\n\t    };\n\t\n\t    // For deciding which dimensions to use when creating list data\n\t    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\t\n\t    __webpack_require__(/*! ../../CoordinateSystem */ 23).register('cartesian2d', Grid);\n\t\n\t    module.exports = Grid;\n\n\n/***/ },\n/* 55 */\n/*!******************************!*\\\n  !*** ./lib/layout/points.js ***!\n  \\******************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = function (seriesType, ecModel) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var coordSys = seriesModel.coordinateSystem;\n\t\n\t            if (coordSys) {\n\t                var dims = coordSys.dimensions;\n\t\n\t                if (coordSys.type === 'singleAxis') {\n\t                    data.each(dims[0], function (x, idx) {\n\t                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n\t                        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n\t                    });\n\t                }\n\t                else {\n\t                    data.each(dims, function (x, y, idx) {\n\t                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n\t                        data.setItemLayout(\n\t                            idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y])\n\t                        );\n\t                    }, true);\n\t                }\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n/* 56 */\n/*!*****************************************!*\\\n  !*** ./lib/model/mixin/colorPalette.js ***!\n  \\*****************************************/\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = {\n\t        clearColorPalette: function () {\n\t            this._colorIdx = 0;\n\t            this._colorNameMap = {};\n\t        },\n\t\n\t        getColorFromPalette: function (name, scope) {\n\t            scope = scope || this;\n\t            var colorIdx = scope._colorIdx || 0;\n\t            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});\n\t            if (colorNameMap[name]) {\n\t                return colorNameMap[name];\n\t            }\n\t            var colorPalette = this.get('color', true) || [];\n\t            if (!colorPalette.length) {\n\t                return;\n\t            }\n\t\n\t            var color = colorPalette[colorIdx];\n\t            if (name) {\n\t                colorNameMap[name] = color;\n\t            }\n\t            scope._colorIdx = (colorIdx + 1) % colorPalette.length;\n\t\n\t            return color;\n\t        }\n\t    };\n\n\n/***/ },\n/* 57 */\n/*!*******************************!*\\\n  !*** ./lib/view/Component.js ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Group = __webpack_require__(/*! zrender/lib/container/Group */ 34);\n\t    var componentUtil = __webpack_require__(/*! ../util/component */ 43);\n\t    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 21);\n\t\n\t    var Component = function () {\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewComponent');\n\t    };\n\t\n\t    Component.prototype = {\n\t\n\t        constructor: Component,\n\t\n\t        init: function (ecModel, api) {},\n\t\n\t        render: function (componentModel, ecModel, api, payload) {},\n\t\n\t        dispose: function () {}\n\t\n\t    };\n\t\n\t    var componentProto = Component.prototype;\n\t    componentProto.updateView\n\t        = componentProto.updateLayout\n\t        = componentProto.updateVisual\n\t        = function (seriesModel, ecModel, api, payload) {\n\t            // Do nothing;\n\t        };\n\t    // Enable Component.extend.\n\t    clazzUtil.enableClassExtend(Component);\n\t\n\t    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\t\n\t    module.exports = Component;\n\n\n/***/ },\n/* 58 */\n/*!**********************************!*\\\n  !*** ./~/zrender/lib/Element.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/Element\n\t */\n\t\n\t\n\t    var guid = __webpack_require__(/*! ./core/guid */ 62);\n\t    var Eventful = __webpack_require__(/*! ./mixin/Eventful */ 20);\n\t    var Transformable = __webpack_require__(/*! ./mixin/Transformable */ 88);\n\t    var Animatable = __webpack_require__(/*! ./mixin/Animatable */ 166);\n\t    var zrUtil = __webpack_require__(/*! ./core/util */ 1);\n\t\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t\n\t        /**\n\t         * ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t\n\t    Element.prototype = {\n\t\n\t        /**\n\t         * \n\t         * Element type\n\t         * @type {string}\n\t         */\n\t        type: 'element',\n\t\n\t        /**\n\t         * \n\t         * Element name\n\t         * @type {string}\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * ZRender  element  zrender \n\t         * ZRender instance will be assigned when element is associated with zrender\n\t         * @name module:/zrender/Element#__zr\n\t         * @type {module:zrender/ZRender}\n\t         */\n\t        __zr: null,\n\t\n\t        /**\n\t         * true\n\t         * If ignore drawing and events of the element object\n\t         * @name module:/zrender/Element#ignore\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        ignore: false,\n\t\n\t        /**\n\t         * (shape) Group \n\t         * \n\t         * @type {module:zrender/graphic/Path}\n\t         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t         * @readOnly\n\t         */\n\t        clipPath: null,\n\t\n\t        /**\n\t         * Drift element\n\t         * @param  {number} dx dx on the global space\n\t         * @param  {number} dy dy on the global space\n\t         */\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t                case 'horizontal':\n\t                    dy = 0;\n\t                    break;\n\t                case 'vertical':\n\t                    dx = 0;\n\t                    break;\n\t            }\n\t\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [1, 0, 0, 1, 0, 0];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t\n\t            this.decomposeTransform();\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         * Hook before update\n\t         */\n\t        beforeUpdate: function () {},\n\t        /**\n\t         * Hook after update\n\t         */\n\t        afterUpdate: function () {},\n\t        /**\n\t         * Update each frame\n\t         */\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {},\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        attrKV: function (key, value) {\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            }\n\t            else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Hide the element\n\t         */\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * Show the element\n\t         */\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * @param {string|Object} key\n\t         * @param {*} value\n\t         */\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            }\n\t            else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.dirty(false);\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/graphic/Path} clipPath\n\t         */\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         */\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t\n\t                this.dirty(false);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // \n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Remove self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // \n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t\n\t    module.exports = Element;\n\n\n/***/ },\n/* 59 */\n/*!*********************************************!*\\\n  !*** ./~/zrender/lib/animation/Animator.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\t\n\t\n\t    var Clip = __webpack_require__(/*! ./Clip */ 144);\n\t    var color = __webpack_require__(/*! ../tool/color */ 18);\n\t    var util = __webpack_require__(/*! ../core/util */ 1);\n\t    var isArrayLike = util.isArrayLike;\n\t\n\t    var arraySlice = Array.prototype.slice;\n\t\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(\n\t                        p0[i][j], p1[i][j], percent\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    // arr0 is source array, arr1 is target array.\n\t    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len !== arr1Len) {\n\t            // FIXME Not work for TypedArray\n\t            var isPreviousLarger = arr0Len > arr1Len;\n\t            if (isPreviousLarger) {\n\t                // Cut the previous\n\t                arr0.length = arr1Len;\n\t            }\n\t            else {\n\t                // Fill the previous\n\t                for (var i = arr0Len; i < arr1Len; i++) {\n\t                    arr0.push(\n\t                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n\t                    );\n\t                }\n\t            }\n\t        }\n\t        // Handling NaN value\n\t        var len2 = arr0[0] && arr0[0].length;\n\t        for (var i = 0; i < arr0.length; i++) {\n\t            if (arrDim === 1) {\n\t                if (isNaN(arr0[i])) {\n\t                    arr0[i] = arr1[i];\n\t                }\n\t            }\n\t            else {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (isNaN(arr0[i][j])) {\n\t                        arr0[i][j] = arr1[i][j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(\n\t        p0, p1, p2, p3, t, t2, t3, out, arrDim\n\t    ) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(\n\t                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n\t                );\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(\n\t                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n\t                        t, t2, t3\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t\n\t            return arraySlice.call(value);\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t\n\t    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t\n\t        // For vertices morphing\n\t        var arrDim = (\n\t                isValueArray\n\t                && isArrayLike(firstVal[0])\n\t            )\n\t            ? 2 : 1;\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function(a, b) {\n\t            return a.time - b.time;\n\t        });\n\t\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t\n\t            // Check if value is equal, deep check if value is array\n\t            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n\t                || (!isValueArray && value === prevValue))) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                }\n\t                else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (isAllValueEqual) {\n\t            return;\n\t        }\n\t\n\t        var lastValue = kfValues[trackLen - 1];\n\t        // Polyfill array and NaN value\n\t        for (var i = 0; i < trackLen - 1; i++) {\n\t            if (isValueArray) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            }\n\t            else {\n\t                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t                    kfValues[i] = lastValue;\n\t                }\n\t            }\n\t        }\n\t        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t\n\t        if (isValueColor) {\n\t            var rgba = [0, 0, 0, 0];\n\t        }\n\t\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            // In the easing function like elasticOut, percent may less than 0\n\t            if (percent < 0) {\n\t                frame = 0;\n\t            }\n\t            else if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                // PENDING start from lastFrame ?\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                // PENDING really need to do this ?\n\t                frame = Math.min(frame, trackLen - 2);\n\t            }\n\t            else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t\n\t            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n\t            if (range === 0) {\n\t                return;\n\t            }\n\t            else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(\n\t                        p0, p1, p2, p3, w, w * w, w * w * w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    }\n\t                    else {\n\t                        value = catmullRomInterpolate(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w\n\t                        );\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t            else {\n\t                if (isValueArray) {\n\t                    interpolateArray(\n\t                        kfValues[frame], kfValues[frame + 1], w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(\n\t                            kfValues[frame], kfValues[frame + 1], w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t        };\n\t\n\t        var clip = new Clip({\n\t            target: animator._target,\n\t            life: trackMaxTime,\n\t            loop: animator._loop,\n\t            delay: animator._delay,\n\t            onframe: onframe,\n\t            ondestroy: oneTrackDone\n\t        });\n\t\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t\n\t        return clip;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function(target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t\n\t        this._loop = loop || false;\n\t\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t\n\t        this._clipCount = 0;\n\t\n\t        this._delay = 0;\n\t\n\t        this._doneList = [];\n\t\n\t        this._onframeList = [];\n\t\n\t        this._clipList = [];\n\t    };\n\t\n\t    Animator.prototype = {\n\t        /**\n\t         * \n\t         * @param  {number} time ms\n\t         * @param  {Object} props key-value\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        when: function(time /* ms */, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!props.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Function} callback\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t\n\t            var doneList = this._doneList;\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        /**\n\t         * \n\t         * @param  {string|Function} easing\n\t         *         {@link module:zrender/animation/easing}\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        start: function (easing) {\n\t\n\t            var self = this;\n\t            var clipCount = 0;\n\t\n\t            var oneTrackDone = function() {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\n\t\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                if (!this._tracks.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t                var clip = createTrackClip(\n\t                    this, easing, oneTrackDone,\n\t                    this._tracks[propName], propName\n\t                );\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {number} time ms\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        done: function(cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/animation/Clip>}\n\t         */\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t\n\t    module.exports = Animator;\n\n\n/***/ },\n/* 60 */\n/*!**********************************************************!*\\\n  !*** ./~/zrender/lib/animation/requestAnimationFrame.js ***!\n  \\**********************************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = (typeof window !== 'undefined' &&\n\t                                    (window.requestAnimationFrame\n\t                                    || window.msRequestAnimationFrame\n\t                                    || window.mozRequestAnimationFrame\n\t                                    || window.webkitRequestAnimationFrame))\n\t                                || function (func) {\n\t                                    setTimeout(func, 16);\n\t                                };\n\t\n\n\n/***/ },\n/* 61 */\n/*!***************************************!*\\\n  !*** ./~/zrender/lib/contain/util.js ***!\n  \\***************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var PI2 = Math.PI * 2;\n\t    module.exports = {\n\t        normalizeRadian: function(angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 62 */\n/*!************************************!*\\\n  !*** ./~/zrender/lib/core/guid.js ***!\n  \\************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * zrender: id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var idStart = 0x0907;\n\t\n\t    module.exports = function () {\n\t        return idStart++;\n\t    };\n\t\n\n\n/***/ },\n/* 63 */\n/*!******************************************!*\\\n  !*** ./~/zrender/lib/graphic/Pattern.js ***!\n  \\******************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var Pattern = function (image, repeat) {\n\t        this.image = image;\n\t        this.repeat = repeat;\n\t\n\t        // Can be cloned\n\t        this.type = 'pattern';\n\t    };\n\t\n\t    Pattern.prototype.getCanvasPattern = function (ctx) {\n\t\n\t        return this._canvasPattern\n\t            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n\t    };\n\t\n\t    module.exports = Pattern;\n\n\n/***/ },\n/* 64 */\n/*!****************************************!*\\\n  !*** ./~/zrender/lib/graphic/Style.js ***!\n  \\****************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/graphic/Style\n\t */\n\t\n\t\n\t    var STYLE_COMMON_PROPS = [\n\t        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n\t        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n\t    ];\n\t\n\t    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t\n\t    var Style = function (opts) {\n\t        this.extendFrom(opts);\n\t    };\n\t\n\t    function createLinearGradient(ctx, obj, rect) {\n\t        // var size =\n\t        var x = obj.x;\n\t        var x2 = obj.x2;\n\t        var y = obj.y;\n\t        var y2 = obj.y2;\n\t\n\t        if (!obj.global) {\n\t            x = x * rect.width + rect.x;\n\t            x2 = x2 * rect.width + rect.x;\n\t            y = y * rect.height + rect.y;\n\t            y2 = y2 * rect.height + rect.y;\n\t        }\n\t\n\t        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t    function createRadialGradient(ctx, obj, rect) {\n\t        var width = rect.width;\n\t        var height = rect.height;\n\t        var min = Math.min(width, height);\n\t\n\t        var x = obj.x;\n\t        var y = obj.y;\n\t        var r = obj.r;\n\t        if (!obj.global) {\n\t            x = x * width + rect.x;\n\t            y = y * height + rect.y;\n\t            r = r * min;\n\t        }\n\t\n\t        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t\n\t    Style.prototype = {\n\t\n\t        constructor: Style,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        fill: '#000000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        stroke: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        opacity: 1,\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         */\n\t        lineDash: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineDashOffset: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowBlur: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetX: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetY: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineWidth: 1,\n\t\n\t        /**\n\t         * If stroke ignore scale\n\t         * @type {Boolean}\n\t         */\n\t        strokeNoScale: false,\n\t\n\t        // Bounding rect text configuration\n\t        // Not affected by element transform\n\t        /**\n\t         * @type {string}\n\t         */\n\t        text: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textFill: '#000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textStroke: null,\n\t\n\t        /**\n\t         * 'inside', 'left', 'right', 'top', 'bottom'\n\t         * [x, y]\n\t         * @type {string|Array.<number>}\n\t         * @default 'inside'\n\t         */\n\t        textPosition: 'inside',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textBaseline: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textAlign: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textVerticalAlign: null,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textDistance: 5,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowBlur: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetX: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetY: 0,\n\t\n\t        /**\n\t         * If transform text\n\t         * Only useful in Path and Image element\n\t         * @type {boolean}\n\t         */\n\t        textTransform: false,\n\t\n\t        /**\n\t         * Text rotate around position of Path or Image\n\t         * Only useful in Path and Image element and textTransform is false.\n\t         */\n\t        textRotation: 0,\n\t\n\t        /**\n\t         * @type {string}\n\t         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t         */\n\t        blend: null,\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         */\n\t        bind: function (ctx, el, prevEl) {\n\t            var style = this;\n\t            var prevStyle = prevEl && prevEl.style;\n\t            var firstDraw = !prevStyle;\n\t\n\t            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t                var prop = STYLE_COMMON_PROPS[i];\n\t                var styleName = prop[0];\n\t\n\t                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t                    // FIXME Invalid property value will cause style leak from previous element.\n\t                    ctx[styleName] = style[styleName] || prop[1];\n\t                }\n\t            }\n\t\n\t            if ((firstDraw || style.fill !== prevStyle.fill)) {\n\t                ctx.fillStyle = style.fill;\n\t            }\n\t            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n\t                ctx.strokeStyle = style.stroke;\n\t            }\n\t            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n\t                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t            }\n\t\n\t            if ((firstDraw || style.blend !== prevStyle.blend)) {\n\t                ctx.globalCompositeOperation = style.blend || 'source-over';\n\t            }\n\t            if (this.hasStroke()) {\n\t                var lineWidth = style.lineWidth;\n\t                ctx.lineWidth = lineWidth / (\n\t                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n\t                );\n\t            }\n\t        },\n\t\n\t        hasFill: function () {\n\t            var fill = this.fill;\n\t            return fill != null && fill !== 'none';\n\t        },\n\t\n\t        hasStroke: function () {\n\t            var stroke = this.stroke;\n\t            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t        },\n\t\n\t        /**\n\t         * Extend from other style\n\t         * @param {zrender/graphic/Style} otherStyle\n\t         * @param {boolean} overwrite\n\t         */\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                var target = this;\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name)\n\t                        && (overwrite || ! target.hasOwnProperty(name))\n\t                    ) {\n\t                        target[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Batch setting style with a given object\n\t         * @param {Object|string} obj\n\t         * @param {*} [obj]\n\t         */\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            }\n\t            else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clone\n\t         * @return {zrender/graphic/Style} [description]\n\t         */\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        },\n\t\n\t        getGradient: function (ctx, obj, rect) {\n\t            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t            var canvasGradient = method(ctx, obj, rect);\n\t            var colorStops = obj.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(\n\t                    colorStops[i].offset, colorStops[i].color\n\t                );\n\t            }\n\t            return canvasGradient;\n\t        }\n\t    };\n\t\n\t    var styleProto = Style.prototype;\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t        var prop = STYLE_COMMON_PROPS[i];\n\t        if (!(prop[0] in styleProto)) {\n\t            styleProto[prop[0]] = prop[1];\n\t        }\n\t    }\n\t\n\t    // Provide for others\n\t    Style.getGradient = styleProto.getGradient;\n\t\n\t    module.exports = Style;\n\n\n/***/ },\n/* 65 */\n/*!**********************************************!*\\\n  !*** ./~/zrender/lib/graphic/helper/poly.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var smoothSpline = __webpack_require__(/*! ./smoothSpline */ 156);\n\t    var smoothBezier = __webpack_require__(/*! ./smoothBezier */ 155);\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(\n\t                        points, smooth, closePath, shape.smoothConstraint\n\t                    );\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(\n\t                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n\t                        );\n\t                    }\n\t                }\n\t                else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\n\n/***/ },\n/* 66 */\n/*!*************************************************!*\\\n  !*** ./lib/component/helper/selectableMixin.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Data selectable mixin for chart series.\n\t * To eanble data select, option of series must have `selectedMode`.\n\t * And each data item will use `selected` to toggle itself selected status\n\t *\n\t * @module echarts/chart/helper/DataSelectable\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    module.exports = {\n\t\n\t        updateSelectedMap: function (targetList) {\n\t            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n\t                targetMap[target.name] = target;\n\t                return targetMap;\n\t            }, {});\n\t        },\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        // PENGING If selectedMode is null ?\n\t        select: function (name) {\n\t            var targetMap = this._selectTargetMap;\n\t            var target = targetMap[name];\n\t            var selectedMode = this.get('selectedMode');\n\t            if (selectedMode === 'single') {\n\t                zrUtil.each(targetMap, function (target) {\n\t                    target.selected = false;\n\t                });\n\t            }\n\t            target && (target.selected = true);\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        unSelect: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            // var selectedMode = this.get('selectedMode');\n\t            // selectedMode !== 'single' && target && (target.selected = false);\n\t            target && (target.selected = false);\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        toggleSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            if (target != null) {\n\t                this[target.selected ? 'unSelect' : 'select'](name);\n\t                return target.selected;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        isSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            return target && target.selected;\n\t        }\n\t    };\n\n\n/***/ },\n/* 67 */\n/*!*********************************************!*\\\n  !*** ./lib/component/marker/MarkerModel.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var modelUtil = __webpack_require__(/*! ../../util/model */ 7);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var env = __webpack_require__(/*! zrender/lib/core/env */ 11);\n\t\n\t    var formatUtil = __webpack_require__(/*! ../../util/format */ 9);\n\t    var addCommas = formatUtil.addCommas;\n\t    var encodeHTML = formatUtil.encodeHTML;\n\t\n\t    function fillLabel(opt) {\n\t        modelUtil.defaultEmphasis(\n\t            opt.label,\n\t            modelUtil.LABEL_OPTIONS\n\t        );\n\t    }\n\t    var MarkerModel = __webpack_require__(/*! ../../echarts */ 2).extendComponentModel({\n\t\n\t        type: 'marker',\n\t\n\t        dependencies: ['series', 'grid', 'polar', 'geo'],\n\t        /**\n\t         * @overrite\n\t         */\n\t        init: function (option, parentModel, ecModel, extraOpt) {\n\t\n\t            if (false) {\n\t                if (this.type === 'marker') {\n\t                    throw new Error('Marker component is abstract component. Use markLine, markPoint, markArea instead.');\n\t                }\n\t            }\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t            this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);\n\t        },\n\t\n\t        /**\n\t         * @return {boolean}\n\t         */\n\t        ifEnableAnimation: function () {\n\t            if (env.node) {\n\t                return false;\n\t            }\n\t\n\t            var hostSeries = this.__hostSeries;\n\t            return this.getShallow('animation') && hostSeries && hostSeries.ifEnableAnimation();\n\t        },\n\t\n\t        mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {\n\t            var MarkerModel = this.constructor;\n\t            var modelPropName = this.mainType + 'Model';\n\t            if (!createdBySelf) {\n\t                ecModel.eachSeries(function (seriesModel) {\n\t\n\t                    var markerOpt = seriesModel.get(this.mainType);\n\t\n\t                    var markerModel = seriesModel[modelPropName];\n\t                    if (!markerOpt || !markerOpt.data) {\n\t                        seriesModel[modelPropName] = null;\n\t                        return;\n\t                    }\n\t                    if (!markerModel) {\n\t                        if (isInit) {\n\t                            // Default label emphasis `position` and `show`\n\t                            fillLabel(markerOpt);\n\t                        }\n\t                        zrUtil.each(markerOpt.data, function (item) {\n\t                            // FIXME Overwrite fillLabel method ?\n\t                            if (item instanceof Array) {\n\t                                fillLabel(item[0]);\n\t                                fillLabel(item[1]);\n\t                            }\n\t                            else {\n\t                                fillLabel(item);\n\t                            }\n\t                        });\n\t\n\t                        markerModel = new MarkerModel(\n\t                            markerOpt, this, ecModel\n\t                        );\n\t\n\t                        zrUtil.extend(markerModel, {\n\t                            mainType: this.mainType,\n\t                            // Use the same series index and name\n\t                            seriesIndex: seriesModel.seriesIndex,\n\t                            name: seriesModel.name,\n\t                            createdBySelf: true\n\t                        });\n\t\n\t                        markerModel.__hostSeries = seriesModel;\n\t                    }\n\t                    else {\n\t                        markerModel.mergeOption(markerOpt, ecModel, true);\n\t                    }\n\t                    seriesModel[modelPropName] = markerModel;\n\t                }, this);\n\t            }\n\t        },\n\t\n\t        formatTooltip: function (dataIndex) {\n\t            var data = this.getData();\n\t            var value = this.getRawValue(dataIndex);\n\t            var formattedValue = zrUtil.isArray(value)\n\t                ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);\n\t            var name = data.getName(dataIndex);\n\t            var html = this.name;\n\t            if (value != null || name) {\n\t                html += '<br />';\n\t            }\n\t            if (name) {\n\t                html += encodeHTML(name);\n\t                if (value != null) {\n\t                    html += ' : ';\n\t                }\n\t            }\n\t            if (value != null) {\n\t                html += formattedValue;\n\t            }\n\t            return html;\n\t        },\n\t\n\t        getData: function () {\n\t            return this._data;\n\t        },\n\t\n\t        setData: function (data) {\n\t            this._data = data;\n\t        }\n\t    });\n\t\n\t    zrUtil.mixin(MarkerModel, modelUtil.dataFormatMixin);\n\t\n\t    module.exports = MarkerModel;\n\n\n/***/ },\n/* 68 */\n/*!********************************************!*\\\n  !*** ./lib/component/marker/MarkerView.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    module.exports = __webpack_require__(/*! ../../echarts */ 2).extendComponentView({\n\t\n\t        type: 'marker',\n\t\n\t        init: function () {\n\t            /**\n\t             * Markline grouped by series\n\t             * @private\n\t             * @type {Object}\n\t             */\n\t            this.markerGroupMap = {};\n\t        },\n\t\n\t        render: function (markerModel, ecModel, api) {\n\t            var markerGroupMap = this.markerGroupMap;\n\t            for (var name in markerGroupMap) {\n\t                if (markerGroupMap.hasOwnProperty(name)) {\n\t                    markerGroupMap[name].__keep = false;\n\t                }\n\t            }\n\t\n\t            var markerModelKey = this.type + 'Model';\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                var markerModel = seriesModel[markerModelKey];\n\t                markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);\n\t            }, this);\n\t\n\t            for (var name in markerGroupMap) {\n\t                if (markerGroupMap.hasOwnProperty(name) && !markerGroupMap[name].__keep) {\n\t                    this.group.remove(markerGroupMap[name].group);\n\t                }\n\t            }\n\t        },\n\t\n\t        renderSeries: function () {}\n\t    });\n\n\n/***/ },\n/* 69 */\n/*!**********************************************!*\\\n  !*** ./lib/component/marker/markerHelper.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var numberUtil = __webpack_require__(/*! ../../util/number */ 4);\n\t    var indexOf = zrUtil.indexOf;\n\t\n\t    function hasXOrY(item) {\n\t        return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n\t    }\n\t\n\t    function hasXAndY(item) {\n\t        return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n\t    }\n\t\n\t    function getPrecision(data, valueAxisDim, dataIndex) {\n\t        var precision = -1;\n\t        do {\n\t            precision = Math.max(\n\t                numberUtil.getPrecision(data.get(\n\t                    valueAxisDim, dataIndex\n\t                )),\n\t                precision\n\t            );\n\t            data = data.stackedOn;\n\t        } while (data);\n\t\n\t        return precision;\n\t    }\n\t\n\t    function markerTypeCalculatorWithExtent(\n\t        mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex\n\t    ) {\n\t        var coordArr = [];\n\t        var value = numCalculate(data, targetDataDim, mlType);\n\t\n\t        var dataIndex = data.indexOfNearest(targetDataDim, value, true);\n\t        coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex, true);\n\t        coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex, true);\n\t\n\t        var precision = getPrecision(data, targetDataDim, dataIndex);\n\t        if (precision >= 0) {\n\t            coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n\t        }\n\t\n\t        return coordArr;\n\t    }\n\t\n\t    var curry = zrUtil.curry;\n\t    // TODO Specified percent\n\t    var markerTypeCalculator = {\n\t        /**\n\t         * @method\n\t         * @param {module:echarts/data/List} data\n\t         * @param {string} baseAxisDim\n\t         * @param {string} valueAxisDim\n\t         */\n\t        min: curry(markerTypeCalculatorWithExtent, 'min'),\n\t        /**\n\t         * @method\n\t         * @param {module:echarts/data/List} data\n\t         * @param {string} baseAxisDim\n\t         * @param {string} valueAxisDim\n\t         */\n\t        max: curry(markerTypeCalculatorWithExtent, 'max'),\n\t\n\t        /**\n\t         * @method\n\t         * @param {module:echarts/data/List} data\n\t         * @param {string} baseAxisDim\n\t         * @param {string} valueAxisDim\n\t         */\n\t        average: curry(markerTypeCalculatorWithExtent, 'average')\n\t    };\n\t\n\t    /**\n\t     * Transform markPoint data item to format used in List by do the following\n\t     * 1. Calculate statistic like `max`, `min`, `average`\n\t     * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n\t     * @param  {module:echarts/model/Series} seriesModel\n\t     * @param  {module:echarts/coord/*} [coordSys]\n\t     * @param  {Object} item\n\t     * @return {Object}\n\t     */\n\t    var dataTransform = function (seriesModel, item) {\n\t        var data = seriesModel.getData();\n\t        var coordSys = seriesModel.coordinateSystem;\n\t\n\t        // 1. If not specify the position with pixel directly\n\t        // 2. If `coord` is not a data array. Which uses `xAxis`,\n\t        // `yAxis` to specify the coord on each dimension\n\t\n\t        // parseFloat first because item.x and item.y can be percent string like '20%'\n\t        if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n\t            var dims = coordSys.dimensions;\n\t            var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);\n\t\n\t            // Clone the option\n\t            // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\t            item = zrUtil.clone(item);\n\t\n\t            if (item.type\n\t                && markerTypeCalculator[item.type]\n\t                && axisInfo.baseAxis && axisInfo.valueAxis\n\t            ) {\n\t                var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n\t                var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n\t\n\t                item.coord = markerTypeCalculator[item.type](\n\t                    data, axisInfo.baseDataDim, axisInfo.valueDataDim,\n\t                    otherCoordIndex, targetCoordIndex\n\t                );\n\t                // Force to use the value of calculated value.\n\t                item.value = item.coord[targetCoordIndex];\n\t            }\n\t            else {\n\t                // FIXME Only has one of xAxis and yAxis.\n\t                var coord = [\n\t                    item.xAxis != null ? item.xAxis : item.radiusAxis,\n\t                    item.yAxis != null ? item.yAxis : item.angleAxis\n\t                ];\n\t                // Each coord support max, min, average\n\t                for (var i = 0; i < 2; i++) {\n\t                    if (markerTypeCalculator[coord[i]]) {\n\t                        var dataDim = seriesModel.coordDimToDataDim(dims[i])[0];\n\t                        coord[i] = numCalculate(data, dataDim, coord[i]);\n\t                    }\n\t                }\n\t                item.coord = coord;\n\t            }\n\t        }\n\t        return item;\n\t    };\n\t\n\t    var getAxisInfo = function (item, data, coordSys, seriesModel) {\n\t        var ret = {};\n\t\n\t        if (item.valueIndex != null || item.valueDim != null) {\n\t            ret.valueDataDim = item.valueIndex != null\n\t                ? data.getDimension(item.valueIndex) : item.valueDim;\n\t            ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));\n\t            ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n\t            ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n\t        }\n\t        else {\n\t            ret.baseAxis = seriesModel.getBaseAxis();\n\t            ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n\t            ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n\t            ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];\n\t        }\n\t\n\t        return ret;\n\t    };\n\t\n\t    /**\n\t     * Filter data which is out of coordinateSystem range\n\t     * [dataFilter description]\n\t     * @param  {module:echarts/coord/*} [coordSys]\n\t     * @param  {Object} item\n\t     * @return {boolean}\n\t     */\n\t    var dataFilter = function (coordSys, item) {\n\t        // Alwalys return true if there is no coordSys\n\t        return (coordSys && coordSys.containData && item.coord && !hasXOrY(item))\n\t            ? coordSys.containData(item.coord) : true;\n\t    };\n\t\n\t    var dimValueGetter = function (item, dimName, dataIndex, dimIndex) {\n\t        // x, y, radius, angle\n\t        if (dimIndex < 2) {\n\t            return item.coord && item.coord[dimIndex];\n\t        }\n\t        return item.value;\n\t    };\n\t\n\t    var numCalculate = function (data, valueDataDim, type) {\n\t        if (type === 'average') {\n\t            var sum = 0;\n\t            var count = 0;\n\t            data.each(valueDataDim, function (val, idx) {\n\t                if (!isNaN(val)) {\n\t                    sum += val;\n\t                    count++;\n\t                }\n\t            }, true);\n\t            return sum / count;\n\t        }\n\t        else {\n\t            return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n\t        }\n\t    };\n\t\n\t    module.exports = {\n\t        dataTransform: dataTransform,\n\t        dataFilter: dataFilter,\n\t        dimValueGetter: dimValueGetter,\n\t        getAxisInfo: getAxisInfo,\n\t        numCalculate: numCalculate\n\t    };\n\n\n/***/ },\n/* 70 */\n/*!*************************************!*\\\n  !*** ./lib/processor/dataFilter.js ***!\n  \\*************************************/\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function (seriesType, ecModel) {\n\t        var legendModels = ecModel.findComponents({\n\t            mainType: 'legend'\n\t        });\n\t        if (!legendModels || !legendModels.length) {\n\t            return;\n\t        }\n\t        ecModel.eachSeriesByType(seriesType, function (series) {\n\t            var data = series.getData();\n\t            data.filterSelf(function (idx) {\n\t                var name = data.getName(idx);\n\t                // If in any legend component the status is not selected.\n\t                for (var i = 0; i < legendModels.length; i++) {\n\t                    if (!legendModels[i].isSelected(name)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return true;\n\t            }, this);\n\t        }, this);\n\t    };\n\n\n/***/ },\n/* 71 */,\n/* 72 */\n/*!*********************************!*\\\n  !*** ./lib/visual/dataColor.js ***!\n  \\*********************************/\n/***/ function(module, exports) {\n\n\t// Pick color from palette for each data item\n\t\n\t\n\t    module.exports = function (seriesType, ecModel) {\n\t        // Pie and funnel may use diferrent scope\n\t        var paletteScope = {};\n\t        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n\t            var dataAll = seriesModel.getRawData();\n\t            var idxMap = {};\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                var data = seriesModel.getData();\n\t                data.each(function (idx) {\n\t                    var rawIdx = data.getRawIndex(idx);\n\t                    idxMap[rawIdx] = idx;\n\t                });\n\t                dataAll.each(function (rawIdx) {\n\t                    // FIXME Performance\n\t                    var itemModel = dataAll.getItemModel(rawIdx);\n\t                    var filteredIdx = idxMap[rawIdx];\n\t\n\t                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\t                    var singleDataColor = filteredIdx != null\n\t                        && data.getItemVisual(filteredIdx, 'color', true);\n\t\n\t                    if (!singleDataColor) {\n\t                        var color = itemModel.get('itemStyle.normal.color')\n\t                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n\t                        // Legend may use the visual info in data before processed\n\t                        dataAll.setItemVisual(rawIdx, 'color', color);\n\t\n\t                        // Data is not filtered\n\t                        if (filteredIdx != null) {\n\t                            data.setItemVisual(filteredIdx, 'color', color);\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Set data all color for legend\n\t                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n\t                    }\n\t                });\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n/* 73 */\n/*!************************************!*\\\n  !*** ./~/zrender/lib/core/bbox.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(/*! ./vector */ 5);\n\t    var curve = __webpack_require__(/*! ./curve */ 17);\n\t\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * `min``max`\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points \n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function(points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t\n\t    var xDim = [];\n\t    var yDim = [];\n\t    /**\n\t     * (p0, p1, p2, p3)`min``max`\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function(\n\t        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n\t    ) {\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t        min[0] = Infinity;\n\t        min[1] = Infinity;\n\t        max[0] = -Infinity;\n\t        max[1] = -Infinity;\n\t\n\t        for (i = 0; i < n; i++) {\n\t            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t            min[0] = mathMin(x, min[0]);\n\t            max[0] = mathMax(x, max[0]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t            min[1] = mathMin(y, min[1]);\n\t            max[1] = mathMax(y, max[1]);\n\t        }\n\t\n\t        min[0] = mathMin(x0, min[0]);\n\t        max[0] = mathMax(x0, max[0]);\n\t        min[0] = mathMin(x3, min[0]);\n\t        max[0] = mathMax(x3, max[0]);\n\t\n\t        min[1] = mathMin(y0, min[1]);\n\t        max[1] = mathMax(y0, max[1]);\n\t        min[1] = mathMin(y3, min[1]);\n\t        max[1] = mathMax(y3, max[1]);\n\t    };\n\t\n\t    /**\n\t     * (p0, p1, p2)`min``max`\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n\t            );\n\t        var ty =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n\t            );\n\t\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t\n\t    /**\n\t     * `min``max`\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (\n\t        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n\t    ) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t\n\t\n\t        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % (PI2);\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % (PI2);\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        }\n\t        else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = bbox;\n\t\n\n\n/***/ },\n/* 74 */\n/*!***************************************!*\\\n  !*** ./~/zrender/lib/graphic/Text.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Text element\n\t * @module zrender/graphic/Text\n\t *\n\t * TODO Wrapping\n\t *\n\t * Text not support gradient\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(/*! ./Displayable */ 37);\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t    var textContain = __webpack_require__(/*! ../contain/text */ 16);\n\t\n\t    /**\n\t     * @alias zrender/graphic/Text\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var Text = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t\n\t    Text.prototype = {\n\t\n\t        constructor: Text,\n\t\n\t        type: 'text',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var x = style.x || 0;\n\t            var y = style.y || 0;\n\t            // Convert to string\n\t            var text = style.text;\n\t\n\t            // Convert to string\n\t            text != null && (text += '');\n\t\n\t            // Always bind style\n\t            style.bind(ctx, this, prevEl);\n\t\n\t            if (text) {\n\t\n\t                this.setTransform(ctx);\n\t\n\t                var textBaseline;\n\t                var textAlign = style.textAlign;\n\t                var font = style.textFont || style.font;\n\t                if (style.textVerticalAlign) {\n\t                    var rect = textContain.getBoundingRect(\n\t                        text, font, style.textAlign, 'top'\n\t                    );\n\t                    // Ignore textBaseline\n\t                    textBaseline = 'middle';\n\t                    switch (style.textVerticalAlign) {\n\t                        case 'middle':\n\t                            y -= rect.height / 2 - rect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= rect.height - rect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += rect.lineHeight / 2;\n\t                    }\n\t                }\n\t                else {\n\t                    textBaseline = style.textBaseline;\n\t                }\n\t\n\t                // TODO Invalid font\n\t                ctx.font = font || '12px sans-serif';\n\t                ctx.textAlign = textAlign || 'left';\n\t                // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t                if (ctx.textAlign !== textAlign) {\n\t                    ctx.textAlign = 'left';\n\t                }\n\t                ctx.textBaseline = textBaseline || 'alphabetic';\n\t                // Use canvas default alphabetic baseline\n\t                if (ctx.textBaseline !== textBaseline) {\n\t                    ctx.textBaseline = 'alphabetic';\n\t                }\n\t\n\t                var lineHeight = textContain.measureText('', ctx.font).width;\n\t\n\t                var textLines = text.split('\\n');\n\t                for (var i = 0; i < textLines.length; i++) {\n\t                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n\t                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n\t                    y += lineHeight;\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            if (!this._rect) {\n\t                var style = this.style;\n\t                var textVerticalAlign = style.textVerticalAlign;\n\t                var rect = textContain.getBoundingRect(\n\t                    style.text + '', style.textFont || style.font, style.textAlign,\n\t                    textVerticalAlign ? 'top' : style.textBaseline\n\t                );\n\t                switch (textVerticalAlign) {\n\t                    case 'middle':\n\t                        rect.y -= rect.height / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        rect.y -= rect.height;\n\t                        break;\n\t                }\n\t                rect.x += style.x || 0;\n\t                rect.y += style.y || 0;\n\t                this._rect = rect;\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Text, Displayable);\n\t\n\t    module.exports = Text;\n\n\n/***/ },\n/* 75 */\n/*!*************************************************!*\\\n  !*** ./~/zrender/lib/graphic/mixin/RectText.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\t\n\t\n\t\n\t    var textContain = __webpack_require__(/*! ../../contain/text */ 16);\n\t    var BoundingRect = __webpack_require__(/*! ../../core/BoundingRect */ 8);\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var RectText = function () {};\n\t\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t\n\t    RectText.prototype = {\n\t\n\t        constructor: RectText,\n\t\n\t        /**\n\t         * Draw text in a rect with specified position.\n\t         * @param  {CanvasRenderingContext} ctx\n\t         * @param  {Object} rect Displayable rect\n\t         * @return {Object} textRect Alternative precalculated text bounding rect\n\t         */\n\t        drawRectText: function (ctx, rect, textRect) {\n\t            var style = this.style;\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            if (!text) {\n\t                return;\n\t            }\n\t\n\t            // FIXME\n\t            ctx.save();\n\t\n\t            var x;\n\t            var y;\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            var align = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            var baseline = style.textBaseline;\n\t            var verticalAlign = style.textVerticalAlign;\n\t\n\t            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t\n\t            // Transform rect to view space\n\t            var transform = this.transform;\n\t            if (!style.textTransform) {\n\t                if (transform) {\n\t                    tmpRect.copy(rect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = tmpRect;\n\t                }\n\t            }\n\t            else {\n\t                this.setTransform(ctx);\n\t            }\n\t\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t\n\t                if (verticalAlign) {\n\t                    switch (verticalAlign) {\n\t                        case 'middle':\n\t                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= textRect.height - textRect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += textRect.lineHeight / 2;\n\t                    }\n\t                    // Force bseline to be middle\n\t                    baseline = 'middle';\n\t                }\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t\n\t            // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t            ctx.textAlign = align || 'left';\n\t            // Use canvas default alphabetic baseline\n\t            ctx.textBaseline = baseline || 'alphabetic';\n\t\n\t            var textFill = style.textFill;\n\t            var textStroke = style.textStroke;\n\t            textFill && (ctx.fillStyle = textFill);\n\t            textStroke && (ctx.strokeStyle = textStroke);\n\t\n\t            // TODO Invalid font\n\t            ctx.font = font || '12px sans-serif';\n\t\n\t            // Text shadow\n\t            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n\t            ctx.shadowBlur = style.textShadowBlur;\n\t            ctx.shadowColor = style.textShadowColor || 'transparent';\n\t            ctx.shadowOffsetX = style.textShadowOffsetX;\n\t            ctx.shadowOffsetY = style.textShadowOffsetY;\n\t\n\t            var textLines = text.split('\\n');\n\t\n\t            if (style.textRotation) {\n\t                transform && ctx.translate(transform[4], transform[5]);\n\t                ctx.rotate(style.textRotation);\n\t                transform && ctx.translate(-transform[4], -transform[5]);\n\t            }\n\t\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                textFill && ctx.fillText(textLines[i], x, y);\n\t                textStroke && ctx.strokeText(textLines[i], x, y);\n\t                y += textRect.lineHeight;\n\t            }\n\t\n\t            ctx.restore();\n\t        }\n\t    };\n\t\n\t    module.exports = RectText;\n\n\n/***/ },\n/* 76 */\n/*!**********************************!*\\\n  !*** ./~/zrender/lib/zrender.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * ZRender, a high performance 2d drawing library.\n\t *\n\t * Copyright (c) 2013, Baidu Inc.\n\t * All rights reserved.\n\t *\n\t * LICENSE\n\t * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n\t */\n\t// Global defines\n\t\n\t    var guid = __webpack_require__(/*! ./core/guid */ 62);\n\t    var env = __webpack_require__(/*! ./core/env */ 11);\n\t    var zrUtil = __webpack_require__(/*! ./core/util */ 1);\n\t\n\t    var Handler = __webpack_require__(/*! ./Handler */ 139);\n\t    var Storage = __webpack_require__(/*! ./Storage */ 142);\n\t    var Animation = __webpack_require__(/*! ./animation/Animation */ 143);\n\t    var HandlerProxy = __webpack_require__(/*! ./dom/HandlerProxy */ 151);\n\t\n\t    var useVML = !env.canvasSupported;\n\t\n\t    var painterCtors = {\n\t        canvas: __webpack_require__(/*! ./Painter */ 141)\n\t    };\n\t\n\t    var instances = {};    // ZRendermap\n\t\n\t    var zrender = {};\n\t\n\t    /**\n\t     * @type {string}\n\t     */\n\t    zrender.version = '3.2.2';\n\t\n\t    /**\n\t     * Initializing a zrender instance\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.init = function(dom, opts) {\n\t        var zr = new ZRender(guid(), dom, opts);\n\t        instances[zr.id] = zr;\n\t        return zr;\n\t    };\n\t\n\t    /**\n\t     * Dispose zrender instance\n\t     * @param {module:zrender/ZRender} zr\n\t     */\n\t    zrender.dispose = function (zr) {\n\t        if (zr) {\n\t            zr.dispose();\n\t        }\n\t        else {\n\t            for (var key in instances) {\n\t                if (instances.hasOwnProperty(key)) {\n\t                    instances[key].dispose();\n\t                }\n\t            }\n\t            instances = {};\n\t        }\n\t\n\t        return zrender;\n\t    };\n\t\n\t    /**\n\t     * Get zrender instance by id\n\t     * @param {string} id zrender instance id\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.getInstance = function (id) {\n\t        return instances[id];\n\t    };\n\t\n\t    zrender.registerPainter = function (name, Ctor) {\n\t        painterCtors[name] = Ctor;\n\t    };\n\t\n\t    function delInstance(id) {\n\t        delete instances[id];\n\t    }\n\t\n\t    /**\n\t     * @module zrender/ZRender\n\t     */\n\t    /**\n\t     * @constructor\n\t     * @alias module:zrender/ZRender\n\t     * @param {string} id\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     */\n\t    var ZRender = function(id, dom, opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         */\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id = id;\n\t\n\t        var self = this;\n\t        var storage = new Storage();\n\t\n\t        var rendererType = opts.renderer;\n\t        if (useVML) {\n\t            if (!painterCtors.vml) {\n\t                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t            }\n\t            rendererType = 'vml';\n\t        }\n\t        else if (!rendererType || !painterCtors[rendererType]) {\n\t            rendererType = 'canvas';\n\t        }\n\t        var painter = new painterCtors[rendererType](dom, storage, opts);\n\t\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t\n\t        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\t\n\t        /**\n\t         * @type {module:zrender/animation/Animation}\n\t         */\n\t        this.animation = new Animation({\n\t            stage: {\n\t                update: zrUtil.bind(this.flush, this)\n\t            }\n\t        });\n\t        this.animation.start();\n\t\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._needsRefresh;\n\t\n\t        //  storage.delFromMap, \n\t        // FIXME ugly\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t\n\t            oldDelFromMap.call(storage, elId);\n\t\n\t            el && el.removeSelfFromZr(self);\n\t        };\n\t\n\t        storage.addToMap = function (el) {\n\t            oldAddToMap.call(storage, el);\n\t\n\t            el.addSelfToZr(self);\n\t        };\n\t    };\n\t\n\t    ZRender.prototype = {\n\t\n\t        constructor: ZRender,\n\t        /**\n\t         * \n\t         * @return {string}\n\t         */\n\t        getId: function () {\n\t            return this.id;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        add: function (el) {\n\t            this.storage.addRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        remove: function (el) {\n\t            this.storage.delRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Change configuration of layer\n\t         * @param {string} zLevel\n\t         * @param {Object} config\n\t         * @param {string} [config.clearColor=0] Clear color\n\t         * @param {string} [config.motionBlur=false] If enable motion blur\n\t         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n\t        */\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Repaint the canvas immediately\n\t         */\n\t        refreshImmediately: function () {\n\t            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t            // Or it will cause zrender refreshes again and again.\n\t            this._needsRefresh = false;\n\t            this.painter.refresh();\n\t            /**\n\t             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t             */\n\t            this._needsRefresh = false;\n\t        },\n\t\n\t        /**\n\t         * Mark and repaint the canvas in the next frame of browser\n\t         */\n\t        refresh: function() {\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Perform all refresh\n\t         */\n\t        flush: function () {\n\t            if (this._needsRefresh) {\n\t                this.refreshImmediately();\n\t            }\n\t            if (this._needsRefreshHover) {\n\t                this.refreshHoverImmediately();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element to hover layer\n\t         * @param  {module:zrender/Element} el\n\t         * @param {Object} style\n\t         */\n\t        addHover: function (el, style) {\n\t            if (this.painter.addHover) {\n\t                this.painter.addHover(el, style);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element from hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        removeHover: function (el) {\n\t            if (this.painter.removeHover) {\n\t                this.painter.removeHover(el);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clear all hover elements in hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        clearHover: function () {\n\t            if (this.painter.clearHover) {\n\t                this.painter.clearHover();\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Refresh hover in next frame\n\t         */\n\t        refreshHover: function () {\n\t            this._needsRefreshHover = true;\n\t        },\n\t\n\t        /**\n\t         * Refresh hover immediately\n\t         */\n\t        refreshHoverImmediately: function () {\n\t            this._needsRefreshHover = false;\n\t            this.painter.refreshHover && this.painter.refreshHover();\n\t        },\n\t\n\t        /**\n\t         * Resize the canvas.\n\t         * Should be invoked when container size is changed\n\t         * @param {Object} [opts]\n\t         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t         */\n\t        resize: function(opts) {\n\t            opts = opts || {};\n\t            this.painter.resize(opts.width, opts.height);\n\t            this.handler.resize();\n\t        },\n\t\n\t        /**\n\t         * Stop and clear all animation immediately\n\t         */\n\t        clearAnimation: function () {\n\t            this.animation.clear();\n\t        },\n\t\n\t        /**\n\t         * Get container width\n\t         */\n\t        getWidth: function() {\n\t            return this.painter.getWidth();\n\t        },\n\t\n\t        /**\n\t         * Get container height\n\t         */\n\t        getHeight: function() {\n\t            return this.painter.getHeight();\n\t        },\n\t\n\t        /**\n\t         * Export the canvas as Base64 URL\n\t         * @param {string} type\n\t         * @param {string} [backgroundColor='#fff']\n\t         * @return {string} Base64 URL\n\t         */\n\t        // toDataURL: function(type, backgroundColor) {\n\t        //     return this.painter.getRenderedCanvas({\n\t        //         backgroundColor: backgroundColor\n\t        //     }).toDataURL(type);\n\t        // },\n\t\n\t        /**\n\t         * Converting a path to image.\n\t         * It has much better performance of drawing image rather than drawing a vector path.\n\t         * @param {module:zrender/graphic/Path} e\n\t         * @param {number} width\n\t         * @param {number} height\n\t         */\n\t        pathToImage: function(e, width, height) {\n\t            var id = guid();\n\t            return this.painter.pathToImage(id, e, width, height);\n\t        },\n\t\n\t        /**\n\t         * Set default cursor\n\t         * @param {string} [cursorStyle='default']  crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            this.handler.setCursorStyle(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * Bind event\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {Function} eventHandler Handler function\n\t         * @param {Object} [context] Context object\n\t         */\n\t        on: function(eventName, eventHandler, context) {\n\t            this.handler.on(eventName, eventHandler, context);\n\t        },\n\t\n\t        /**\n\t         * Unbind event\n\t         * @param {string} eventName Event name\n\t         * @param {Function} [eventHandler] Handler function\n\t         */\n\t        off: function(eventName, eventHandler) {\n\t            this.handler.off(eventName, eventHandler);\n\t        },\n\t\n\t        /**\n\t         * Trigger event manually\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {event=} event Event object\n\t         */\n\t        trigger: function (eventName, event) {\n\t            this.handler.trigger(eventName, event);\n\t        },\n\t\n\t\n\t        /**\n\t         * Clear all objects and the canvas.\n\t         */\n\t        clear: function () {\n\t            this.storage.delRoot();\n\t            this.painter.clear();\n\t        },\n\t\n\t        /**\n\t         * Dispose self.\n\t         */\n\t        dispose: function () {\n\t            this.animation.stop();\n\t\n\t            this.clear();\n\t            this.storage.dispose();\n\t            this.painter.dispose();\n\t            this.handler.dispose();\n\t\n\t            this.animation =\n\t            this.storage =\n\t            this.painter =\n\t            this.handler = null;\n\t\n\t            delInstance(this.id);\n\t        }\n\t    };\n\t\n\t    module.exports = zrender;\n\t\n\n\n/***/ },\n/* 77 */\n/*!**********************************************!*\\\n  !*** ./lib/action/createDataSelectAction.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var echarts = __webpack_require__(/*! ../echarts */ 2);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    module.exports = function (seriesType, actionInfos) {\n\t        zrUtil.each(actionInfos, function (actionInfo) {\n\t            actionInfo.update = 'updateView';\n\t            /**\n\t             * @payload\n\t             * @property {string} seriesName\n\t             * @property {string} name\n\t             */\n\t            echarts.registerAction(actionInfo, function (payload, ecModel) {\n\t                var selected = {};\n\t                ecModel.eachComponent(\n\t                    {mainType: 'series', subType: seriesType, query: payload},\n\t                    function (seriesModel) {\n\t                        if (seriesModel[actionInfo.method]) {\n\t                            seriesModel[actionInfo.method](payload.name);\n\t                        }\n\t                        var data = seriesModel.getData();\n\t                        // Create selected map\n\t                        data.each(function (idx) {\n\t                            var name = data.getName(idx);\n\t                            selected[name] = seriesModel.isSelected(name) || false;\n\t                        });\n\t                    }\n\t                );\n\t                return {\n\t                    name: payload.name,\n\t                    selected: selected\n\t                };\n\t            });\n\t        });\n\t    };\n\n\n/***/ },\n/* 78 */,\n/* 79 */\n/*!************************************************!*\\\n  !*** ./lib/component/helper/RoamController.js ***!\n  \\************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/component/helper/RoamController\n\t */\n\t\n\t\n\t\n\t    var Eventful = __webpack_require__(/*! zrender/lib/mixin/Eventful */ 20);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var eventTool = __webpack_require__(/*! zrender/lib/core/event */ 24);\n\t    var interactionMutex = __webpack_require__(/*! ./interactionMutex */ 115);\n\t\n\t    function mousedown(e) {\n\t        if (e.target && e.target.draggable) {\n\t            return;\n\t        }\n\t\n\t        var x = e.offsetX;\n\t        var y = e.offsetY;\n\t\n\t        if (this.containsPoint && this.containsPoint(x, y)) {\n\t            this._x = x;\n\t            this._y = y;\n\t            this._dragging = true;\n\t        }\n\t    }\n\t\n\t    function mousemove(e) {\n\t        if (!this._dragging) {\n\t            return;\n\t        }\n\t\n\t        eventTool.stop(e.event);\n\t\n\t        if (e.gestureEvent !== 'pinch') {\n\t\n\t            if (interactionMutex.isTaken(this._zr, 'globalPan')) {\n\t                return;\n\t            }\n\t\n\t            var x = e.offsetX;\n\t            var y = e.offsetY;\n\t\n\t            var oldX = this._x;\n\t            var oldY = this._y;\n\t\n\t            var dx = x - oldX;\n\t            var dy = y - oldY;\n\t\n\t            this._x = x;\n\t            this._y = y;\n\t\n\t            var target = this.target;\n\t\n\t            if (target) {\n\t                var pos = target.position;\n\t                pos[0] += dx;\n\t                pos[1] += dy;\n\t                target.dirty();\n\t            }\n\t\n\t            eventTool.stop(e.event);\n\t            this.trigger('pan', dx, dy, oldX, oldY, x, y);\n\t        }\n\t    }\n\t\n\t    function mouseup(e) {\n\t        this._dragging = false;\n\t    }\n\t\n\t    function mousewheel(e) {\n\t        // Convenience:\n\t        // Mac and VM Windows on Mac: scroll up: zoom out.\n\t        // Windows: scroll up: zoom in.\n\t        var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\n\t        zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);\n\t    }\n\t\n\t    function pinch(e) {\n\t        if (interactionMutex.isTaken(this._zr, 'globalPan')) {\n\t            return;\n\t        }\n\t        var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;\n\t        zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);\n\t    }\n\t\n\t    function zoom(e, zoomDelta, zoomX, zoomY) {\n\t        if (this.containsPoint && this.containsPoint(zoomX, zoomY)) {\n\t            // When mouse is out of roamController rect,\n\t            // default befavoius should be be disabled, otherwise\n\t            // page sliding is disabled, contrary to expectation.\n\t            eventTool.stop(e.event);\n\t\n\t            var target = this.target;\n\t            var zoomLimit = this.zoomLimit;\n\t\n\t            if (target) {\n\t                var pos = target.position;\n\t                var scale = target.scale;\n\t\n\t                var newZoom = this.zoom = this.zoom || 1;\n\t                newZoom *= zoomDelta;\n\t                if (zoomLimit) {\n\t                    var zoomMin = zoomLimit.min || 0;\n\t                    var zoomMax = zoomLimit.max || Infinity;\n\t                    newZoom = Math.max(\n\t                        Math.min(zoomMax, newZoom),\n\t                        zoomMin\n\t                    );\n\t                }\n\t                var zoomScale = newZoom / this.zoom;\n\t                this.zoom = newZoom;\n\t                // Keep the mouse center when scaling\n\t                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\n\t                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\n\t                scale[0] *= zoomScale;\n\t                scale[1] *= zoomScale;\n\t\n\t                target.dirty();\n\t            }\n\t\n\t            this.trigger('zoom', zoomDelta, zoomX, zoomY);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @alias module:echarts/component/helper/RoamController\n\t     * @constructor\n\t     * @mixin {module:zrender/mixin/Eventful}\n\t     *\n\t     * @param {module:zrender/zrender~ZRender} zr\n\t     * @param {module:zrender/Element} target\n\t     */\n\t    function RoamController(zr, target) {\n\t\n\t        /**\n\t         * @type {module:zrender/Element}\n\t         */\n\t        this.target = target;\n\t\n\t        /**\n\t         * @type {Function}\n\t         */\n\t        this.containsPoint;\n\t\n\t        /**\n\t         * { min: 1, max: 2 }\n\t         * @type {Object}\n\t         */\n\t        this.zoomLimit;\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.zoom;\n\t        /**\n\t         * @type {module:zrender}\n\t         */\n\t        this._zr = zr;\n\t\n\t        // Avoid two roamController bind the same handler\n\t        var bind = zrUtil.bind;\n\t        var mousedownHandler = bind(mousedown, this);\n\t        var mousemoveHandler = bind(mousemove, this);\n\t        var mouseupHandler = bind(mouseup, this);\n\t        var mousewheelHandler = bind(mousewheel, this);\n\t        var pinchHandler = bind(pinch, this);\n\t\n\t        Eventful.call(this);\n\t\n\t        /**\n\t         * @param {Function} containsPoint\n\t         *                   input: x, y\n\t         *                   output: boolean\n\t         */\n\t        this.setContainsPoint = function (containsPoint) {\n\t            this.containsPoint = containsPoint;\n\t        };\n\t\n\t        /**\n\t         * Notice: only enable needed types. For example, if 'zoom'\n\t         * is not needed, 'zoom' should not be enabled, otherwise\n\t         * default mousewheel behaviour (scroll page) will be disabled.\n\t         *\n\t         * @param  {boolean|string} [controlType=true] Specify the control type,\n\t         *                          which can be null/undefined or true/false\n\t         *                          or 'pan/move' or 'zoom'/'scale'\n\t         */\n\t        this.enable = function (controlType) {\n\t            // Disable previous first\n\t            this.disable();\n\t\n\t            if (controlType == null) {\n\t                controlType = true;\n\t            }\n\t\n\t            if (controlType === true || (controlType === 'move' || controlType === 'pan')) {\n\t                zr.on('mousedown', mousedownHandler);\n\t                zr.on('mousemove', mousemoveHandler);\n\t                zr.on('mouseup', mouseupHandler);\n\t            }\n\t            if (controlType === true || (controlType === 'scale' || controlType === 'zoom')) {\n\t                zr.on('mousewheel', mousewheelHandler);\n\t                zr.on('pinch', pinchHandler);\n\t            }\n\t        };\n\t\n\t        this.disable = function () {\n\t            zr.off('mousedown', mousedownHandler);\n\t            zr.off('mousemove', mousemoveHandler);\n\t            zr.off('mouseup', mouseupHandler);\n\t            zr.off('mousewheel', mousewheelHandler);\n\t            zr.off('pinch', pinchHandler);\n\t        };\n\t\n\t        this.dispose = this.disable;\n\t\n\t        this.isDragging = function () {\n\t            return this._dragging;\n\t        };\n\t\n\t        this.isPinching = function () {\n\t            return this._pinching;\n\t        };\n\t    }\n\t\n\t    zrUtil.mixin(RoamController, Eventful);\n\t\n\t    module.exports = RoamController;\n\n\n/***/ },\n/* 80 */\n/*!********************************************!*\\\n  !*** ./lib/component/helper/sliderMove.js ***!\n  \\********************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    /**\n\t     * Calculate slider move result.\n\t     *\n\t     * @param {number} delta Move length.\n\t     * @param {Array.<number>} handleEnds handleEnds[0] and be bigger then handleEnds[1].\n\t     *                                    handleEnds will be modified in this method.\n\t     * @param {Array.<number>} extent handleEnds is restricted by extent.\n\t     *                                extent[0] should less or equals than extent[1].\n\t     * @param {string} mode 'rigid': Math.abs(handleEnds[0] - handleEnds[1]) remain unchanged,\n\t     *                      'cross' handleEnds[0] can be bigger then handleEnds[1],\n\t     *                      'push' handleEnds[0] can not be bigger then handleEnds[1],\n\t     *                              when they touch, one push other.\n\t     * @param {number} handleIndex If mode is 'rigid', handleIndex is not required.\n\t     * @param {Array.<number>} The input handleEnds.\n\t     */\n\t    module.exports = function (delta, handleEnds, extent, mode, handleIndex) {\n\t        if (!delta) {\n\t            return handleEnds;\n\t        }\n\t\n\t        if (mode === 'rigid') {\n\t            delta = getRealDelta(delta, handleEnds, extent);\n\t            handleEnds[0] += delta;\n\t            handleEnds[1] += delta;\n\t        }\n\t        else {\n\t            delta = getRealDelta(delta, handleEnds[handleIndex], extent);\n\t            handleEnds[handleIndex] += delta;\n\t\n\t            if (mode === 'push' && handleEnds[0] > handleEnds[1]) {\n\t                handleEnds[1 - handleIndex] = handleEnds[handleIndex];\n\t            }\n\t        }\n\t\n\t        return handleEnds;\n\t\n\t        function getRealDelta(delta, handleEnds, extent) {\n\t            var handleMinMax = !handleEnds.length\n\t                ? [handleEnds, handleEnds]\n\t                : handleEnds.slice();\n\t            handleEnds[0] > handleEnds[1] && handleMinMax.reverse();\n\t\n\t            if (delta < 0 && handleMinMax[0] + delta < extent[0]) {\n\t                delta = extent[0] - handleMinMax[0];\n\t            }\n\t            if (delta > 0 && handleMinMax[1] + delta > extent[1]) {\n\t                delta = extent[1] - handleMinMax[1];\n\t            }\n\t            return delta;\n\t        }\n\t    };\n\n\n/***/ },\n/* 81 */\n/*!**********************************!*\\\n  !*** ./lib/coord/axisDefault.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var defaultOption = {\n\t        show: true,\n\t        zlevel: 0,                  // \n\t        z: 0,                       // \n\t        // \n\t        inverse: false,\n\t\n\t        // \n\t        name: '',\n\t        // 'start' | 'middle' | 'end'\n\t        nameLocation: 'end',\n\t        // degree\n\t        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n\t        nameTruncate: {\n\t            maxWidth: null,\n\t            ellipsis: '...',\n\t            placeholder: '.'\n\t        },\n\t        // \n\t        nameTextStyle: {},\n\t        // \n\t        nameGap: 15,\n\t\n\t        silent: false, // Default false to support tooltip.\n\t        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\t\n\t        tooltip: {\n\t            show: false\n\t        },\n\t\n\t        // \n\t        axisLine: {\n\t            // show\n\t            show: true,\n\t            onZero: true,\n\t            // lineStyle\n\t            lineStyle: {\n\t                color: '#333',\n\t                width: 1,\n\t                type: 'solid'\n\t            }\n\t        },\n\t        // \n\t        axisTick: {\n\t            // show\n\t            show: true,\n\t            // grid\n\t            inside: false,\n\t            // length\n\t            length: 5,\n\t            // lineStyle\n\t            lineStyle: {\n\t                width: 1\n\t            }\n\t        },\n\t        // axis.axisLabel\n\t        axisLabel: {\n\t            show: true,\n\t            // grid\n\t            inside: false,\n\t            rotate: 0,\n\t            margin: 8,\n\t            // formatter: null,\n\t            // TEXTSTYLE\n\t            textStyle: {\n\t                fontSize: 12\n\t            }\n\t        },\n\t        // \n\t        splitLine: {\n\t            // show\n\t            show: true,\n\t            // lineStylelineStyle\n\t            lineStyle: {\n\t                color: ['#ccc'],\n\t                width: 1,\n\t                type: 'solid'\n\t            }\n\t        },\n\t        // \n\t        splitArea: {\n\t            // show\n\t            show: false,\n\t            // areaStyleareaStyle\n\t            areaStyle: {\n\t                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n\t            }\n\t        }\n\t    };\n\t\n\t    var categoryAxis = zrUtil.merge({\n\t        // \n\t        boundaryGap: true,\n\t        // splitArea: {\n\t            // show: false\n\t        // },\n\t        splitLine: {\n\t            show: false\n\t        },\n\t        // \n\t        axisTick: {\n\t            // If tick is align with label when boundaryGap is true\n\t            // Default with axisTick\n\t            alignWithLabel: false,\n\t            interval: 'auto'\n\t        },\n\t        // axis.axisLabel\n\t        axisLabel: {\n\t            interval: 'auto'\n\t        }\n\t    }, defaultOption);\n\t\n\t    var valueAxis = zrUtil.merge({\n\t        // \n\t        boundaryGap: [0, 0],\n\t        // ,  'dataMin' \n\t        // min: null,\n\t        //  'dataMax' \n\t        // max: null,\n\t        // Readonly prop, specifies start value of the range when using data zoom.\n\t        // rangeStart: null\n\t        // Readonly prop, specifies end value of the range when using data zoom.\n\t        // rangeEnd: null\n\t        // 0_min_max\n\t        // scale: false,\n\t        // 5\n\t        splitNumber: 5\n\t        // Minimum interval\n\t        // minInterval: null\n\t    }, defaultOption);\n\t\n\t    // FIXME\n\t    var timeAxis = zrUtil.defaults({\n\t        scale: true,\n\t        min: 'dataMin',\n\t        max: 'dataMax'\n\t    }, valueAxis);\n\t    var logAxis = zrUtil.defaults({\n\t        logBase: 10\n\t    }, valueAxis);\n\t    logAxis.scale = true;\n\t\n\t    module.exports = {\n\t        categoryAxis: categoryAxis,\n\t        valueAxis: valueAxis,\n\t        timeAxis: timeAxis,\n\t        logAxis: logAxis\n\t    };\n\n\n/***/ },\n/* 82 */\n/*!*****************************************!*\\\n  !*** ./lib/coord/axisModelZoomMixin.js ***!\n  \\*****************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t\n\t        /**\n\t         * @public\n\t         * @return {Array.<number|string|Date>}\n\t         */\n\t        getMin: function () {\n\t            var option = this.option;\n\t            var min = option.rangeStart != null ? option.rangeStart : option.min;\n\t            // In case of axis.type === 'time', Date should be converted to timestamp.\n\t            // In other cases, min/max should be a number or null/undefined or 'dataMin/Max'.\n\t            if (min instanceof Date) {\n\t                min = +min;\n\t            }\n\t            return min;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @return {Array.<number|string|Date>}\n\t         */\n\t        getMax: function () {\n\t            var option = this.option;\n\t            var max = option.rangeEnd != null ? option.rangeEnd : option.max;\n\t            // In case of axis.type === 'time', Date should be converted to timestamp.\n\t            // In other cases, min/max should be a number or null/undefined or 'dataMin/Max'.\n\t            if (max instanceof Date) {\n\t                max = +max;\n\t            }\n\t            return max;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @return {boolean}\n\t         */\n\t        getNeedCrossZero: function () {\n\t            var option = this.option;\n\t            return (option.rangeStart != null || option.rangeEnd != null)\n\t                ? false : !option.scale;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @param {number} rangeStart\n\t         * @param {number} rangeEnd\n\t         */\n\t        setRange: function (rangeStart, rangeEnd) {\n\t            this.option.rangeStart = rangeStart;\n\t            this.option.rangeEnd = rangeEnd;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         */\n\t        resetRange: function () {\n\t            // rangeStart and rangeEnd is readonly.\n\t            this.option.rangeStart = this.option.rangeEnd = null;\n\t        }\n\t    };\n\t\n\n\n/***/ },\n/* 83 */\n/*!******************************!*\\\n  !*** ./lib/util/throttle.js ***!\n  \\******************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var lib = {};\n\t\n\t    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n\t    var RATE = '\\0__throttleRate';\n\t    var THROTTLE_TYPE = '\\0__throttleType';\n\t\n\t    /**\n\t     * @public\n\t     * @param {(Function)} fn\n\t     * @param {number} [delay=0] Unit: ms.\n\t     * @param {boolean} [debounce=false]\n\t     *        true: If call interval less than `delay`, only the last call works.\n\t     *        false: If call interval less than `delay, call works on fixed rate.\n\t     * @return {(Function)} throttled fn.\n\t     */\n\t    lib.throttle = function (fn, delay, debounce) {\n\t\n\t        var currCall;\n\t        var lastCall = 0;\n\t        var lastExec = 0;\n\t        var timer = null;\n\t        var diff;\n\t        var scope;\n\t        var args;\n\t\n\t        delay = delay || 0;\n\t\n\t        function exec() {\n\t            lastExec = (new Date()).getTime();\n\t            timer = null;\n\t            fn.apply(scope, args || []);\n\t        }\n\t\n\t        var cb = function () {\n\t            currCall = (new Date()).getTime();\n\t            scope = this;\n\t            args = arguments;\n\t            diff = currCall - (debounce ? lastCall : lastExec) - delay;\n\t\n\t            clearTimeout(timer);\n\t\n\t            if (debounce) {\n\t                timer = setTimeout(exec, delay);\n\t            }\n\t            else {\n\t                if (diff >= 0) {\n\t                    exec();\n\t                }\n\t                else {\n\t                    timer = setTimeout(exec, -diff);\n\t                }\n\t            }\n\t\n\t            lastCall = currCall;\n\t        };\n\t\n\t        /**\n\t         * Clear throttle.\n\t         * @public\n\t         */\n\t        cb.clear = function () {\n\t            if (timer) {\n\t                clearTimeout(timer);\n\t                timer = null;\n\t            }\n\t        };\n\t\n\t        return cb;\n\t    };\n\t\n\t    /**\n\t     * Create throttle method or update throttle rate.\n\t     *\n\t     * @example\n\t     * ComponentView.prototype.render = function () {\n\t     *     ...\n\t     *     throttle.createOrUpdate(\n\t     *         this,\n\t     *         '_dispatchAction',\n\t     *         this.model.get('throttle'),\n\t     *         'fixRate'\n\t     *     );\n\t     * };\n\t     * ComponentView.prototype.remove = function () {\n\t     *     throttle.clear(this, '_dispatchAction');\n\t     * };\n\t     * ComponentView.prototype.dispose = function () {\n\t     *     throttle.clear(this, '_dispatchAction');\n\t     * };\n\t     *\n\t     * @public\n\t     * @param {Object} obj\n\t     * @param {string} fnAttr\n\t     * @param {number} [rate]\n\t     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n\t     * @return {Function} throttled function.\n\t     */\n\t    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n\t        var fn = obj[fnAttr];\n\t\n\t        if (!fn) {\n\t            return;\n\t        }\n\t\n\t        var originFn = fn[ORIGIN_METHOD] || fn;\n\t        var lastThrottleType = fn[THROTTLE_TYPE];\n\t        var lastRate = fn[RATE];\n\t\n\t        if (lastRate !== rate || lastThrottleType !== throttleType) {\n\t            if (rate == null || !throttleType) {\n\t                return (obj[fnAttr] = originFn);\n\t            }\n\t\n\t            fn = obj[fnAttr] = lib.throttle(\n\t                originFn, rate, throttleType === 'debounce'\n\t            );\n\t            fn[ORIGIN_METHOD] = originFn;\n\t            fn[THROTTLE_TYPE] = throttleType;\n\t            fn[RATE] = rate;\n\t        }\n\t\n\t        return fn;\n\t    };\n\t\n\t    /**\n\t     * Clear throttle. Example see throttle.createOrUpdate.\n\t     *\n\t     * @public\n\t     * @param {Object} obj\n\t     * @param {string} fnAttr\n\t     */\n\t    lib.clear = function (obj, fnAttr) {\n\t        var fn = obj[fnAttr];\n\t        if (fn && fn[ORIGIN_METHOD]) {\n\t            obj[fnAttr] = fn[ORIGIN_METHOD];\n\t        }\n\t    };\n\t\n\t    module.exports = lib;\n\t\n\n\n/***/ },\n/* 84 */\n/*!***************************************!*\\\n  !*** ./~/zrender/lib/contain/line.js ***!\n  \\***************************************/\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l)\n\t                || (y < y0 - _l && y < y1 - _l)\n\t                || (x > x0 + _l && x > x1 + _l)\n\t                || (x < x0 - _l && x < x1 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n\t            }\n\t            else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 85 */\n/*!********************************************!*\\\n  !*** ./~/zrender/lib/contain/quadratic.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(/*! ../core/curve */ 17);\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(\n\t                x0, y0, x1, y1, x2, y2,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 86 */\n/*!**********************************************!*\\\n  !*** ./~/zrender/lib/contain/windingLine.js ***!\n  \\**********************************************/\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n\t        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n\t            return 0;\n\t        }\n\t        // Ignore horizontal line\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t\n\t        // Avoid winding error when intersection point is the connect point of two line of polygon\n\t        if (t === 1 || t === 0) {\n\t            dir = y1 < y0 ? 0.5 : -0.5;\n\t        }\n\t\n\t        var x_ = t * (x1 - x0) + x0;\n\t\n\t        return x_ > x ? dir : 0;\n\t    };\n\n\n/***/ },\n/* 87 */\n/*!*************************************************!*\\\n  !*** ./~/zrender/lib/graphic/LinearGradient.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t\n\t    var Gradient = __webpack_require__(/*! ./Gradient */ 29);\n\t\n\t    /**\n\t     * x, y, x2, y2 are all percent from 0 to 1\n\t     * @param {number} [x=0]\n\t     * @param {number} [y=0]\n\t     * @param {number} [x2=1]\n\t     * @param {number} [y2=0]\n\t     * @param {Array.<Object>} colorStops\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t        this.x = x == null ? 0 : x;\n\t\n\t        this.y = y == null ? 0 : y;\n\t\n\t        this.x2 = x2 == null ? 1 : x2;\n\t\n\t        this.y2 = y2 == null ? 0 : y2;\n\t\n\t        // Can be cloned\n\t        this.type = 'linear';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    LinearGradient.prototype = {\n\t\n\t        constructor: LinearGradient\n\t    };\n\t\n\t    zrUtil.inherits(LinearGradient, Gradient);\n\t\n\t    module.exports = LinearGradient;\n\n\n/***/ },\n/* 88 */\n/*!**********************************************!*\\\n  !*** ./~/zrender/lib/mixin/Transformable.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var matrix = __webpack_require__(/*! ../core/matrix */ 19);\n\t    var vector = __webpack_require__(/*! ../core/vector */ 5);\n\t    var mIdentity = matrix.identity;\n\t\n\t    var EPSILON = 5e-5;\n\t\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [0, 0];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [1, 1];\n\t        }\n\t        /**\n\t         * \n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t\n\t    /**\n\t     * \n\t     * , position, rotation, scaletransformtransform\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation)\n\t            || isNotAroundZero(this.position[0])\n\t            || isNotAroundZero(this.position[1])\n\t            || isNotAroundZero(this.scale[0] - 1)\n\t            || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t\n\t        m = m || matrix.create();\n\t\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        }\n\t        else {\n\t            mIdentity(m);\n\t        }\n\t\n\t        // \n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            }\n\t            else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // \n\t        this.transform = m;\n\t\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t\n\t    transformableProto.getLocalTransform = function (m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t\n\t        var origin = this.origin;\n\t\n\t        var scale = this.scale;\n\t        var rotation = this.rotation;\n\t        var position = this.position;\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t\n\t        return m;\n\t    };\n\t    /**\n\t     * transformcontext\n\t     * @param {Context2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        if (m) {\n\t            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t        }\n\t        else {\n\t            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t        }\n\t    };\n\t\n\t    transformableProto.restoreTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t    }\n\t\n\t    var tmpTransform = [];\n\t\n\t    /**\n\t     * `transform``position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t\n\t    /**\n\t     * Get global scale\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.getGlobalScale = function () {\n\t        var m = this.transform;\n\t        if (!m) {\n\t            return [1, 1];\n\t        }\n\t        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        return [sx, sy];\n\t    };\n\t    /**\n\t     *  shape \n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    /**\n\t     * \n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    module.exports = Transformable;\n\t\n\n\n/***/ },\n/* 89 */\n/*!*****************************!*\\\n  !*** ./lib/ExtensionAPI.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var echartsAPIList = [\n\t        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction', 'isDisposed',\n\t        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\n\t    ];\n\t\n\t    function ExtensionAPI(chartInstance) {\n\t        zrUtil.each(echartsAPIList, function (name) {\n\t            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n\t        }, this);\n\t    }\n\t\n\t    module.exports = ExtensionAPI;\n\n\n/***/ },\n/* 90 */\n/*!**************************!*\\\n  !*** ./lib/chart/bar.js ***!\n  \\**************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    __webpack_require__(/*! ../coord/cartesian/Grid */ 54);\n\t\n\t    __webpack_require__(/*! ./bar/BarSeries */ 91);\n\t    __webpack_require__(/*! ./bar/BarView */ 92);\n\t\n\t    var barLayoutGrid = __webpack_require__(/*! ../layout/barGrid */ 122);\n\t    var echarts = __webpack_require__(/*! ../echarts */ 2);\n\t\n\t    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n\t    // Visual coding for legend\n\t    echarts.registerVisual(function (ecModel) {\n\t        ecModel.eachSeriesByType('bar', function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            data.setVisual('legendSymbol', 'roundRect');\n\t        });\n\t    });\n\t\n\t    // In case developer forget to include grid component\n\t    __webpack_require__(/*! ../component/grid */ 36);\n\n\n/***/ },\n/* 91 */\n/*!************************************!*\\\n  !*** ./lib/chart/bar/BarSeries.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var SeriesModel = __webpack_require__(/*! ../../model/Series */ 15);\n\t    var createListFromArray = __webpack_require__(/*! ../helper/createListFromArray */ 35);\n\t\n\t    module.exports = SeriesModel.extend({\n\t\n\t        type: 'series.bar',\n\t\n\t        dependencies: ['grid', 'polar'],\n\t\n\t        getInitialData: function (option, ecModel) {\n\t            if (false) {\n\t                var coordSys = option.coordinateSystem;\n\t                if (coordSys !== 'cartesian2d') {\n\t                    throw new Error('Bar only support cartesian2d coordinateSystem');\n\t                }\n\t            }\n\t            return createListFromArray(option.data, this, ecModel);\n\t        },\n\t\n\t        getMarkerPosition: function (value) {\n\t            var coordSys = this.coordinateSystem;\n\t            if (coordSys) {\n\t                // PENDING if clamp ?\n\t                var pt = coordSys.dataToPoint(value, true);\n\t                var data = this.getData();\n\t                var offset = data.getLayout('offset');\n\t                var size = data.getLayout('size');\n\t                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n\t                pt[offsetIndex] += offset + size / 2;\n\t                return pt;\n\t            }\n\t            return [NaN, NaN];\n\t        },\n\t\n\t        brushSelector: 'rect',\n\t\n\t        defaultOption: {\n\t            zlevel: 0,                  // \n\t            z: 2,                       // \n\t            coordinateSystem: 'cartesian2d',\n\t            legendHoverLink: true,\n\t            // stack: null\n\t\n\t            // Cartesian coordinate system\n\t            // xAxisIndex: 0,\n\t            // yAxisIndex: 0,\n\t\n\t            // 0\n\t            barMinHeight: 0,\n\t\n\t            // barMaxWidth: null,\n\t            // \n\t            // barWidth: null,\n\t            // 30%\n\t            // barGap: '30%',\n\t            // 20%\n\t            // barCategoryGap: '20%',\n\t            // label: {\n\t            //     normal: {\n\t            //         show: false\n\t            //     }\n\t            // },\n\t            itemStyle: {\n\t                normal: {\n\t                    // color: ''\n\t                },\n\t                emphasis: {}\n\t            }\n\t        }\n\t    });\n\n\n/***/ },\n/* 92 */\n/*!**********************************!*\\\n  !*** ./lib/chart/bar/BarView.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t\n\t    zrUtil.extend(__webpack_require__(/*! ../../model/Model */ 10).prototype, __webpack_require__(/*! ./barItemStyle */ 93));\n\t\n\t    function fixLayoutWithLineWidth(layout, lineWidth) {\n\t        var signX = layout.width > 0 ? 1 : -1;\n\t        var signY = layout.height > 0 ? 1 : -1;\n\t        // In case width or height are too small.\n\t        lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));\n\t        layout.x += signX * lineWidth / 2;\n\t        layout.y += signY * lineWidth / 2;\n\t        layout.width -= signX * lineWidth;\n\t        layout.height -= signY * lineWidth;\n\t    }\n\t\n\t    module.exports = __webpack_require__(/*! ../../echarts */ 2).extendChartView({\n\t\n\t        type: 'bar',\n\t\n\t        render: function (seriesModel, ecModel, api) {\n\t            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\t\n\t            if (coordinateSystemType === 'cartesian2d') {\n\t                this._renderOnCartesian(seriesModel, ecModel, api);\n\t            }\n\t\n\t            return this.group;\n\t        },\n\t\n\t        dispose: zrUtil.noop,\n\t\n\t        _renderOnCartesian: function (seriesModel, ecModel, api) {\n\t            var group = this.group;\n\t            var data = seriesModel.getData();\n\t            var oldData = this._data;\n\t\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var isHorizontal = baseAxis.isHorizontal();\n\t\n\t            var enableAnimation = seriesModel.get('animation');\n\t\n\t            var barBorderWidthQuery = ['itemStyle', 'normal', 'barBorderWidth'];\n\t\n\t            function createRect(dataIndex, isUpdate) {\n\t                var layout = data.getItemLayout(dataIndex);\n\t                var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;\n\t                fixLayoutWithLineWidth(layout, lineWidth);\n\t\n\t                var rect = new graphic.Rect({\n\t                    shape: zrUtil.extend({}, layout)\n\t                });\n\t                // Animation\n\t                if (enableAnimation) {\n\t                    var rectShape = rect.shape;\n\t                    var animateProperty = isHorizontal ? 'height' : 'width';\n\t                    var animateTarget = {};\n\t                    rectShape[animateProperty] = 0;\n\t                    animateTarget[animateProperty] = layout[animateProperty];\n\t                    graphic[isUpdate? 'updateProps' : 'initProps'](rect, {\n\t                        shape: animateTarget\n\t                    }, seriesModel, dataIndex);\n\t                }\n\t                return rect;\n\t            }\n\t            data.diff(oldData)\n\t                .add(function (dataIndex) {\n\t                    // \n\t                    if (!data.hasValue(dataIndex)) {\n\t                        return;\n\t                    }\n\t\n\t                    var rect = createRect(dataIndex);\n\t\n\t                    data.setItemGraphicEl(dataIndex, rect);\n\t\n\t                    group.add(rect);\n\t\n\t                })\n\t                .update(function (newIndex, oldIndex) {\n\t                    var rect = oldData.getItemGraphicEl(oldIndex);\n\t                    // \n\t                    if (!data.hasValue(newIndex)) {\n\t                        group.remove(rect);\n\t                        return;\n\t                    }\n\t                    if (!rect) {\n\t                        rect = createRect(newIndex, true);\n\t                    }\n\t\n\t                    var layout = data.getItemLayout(newIndex);\n\t                    var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;\n\t                    fixLayoutWithLineWidth(layout, lineWidth);\n\t\n\t                    graphic.updateProps(rect, {\n\t                        shape: layout\n\t                    }, seriesModel, newIndex);\n\t\n\t                    data.setItemGraphicEl(newIndex, rect);\n\t\n\t                    // Add back\n\t                    group.add(rect);\n\t                })\n\t                .remove(function (idx) {\n\t                    var rect = oldData.getItemGraphicEl(idx);\n\t                    if (rect) {\n\t                        // Not show text when animating\n\t                        rect.style.text = '';\n\t                        graphic.updateProps(rect, {\n\t                            shape: {\n\t                                width: 0\n\t                            }\n\t                        }, seriesModel, idx, function () {\n\t                            group.remove(rect);\n\t                        });\n\t                    }\n\t                })\n\t                .execute();\n\t\n\t            this._updateStyle(seriesModel, data, isHorizontal);\n\t\n\t            this._data = data;\n\t        },\n\t\n\t        _updateStyle: function (seriesModel, data, isHorizontal) {\n\t            function setLabel(style, model, color, labelText, labelPositionOutside) {\n\t                graphic.setText(style, model, color);\n\t                style.text = labelText;\n\t                if (style.textPosition === 'outside') {\n\t                    style.textPosition = labelPositionOutside;\n\t                }\n\t            }\n\t\n\t            data.eachItemGraphicEl(function (rect, idx) {\n\t                var itemModel = data.getItemModel(idx);\n\t                var color = data.getItemVisual(idx, 'color');\n\t                var opacity = data.getItemVisual(idx, 'opacity');\n\t                var layout = data.getItemLayout(idx);\n\t                var itemStyleModel = itemModel.getModel('itemStyle.normal');\n\t\n\t                var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\t\n\t                rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n\t\n\t                rect.useStyle(zrUtil.defaults(\n\t                    {\n\t                        fill: color,\n\t                        opacity: opacity\n\t                    },\n\t                    itemStyleModel.getBarItemStyle()\n\t                ));\n\t\n\t                var labelPositionOutside = isHorizontal\n\t                    ? (layout.height > 0 ? 'bottom' : 'top')\n\t                    : (layout.width > 0 ? 'left' : 'right');\n\t\n\t                var labelModel = itemModel.getModel('label.normal');\n\t                var hoverLabelModel = itemModel.getModel('label.emphasis');\n\t                var rectStyle = rect.style;\n\t                if (labelModel.get('show')) {\n\t                    setLabel(\n\t                        rectStyle, labelModel, color,\n\t                        zrUtil.retrieve(\n\t                            seriesModel.getFormattedLabel(idx, 'normal'),\n\t                            seriesModel.getRawValue(idx)\n\t                        ),\n\t                        labelPositionOutside\n\t                    );\n\t                }\n\t                else {\n\t                    rectStyle.text = '';\n\t                }\n\t                if (hoverLabelModel.get('show')) {\n\t                    setLabel(\n\t                        hoverStyle, hoverLabelModel, color,\n\t                        zrUtil.retrieve(\n\t                            seriesModel.getFormattedLabel(idx, 'emphasis'),\n\t                            seriesModel.getRawValue(idx)\n\t                        ),\n\t                        labelPositionOutside\n\t                    );\n\t                }\n\t                else {\n\t                    hoverStyle.text = '';\n\t                }\n\t                graphic.setHoverStyle(rect, hoverStyle);\n\t            });\n\t        },\n\t\n\t        remove: function (ecModel, api) {\n\t            var group = this.group;\n\t            if (ecModel.get('animation')) {\n\t                if (this._data) {\n\t                    this._data.eachItemGraphicEl(function (el) {\n\t                        // Not show text when animating\n\t                        el.style.text = '';\n\t                        graphic.updateProps(el, {\n\t                            shape: {\n\t                                width: 0\n\t                            }\n\t                        }, ecModel, el.dataIndex, function () {\n\t                            group.remove(el);\n\t                        });\n\t                    });\n\t                }\n\t            }\n\t            else {\n\t                group.removeAll();\n\t            }\n\t        }\n\t    });\n\n\n/***/ },\n/* 93 */\n/*!***************************************!*\\\n  !*** ./lib/chart/bar/barItemStyle.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t\n\t    var getBarItemStyle = __webpack_require__(/*! ../../model/mixin/makeStyleMapper */ 31)(\n\t        [\n\t            ['fill', 'color'],\n\t            ['stroke', 'borderColor'],\n\t            ['lineWidth', 'borderWidth'],\n\t            // Compatitable with 2\n\t            ['stroke', 'barBorderColor'],\n\t            ['lineWidth', 'barBorderWidth'],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]\n\t    );\n\t    module.exports = {\n\t        getBarItemStyle: function (excludes) {\n\t            var style = getBarItemStyle.call(this, excludes);\n\t            if (this.getBorderLineDash) {\n\t                var lineDash = this.getBorderLineDash();\n\t                lineDash && (style.lineDash = lineDash);\n\t            }\n\t            return style;\n\t        }\n\t    };\n\n\n/***/ },\n/* 94 */\n/*!**********************************!*\\\n  !*** ./lib/chart/helper/Line.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/chart/helper/Line\n\t */\n\t\n\t\n\t    var symbolUtil = __webpack_require__(/*! ../../util/symbol */ 26);\n\t    var vector = __webpack_require__(/*! zrender/lib/core/vector */ 5);\n\t    // var matrix = require('zrender/lib/core/matrix');\n\t    var LinePath = __webpack_require__(/*! ./LinePath */ 175);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var numberUtil = __webpack_require__(/*! ../../util/number */ 4);\n\t\n\t    var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];\n\t    function makeSymbolTypeKey(symbolCategory) {\n\t        return '_' + symbolCategory + 'Type';\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function createSymbol(name, lineData, idx) {\n\t        var color = lineData.getItemVisual(idx, 'color');\n\t        var symbolType = lineData.getItemVisual(idx, name);\n\t        var symbolSize = lineData.getItemVisual(idx, name + 'Size');\n\t\n\t        if (!symbolType || symbolType === 'none') {\n\t            return;\n\t        }\n\t\n\t        if (!zrUtil.isArray(symbolSize)) {\n\t            symbolSize = [symbolSize, symbolSize];\n\t        }\n\t        var symbolPath = symbolUtil.createSymbol(\n\t            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\n\t            symbolSize[0], symbolSize[1], color\n\t        );\n\t\n\t        symbolPath.name = name;\n\t\n\t        return symbolPath;\n\t    }\n\t\n\t    function createLine(points) {\n\t        var line = new LinePath({\n\t            name: 'line'\n\t        });\n\t        setLinePoints(line.shape, points);\n\t        return line;\n\t    }\n\t\n\t    function setLinePoints(targetShape, points) {\n\t        var p1 = points[0];\n\t        var p2 = points[1];\n\t        var cp1 = points[2];\n\t        targetShape.x1 = p1[0];\n\t        targetShape.y1 = p1[1];\n\t        targetShape.x2 = p2[0];\n\t        targetShape.y2 = p2[1];\n\t        targetShape.percent = 1;\n\t\n\t        if (cp1) {\n\t            targetShape.cpx1 = cp1[0];\n\t            targetShape.cpy1 = cp1[1];\n\t        }\n\t        else {\n\t            targetShape.cpx1 = NaN;\n\t            targetShape.cpy1 = NaN;\n\t        }\n\t    }\n\t\n\t    function updateSymbolAndLabelBeforeLineUpdate () {\n\t        var lineGroup = this;\n\t        var symbolFrom = lineGroup.childOfName('fromSymbol');\n\t        var symbolTo = lineGroup.childOfName('toSymbol');\n\t        var label = lineGroup.childOfName('label');\n\t        // Quick reject\n\t        if (!symbolFrom && !symbolTo && label.ignore) {\n\t            return;\n\t        }\n\t\n\t        var invScale = 1;\n\t        var parentNode = this.parent;\n\t        while (parentNode) {\n\t            if (parentNode.scale) {\n\t                invScale /= parentNode.scale[0];\n\t            }\n\t            parentNode = parentNode.parent;\n\t        }\n\t\n\t        var line = lineGroup.childOfName('line');\n\t        // If line not changed\n\t        // FIXME Parent scale changed\n\t        if (!this.__dirty && !line.__dirty) {\n\t            return;\n\t        }\n\t\n\t        var percent = line.shape.percent;\n\t        var fromPos = line.pointAt(0);\n\t        var toPos = line.pointAt(percent);\n\t\n\t        var d = vector.sub([], toPos, fromPos);\n\t        vector.normalize(d, d);\n\t\n\t        if (symbolFrom) {\n\t            symbolFrom.attr('position', fromPos);\n\t            var tangent = line.tangentAt(0);\n\t            symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(\n\t                tangent[1], tangent[0]\n\t            ));\n\t            symbolFrom.attr('scale', [invScale * percent, invScale * percent]);\n\t        }\n\t        if (symbolTo) {\n\t            symbolTo.attr('position', toPos);\n\t            var tangent = line.tangentAt(1);\n\t            symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(\n\t                tangent[1], tangent[0]\n\t            ));\n\t            symbolTo.attr('scale', [invScale * percent, invScale * percent]);\n\t        }\n\t\n\t        if (!label.ignore) {\n\t            label.attr('position', toPos);\n\t\n\t            var textPosition;\n\t            var textAlign;\n\t            var textVerticalAlign;\n\t\n\t            var distance = 5 * invScale;\n\t            // End\n\t            if (label.__position === 'end') {\n\t                textPosition = [d[0] * distance + toPos[0], d[1] * distance + toPos[1]];\n\t                textAlign = d[0] > 0.8 ? 'left' : (d[0] < -0.8 ? 'right' : 'center');\n\t                textVerticalAlign = d[1] > 0.8 ? 'top' : (d[1] < -0.8 ? 'bottom' : 'middle');\n\t            }\n\t            // Middle\n\t            else if (label.__position === 'middle') {\n\t                var halfPercent = percent / 2;\n\t                var tangent = line.tangentAt(halfPercent);\n\t                var n = [tangent[1], -tangent[0]];\n\t                var cp = line.pointAt(halfPercent);\n\t                if (n[1] > 0) {\n\t                    n[0] = -n[0];\n\t                    n[1] = -n[1];\n\t                }\n\t                textPosition = [cp[0] + n[0] * distance, cp[1] + n[1] * distance];\n\t                textAlign = 'center';\n\t                textVerticalAlign = 'bottom';\n\t                var rotation = -Math.atan2(tangent[1], tangent[0]);\n\t                if (toPos[0] < fromPos[0]) {\n\t                    rotation = Math.PI + rotation;\n\t                }\n\t                label.attr('rotation', rotation);\n\t            }\n\t            // Start\n\t            else {\n\t                textPosition = [-d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1]];\n\t                textAlign = d[0] > 0.8 ? 'right' : (d[0] < -0.8 ? 'left' : 'center');\n\t                textVerticalAlign = d[1] > 0.8 ? 'bottom' : (d[1] < -0.8 ? 'top' : 'middle');\n\t            }\n\t            label.attr({\n\t                style: {\n\t                    // Use the user specified text align and baseline first\n\t                    textVerticalAlign: label.__verticalAlign || textVerticalAlign,\n\t                    textAlign: label.__textAlign || textAlign\n\t                },\n\t                position: textPosition,\n\t                scale: [invScale, invScale]\n\t            });\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @constructor\n\t     * @extends {module:zrender/graphic/Group}\n\t     * @alias {module:echarts/chart/helper/Line}\n\t     */\n\t    function Line(lineData, idx, seriesScope) {\n\t        graphic.Group.call(this);\n\t\n\t        this._createLine(lineData, idx, seriesScope);\n\t    }\n\t\n\t    var lineProto = Line.prototype;\n\t\n\t    // Update symbol position and rotation\n\t    lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;\n\t\n\t    lineProto._createLine = function (lineData, idx, seriesScope) {\n\t        var seriesModel = lineData.hostModel;\n\t        var linePoints = lineData.getItemLayout(idx);\n\t\n\t        var line = createLine(linePoints);\n\t        line.shape.percent = 0;\n\t        graphic.initProps(line, {\n\t            shape: {\n\t                percent: 1\n\t            }\n\t        }, seriesModel, idx);\n\t\n\t        this.add(line);\n\t\n\t        var label = new graphic.Text({\n\t            name: 'label'\n\t        });\n\t        this.add(label);\n\t\n\t        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n\t            var symbol = createSymbol(symbolCategory, lineData, idx);\n\t            // symbols must added after line to make sure\n\t            // it will be updated after line#update.\n\t            // Or symbol position and rotation update in line#beforeUpdate will be one frame slow\n\t            this.add(symbol);\n\t            this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);\n\t        }, this);\n\t\n\t        this._updateCommonStl(lineData, idx, seriesScope);\n\t    };\n\t\n\t    lineProto.updateData = function (lineData, idx, seriesScope) {\n\t        var seriesModel = lineData.hostModel;\n\t\n\t        var line = this.childOfName('line');\n\t        var linePoints = lineData.getItemLayout(idx);\n\t        var target = {\n\t            shape: {}\n\t        };\n\t        setLinePoints(target.shape, linePoints);\n\t        graphic.updateProps(line, target, seriesModel, idx);\n\t\n\t        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n\t            var symbolType = lineData.getItemVisual(idx, symbolCategory);\n\t            var key = makeSymbolTypeKey(symbolCategory);\n\t            // Symbol changed\n\t            if (this[key] !== symbolType) {\n\t                this.remove(this.childOfName(symbolCategory));\n\t                var symbol = createSymbol(symbolCategory, lineData, idx);\n\t                this.add(symbol);\n\t            }\n\t            this[key] = symbolType;\n\t        }, this);\n\t\n\t        this._updateCommonStl(lineData, idx, seriesScope);\n\t    };\n\t\n\t    lineProto._updateCommonStl = function (lineData, idx, seriesScope) {\n\t        var seriesModel = lineData.hostModel;\n\t\n\t        var line = this.childOfName('line');\n\t\n\t        var lineStyle = seriesScope && seriesScope.lineStyle;\n\t        var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;\n\t        var labelModel = seriesScope && seriesScope.labelModel;\n\t        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n\t\n\t        // Optimization for large dataset\n\t        if (!seriesScope || lineData.hasItemOption) {\n\t            var itemModel = lineData.getItemModel(idx);\n\t\n\t            lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle();\n\t            hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n\t\n\t            labelModel = itemModel.getModel('label.normal');\n\t            hoverLabelModel = itemModel.getModel('label.emphasis');\n\t        }\n\t\n\t        var visualColor = lineData.getItemVisual(idx, 'color');\n\t        var visualOpacity = zrUtil.retrieve(\n\t            lineData.getItemVisual(idx, 'opacity'),\n\t            lineStyle.opacity,\n\t            1\n\t        );\n\t\n\t        line.useStyle(zrUtil.defaults(\n\t            {\n\t                strokeNoScale: true,\n\t                fill: 'none',\n\t                stroke: visualColor,\n\t                opacity: visualOpacity\n\t            },\n\t            lineStyle\n\t        ));\n\t        line.hoverStyle = hoverLineStyle;\n\t\n\t        // Update symbol\n\t        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n\t            var symbol = this.childOfName(symbolCategory);\n\t            if (symbol) {\n\t                symbol.setColor(visualColor);\n\t                symbol.setStyle({\n\t                    opacity: visualOpacity\n\t                });\n\t            }\n\t        }, this);\n\t\n\t        var showLabel = labelModel.getShallow('show');\n\t        var hoverShowLabel = hoverLabelModel.getShallow('show');\n\t\n\t        var label = this.childOfName('label');\n\t        var defaultLabelColor;\n\t        var defaultText;\n\t\n\t        if (showLabel || hoverShowLabel) {\n\t            var rawVal = seriesModel.getRawValue(idx);\n\t            defaultText = rawVal == null\n\t                ? defaultText = lineData.getName(idx)\n\t                : isFinite(rawVal)\n\t                ? numberUtil.round(rawVal)\n\t                : rawVal;\n\t            defaultLabelColor = visualColor || '#000';\n\t        }\n\t\n\t        // label.afterUpdate = lineAfterUpdate;\n\t        if (showLabel) {\n\t            var textStyleModel = labelModel.getModel('textStyle');\n\t            label.setStyle({\n\t                text: zrUtil.retrieve(\n\t                    seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType),\n\t                    defaultText\n\t                ),\n\t                textFont: textStyleModel.getFont(),\n\t                fill: textStyleModel.getTextColor() || defaultLabelColor\n\t            });\n\t\n\t            label.__textAlign = textStyleModel.get('align');\n\t            label.__verticalAlign = textStyleModel.get('baseline');\n\t            label.__position = labelModel.get('position');\n\t        }\n\t        else {\n\t            label.setStyle('text', '');\n\t        }\n\t        if (hoverShowLabel) {\n\t            var textStyleHoverModel = hoverLabelModel.getModel('textStyle');\n\t\n\t            label.hoverStyle = {\n\t                text: zrUtil.retrieve(\n\t                    seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType),\n\t                    defaultText\n\t                ),\n\t                textFont: textStyleHoverModel.getFont(),\n\t                fill: textStyleHoverModel.getTextColor() || defaultLabelColor\n\t            };\n\t        }\n\t        else {\n\t            label.hoverStyle = {\n\t                text: ''\n\t            };\n\t        }\n\t\n\t        label.ignore = !showLabel && !hoverShowLabel;\n\t\n\t        graphic.setHoverStyle(this);\n\t    };\n\t\n\t    lineProto.updateLayout = function (lineData, idx) {\n\t        this.setLinePoints(lineData.getItemLayout(idx));\n\t    };\n\t\n\t    lineProto.setLinePoints = function (points) {\n\t        var linePath = this.childOfName('line');\n\t        setLinePoints(linePath.shape, points);\n\t        linePath.dirty();\n\t    };\n\t\n\t    zrUtil.inherits(Line, graphic.Group);\n\t\n\t    module.exports = Line;\n\n\n/***/ },\n/* 95 */\n/*!**************************************!*\\\n  !*** ./lib/chart/helper/LineDraw.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/chart/helper/LineDraw\n\t */\n\t\n\t\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var LineGroup = __webpack_require__(/*! ./Line */ 94);\n\t\n\t\n\t    function isPointNaN(pt) {\n\t        return isNaN(pt[0]) || isNaN(pt[1]);\n\t    }\n\t    function lineNeedsDraw(pts) {\n\t        return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);\n\t    }\n\t    /**\n\t     * @alias module:echarts/component/marker/LineDraw\n\t     * @constructor\n\t     */\n\t    function LineDraw(ctor) {\n\t        this._ctor = ctor || LineGroup;\n\t        this.group = new graphic.Group();\n\t    }\n\t\n\t    var lineDrawProto = LineDraw.prototype;\n\t\n\t    /**\n\t     * @param {module:echarts/data/List} lineData\n\t     */\n\t    lineDrawProto.updateData = function (lineData) {\n\t\n\t        var oldLineData = this._lineData;\n\t        var group = this.group;\n\t        var LineCtor = this._ctor;\n\t\n\t        var hostModel = lineData.hostModel;\n\t\n\t        var seriesScope = {\n\t            lineStyle: hostModel.getModel('lineStyle.normal').getLineStyle(),\n\t            hoverLineStyle: hostModel.getModel('lineStyle.emphasis').getLineStyle(),\n\t            labelModel: hostModel.getModel('label.normal'),\n\t            hoverLabelModel: hostModel.getModel('label.emphasis')\n\t        };\n\t\n\t        lineData.diff(oldLineData)\n\t            .add(function (idx) {\n\t                if (!lineNeedsDraw(lineData.getItemLayout(idx))) {\n\t                    return;\n\t                }\n\t                var lineGroup = new LineCtor(lineData, idx, seriesScope);\n\t\n\t                lineData.setItemGraphicEl(idx, lineGroup);\n\t\n\t                group.add(lineGroup);\n\t            })\n\t            .update(function (newIdx, oldIdx) {\n\t                var lineGroup = oldLineData.getItemGraphicEl(oldIdx);\n\t                if (!lineNeedsDraw(lineData.getItemLayout(newIdx))) {\n\t                    group.remove(lineGroup);\n\t                    return;\n\t                }\n\t\n\t                if (!lineGroup) {\n\t                    lineGroup = new LineCtor(lineData, newIdx, seriesScope);\n\t                }\n\t                else {\n\t                    lineGroup.updateData(lineData, newIdx, seriesScope);\n\t                }\n\t\n\t                lineData.setItemGraphicEl(newIdx, lineGroup);\n\t\n\t                group.add(lineGroup);\n\t            })\n\t            .remove(function (idx) {\n\t                group.remove(oldLineData.getItemGraphicEl(idx));\n\t            })\n\t            .execute();\n\t\n\t        this._lineData = lineData;\n\t    };\n\t\n\t    lineDrawProto.updateLayout = function () {\n\t        var lineData = this._lineData;\n\t        lineData.eachItemGraphicEl(function (el, idx) {\n\t            el.updateLayout(lineData, idx);\n\t        }, this);\n\t    };\n\t\n\t    lineDrawProto.remove = function () {\n\t        this.group.removeAll();\n\t    };\n\t\n\t    module.exports = LineDraw;\n\n\n/***/ },\n/* 96 */\n/*!***************************!*\\\n  !*** ./lib/chart/line.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var echarts = __webpack_require__(/*! ../echarts */ 2);\n\t    var PRIORITY = echarts.PRIORITY;\n\t\n\t    __webpack_require__(/*! ./line/LineSeries */ 97);\n\t    __webpack_require__(/*! ./line/LineView */ 98);\n\t\n\t    echarts.registerVisual(zrUtil.curry(\n\t        __webpack_require__(/*! ../visual/symbol */ 46), 'line', 'circle', 'line'\n\t    ));\n\t    echarts.registerLayout(zrUtil.curry(\n\t        __webpack_require__(/*! ../layout/points */ 55), 'line'\n\t    ));\n\t\n\t    // Down sample after filter\n\t    echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(\n\t        __webpack_require__(/*! ../processor/dataSample */ 134), 'line'\n\t    ));\n\t\n\t    // In case developer forget to include grid component\n\t    __webpack_require__(/*! ../component/grid */ 36);\n\n\n/***/ },\n/* 97 */\n/*!**************************************!*\\\n  !*** ./lib/chart/line/LineSeries.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var createListFromArray = __webpack_require__(/*! ../helper/createListFromArray */ 35);\n\t    var SeriesModel = __webpack_require__(/*! ../../model/Series */ 15);\n\t\n\t    module.exports = SeriesModel.extend({\n\t\n\t        type: 'series.line',\n\t\n\t        dependencies: ['grid', 'polar'],\n\t\n\t        getInitialData: function (option, ecModel) {\n\t            if (false) {\n\t                var coordSys = option.coordinateSystem;\n\t                if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {\n\t                    throw new Error('Line not support coordinateSystem besides cartesian and polar');\n\t                }\n\t            }\n\t            return createListFromArray(option.data, this, ecModel);\n\t        },\n\t\n\t        defaultOption: {\n\t            zlevel: 0,                  // \n\t            z: 2,                       // \n\t            coordinateSystem: 'cartesian2d',\n\t            legendHoverLink: true,\n\t\n\t            hoverAnimation: true,\n\t            // stack: null\n\t            // xAxisIndex: 0,\n\t            // yAxisIndex: 0,\n\t\n\t            // polarIndex: 0,\n\t\n\t            // If clip the overflow value\n\t            clipOverflow: true,\n\t\n\t            label: {\n\t                normal: {\n\t                    position: 'top'\n\t                }\n\t            },\n\t            // itemStyle: {\n\t            //     normal: {},\n\t            //     emphasis: {}\n\t            // },\n\t            lineStyle: {\n\t                normal: {\n\t                    width: 2,\n\t                    type: 'solid'\n\t                }\n\t            },\n\t            // areaStyle: {},\n\t            // false, 'start', 'end', 'middle'\n\t            step: false,\n\t\n\t            // Disabled if step is true\n\t            smooth: false,\n\t            smoothMonotone: null,\n\t            // \n\t            symbol: 'emptyCircle',\n\t            // \n\t            symbolSize: 4,\n\t            // \n\t            symbolRotate: null,\n\t\n\t            //  symbol,  tooltip hover \n\t            showSymbol: true,\n\t            // \n\t            showAllSymbol: false,\n\t\n\t            // \n\t            connectNulls: false,\n\t\n\t            // 'average', 'max', 'min', 'sum'\n\t            sampling: 'none',\n\t\n\t            animationEasing: 'linear',\n\t\n\t            // Disable progressive\n\t            progressive: 0,\n\t            hoverLayerThreshold: Infinity\n\t        }\n\t    });\n\n\n/***/ },\n/* 98 */\n/*!************************************!*\\\n  !*** ./lib/chart/line/LineView.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// FIXME step not support polar\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var SymbolDraw = __webpack_require__(/*! ../helper/SymbolDraw */ 39);\n\t    var Symbol = __webpack_require__(/*! ../helper/Symbol */ 49);\n\t    var lineAnimationDiff = __webpack_require__(/*! ./lineAnimationDiff */ 99);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var modelUtil = __webpack_require__(/*! ../../util/model */ 7);\n\t\n\t    var polyHelper = __webpack_require__(/*! ./poly */ 100);\n\t\n\t    var ChartView = __webpack_require__(/*! ../../view/Chart */ 27);\n\t\n\t    function isPointsSame(points1, points2) {\n\t        if (points1.length !== points2.length) {\n\t            return;\n\t        }\n\t        for (var i = 0; i < points1.length; i++) {\n\t            var p1 = points1[i];\n\t            var p2 = points2[i];\n\t            if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n\t                return;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    function getSmooth(smooth) {\n\t        return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);\n\t    }\n\t\n\t    function getAxisExtentWithGap(axis) {\n\t        var extent = axis.getGlobalExtent();\n\t        if (axis.onBand) {\n\t            // Remove extra 1px to avoid line miter in clipped edge\n\t            var halfBandWidth = axis.getBandWidth() / 2 - 1;\n\t            var dir = extent[1] > extent[0] ? 1 : -1;\n\t            extent[0] += dir * halfBandWidth;\n\t            extent[1] -= dir * halfBandWidth;\n\t        }\n\t        return extent;\n\t    }\n\t\n\t    function sign(val) {\n\t        return val >= 0 ? 1 : -1;\n\t    }\n\t    /**\n\t     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Array.<Array.<number>>} points\n\t     * @private\n\t     */\n\t    function getStackedOnPoints(coordSys, data) {\n\t        var baseAxis = coordSys.getBaseAxis();\n\t        var valueAxis = coordSys.getOtherAxis(baseAxis);\n\t        var valueStart = baseAxis.onZero\n\t            ? 0 : valueAxis.scale.getExtent()[0];\n\t\n\t        var valueDim = valueAxis.dim;\n\t\n\t        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\t\n\t        return data.mapArray([valueDim], function (val, idx) {\n\t            var stackedOnSameSign;\n\t            var stackedOn = data.stackedOn;\n\t            // Find first stacked value with same sign\n\t            while (stackedOn &&\n\t                sign(stackedOn.get(valueDim, idx)) === sign(val)\n\t            ) {\n\t                stackedOnSameSign = stackedOn;\n\t                break;\n\t            }\n\t            var stackedData = [];\n\t            stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n\t            stackedData[1 - baseDataOffset] = stackedOnSameSign\n\t                ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\t\n\t            return coordSys.dataToPoint(stackedData);\n\t        }, true);\n\t    }\n\t\n\t    function createGridClipShape(cartesian, hasAnimation, seriesModel) {\n\t        var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n\t        var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n\t        var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n\t\n\t        var x = Math.min(xExtent[0], xExtent[1]);\n\t        var y = Math.min(yExtent[0], yExtent[1]);\n\t        var width = Math.max(xExtent[0], xExtent[1]) - x;\n\t        var height = Math.max(yExtent[0], yExtent[1]) - y;\n\t        var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;\n\t        // Expand clip shape to avoid clipping when line value exceeds axis\n\t        var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\t        if (isHorizontal) {\n\t            y -= expandSize;\n\t            height += expandSize * 2;\n\t        }\n\t        else {\n\t            x -= expandSize;\n\t            width += expandSize * 2;\n\t        }\n\t\n\t        var clipPath = new graphic.Rect({\n\t            shape: {\n\t                x: x,\n\t                y: y,\n\t                width: width,\n\t                height: height\n\t            }\n\t        });\n\t\n\t        if (hasAnimation) {\n\t            clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n\t            graphic.initProps(clipPath, {\n\t                shape: {\n\t                    width: width,\n\t                    height: height\n\t                }\n\t            }, seriesModel);\n\t        }\n\t\n\t        return clipPath;\n\t    }\n\t\n\t    function createPolarClipShape(polar, hasAnimation, seriesModel) {\n\t        var angleAxis = polar.getAngleAxis();\n\t        var radiusAxis = polar.getRadiusAxis();\n\t\n\t        var radiusExtent = radiusAxis.getExtent();\n\t        var angleExtent = angleAxis.getExtent();\n\t\n\t        var RADIAN = Math.PI / 180;\n\t\n\t        var clipPath = new graphic.Sector({\n\t            shape: {\n\t                cx: polar.cx,\n\t                cy: polar.cy,\n\t                r0: radiusExtent[0],\n\t                r: radiusExtent[1],\n\t                startAngle: -angleExtent[0] * RADIAN,\n\t                endAngle: -angleExtent[1] * RADIAN,\n\t                clockwise: angleAxis.inverse\n\t            }\n\t        });\n\t\n\t        if (hasAnimation) {\n\t            clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n\t            graphic.initProps(clipPath, {\n\t                shape: {\n\t                    endAngle: -angleExtent[1] * RADIAN\n\t                }\n\t            }, seriesModel);\n\t        }\n\t\n\t        return clipPath;\n\t    }\n\t\n\t    function createClipShape(coordSys, hasAnimation, seriesModel) {\n\t        return coordSys.type === 'polar'\n\t            ? createPolarClipShape(coordSys, hasAnimation, seriesModel)\n\t            : createGridClipShape(coordSys, hasAnimation, seriesModel);\n\t    }\n\t\n\t    function turnPointsIntoStep(points, coordSys, stepTurnAt) {\n\t        var baseAxis = coordSys.getBaseAxis();\n\t        var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\t\n\t        var stepPoints = [];\n\t        for (var i = 0; i < points.length - 1; i++) {\n\t            var nextPt = points[i + 1];\n\t            var pt = points[i];\n\t            stepPoints.push(pt);\n\t\n\t            var stepPt = [];\n\t            switch (stepTurnAt) {\n\t                case 'end':\n\t                    stepPt[baseIndex] = nextPt[baseIndex];\n\t                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n\t                    // default is start\n\t                    stepPoints.push(stepPt);\n\t                    break;\n\t                case 'middle':\n\t                    // default is start\n\t                    var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n\t                    var stepPt2 = [];\n\t                    stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n\t                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n\t                    stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n\t                    stepPoints.push(stepPt);\n\t                    stepPoints.push(stepPt2);\n\t                    break;\n\t                default:\n\t                    stepPt[baseIndex] = pt[baseIndex];\n\t                    stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n\t                    // default is start\n\t                    stepPoints.push(stepPt);\n\t            }\n\t        }\n\t        // Last points\n\t        points[i] && stepPoints.push(points[i]);\n\t        return stepPoints;\n\t    }\n\t\n\t    function clamp(number, extent) {\n\t        return Math.max(Math.min(number, extent[1]), extent[0]);\n\t    }\n\t\n\t    function getVisualGradient(data, coordSys) {\n\t        var visualMetaList = data.getVisual('visualMeta');\n\t        if (!visualMetaList || !visualMetaList.length || !data.count()) {\n\t            // When data.count() is 0, gradient range can not be calculated.\n\t            return;\n\t        }\n\t\n\t        var visualMeta;\n\t        for (var i = visualMetaList.length - 1; i >= 0; i--) {\n\t            // Can only be x or y\n\t            if (visualMetaList[i].dimension < 2) {\n\t                visualMeta = visualMetaList[i];\n\t                break;\n\t            }\n\t        }\n\t        if (!visualMeta || coordSys.type !== 'cartesian2d') {\n\t            if (false) {\n\t                console.warn('Visual map on line style only support x or y dimension.');\n\t            }\n\t            return;\n\t        }\n\t\n\t        var dimension = visualMeta.dimension;\n\t        var dimName = data.dimensions[dimension];\n\t        var dataExtent = data.getDataExtent(dimName);\n\t\n\t        var stops = visualMeta.stops;\n\t\n\t        var colorStops = [];\n\t        if (stops[0].interval) {\n\t            stops.sort(function (a, b) {\n\t                return a.interval[0] - b.interval[0];\n\t            });\n\t        }\n\t\n\t        var firstStop = stops[0];\n\t        var lastStop = stops[stops.length - 1];\n\t        // Interval can be infinity in piecewise case\n\t        var min = firstStop.interval ? clamp(firstStop.interval[0], dataExtent) : firstStop.value;\n\t        var max = lastStop.interval ? clamp(lastStop.interval[1], dataExtent) : lastStop.value;\n\t        var stopsSpan = max - min;\n\t\n\t        // In the piecewise case data out of visual range\n\t        // ----dataMin----dataMax-----visualMin----visualMax\n\t        if (stopsSpan === 0) {\n\t            return data.getItemVisual(0, 'color');\n\t        }\n\t        for (var i = 0; i < stops.length; i++) {\n\t            // Piecewise\n\t            if (stops[i].interval) {\n\t                if (stops[i].interval[1] === stops[i].interval[0]) {\n\t                    continue;\n\t                }\n\t                colorStops.push({\n\t                    // Make sure offset is between 0 and 1\n\t                    offset: (clamp(stops[i].interval[0], dataExtent) - min) / stopsSpan,\n\t                    color: stops[i].color\n\t                }, {\n\t                    offset: (clamp(stops[i].interval[1], dataExtent) - min) / stopsSpan,\n\t                    color: stops[i].color\n\t                });\n\t            }\n\t            // Continous\n\t            else {\n\t                // if (i > 0 && stops[i].value === stops[i - 1].value) {\n\t                //     continue;\n\t                // }\n\t                colorStops.push({\n\t                    offset: (stops[i].value - min) / stopsSpan,\n\t                    color: stops[i].color\n\t                });\n\t            }\n\t        }\n\t\n\t        var gradient = new graphic.LinearGradient(\n\t            0, 0, 0, 0, colorStops, true\n\t        );\n\t        var axis = coordSys.getAxis(dimName);\n\t\n\t        var start = axis.toGlobalCoord(axis.dataToCoord(min));\n\t        var end = axis.toGlobalCoord(axis.dataToCoord(max));\n\t        // zrUtil.each(colorStops, function (colorStop) {\n\t        //     // Make sure each offset has rounded px to avoid not sharp edge\n\t        //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n\t        // });\n\t\n\t        gradient[dimName] = start;\n\t        gradient[dimName + '2'] = end;\n\t\n\t        return gradient;\n\t    }\n\t\n\t    module.exports = ChartView.extend({\n\t\n\t        type: 'line',\n\t\n\t        init: function () {\n\t            var lineGroup = new graphic.Group();\n\t\n\t            var symbolDraw = new SymbolDraw();\n\t            this.group.add(symbolDraw.group);\n\t\n\t            this._symbolDraw = symbolDraw;\n\t            this._lineGroup = lineGroup;\n\t        },\n\t\n\t        render: function (seriesModel, ecModel, api) {\n\t            var coordSys = seriesModel.coordinateSystem;\n\t            var group = this.group;\n\t            var data = seriesModel.getData();\n\t            var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n\t            var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n\t\n\t            var points = data.mapArray(data.getItemLayout, true);\n\t\n\t            var isCoordSysPolar = coordSys.type === 'polar';\n\t            var prevCoordSys = this._coordSys;\n\t\n\t            var symbolDraw = this._symbolDraw;\n\t            var polyline = this._polyline;\n\t            var polygon = this._polygon;\n\t\n\t            var lineGroup = this._lineGroup;\n\t\n\t            var hasAnimation = seriesModel.get('animation');\n\t\n\t            var isAreaChart = !areaStyleModel.isEmpty();\n\t            var stackedOnPoints = getStackedOnPoints(coordSys, data);\n\t\n\t            var showSymbol = seriesModel.get('showSymbol');\n\t\n\t            var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol')\n\t                && this._getSymbolIgnoreFunc(data, coordSys);\n\t\n\t            // Remove temporary symbols\n\t            var oldData = this._data;\n\t            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n\t                if (el.__temp) {\n\t                    group.remove(el);\n\t                    oldData.setItemGraphicEl(idx, null);\n\t                }\n\t            });\n\t\n\t            // Remove previous created symbols if showSymbol changed to false\n\t            if (!showSymbol) {\n\t                symbolDraw.remove();\n\t            }\n\t\n\t            group.add(lineGroup);\n\t\n\t            // FIXME step not support polar\n\t            var step = !isCoordSysPolar && seriesModel.get('step');\n\t            // Initialization animation or coordinate system changed\n\t            if (\n\t                !(polyline && prevCoordSys.type === coordSys.type && step === this._step)\n\t            ) {\n\t                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\t\n\t                if (step) {\n\t                    // TODO If stacked series is not step\n\t                    points = turnPointsIntoStep(points, coordSys, step);\n\t                    stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n\t                }\n\t\n\t                polyline = this._newPolyline(points, coordSys, hasAnimation);\n\t                if (isAreaChart) {\n\t                    polygon = this._newPolygon(\n\t                        points, stackedOnPoints,\n\t                        coordSys, hasAnimation\n\t                    );\n\t                }\n\t                lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n\t            }\n\t            else {\n\t                if (isAreaChart && !polygon) {\n\t                    // If areaStyle is added\n\t                    polygon = this._newPolygon(\n\t                        points, stackedOnPoints,\n\t                        coordSys, hasAnimation\n\t                    );\n\t                }\n\t                else if (polygon && !isAreaChart) {\n\t                    // If areaStyle is removed\n\t                    lineGroup.remove(polygon);\n\t                    polygon = this._polygon = null;\n\t                }\n\t\n\t                // Update clipPath\n\t                lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));\n\t\n\t                // Always update, or it is wrong in the case turning on legend\n\t                // because points are not changed\n\t                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\t\n\t                // Stop symbol animation and sync with line points\n\t                // FIXME performance?\n\t                data.eachItemGraphicEl(function (el) {\n\t                    el.stopAnimation(true);\n\t                });\n\t\n\t                // In the case data zoom triggerred refreshing frequently\n\t                // Data may not change if line has a category axis. So it should animate nothing\n\t                if (!isPointsSame(this._stackedOnPoints, stackedOnPoints)\n\t                    || !isPointsSame(this._points, points)\n\t                ) {\n\t                    if (hasAnimation) {\n\t                        this._updateAnimation(\n\t                            data, stackedOnPoints, coordSys, api, step\n\t                        );\n\t                    }\n\t                    else {\n\t                        // Not do it in update with animation\n\t                        if (step) {\n\t                            // TODO If stacked series is not step\n\t                            points = turnPointsIntoStep(points, coordSys, step);\n\t                            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n\t                        }\n\t\n\t                        polyline.setShape({\n\t                            points: points\n\t                        });\n\t                        polygon && polygon.setShape({\n\t                            points: points,\n\t                            stackedOnPoints: stackedOnPoints\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t\n\t            var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n\t\n\t            polyline.useStyle(zrUtil.defaults(\n\t                // Use color in lineStyle first\n\t                lineStyleModel.getLineStyle(),\n\t                {\n\t                    fill: 'none',\n\t                    stroke: visualColor,\n\t                    lineJoin: 'bevel'\n\t                }\n\t            ));\n\t\n\t            var smooth = seriesModel.get('smooth');\n\t            smooth = getSmooth(seriesModel.get('smooth'));\n\t            polyline.setShape({\n\t                smooth: smooth,\n\t                smoothMonotone: seriesModel.get('smoothMonotone'),\n\t                connectNulls: seriesModel.get('connectNulls')\n\t            });\n\t\n\t            if (polygon) {\n\t                var stackedOn = data.stackedOn;\n\t                var stackedOnSmooth = 0;\n\t\n\t                polygon.useStyle(zrUtil.defaults(\n\t                    areaStyleModel.getAreaStyle(),\n\t                    {\n\t                        fill: visualColor,\n\t                        opacity: 0.7,\n\t                        lineJoin: 'bevel'\n\t                    }\n\t                ));\n\t\n\t                if (stackedOn) {\n\t                    var stackedOnSeries = stackedOn.hostModel;\n\t                    stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n\t                }\n\t\n\t                polygon.setShape({\n\t                    smooth: smooth,\n\t                    stackedOnSmooth: stackedOnSmooth,\n\t                    smoothMonotone: seriesModel.get('smoothMonotone'),\n\t                    connectNulls: seriesModel.get('connectNulls')\n\t                });\n\t            }\n\t\n\t            this._data = data;\n\t            // Save the coordinate system for transition animation when data changed\n\t            this._coordSys = coordSys;\n\t            this._stackedOnPoints = stackedOnPoints;\n\t            this._points = points;\n\t            this._step = step;\n\t        },\n\t\n\t        dispose: function () {},\n\t\n\t        highlight: function (seriesModel, ecModel, api, payload) {\n\t            var data = seriesModel.getData();\n\t            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\t\n\t            if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n\t                var symbol = data.getItemGraphicEl(dataIndex);\n\t                if (!symbol) {\n\t                    // Create a temporary symbol if it is not exists\n\t                    var pt = data.getItemLayout(dataIndex);\n\t                    symbol = new Symbol(data, dataIndex);\n\t                    symbol.position = pt;\n\t                    symbol.setZ(\n\t                        seriesModel.get('zlevel'),\n\t                        seriesModel.get('z')\n\t                    );\n\t                    symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n\t                    symbol.__temp = true;\n\t                    data.setItemGraphicEl(dataIndex, symbol);\n\t\n\t                    // Stop scale animation\n\t                    symbol.stopSymbolAnimation(true);\n\t\n\t                    this.group.add(symbol);\n\t                }\n\t                symbol.highlight();\n\t            }\n\t            else {\n\t                // Highlight whole series\n\t                ChartView.prototype.highlight.call(\n\t                    this, seriesModel, ecModel, api, payload\n\t                );\n\t            }\n\t        },\n\t\n\t        downplay: function (seriesModel, ecModel, api, payload) {\n\t            var data = seriesModel.getData();\n\t            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\t            if (dataIndex != null && dataIndex >= 0) {\n\t                var symbol = data.getItemGraphicEl(dataIndex);\n\t                if (symbol) {\n\t                    if (symbol.__temp) {\n\t                        data.setItemGraphicEl(dataIndex, null);\n\t                        this.group.remove(symbol);\n\t                    }\n\t                    else {\n\t                        symbol.downplay();\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                // Downplay whole series\n\t                ChartView.prototype.downplay.call(\n\t                    this, seriesModel, ecModel, api, payload\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/container/Group} group\n\t         * @param {Array.<Array.<number>>} points\n\t         * @private\n\t         */\n\t        _newPolyline: function (points) {\n\t            var polyline = this._polyline;\n\t            // Remove previous created polyline\n\t            if (polyline) {\n\t                this._lineGroup.remove(polyline);\n\t            }\n\t\n\t            polyline = new polyHelper.Polyline({\n\t                shape: {\n\t                    points: points\n\t                },\n\t                silent: true,\n\t                z2: 10\n\t            });\n\t\n\t            this._lineGroup.add(polyline);\n\t\n\t            this._polyline = polyline;\n\t\n\t            return polyline;\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/container/Group} group\n\t         * @param {Array.<Array.<number>>} stackedOnPoints\n\t         * @param {Array.<Array.<number>>} points\n\t         * @private\n\t         */\n\t        _newPolygon: function (points, stackedOnPoints) {\n\t            var polygon = this._polygon;\n\t            // Remove previous created polygon\n\t            if (polygon) {\n\t                this._lineGroup.remove(polygon);\n\t            }\n\t\n\t            polygon = new polyHelper.Polygon({\n\t                shape: {\n\t                    points: points,\n\t                    stackedOnPoints: stackedOnPoints\n\t                },\n\t                silent: true\n\t            });\n\t\n\t            this._lineGroup.add(polygon);\n\t\n\t            this._polygon = polygon;\n\t            return polygon;\n\t        },\n\t        /**\n\t         * @private\n\t         */\n\t        _getSymbolIgnoreFunc: function (data, coordSys) {\n\t            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\t            // `getLabelInterval` is provided by echarts/component/axis\n\t            if (categoryAxis && categoryAxis.isLabelIgnored) {\n\t                return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        // FIXME Two value axis\n\t        _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n\t            var polyline = this._polyline;\n\t            var polygon = this._polygon;\n\t            var seriesModel = data.hostModel;\n\t\n\t            var diff = lineAnimationDiff(\n\t                this._data, data,\n\t                this._stackedOnPoints, stackedOnPoints,\n\t                this._coordSys, coordSys\n\t            );\n\t\n\t            var current = diff.current;\n\t            var stackedOnCurrent = diff.stackedOnCurrent;\n\t            var next = diff.next;\n\t            var stackedOnNext = diff.stackedOnNext;\n\t            if (step) {\n\t                // TODO If stacked series is not step\n\t                current = turnPointsIntoStep(diff.current, coordSys, step);\n\t                stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n\t                next = turnPointsIntoStep(diff.next, coordSys, step);\n\t                stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n\t            }\n\t            // `diff.current` is subset of `current` (which should be ensured by\n\t            // turnPointsIntoStep), so points in `__points` can be updated when\n\t            // points in `current` are update during animation.\n\t            polyline.shape.__points = diff.current;\n\t            polyline.shape.points = current;\n\t\n\t            graphic.updateProps(polyline, {\n\t                shape: {\n\t                    points: next\n\t                }\n\t            }, seriesModel);\n\t\n\t            if (polygon) {\n\t                polygon.setShape({\n\t                    points: current,\n\t                    stackedOnPoints: stackedOnCurrent\n\t                });\n\t                graphic.updateProps(polygon, {\n\t                    shape: {\n\t                        points: next,\n\t                        stackedOnPoints: stackedOnNext\n\t                    }\n\t                }, seriesModel);\n\t            }\n\t\n\t            var updatedDataInfo = [];\n\t            var diffStatus = diff.status;\n\t\n\t            for (var i = 0; i < diffStatus.length; i++) {\n\t                var cmd = diffStatus[i].cmd;\n\t                if (cmd === '=') {\n\t                    var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\t                    if (el) {\n\t                        updatedDataInfo.push({\n\t                            el: el,\n\t                            ptIdx: i    // Index of points\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (polyline.animators && polyline.animators.length) {\n\t                polyline.animators[0].during(function () {\n\t                    for (var i = 0; i < updatedDataInfo.length; i++) {\n\t                        var el = updatedDataInfo[i].el;\n\t                        el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        remove: function (ecModel) {\n\t            var group = this.group;\n\t            var oldData = this._data;\n\t            this._lineGroup.removeAll();\n\t            this._symbolDraw.remove(true);\n\t            // Remove temporary created elements when highlighting\n\t            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n\t                if (el.__temp) {\n\t                    group.remove(el);\n\t                    oldData.setItemGraphicEl(idx, null);\n\t                }\n\t            });\n\t\n\t            this._polyline =\n\t            this._polygon =\n\t            this._coordSys =\n\t            this._points =\n\t            this._stackedOnPoints =\n\t            this._data = null;\n\t        }\n\t    });\n\n\n/***/ },\n/* 99 */\n/*!*********************************************!*\\\n  !*** ./lib/chart/line/lineAnimationDiff.js ***!\n  \\*********************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    // var arrayDiff = require('zrender/lib/core/arrayDiff');\n\t    // 'zrender/core/arrayDiff' has been used before, but it did\n\t    // not do well in performance when roam with fixed dataZoom window.\n\t\n\t    function sign(val) {\n\t        return val >= 0 ? 1 : -1;\n\t    }\n\t\n\t    function getStackedOnPoint(coordSys, data, idx) {\n\t        var baseAxis = coordSys.getBaseAxis();\n\t        var valueAxis = coordSys.getOtherAxis(baseAxis);\n\t        var valueStart = baseAxis.onZero\n\t            ? 0 : valueAxis.scale.getExtent()[0];\n\t\n\t        var valueDim = valueAxis.dim;\n\t        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\t\n\t        var stackedOnSameSign;\n\t        var stackedOn = data.stackedOn;\n\t        var val = data.get(valueDim, idx);\n\t        // Find first stacked value with same sign\n\t        while (stackedOn &&\n\t            sign(stackedOn.get(valueDim, idx)) === sign(val)\n\t        ) {\n\t            stackedOnSameSign = stackedOn;\n\t            break;\n\t        }\n\t        var stackedData = [];\n\t        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n\t        stackedData[1 - baseDataOffset] = stackedOnSameSign\n\t            ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\t\n\t        return coordSys.dataToPoint(stackedData);\n\t    }\n\t\n\t    // function convertToIntId(newIdList, oldIdList) {\n\t    //     // Generate int id instead of string id.\n\t    //     // Compare string maybe slow in score function of arrDiff\n\t\n\t    //     // Assume id in idList are all unique\n\t    //     var idIndicesMap = {};\n\t    //     var idx = 0;\n\t    //     for (var i = 0; i < newIdList.length; i++) {\n\t    //         idIndicesMap[newIdList[i]] = idx;\n\t    //         newIdList[i] = idx++;\n\t    //     }\n\t    //     for (var i = 0; i < oldIdList.length; i++) {\n\t    //         var oldId = oldIdList[i];\n\t    //         // Same with newIdList\n\t    //         if (idIndicesMap[oldId]) {\n\t    //             oldIdList[i] = idIndicesMap[oldId];\n\t    //         }\n\t    //         else {\n\t    //             oldIdList[i] = idx++;\n\t    //         }\n\t    //     }\n\t    // }\n\t\n\t    function diffData(oldData, newData) {\n\t        var diffResult = [];\n\t\n\t        newData.diff(oldData)\n\t            .add(function (idx) {\n\t                diffResult.push({cmd: '+', idx: idx});\n\t            })\n\t            .update(function (newIdx, oldIdx) {\n\t                diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx});\n\t            })\n\t            .remove(function (idx) {\n\t                diffResult.push({cmd: '-', idx: idx});\n\t            })\n\t            .execute();\n\t\n\t        return diffResult;\n\t    }\n\t\n\t    module.exports = function (\n\t        oldData, newData,\n\t        oldStackedOnPoints, newStackedOnPoints,\n\t        oldCoordSys, newCoordSys\n\t    ) {\n\t        var diff = diffData(oldData, newData);\n\t\n\t        // var newIdList = newData.mapArray(newData.getId);\n\t        // var oldIdList = oldData.mapArray(oldData.getId);\n\t\n\t        // convertToIntId(newIdList, oldIdList);\n\t\n\t        // // FIXME One data ?\n\t        // diff = arrayDiff(oldIdList, newIdList);\n\t\n\t        var currPoints = [];\n\t        var nextPoints = [];\n\t        // Points for stacking base line\n\t        var currStackedPoints = [];\n\t        var nextStackedPoints = [];\n\t\n\t        var status = [];\n\t        var sortedIndices = [];\n\t        var rawIndices = [];\n\t        var dims = newCoordSys.dimensions;\n\t        for (var i = 0; i < diff.length; i++) {\n\t            var diffItem = diff[i];\n\t            var pointAdded = true;\n\t\n\t            // FIXME, animation is not so perfect when dataZoom window moves fast\n\t            // Which is in case remvoing or add more than one data in the tail or head\n\t            switch (diffItem.cmd) {\n\t                case '=':\n\t                    var currentPt = oldData.getItemLayout(diffItem.idx);\n\t                    var nextPt = newData.getItemLayout(diffItem.idx1);\n\t                    // If previous data is NaN, use next point directly\n\t                    if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n\t                        currentPt = nextPt.slice();\n\t                    }\n\t                    currPoints.push(currentPt);\n\t                    nextPoints.push(nextPt);\n\t\n\t                    currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n\t                    nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n\t\n\t                    rawIndices.push(newData.getRawIndex(diffItem.idx1));\n\t                    break;\n\t                case '+':\n\t                    var idx = diffItem.idx;\n\t                    currPoints.push(\n\t                        oldCoordSys.dataToPoint([\n\t                            newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)\n\t                        ])\n\t                    );\n\t\n\t                    nextPoints.push(newData.getItemLayout(idx).slice());\n\t\n\t                    currStackedPoints.push(\n\t                        getStackedOnPoint(oldCoordSys, newData, idx)\n\t                    );\n\t                    nextStackedPoints.push(newStackedOnPoints[idx]);\n\t\n\t                    rawIndices.push(newData.getRawIndex(idx));\n\t                    break;\n\t                case '-':\n\t                    var idx = diffItem.idx;\n\t                    var rawIndex = oldData.getRawIndex(idx);\n\t                    // Data is replaced. In the case of dynamic data queue\n\t                    // FIXME FIXME FIXME\n\t                    if (rawIndex !== idx) {\n\t                        currPoints.push(oldData.getItemLayout(idx));\n\t                        nextPoints.push(newCoordSys.dataToPoint([\n\t                            oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)\n\t                        ]));\n\t\n\t                        currStackedPoints.push(oldStackedOnPoints[idx]);\n\t                        nextStackedPoints.push(\n\t                            getStackedOnPoint(\n\t                                newCoordSys, oldData, idx\n\t                            )\n\t                        );\n\t\n\t                        rawIndices.push(rawIndex);\n\t                    }\n\t                    else {\n\t                        pointAdded = false;\n\t                    }\n\t            }\n\t\n\t            // Original indices\n\t            if (pointAdded) {\n\t                status.push(diffItem);\n\t                sortedIndices.push(sortedIndices.length);\n\t            }\n\t        }\n\t\n\t        // Diff result may be crossed if all items are changed\n\t        // Sort by data index\n\t        sortedIndices.sort(function (a, b) {\n\t            return rawIndices[a] - rawIndices[b];\n\t        });\n\t\n\t        var sortedCurrPoints = [];\n\t        var sortedNextPoints = [];\n\t\n\t        var sortedCurrStackedPoints = [];\n\t        var sortedNextStackedPoints = [];\n\t\n\t        var sortedStatus = [];\n\t        for (var i = 0; i < sortedIndices.length; i++) {\n\t            var idx = sortedIndices[i];\n\t            sortedCurrPoints[i] = currPoints[idx];\n\t            sortedNextPoints[i] = nextPoints[idx];\n\t\n\t            sortedCurrStackedPoints[i] = currStackedPoints[idx];\n\t            sortedNextStackedPoints[i] = nextStackedPoints[idx];\n\t\n\t            sortedStatus[i] = status[idx];\n\t        }\n\t\n\t        return {\n\t            current: sortedCurrPoints,\n\t            next: sortedNextPoints,\n\t\n\t            stackedOnCurrent: sortedCurrStackedPoints,\n\t            stackedOnNext: sortedNextStackedPoints,\n\t\n\t            status: sortedStatus\n\t        };\n\t    };\n\n\n/***/ },\n/* 100 */\n/*!********************************!*\\\n  !*** ./lib/chart/line/poly.js ***!\n  \\********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Poly path support NaN point\n\t\n\t\n\t    var Path = __webpack_require__(/*! zrender/lib/graphic/Path */ 6);\n\t    var vec2 = __webpack_require__(/*! zrender/lib/core/vector */ 5);\n\t\n\t    var vec2Min = vec2.min;\n\t    var vec2Max = vec2.max;\n\t\n\t    var scaleAndAdd = vec2.scaleAndAdd;\n\t    var v2Copy = vec2.copy;\n\t\n\t    // Temporary variable\n\t    var v = [];\n\t    var cp0 = [];\n\t    var cp1 = [];\n\t\n\t    function isPointNull(p) {\n\t        return isNaN(p[0]) || isNaN(p[1]);\n\t    }\n\t\n\t    function drawSegment(\n\t        ctx, points, start, segLen, allLen,\n\t        dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls\n\t    ) {\n\t        var prevIdx = 0;\n\t        var idx = start;\n\t        for (var k = 0; k < segLen; k++) {\n\t            var p = points[idx];\n\t            if (idx >= allLen || idx < 0) {\n\t                break;\n\t            }\n\t            if (isPointNull(p)) {\n\t                if (connectNulls) {\n\t                    idx += dir;\n\t                    continue;\n\t                }\n\t                break;\n\t            }\n\t\n\t            if (idx === start) {\n\t                ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n\t                v2Copy(cp0, p);\n\t            }\n\t            else {\n\t                if (smooth > 0) {\n\t                    var nextIdx = idx + dir;\n\t                    var nextP = points[nextIdx];\n\t                    if (connectNulls) {\n\t                        // Find next point not null\n\t                        while (nextP && isPointNull(points[nextIdx])) {\n\t                            nextIdx += dir;\n\t                            nextP = points[nextIdx];\n\t                        }\n\t                    }\n\t\n\t                    var ratioNextSeg = 0.5;\n\t                    var prevP = points[prevIdx];\n\t                    var nextP = points[nextIdx];\n\t                    // Last point\n\t                    if (!nextP || isPointNull(nextP)) {\n\t                        v2Copy(cp1, p);\n\t                    }\n\t                    else {\n\t                        // If next data is null in not connect case\n\t                        if (isPointNull(nextP) && !connectNulls) {\n\t                            nextP = p;\n\t                        }\n\t\n\t                        vec2.sub(v, nextP, prevP);\n\t\n\t                        var lenPrevSeg;\n\t                        var lenNextSeg;\n\t                        if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n\t                            var dim = smoothMonotone === 'x' ? 0 : 1;\n\t                            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n\t                            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n\t                        }\n\t                        else {\n\t                            lenPrevSeg = vec2.dist(p, prevP);\n\t                            lenNextSeg = vec2.dist(p, nextP);\n\t                        }\n\t\n\t                        // Use ratio of seg length\n\t                        ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n\t\n\t                        scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n\t                    }\n\t                    // Smooth constraint\n\t                    vec2Min(cp0, cp0, smoothMax);\n\t                    vec2Max(cp0, cp0, smoothMin);\n\t                    vec2Min(cp1, cp1, smoothMax);\n\t                    vec2Max(cp1, cp1, smoothMin);\n\t\n\t                    ctx.bezierCurveTo(\n\t                        cp0[0], cp0[1],\n\t                        cp1[0], cp1[1],\n\t                        p[0], p[1]\n\t                    );\n\t                    // cp0 of next segment\n\t                    scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n\t                }\n\t                else {\n\t                    ctx.lineTo(p[0], p[1]);\n\t                }\n\t            }\n\t\n\t            prevIdx = idx;\n\t            idx += dir;\n\t        }\n\t\n\t        return k;\n\t    }\n\t\n\t    function getBoundingBox(points, smoothConstraint) {\n\t        var ptMin = [Infinity, Infinity];\n\t        var ptMax = [-Infinity, -Infinity];\n\t        if (smoothConstraint) {\n\t            for (var i = 0; i < points.length; i++) {\n\t                var pt = points[i];\n\t                if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; }\n\t                if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; }\n\t                if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; }\n\t                if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; }\n\t            }\n\t        }\n\t        return {\n\t            min: smoothConstraint ? ptMin : ptMax,\n\t            max: smoothConstraint ? ptMax : ptMin\n\t        };\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        Polyline: Path.extend({\n\t\n\t            type: 'ec-polyline',\n\t\n\t            shape: {\n\t                points: [],\n\t\n\t                smooth: 0,\n\t\n\t                smoothConstraint: true,\n\t\n\t                smoothMonotone: null,\n\t\n\t                connectNulls: false\n\t            },\n\t\n\t            style: {\n\t                fill: null,\n\t\n\t                stroke: '#000'\n\t            },\n\t\n\t            buildPath: function (ctx, shape) {\n\t                var points = shape.points;\n\t\n\t                var i = 0;\n\t                var len = points.length;\n\t\n\t                var result = getBoundingBox(points, shape.smoothConstraint);\n\t\n\t                if (shape.connectNulls) {\n\t                    // Must remove first and last null values avoid draw error in polygon\n\t                    for (; len > 0; len--) {\n\t                        if (!isPointNull(points[len - 1])) {\n\t                            break;\n\t                        }\n\t                    }\n\t                    for (; i < len; i++) {\n\t                        if (!isPointNull(points[i])) {\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t                while (i < len) {\n\t                    i += drawSegment(\n\t                        ctx, points, i, len, len,\n\t                        1, result.min, result.max, shape.smooth,\n\t                        shape.smoothMonotone, shape.connectNulls\n\t                    ) + 1;\n\t                }\n\t            }\n\t        }),\n\t\n\t        Polygon: Path.extend({\n\t\n\t            type: 'ec-polygon',\n\t\n\t            shape: {\n\t                points: [],\n\t\n\t                // Offset between stacked base points and points\n\t                stackedOnPoints: [],\n\t\n\t                smooth: 0,\n\t\n\t                stackedOnSmooth: 0,\n\t\n\t                smoothConstraint: true,\n\t\n\t                smoothMonotone: null,\n\t\n\t                connectNulls: false\n\t            },\n\t\n\t            buildPath: function (ctx, shape) {\n\t                var points = shape.points;\n\t                var stackedOnPoints = shape.stackedOnPoints;\n\t\n\t                var i = 0;\n\t                var len = points.length;\n\t                var smoothMonotone = shape.smoothMonotone;\n\t                var bbox = getBoundingBox(points, shape.smoothConstraint);\n\t                var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\t\n\t                if (shape.connectNulls) {\n\t                    // Must remove first and last null values avoid draw error in polygon\n\t                    for (; len > 0; len--) {\n\t                        if (!isPointNull(points[len - 1])) {\n\t                            break;\n\t                        }\n\t                    }\n\t                    for (; i < len; i++) {\n\t                        if (!isPointNull(points[i])) {\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t                while (i < len) {\n\t                    var k = drawSegment(\n\t                        ctx, points, i, len, len,\n\t                        1, bbox.min, bbox.max, shape.smooth,\n\t                        smoothMonotone, shape.connectNulls\n\t                    );\n\t                    drawSegment(\n\t                        ctx, stackedOnPoints, i + k - 1, k, len,\n\t                        -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth,\n\t                        smoothMonotone, shape.connectNulls\n\t                    );\n\t                    i += k + 1;\n\t\n\t                    ctx.closePath();\n\t                }\n\t            }\n\t        })\n\t    };\n\n\n/***/ },\n/* 101 */\n/*!**************************!*\\\n  !*** ./lib/chart/pie.js ***!\n  \\**************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var echarts = __webpack_require__(/*! ../echarts */ 2);\n\t\n\t    __webpack_require__(/*! ./pie/PieSeries */ 102);\n\t    __webpack_require__(/*! ./pie/PieView */ 103);\n\t\n\t    __webpack_require__(/*! ../action/createDataSelectAction */ 77)('pie', [{\n\t        type: 'pieToggleSelect',\n\t        event: 'pieselectchanged',\n\t        method: 'toggleSelected'\n\t    }, {\n\t        type: 'pieSelect',\n\t        event: 'pieselected',\n\t        method: 'select'\n\t    }, {\n\t        type: 'pieUnSelect',\n\t        event: 'pieunselected',\n\t        method: 'unSelect'\n\t    }]);\n\t\n\t    echarts.registerVisual(zrUtil.curry(__webpack_require__(/*! ../visual/dataColor */ 72), 'pie'));\n\t\n\t    echarts.registerLayout(zrUtil.curry(\n\t        __webpack_require__(/*! ./pie/pieLayout */ 105), 'pie'\n\t    ));\n\t\n\t    echarts.registerProcessor(zrUtil.curry(__webpack_require__(/*! ../processor/dataFilter */ 70), 'pie'));\n\n\n/***/ },\n/* 102 */\n/*!************************************!*\\\n  !*** ./lib/chart/pie/PieSeries.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var List = __webpack_require__(/*! ../../data/List */ 14);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var modelUtil = __webpack_require__(/*! ../../util/model */ 7);\n\t    var completeDimensions = __webpack_require__(/*! ../../data/helper/completeDimensions */ 30);\n\t\n\t    var dataSelectableMixin = __webpack_require__(/*! ../../component/helper/selectableMixin */ 66);\n\t\n\t    var PieSeries = __webpack_require__(/*! ../../echarts */ 2).extendSeriesModel({\n\t\n\t        type: 'series.pie',\n\t\n\t        // Overwrite\n\t        init: function (option) {\n\t            PieSeries.superApply(this, 'init', arguments);\n\t\n\t            // Enable legend selection for each data item\n\t            // Use a function instead of direct access because data reference may changed\n\t            this.legendDataProvider = function () {\n\t                return this._dataBeforeProcessed;\n\t            };\n\t\n\t            this.updateSelectedMap(option.data);\n\t\n\t            this._defaultLabelLine(option);\n\t        },\n\t\n\t        // Overwrite\n\t        mergeOption: function (newOption) {\n\t            PieSeries.superCall(this, 'mergeOption', newOption);\n\t            this.updateSelectedMap(this.option.data);\n\t        },\n\t\n\t        getInitialData: function (option, ecModel) {\n\t            var dimensions = completeDimensions(['value'], option.data);\n\t            var list = new List(dimensions, this);\n\t            list.initData(option.data);\n\t            return list;\n\t        },\n\t\n\t        // Overwrite\n\t        getDataParams: function (dataIndex) {\n\t            var data = this._data;\n\t            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n\t            var sum = data.getSum('value');\n\t            // FIXME toFixed?\n\t            //\n\t            // Percent is 0 if sum is 0\n\t            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\t\n\t            params.$vars.push('percent');\n\t            return params;\n\t        },\n\t\n\t        _defaultLabelLine: function (option) {\n\t            // Extend labelLine emphasis\n\t            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\t\n\t            var labelLineNormalOpt = option.labelLine.normal;\n\t            var labelLineEmphasisOpt = option.labelLine.emphasis;\n\t            // Not show label line if `label.normal.show = false`\n\t            labelLineNormalOpt.show = labelLineNormalOpt.show\n\t                && option.label.normal.show;\n\t            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n\t                && option.label.emphasis.show;\n\t        },\n\t\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 2,\n\t            legendHoverLink: true,\n\t\n\t            hoverAnimation: true,\n\t            // \n\t            center: ['50%', '50%'],\n\t            radius: [0, '75%'],\n\t            // \n\t            clockwise: true,\n\t            startAngle: 90,\n\t            // 0\n\t            minAngle: 0,\n\t            // \n\t            selectedOffset: 10,\n\t\n\t            // If use strategy to avoid label overlapping\n\t            avoidLabelOverlap: true,\n\t            // singlemultiple\n\t            // selectedMode: false,\n\t            // 'radius' | 'area'\n\t            // roseType: null,\n\t\n\t            label: {\n\t                normal: {\n\t                    // If rotate around circle\n\t                    rotate: false,\n\t                    show: true,\n\t                    // 'outer', 'inside', 'center'\n\t                    position: 'outer'\n\t                    // formatter: Tooltip.formatter\n\t                    // textStyle: null      // TEXTSTYLE\n\t                    // distance: positioninnerlabel()\n\t                },\n\t                emphasis: {}\n\t            },\n\t            // Enabled when label.normal.position is 'outer'\n\t            labelLine: {\n\t                normal: {\n\t                    show: true,\n\t                    // \n\t                    length: 15,\n\t                    // \n\t                    length2: 15,\n\t                    smooth: false,\n\t                    lineStyle: {\n\t                        // color: ,\n\t                        width: 1,\n\t                        type: 'solid'\n\t                    }\n\t                }\n\t            },\n\t            itemStyle: {\n\t                normal: {\n\t                    borderWidth: 1\n\t                },\n\t                emphasis: {}\n\t            },\n\t\n\t            animationEasing: 'cubicOut',\n\t\n\t            data: []\n\t        }\n\t    });\n\t\n\t    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\t\n\t    module.exports = PieSeries;\n\n\n/***/ },\n/* 103 */\n/*!**********************************!*\\\n  !*** ./lib/chart/pie/PieView.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    /**\n\t     * @param {module:echarts/model/Series} seriesModel\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n\t        var data = seriesModel.getData();\n\t        var dataIndex = this.dataIndex;\n\t        var name = data.getName(dataIndex);\n\t        var selectedOffset = seriesModel.get('selectedOffset');\n\t\n\t        api.dispatchAction({\n\t            type: 'pieToggleSelect',\n\t            from: uid,\n\t            name: name,\n\t            seriesId: seriesModel.id\n\t        });\n\t\n\t        data.each(function (idx) {\n\t            toggleItemSelected(\n\t                data.getItemGraphicEl(idx),\n\t                data.getItemLayout(idx),\n\t                seriesModel.isSelected(data.getName(idx)),\n\t                selectedOffset,\n\t                hasAnimation\n\t            );\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @param {module:zrender/graphic/Sector} el\n\t     * @param {Object} layout\n\t     * @param {boolean} isSelected\n\t     * @param {number} selectedOffset\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n\t        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t\n\t        var dx = Math.cos(midAngle);\n\t        var dy = Math.sin(midAngle);\n\t\n\t        var offset = isSelected ? selectedOffset : 0;\n\t        var position = [dx * offset, dy * offset];\n\t\n\t        hasAnimation\n\t            // animateTo will stop revious animation like update transition\n\t            ? el.animate()\n\t                .when(200, {\n\t                    position: position\n\t                })\n\t                .start('bounceOut')\n\t            : el.attr('position', position);\n\t    }\n\t\n\t    /**\n\t     * Piece of pie including Sector, Label, LabelLine\n\t     * @constructor\n\t     * @extends {module:zrender/graphic/Group}\n\t     */\n\t    function PiePiece(data, idx) {\n\t\n\t        graphic.Group.call(this);\n\t\n\t        var sector = new graphic.Sector({\n\t            z2: 2\n\t        });\n\t        var polyline = new graphic.Polyline();\n\t        var text = new graphic.Text();\n\t        this.add(sector);\n\t        this.add(polyline);\n\t        this.add(text);\n\t\n\t        this.updateData(data, idx, true);\n\t\n\t        // Hover to change label and labelLine\n\t        function onEmphasis() {\n\t            polyline.ignore = polyline.hoverIgnore;\n\t            text.ignore = text.hoverIgnore;\n\t        }\n\t        function onNormal() {\n\t            polyline.ignore = polyline.normalIgnore;\n\t            text.ignore = text.normalIgnore;\n\t        }\n\t        this.on('emphasis', onEmphasis)\n\t            .on('normal', onNormal)\n\t            .on('mouseover', onEmphasis)\n\t            .on('mouseout', onNormal);\n\t    }\n\t\n\t    var piePieceProto = PiePiece.prototype;\n\t\n\t    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t        return {\n\t            fill: textStyleModel.getTextColor()\n\t                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n\t            opacity: data.getItemVisual(idx, 'opacity'),\n\t            textFont: textStyleModel.getFont(),\n\t            text: zrUtil.retrieve(\n\t                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n\t            )\n\t        };\n\t    }\n\t\n\t    piePieceProto.updateData = function (data, idx, firstCreate) {\n\t\n\t        var sector = this.childAt(0);\n\t\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var sectorShape = zrUtil.extend({}, layout);\n\t        sectorShape.label = null;\n\t        if (firstCreate) {\n\t            sector.setShape(sectorShape);\n\t            sector.shape.endAngle = layout.startAngle;\n\t            graphic.updateProps(sector, {\n\t                shape: {\n\t                    endAngle: layout.endAngle\n\t                }\n\t            }, seriesModel, idx);\n\t        }\n\t        else {\n\t            graphic.updateProps(sector, {\n\t                shape: sectorShape\n\t            }, seriesModel, idx);\n\t        }\n\t\n\t        // Update common style\n\t        var itemStyleModel = itemModel.getModel('itemStyle');\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t\n\t        sector.useStyle(\n\t            zrUtil.defaults(\n\t                {\n\t                    lineJoin: 'bevel',\n\t                    fill: visualColor\n\t                },\n\t                itemStyleModel.getModel('normal').getItemStyle()\n\t            )\n\t        );\n\t        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\t\n\t        // Toggle selected\n\t        toggleItemSelected(\n\t            this,\n\t            data.getItemLayout(idx),\n\t            itemModel.get('selected'),\n\t            seriesModel.get('selectedOffset'),\n\t            seriesModel.get('animation')\n\t        );\n\t\n\t        function onEmphasis() {\n\t            // Sector may has animation of updating data. Force to move to the last frame\n\t            // Or it may stopped on the wrong shape\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({\n\t                shape: {\n\t                    r: layout.r + 10\n\t                }\n\t            }, 300, 'elasticOut');\n\t        }\n\t        function onNormal() {\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({\n\t                shape: {\n\t                    r: layout.r\n\t                }\n\t            }, 300, 'elasticOut');\n\t        }\n\t        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\t        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n\t            sector\n\t                .on('mouseover', onEmphasis)\n\t                .on('mouseout', onNormal)\n\t                .on('emphasis', onEmphasis)\n\t                .on('normal', onNormal);\n\t        }\n\t\n\t        this._updateLabel(data, idx);\n\t\n\t        graphic.setHoverStyle(this);\n\t    };\n\t\n\t    piePieceProto._updateLabel = function (data, idx) {\n\t\n\t        var labelLine = this.childAt(1);\n\t        var labelText = this.childAt(2);\n\t\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var labelLayout = layout.label;\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t\n\t        graphic.updateProps(labelLine, {\n\t            shape: {\n\t                points: labelLayout.linePoints || [\n\t                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n\t                ]\n\t            }\n\t        }, seriesModel, idx);\n\t\n\t        graphic.updateProps(labelText, {\n\t            style: {\n\t                x: labelLayout.x,\n\t                y: labelLayout.y\n\t            }\n\t        }, seriesModel, idx);\n\t        labelText.attr({\n\t            style: {\n\t                textVerticalAlign: labelLayout.verticalAlign,\n\t                textAlign: labelLayout.textAlign,\n\t                textFont: labelLayout.font\n\t            },\n\t            rotation: labelLayout.rotation,\n\t            origin: [labelLayout.x, labelLayout.y],\n\t            z2: 10\n\t        });\n\t\n\t        var labelModel = itemModel.getModel('label.normal');\n\t        var labelHoverModel = itemModel.getModel('label.emphasis');\n\t        var labelLineModel = itemModel.getModel('labelLine.normal');\n\t        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n\t        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\t\n\t        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\t\n\t        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n\t        labelText.hoverIgnore = !labelHoverModel.get('show');\n\t\n\t        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n\t        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\t\n\t        // Default use item visual color\n\t        labelLine.setStyle({\n\t            stroke: visualColor,\n\t            opacity: data.getItemVisual(idx, 'opacity')\n\t        });\n\t        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\t\n\t        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n\t        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\t\n\t        var smooth = labelLineModel.get('smooth');\n\t        if (smooth && smooth === true) {\n\t            smooth = 0.4;\n\t        }\n\t        labelLine.setShape({\n\t            smooth: smooth\n\t        });\n\t    };\n\t\n\t    zrUtil.inherits(PiePiece, graphic.Group);\n\t\n\t\n\t    // Pie view\n\t    var Pie = __webpack_require__(/*! ../../view/Chart */ 27).extend({\n\t\n\t        type: 'pie',\n\t\n\t        init: function () {\n\t            var sectorGroup = new graphic.Group();\n\t            this._sectorGroup = sectorGroup;\n\t        },\n\t\n\t        render: function (seriesModel, ecModel, api, payload) {\n\t            if (payload && (payload.from === this.uid)) {\n\t                return;\n\t            }\n\t\n\t            var data = seriesModel.getData();\n\t            var oldData = this._data;\n\t            var group = this.group;\n\t\n\t            var hasAnimation = ecModel.get('animation');\n\t            var isFirstRender = !oldData;\n\t\n\t            var onSectorClick = zrUtil.curry(\n\t                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n\t            );\n\t\n\t            var selectedMode = seriesModel.get('selectedMode');\n\t\n\t            data.diff(oldData)\n\t                .add(function (idx) {\n\t                    var piePiece = new PiePiece(data, idx);\n\t                    if (isFirstRender) {\n\t                        piePiece.eachChild(function (child) {\n\t                            child.stopAnimation(true);\n\t                        });\n\t                    }\n\t\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t\n\t                    data.setItemGraphicEl(idx, piePiece);\n\t\n\t                    group.add(piePiece);\n\t                })\n\t                .update(function (newIdx, oldIdx) {\n\t                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\t\n\t                    piePiece.updateData(data, newIdx);\n\t\n\t                    piePiece.off('click');\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t                    group.add(piePiece);\n\t                    data.setItemGraphicEl(newIdx, piePiece);\n\t                })\n\t                .remove(function (idx) {\n\t                    var piePiece = oldData.getItemGraphicEl(idx);\n\t                    group.remove(piePiece);\n\t                })\n\t                .execute();\n\t\n\t            if (hasAnimation && isFirstRender && data.count() > 0) {\n\t                var shape = data.getItemLayout(0);\n\t                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\t\n\t                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n\t                group.setClipPath(this._createClipPath(\n\t                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n\t                ));\n\t            }\n\t\n\t            this._data = data;\n\t        },\n\t\n\t        dispose: function () {},\n\t\n\t        _createClipPath: function (\n\t            cx, cy, r, startAngle, clockwise, cb, seriesModel\n\t        ) {\n\t            var clipPath = new graphic.Sector({\n\t                shape: {\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r0: 0,\n\t                    r: r,\n\t                    startAngle: startAngle,\n\t                    endAngle: startAngle,\n\t                    clockwise: clockwise\n\t                }\n\t            });\n\t\n\t            graphic.initProps(clipPath, {\n\t                shape: {\n\t                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n\t                }\n\t            }, seriesModel, cb);\n\t\n\t            return clipPath;\n\t        },\n\t\n\t        /**\n\t         * @implement\n\t         */\n\t        containPoint: function (point, seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var itemLayout = data.getItemLayout(0);\n\t            if (itemLayout) {\n\t                var dx = point[0] - itemLayout.cx;\n\t                var dy = point[1] - itemLayout.cy;\n\t                var radius = Math.sqrt(dx * dx + dy * dy);\n\t                return radius <= itemLayout.r && radius >= itemLayout.r0;\n\t            }\n\t        }\n\t\n\t    });\n\t\n\t    module.exports = Pie;\n\n\n/***/ },\n/* 104 */\n/*!**************************************!*\\\n  !*** ./lib/chart/pie/labelLayout.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// FIXME emphasis label position is not same with normal label position\n\t\n\t\n\t    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 16);\n\t\n\t    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n\t        list.sort(function (a, b) {\n\t            return a.y - b.y;\n\t        });\n\t\n\t        // \n\t        function shiftDown(start, end, delta, dir) {\n\t            for (var j = start; j < end; j++) {\n\t                list[j].y += delta;\n\t                if (j > start\n\t                    && j + 1 < end\n\t                    && list[j + 1].y > list[j].y + list[j].height\n\t                ) {\n\t                    shiftUp(j, delta / 2);\n\t                    return;\n\t                }\n\t            }\n\t\n\t            shiftUp(end - 1, delta / 2);\n\t        }\n\t\n\t        // \n\t        function shiftUp(end, delta) {\n\t            for (var j = end; j >= 0; j--) {\n\t                list[j].y -= delta;\n\t                if (j > 0\n\t                    && list[j].y > list[j - 1].y + list[j - 1].height\n\t                ) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t\n\t        function changeX(list, isDownList, cx, cy, r, dir) {\n\t            var lastDeltaX = dir > 0\n\t                ? isDownList                // \n\t                    ? Number.MAX_VALUE      // \n\t                    : 0                     // \n\t                : isDownList                // \n\t                    ? Number.MAX_VALUE      // \n\t                    : 0;                    // \n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                // Not change x for center label\n\t                if (list[i].position === 'center') {\n\t                    continue;\n\t                }\n\t                var deltaY = Math.abs(list[i].y - cy);\n\t                var length = list[i].len;\n\t                var length2 = list[i].len2;\n\t                var deltaX = (deltaY < r + length)\n\t                    ? Math.sqrt(\n\t                          (r + length + length2) * (r + length + length2)\n\t                          - deltaY * deltaY\n\t                      )\n\t                    : Math.abs(list[i].x - cx);\n\t                if (isDownList && deltaX >= lastDeltaX) {\n\t                    // \n\t                    deltaX = lastDeltaX - 10;\n\t                }\n\t                if (!isDownList && deltaX <= lastDeltaX) {\n\t                    // \n\t                    deltaX = lastDeltaX + 10;\n\t                }\n\t\n\t                list[i].x = cx + deltaX * dir;\n\t                lastDeltaX = deltaX;\n\t            }\n\t        }\n\t\n\t        var lastY = 0;\n\t        var delta;\n\t        var len = list.length;\n\t        var upList = [];\n\t        var downList = [];\n\t        for (var i = 0; i < len; i++) {\n\t            delta = list[i].y - lastY;\n\t            if (delta < 0) {\n\t                shiftDown(i, len, -delta, dir);\n\t            }\n\t            lastY = list[i].y + list[i].height;\n\t        }\n\t        if (viewHeight - lastY < 0) {\n\t            shiftUp(len - 1, lastY - viewHeight);\n\t        }\n\t        for (var i = 0; i < len; i++) {\n\t            if (list[i].y >= cy) {\n\t                downList.push(list[i]);\n\t            }\n\t            else {\n\t                upList.push(list[i]);\n\t            }\n\t        }\n\t        changeX(upList, false, cx, cy, r, dir);\n\t        changeX(downList, true, cx, cy, r, dir);\n\t    }\n\t\n\t    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n\t        var leftList = [];\n\t        var rightList = [];\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            if (labelLayoutList[i].x < cx) {\n\t                leftList.push(labelLayoutList[i]);\n\t            }\n\t            else {\n\t                rightList.push(labelLayoutList[i]);\n\t            }\n\t        }\n\t\n\t        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n\t        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\t\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            var linePoints = labelLayoutList[i].linePoints;\n\t            if (linePoints) {\n\t                var dist = linePoints[1][0] - linePoints[2][0];\n\t                if (labelLayoutList[i].x < cx) {\n\t                    linePoints[2][0] = labelLayoutList[i].x + 3;\n\t                }\n\t                else {\n\t                    linePoints[2][0] = labelLayoutList[i].x - 3;\n\t                }\n\t                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n\t                linePoints[1][0] = linePoints[2][0] + dist;\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n\t        var data = seriesModel.getData();\n\t        var labelLayoutList = [];\n\t        var cx;\n\t        var cy;\n\t        var hasLabelRotate = false;\n\t\n\t        data.each(function (idx) {\n\t            var layout = data.getItemLayout(idx);\n\t\n\t            var itemModel = data.getItemModel(idx);\n\t            var labelModel = itemModel.getModel('label.normal');\n\t            // Use position in normal or emphasis\n\t            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\t\n\t            var labelLineModel = itemModel.getModel('labelLine.normal');\n\t            var labelLineLen = labelLineModel.get('length');\n\t            var labelLineLen2 = labelLineModel.get('length2');\n\t\n\t            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t            var dx = Math.cos(midAngle);\n\t            var dy = Math.sin(midAngle);\n\t\n\t            var textX;\n\t            var textY;\n\t            var linePoints;\n\t            var textAlign;\n\t\n\t            cx = layout.cx;\n\t            cy = layout.cy;\n\t\n\t            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t            if (labelPosition === 'center') {\n\t                textX = layout.cx;\n\t                textY = layout.cy;\n\t                textAlign = 'center';\n\t            }\n\t            else {\n\t                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n\t                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\t\n\t                textX = x1 + dx * 3;\n\t                textY = y1 + dy * 3;\n\t\n\t                if (!isLabelInside) {\n\t                    // For roseType\n\t                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n\t                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n\t                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n\t                    var y3 = y2;\n\t\n\t                    textX = x3 + (dx < 0 ? -5 : 5);\n\t                    textY = y3;\n\t                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n\t                }\n\t\n\t                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n\t            }\n\t            var font = labelModel.getModel('textStyle').getFont();\n\t\n\t            var labelRotate = labelModel.get('rotate')\n\t                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n\t            var text = seriesModel.getFormattedLabel(idx, 'normal')\n\t                        || data.getName(idx);\n\t            var textRect = textContain.getBoundingRect(\n\t                text, font, textAlign, 'top'\n\t            );\n\t            hasLabelRotate = !!labelRotate;\n\t            layout.label = {\n\t                x: textX,\n\t                y: textY,\n\t                position: labelPosition,\n\t                height: textRect.height,\n\t                len: labelLineLen,\n\t                len2: labelLineLen2,\n\t                linePoints: linePoints,\n\t                textAlign: textAlign,\n\t                verticalAlign: 'middle',\n\t                font: font,\n\t                rotation: labelRotate\n\t            };\n\t\n\t            // Not layout the inside label\n\t            if (!isLabelInside) {\n\t                labelLayoutList.push(layout.label);\n\t            }\n\t        });\n\t        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n\t            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n\t        }\n\t    };\n\n\n/***/ },\n/* 105 */\n/*!************************************!*\\\n  !*** ./lib/chart/pie/pieLayout.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// TODO minAngle\n\t\n\t\n\t\n\t    var numberUtil = __webpack_require__(/*! ../../util/number */ 4);\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var labelLayout = __webpack_require__(/*! ./labelLayout */ 104);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var PI2 = Math.PI * 2;\n\t    var RADIAN = Math.PI / 180;\n\t\n\t    module.exports = function (seriesType, ecModel, api, payload) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var center = seriesModel.get('center');\n\t            var radius = seriesModel.get('radius');\n\t\n\t            if (!zrUtil.isArray(radius)) {\n\t                radius = [0, radius];\n\t            }\n\t            if (!zrUtil.isArray(center)) {\n\t                center = [center, center];\n\t            }\n\t\n\t            var width = api.getWidth();\n\t            var height = api.getHeight();\n\t            var size = Math.min(width, height);\n\t            var cx = parsePercent(center[0], width);\n\t            var cy = parsePercent(center[1], height);\n\t            var r0 = parsePercent(radius[0], size / 2);\n\t            var r = parsePercent(radius[1], size / 2);\n\t\n\t            var data = seriesModel.getData();\n\t\n\t            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\t\n\t            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\t\n\t            var sum = data.getSum('value');\n\t            // Sum may be 0\n\t            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\t\n\t            var clockwise = seriesModel.get('clockwise');\n\t\n\t            var roseType = seriesModel.get('roseType');\n\t\n\t            // [0...max]\n\t            var extent = data.getDataExtent('value');\n\t            extent[0] = 0;\n\t\n\t            // In the case some sector angle is smaller than minAngle\n\t            var restAngle = PI2;\n\t            var valueSumLargerThanMinAngle = 0;\n\t\n\t            var currentAngle = startAngle;\n\t\n\t            var dir = clockwise ? 1 : -1;\n\t            data.each('value', function (value, idx) {\n\t                var angle;\n\t                // FIXME  2.0  roseType  area \n\t                if (roseType !== 'area') {\n\t                    angle = sum === 0 ? unitRadian : (value * unitRadian);\n\t                }\n\t                else {\n\t                    angle = PI2 / (data.count() || 1);\n\t                }\n\t\n\t                if (angle < minAngle) {\n\t                    angle = minAngle;\n\t                    restAngle -= minAngle;\n\t                }\n\t                else {\n\t                    valueSumLargerThanMinAngle += value;\n\t                }\n\t\n\t                var endAngle = currentAngle + dir * angle;\n\t                data.setItemLayout(idx, {\n\t                    angle: angle,\n\t                    startAngle: currentAngle,\n\t                    endAngle: endAngle,\n\t                    clockwise: clockwise,\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r0: r0,\n\t                    r: roseType\n\t                        ? numberUtil.linearMap(value, extent, [r0, r])\n\t                        : r\n\t                });\n\t\n\t                currentAngle = endAngle;\n\t            }, true);\n\t\n\t            // Some sector is constrained by minAngle\n\t            // Rest sectors needs recalculate angle\n\t            if (restAngle < PI2) {\n\t                // Average the angle if rest angle is not enough after all angles is\n\t                // Constrained by minAngle\n\t                if (restAngle <= 1e-3) {\n\t                    var angle = PI2 / data.count();\n\t                    data.each(function (idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        layout.startAngle = startAngle + dir * idx * angle;\n\t                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n\t                    });\n\t                }\n\t                else {\n\t                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n\t                    currentAngle = startAngle;\n\t                    data.each('value', function (value, idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        var angle = layout.angle === minAngle\n\t                            ? minAngle : value * unitRadian;\n\t                        layout.startAngle = currentAngle;\n\t                        layout.endAngle = currentAngle + dir * angle;\n\t                        currentAngle += angle;\n\t                    });\n\t                }\n\t            }\n\t\n\t            labelLayout(seriesModel, r, width, height);\n\t        });\n\t    };\n\n\n/***/ },\n/* 106 */\n/*!*******************************!*\\\n  !*** ./lib/component/axis.js ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// TODO boundaryGap\n\t\n\t\n\t    __webpack_require__(/*! ../coord/cartesian/AxisModel */ 53);\n\t\n\t    __webpack_require__(/*! ./axis/AxisView */ 107);\n\n\n/***/ },\n/* 107 */\n/*!****************************************!*\\\n  !*** ./lib/component/axis/AxisView.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var AxisBuilder = __webpack_require__(/*! ./AxisBuilder */ 50);\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n\t    var getInterval = AxisBuilder.getInterval;\n\t\n\t    var axisBuilderAttrs = [\n\t        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n\t    ];\n\t    var selfBuilderAttrs = [\n\t        'splitArea', 'splitLine'\n\t    ];\n\t\n\t    // function getAlignWithLabel(model, axisModel) {\n\t    //     var alignWithLabel = model.get('alignWithLabel');\n\t    //     if (alignWithLabel === 'auto') {\n\t    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n\t    //     }\n\t    //     return alignWithLabel;\n\t    // }\n\t\n\t    var AxisView = __webpack_require__(/*! ../../echarts */ 2).extendComponentView({\n\t\n\t        type: 'axis',\n\t\n\t        render: function (axisModel, ecModel) {\n\t\n\t            this.group.removeAll();\n\t\n\t            var oldAxisGroup = this._axisGroup;\n\t            this._axisGroup = new graphic.Group();\n\t\n\t            this.group.add(this._axisGroup);\n\t\n\t            if (!axisModel.get('show')) {\n\t                return;\n\t            }\n\t\n\t            var gridModel = axisModel.findGridModel();\n\t\n\t            var layout = layoutAxis(gridModel, axisModel);\n\t\n\t            var axisBuilder = new AxisBuilder(axisModel, layout);\n\t\n\t            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\t\n\t            this._axisGroup.add(axisBuilder.getGroup());\n\t\n\t            zrUtil.each(selfBuilderAttrs, function (name) {\n\t                if (axisModel.get(name + '.show')) {\n\t                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n\t                }\n\t            }, this);\n\t\n\t            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n\t         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t         * @param {number|Function} labelInterval\n\t         * @private\n\t         */\n\t        _splitLine: function (axisModel, gridModel, labelInterval) {\n\t            var axis = axisModel.axis;\n\t\n\t            var splitLineModel = axisModel.getModel('splitLine');\n\t            var lineStyleModel = splitLineModel.getModel('lineStyle');\n\t            var lineColors = lineStyleModel.get('color');\n\t\n\t            var lineInterval = getInterval(splitLineModel, labelInterval);\n\t\n\t            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\t\n\t            var gridRect = gridModel.coordinateSystem.getRect();\n\t            var isHorizontal = axis.isHorizontal();\n\t\n\t            var lineCount = 0;\n\t\n\t            var ticksCoords = axis.getTicksCoords(\n\t                // splitLineModel.get('alignWithLabel')\n\t            );\n\t            var ticks = axis.scale.getTicks();\n\t\n\t            var p1 = [];\n\t            var p2 = [];\n\t            // Simple optimization\n\t            // Batching the lines if color are the same\n\t            var lineStyle = lineStyleModel.getLineStyle();\n\t            for (var i = 0; i < ticksCoords.length; i++) {\n\t                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n\t                    continue;\n\t                }\n\t\n\t                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t\n\t                if (isHorizontal) {\n\t                    p1[0] = tickCoord;\n\t                    p1[1] = gridRect.y;\n\t                    p2[0] = tickCoord;\n\t                    p2[1] = gridRect.y + gridRect.height;\n\t                }\n\t                else {\n\t                    p1[0] = gridRect.x;\n\t                    p1[1] = tickCoord;\n\t                    p2[0] = gridRect.x + gridRect.width;\n\t                    p2[1] = tickCoord;\n\t                }\n\t\n\t                var colorIndex = (lineCount++) % lineColors.length;\n\t                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                    anid: 'line_' + ticks[i],\n\t\n\t                    shape: {\n\t                        x1: p1[0],\n\t                        y1: p1[1],\n\t                        x2: p2[0],\n\t                        y2: p2[1]\n\t                    },\n\t                    style: zrUtil.defaults({\n\t                        stroke: lineColors[colorIndex]\n\t                    }, lineStyle),\n\t                    silent: true\n\t                })));\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n\t         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t         * @param {number|Function} labelInterval\n\t         * @private\n\t         */\n\t        _splitArea: function (axisModel, gridModel, labelInterval) {\n\t            var axis = axisModel.axis;\n\t\n\t            var splitAreaModel = axisModel.getModel('splitArea');\n\t            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\t            var areaColors = areaStyleModel.get('color');\n\t\n\t            var gridRect = gridModel.coordinateSystem.getRect();\n\t\n\t            var ticksCoords = axis.getTicksCoords(\n\t                // splitAreaModel.get('alignWithLabel')\n\t            );\n\t            var ticks = axis.scale.getTicks();\n\t\n\t            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n\t            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\t\n\t            var count = 0;\n\t\n\t            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\t\n\t            var areaStyle = areaStyleModel.getAreaStyle();\n\t            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\t\n\t            for (var i = 1; i < ticksCoords.length; i++) {\n\t                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n\t                    continue;\n\t                }\n\t\n\t                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t\n\t                var x;\n\t                var y;\n\t                var width;\n\t                var height;\n\t                if (axis.isHorizontal()) {\n\t                    x = prevX;\n\t                    y = gridRect.y;\n\t                    width = tickCoord - x;\n\t                    height = gridRect.height;\n\t                }\n\t                else {\n\t                    x = gridRect.x;\n\t                    y = prevY;\n\t                    width = gridRect.width;\n\t                    height = tickCoord - y;\n\t                }\n\t\n\t                var colorIndex = (count++) % areaColors.length;\n\t                this._axisGroup.add(new graphic.Rect({\n\t                    anid: 'area_' + ticks[i],\n\t\n\t                    shape: {\n\t                        x: x,\n\t                        y: y,\n\t                        width: width,\n\t                        height: height\n\t                    },\n\t                    style: zrUtil.defaults({\n\t                        fill: areaColors[colorIndex]\n\t                    }, areaStyle),\n\t                    silent: true\n\t                }));\n\t\n\t                prevX = x + width;\n\t                prevY = y + height;\n\t            }\n\t        }\n\t    });\n\t\n\t    AxisView.extend({\n\t        type: 'xAxis'\n\t    });\n\t    AxisView.extend({\n\t        type: 'yAxis'\n\t    });\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function layoutAxis(gridModel, axisModel) {\n\t        var grid = gridModel.coordinateSystem;\n\t        var axis = axisModel.axis;\n\t        var layout = {};\n\t\n\t        var rawAxisPosition = axis.position;\n\t        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n\t        var axisDim = axis.dim;\n\t\n\t        // [left, right, top, bottom]\n\t        var rect = grid.getRect();\n\t        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\t\n\t        var axisOffset = axisModel.get('offset') || 0;\n\t\n\t        var posMap = {\n\t            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n\t            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n\t        };\n\t\n\t        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n\t        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\t\n\t        function getZero(dim, val) {\n\t            var theAxis = grid.getAxis(dim);\n\t            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n\t        }\n\t\n\t        // Axis position\n\t        layout.position = [\n\t            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n\t            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n\t        ];\n\t\n\t        // Axis rotation\n\t        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\t\n\t        // Tick and label direction, x y is axisDim\n\t        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\t\n\t        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n\t        if (axis.onZero) {\n\t            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n\t        }\n\t\n\t        if (axisModel.getModel('axisTick').get('inside')) {\n\t            layout.tickDirection = -layout.tickDirection;\n\t        }\n\t        if (axisModel.getModel('axisLabel').get('inside')) {\n\t            layout.labelDirection = -layout.labelDirection;\n\t        }\n\t\n\t        // Special label rotation\n\t        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n\t        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\t\n\t        // label interval when auto mode.\n\t        layout.labelInterval = axis.getLabelInterval();\n\t\n\t        // Over splitLine and splitArea\n\t        layout.z2 = 1;\n\t\n\t        return layout;\n\t    }\n\n\n/***/ },\n/* 108 */\n/*!**************************************************!*\\\n  !*** ./lib/component/dataZoom/dataZoomAction.js ***!\n  \\**************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file Data zoom action\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var helper = __webpack_require__(/*! ./helper */ 110);\n\t    var echarts = __webpack_require__(/*! ../../echarts */ 2);\n\t\n\t\n\t    echarts.registerAction('dataZoom', function (payload, ecModel) {\n\t\n\t        var linkedNodesFinder = helper.createLinkedNodesFinder(\n\t            zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'),\n\t            helper.eachAxisDim,\n\t            function (model, dimNames) {\n\t                return model.get(dimNames.axisIndex);\n\t            }\n\t        );\n\t\n\t        var effectedModels = [];\n\t\n\t        ecModel.eachComponent(\n\t            {mainType: 'dataZoom', query: payload},\n\t            function (model, index) {\n\t                effectedModels.push.apply(\n\t                    effectedModels, linkedNodesFinder(model).nodes\n\t                );\n\t            }\n\t        );\n\t\n\t        zrUtil.each(effectedModels, function (dataZoomModel, index) {\n\t            dataZoomModel.setRawRange({\n\t                start: payload.start,\n\t                end: payload.end,\n\t                startValue: payload.startValue,\n\t                endValue: payload.endValue\n\t            });\n\t        });\n\t\n\t    });\n\t\n\n\n/***/ },\n/* 109 */\n/*!*****************************************************!*\\\n  !*** ./lib/component/dataZoom/dataZoomProcessor.js ***!\n  \\*****************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file Data zoom processor\n\t */\n\t\n\t\n\t    var echarts = __webpack_require__(/*! ../../echarts */ 2);\n\t\n\t    echarts.registerProcessor(function (ecModel, api) {\n\t\n\t        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n\t            // We calculate window and reset axis here but not in model\n\t            // init stage and not after action dispatch handler, because\n\t            // reset should be called after seriesData.restoreData.\n\t            dataZoomModel.eachTargetAxis(resetSingleAxis);\n\t\n\t            // Caution: data zoom filtering is order sensitive when using\n\t            // percent range and no min/max/scale set on axis.\n\t            // For example, we have dataZoom definition:\n\t            // [\n\t            //      {xAxisIndex: 0, start: 30, end: 70},\n\t            //      {yAxisIndex: 0, start: 20, end: 80}\n\t            // ]\n\t            // In this case, [20, 80] of y-dataZoom should be based on data\n\t            // that have filtered by x-dataZoom using range of [30, 70],\n\t            // but should not be based on full raw data. Thus sliding\n\t            // x-dataZoom will change both ranges of xAxis and yAxis,\n\t            // while sliding y-dataZoom will only change the range of yAxis.\n\t            // So we should filter x-axis after reset x-axis immediately,\n\t            // and then reset y-axis and filter y-axis.\n\t            dataZoomModel.eachTargetAxis(filterSingleAxis);\n\t        });\n\t\n\t        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n\t            // Fullfill all of the range props so that user\n\t            // is able to get them from chart.getOption().\n\t            var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n\t            var percentRange = axisProxy.getDataPercentWindow();\n\t            var valueRange = axisProxy.getDataValueWindow();\n\t\n\t            dataZoomModel.setRawRange({\n\t                start: percentRange[0],\n\t                end: percentRange[1],\n\t                startValue: valueRange[0],\n\t                endValue: valueRange[1]\n\t            });\n\t        });\n\t    });\n\t\n\t    function resetSingleAxis(dimNames, axisIndex, dataZoomModel) {\n\t        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);\n\t    }\n\t\n\t    function filterSingleAxis(dimNames, axisIndex, dataZoomModel) {\n\t        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);\n\t    }\n\t\n\t\n\n\n/***/ },\n/* 110 */\n/*!******************************************!*\\\n  !*** ./lib/component/dataZoom/helper.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var formatUtil = __webpack_require__(/*! ../../util/format */ 9);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var helper = {};\n\t\n\t    var AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle'];\n\t\n\t    /**\n\t     * Create \"each\" method to iterate names.\n\t     *\n\t     * @pubilc\n\t     * @param  {Array.<string>} names\n\t     * @param  {Array.<string>=} attrs\n\t     * @return {Function}\n\t     */\n\t    helper.createNameEach = function (names, attrs) {\n\t        names = names.slice();\n\t        var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n\t        attrs = (attrs || []).slice();\n\t        var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n\t\n\t        return function (callback, context) {\n\t            zrUtil.each(names, function (name, index) {\n\t                var nameObj = {name: name, capital: capitalNames[index]};\n\t\n\t                for (var j = 0; j < attrs.length; j++) {\n\t                    nameObj[attrs[j]] = name + capitalAttrs[j];\n\t                }\n\t\n\t                callback.call(context, nameObj);\n\t            });\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Iterate each dimension name.\n\t     *\n\t     * @public\n\t     * @param {Function} callback The parameter is like:\n\t     *                            {\n\t     *                                name: 'angle',\n\t     *                                capital: 'Angle',\n\t     *                                axis: 'angleAxis',\n\t     *                                axisIndex: 'angleAixs',\n\t     *                                index: 'angleIndex'\n\t     *                            }\n\t     * @param {Object} context\n\t     */\n\t    helper.eachAxisDim = helper.createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n\t\n\t    /**\n\t     * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n\t     * dataZoomModels and 'links' make up one or more graphics.\n\t     * This function finds the graphic where the source dataZoomModel is in.\n\t     *\n\t     * @public\n\t     * @param {Function} forEachNode Node iterator.\n\t     * @param {Function} forEachEdgeType edgeType iterator\n\t     * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n\t     * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n\t     */\n\t    helper.createLinkedNodesFinder = function (forEachNode, forEachEdgeType, edgeIdGetter) {\n\t\n\t        return function (sourceNode) {\n\t            var result = {\n\t                nodes: [],\n\t                records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n\t            };\n\t\n\t            forEachEdgeType(function (edgeType) {\n\t                result.records[edgeType.name] = {};\n\t            });\n\t\n\t            if (!sourceNode) {\n\t                return result;\n\t            }\n\t\n\t            absorb(sourceNode, result);\n\t\n\t            var existsLink;\n\t            do {\n\t                existsLink = false;\n\t                forEachNode(processSingleNode);\n\t            }\n\t            while (existsLink);\n\t\n\t            function processSingleNode(node) {\n\t                if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n\t                    absorb(node, result);\n\t                    existsLink = true;\n\t                }\n\t            }\n\t\n\t            return result;\n\t        };\n\t\n\t        function isNodeAbsorded(node, result) {\n\t            return zrUtil.indexOf(result.nodes, node) >= 0;\n\t        }\n\t\n\t        function isLinked(node, result) {\n\t            var hasLink = false;\n\t            forEachEdgeType(function (edgeType) {\n\t                zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n\t                    result.records[edgeType.name][edgeId] && (hasLink = true);\n\t                });\n\t            });\n\t            return hasLink;\n\t        }\n\t\n\t        function absorb(node, result) {\n\t            result.nodes.push(node);\n\t            forEachEdgeType(function (edgeType) {\n\t                zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n\t                    result.records[edgeType.name][edgeId] = true;\n\t                });\n\t            });\n\t        }\n\t    };\n\t\n\t    module.exports = helper;\n\n\n/***/ },\n/* 111 */\n/*!*******************************************!*\\\n  !*** ./lib/component/dataZoom/history.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file History manager.\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var each = zrUtil.each;\n\t\n\t    var ATTR = '\\0_ec_hist_store';\n\t\n\t    var history = {\n\t\n\t        /**\n\t         * @public\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}\n\t         */\n\t        push: function (ecModel, newSnapshot) {\n\t            var store = giveStore(ecModel);\n\t\n\t            // If previous dataZoom can not be found,\n\t            // complete an range with current range.\n\t            each(newSnapshot, function (batchItem, dataZoomId) {\n\t                var i = store.length - 1;\n\t                for (; i >= 0; i--) {\n\t                    var snapshot = store[i];\n\t                    if (snapshot[dataZoomId]) {\n\t                        break;\n\t                    }\n\t                }\n\t                if (i < 0) {\n\t                    // No origin range set, create one by current range.\n\t                    var dataZoomModel = ecModel.queryComponents(\n\t                        {mainType: 'dataZoom', subType: 'select', id: dataZoomId}\n\t                    )[0];\n\t                    if (dataZoomModel) {\n\t                        var percentRange = dataZoomModel.getPercentRange();\n\t                        store[0][dataZoomId] = {\n\t                            dataZoomId: dataZoomId,\n\t                            start: percentRange[0],\n\t                            end: percentRange[1]\n\t                        };\n\t                    }\n\t                }\n\t            });\n\t\n\t            store.push(newSnapshot);\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @return {Object} snapshot\n\t         */\n\t        pop: function (ecModel) {\n\t            var store = giveStore(ecModel);\n\t            var head = store[store.length - 1];\n\t            store.length > 1 && store.pop();\n\t\n\t            // Find top for all dataZoom.\n\t            var snapshot = {};\n\t            each(head, function (batchItem, dataZoomId) {\n\t                for (var i = store.length - 1; i >= 0; i--) {\n\t                    var batchItem = store[i][dataZoomId];\n\t                    if (batchItem) {\n\t                        snapshot[dataZoomId] = batchItem;\n\t                        break;\n\t                    }\n\t                }\n\t            });\n\t\n\t            return snapshot;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         */\n\t        clear: function (ecModel) {\n\t            ecModel[ATTR] = null;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @return {number} records. always >= 1.\n\t         */\n\t        count: function (ecModel) {\n\t            return giveStore(ecModel).length;\n\t        }\n\t\n\t    };\n\t\n\t    /**\n\t     * [{key: dataZoomId, value: {dataZoomId, range}}, ...]\n\t     * History length of each dataZoom may be different.\n\t     * this._history[0] is used to store origin range.\n\t     * @type {Array.<Object>}\n\t     */\n\t    function giveStore(ecModel) {\n\t        var store = ecModel[ATTR];\n\t        if (!store) {\n\t            store = ecModel[ATTR] = [{}];\n\t        }\n\t        return store;\n\t    }\n\t\n\t    module.exports = history;\n\t\n\n\n/***/ },\n/* 112 */\n/*!*************************************************!*\\\n  !*** ./lib/component/dataZoom/typeDefaulter.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    __webpack_require__(/*! ../../model/Component */ 12).registerSubTypeDefaulter('dataZoom', function (option) {\n\t        // Default 'slider' when no type specified.\n\t        return 'slider';\n\t    });\n\t\n\n\n/***/ },\n/* 113 */\n/*!*************************************************!*\\\n  !*** ./lib/component/helper/BrushController.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Box selection tool.\n\t *\n\t * @module echarts/component/helper/BrushController\n\t */\n\t\n\t\n\t\n\t    var Eventful = __webpack_require__(/*! zrender/lib/mixin/Eventful */ 20);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var BoundingRect = __webpack_require__(/*! zrender/lib/core/BoundingRect */ 8);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var interactionMutex = __webpack_require__(/*! ./interactionMutex */ 115);\n\t    var DataDiffer = __webpack_require__(/*! ../../data/DataDiffer */ 45);\n\t\n\t    var curry = zrUtil.curry;\n\t    var each = zrUtil.each;\n\t    var map = zrUtil.map;\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathPow = Math.pow;\n\t\n\t    var COVER_Z = 10000;\n\t    var UNSELECT_THRESHOLD = 6;\n\t    var MIN_RESIZE_LINE_WIDTH = 6;\n\t    var MUTEX_RESOURCE_KEY = 'globalPan';\n\t\n\t    var DIRECTION_MAP = {\n\t        w: [0, 0],\n\t        e: [0, 1],\n\t        n: [1, 0],\n\t        s: [1, 1]\n\t    };\n\t    var CURSOR_MAP = {\n\t        w: 'ew',\n\t        e: 'ew',\n\t        n: 'ns',\n\t        s: 'ns',\n\t        ne: 'nesw',\n\t        sw: 'nesw',\n\t        nw: 'nwse',\n\t        se: 'nwse'\n\t    };\n\t    var DEFAULT_BRUSH_OPT = {\n\t        brushStyle: {\n\t            lineWidth: 2,\n\t            stroke: 'rgba(0,0,0,0.3)',\n\t            fill: 'rgba(0,0,0,0.1)'\n\t        },\n\t        transformable: true,\n\t        brushMode: 'single',\n\t        removeOnClick: false\n\t    };\n\t\n\t    var baseUID = 0;\n\t\n\t    /**\n\t     * @alias module:echarts/component/helper/BrushController\n\t     * @constructor\n\t     * @mixin {module:zrender/mixin/Eventful}\n\t     * @event module:echarts/component/helper/BrushController#brush\n\t     *        params:\n\t     *            areas: Array.<Array>, coord relates to container group,\n\t     *                                    If no container specified, to global.\n\t     *            opt {\n\t     *                isEnd: boolean,\n\t     *                removeOnClick: boolean\n\t     *            }\n\t     *\n\t     * @param {module:zrender/zrender~ZRender} zr\n\t     */\n\t    function BrushController(zr) {\n\t\n\t        if (false) {\n\t            zrUtil.assert(zr);\n\t        }\n\t\n\t        Eventful.call(this);\n\t\n\t        /**\n\t         * @type {module:zrender/zrender~ZRender}\n\t         * @private\n\t         */\n\t        this._zr = zr;\n\t\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new graphic.Group();\n\t\n\t        /**\n\t         * Only for drawing (after enabledBrush).\n\t         * @private\n\t         * @type {string}\n\t         */\n\t        this._brushType;\n\t\n\t        /**\n\t         * Only for drawing (after enabledBrush).\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._brushOption;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._panels;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<nubmer>}\n\t         */\n\t        this._track = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._dragging;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array}\n\t         */\n\t        this._covers = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {moudule:zrender/container/Group}\n\t         */\n\t        this._creatingCover;\n\t\n\t        /**\n\t         * true means global panel\n\t         * @private\n\t         * @type {module:zrender/container/Group|boolean}\n\t         */\n\t        this._creatingPanel;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._enableGlobalPan;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        if (false) {\n\t            this._mounted;\n\t        }\n\t\n\t        /**\n\t         * @private\n\t         * @type {string}\n\t         */\n\t        this._uid = 'brushController_' + baseUID++;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._handlers = {};\n\t        each(mouseHandlers, function (handler, eventName) {\n\t            this._handlers[eventName] = zrUtil.bind(handler, this);\n\t        }, this);\n\t    }\n\t\n\t    BrushController.prototype = {\n\t\n\t        constructor: BrushController,\n\t\n\t        /**\n\t         * If set to null/undefined/false, select disabled.\n\t         * @param {Object} brushOption\n\t         * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n\t         *                          If pass false/null/undefined, disable brush.\n\t         * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n\t         * @param {boolean} [brushOption.transformable=true]\n\t         * @param {boolean} [brushOption.removeOnClick=false]\n\t         * @param {Object} [brushOption.brushStyle]\n\t         * @param {number} [brushOption.brushStyle.width]\n\t         * @param {number} [brushOption.brushStyle.lineWidth]\n\t         * @param {string} [brushOption.brushStyle.stroke]\n\t         * @param {string} [brushOption.brushStyle.fill]\n\t         */\n\t        enableBrush: function (brushOption) {\n\t            if (false) {\n\t                zrUtil.assert(this._mounted);\n\t            }\n\t\n\t            this._brushType && doDisableBrush(this);\n\t            brushOption.brushType && doEnableBrush(this, brushOption);\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n\t         *        Each items: {panelId, rect}\n\t         */\n\t        setPanels: function (panelOpts) {\n\t            var oldPanels = this._panels || {};\n\t            var newPanels = this._panels = panelOpts && panelOpts.length && {};\n\t            var thisGroup = this.group;\n\t\n\t            newPanels && each(panelOpts, function (panelOpt) {\n\t                var panelId = panelOpt.panelId;\n\t                var panel = oldPanels[panelId];\n\t                if (!panel) {\n\t                    panel = new graphic.Rect({\n\t                        silent: true,\n\t                        invisible: true\n\t                    });\n\t                    thisGroup.add(panel);\n\t                }\n\t\n\t                var rect = panelOpt.rect;\n\t                // Using BoundingRect to normalize negative width/height.\n\t                if (!(rect instanceof BoundingRect)) {\n\t                    rect = BoundingRect.create(rect);\n\t                }\n\t\n\t                panel.attr('shape', rect.plain());\n\t                panel.__brushPanelId = panelId;\n\t                newPanels[panelId] = panel;\n\t                oldPanels[panelId] = null;\n\t            });\n\t\n\t            each(oldPanels, function (panel) {\n\t                panel && thisGroup.remove(panel);\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {Object} [opt]\n\t         * @return {boolean} [opt.enableGlobalPan=false]\n\t         * @return {boolean} [opt.position=[0, 0]]\n\t         * @return {boolean} [opt.rotation=0]\n\t         * @return {boolean} [opt.scale=[1, 1]]\n\t         */\n\t        mount: function (opt) {\n\t            opt = opt || {};\n\t\n\t            if (false) {\n\t                this._mounted = true; // should be at first.\n\t            }\n\t\n\t            this._enableGlobalPan = opt.enableGlobalPan;\n\t\n\t            var thisGroup = this.group;\n\t            this._zr.add(thisGroup);\n\t\n\t            thisGroup.attr({\n\t                position: opt.position || [0, 0],\n\t                rotation: opt.rotation || 0,\n\t                scale: opt.scale || [1, 1]\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        eachCover: function (cb, context) {\n\t            each(this._covers, cb, context);\n\t        },\n\t\n\t        /**\n\t         * Update covers.\n\t         * @param {Array.<Object>} brushOptionList Like:\n\t         *        [\n\t         *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n\t         *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n\t         *            ...\n\t         *        ]\n\t         *        `brushType` is required in each cover info.\n\t         *        `id` is not mandatory.\n\t         *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n\t         *        If brushOptionList is null/undefined, all covers removed.\n\t         */\n\t        updateCovers: function (brushOptionList) {\n\t            if (false) {\n\t                zrUtil.assert(this._mounted);\n\t            }\n\t\n\t            brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n\t                return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n\t            });\n\t\n\t            var tmpIdPrefix = '\\0-brush-index-';\n\t            var oldCovers = this._covers;\n\t            var newCovers = this._covers = [];\n\t            var controller = this;\n\t            var creatingCover = this._creatingCover;\n\t\n\t            (new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey))\n\t                .add(addOrUpdate)\n\t                .update(addOrUpdate)\n\t                .remove(remove)\n\t                .execute();\n\t\n\t            return this;\n\t\n\t            function getKey(brushOption, index) {\n\t                return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index)\n\t                    + '-' + brushOption.brushType;\n\t            }\n\t\n\t            function oldGetKey(cover, index) {\n\t                return getKey(cover.__brushOption, index);\n\t            }\n\t\n\t            function addOrUpdate(newIndex, oldIndex) {\n\t                var newBrushOption = brushOptionList[newIndex];\n\t                // Consider setOption in event listener of brushSelect,\n\t                // where updating cover when creating should be forbiden.\n\t                if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n\t                    newCovers[newIndex] = oldCovers[oldIndex];\n\t                }\n\t                else {\n\t                    var cover = newCovers[newIndex] = oldIndex != null\n\t                        ? (\n\t                            oldCovers[oldIndex].__brushOption = newBrushOption,\n\t                            oldCovers[oldIndex]\n\t                        )\n\t                        : endCreating(controller, createCover(controller, newBrushOption));\n\t                    updateCoverAfterCreation(controller, cover);\n\t                }\n\t            }\n\t\n\t            function remove(oldIndex) {\n\t                if (oldCovers[oldIndex] !== creatingCover) {\n\t                    controller.group.remove(oldCovers[oldIndex]);\n\t                }\n\t            }\n\t        },\n\t\n\t        unmount: function () {\n\t            this.enableBrush(false);\n\t\n\t            // container may 'removeAll' outside.\n\t            clearCovers(this);\n\t            this._zr.remove(this.group);\n\t\n\t            if (false) {\n\t                this._mounted = false; // should be at last.\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        dispose: function () {\n\t            this.unmount();\n\t            this.off();\n\t        }\n\t    };\n\t\n\t    zrUtil.mixin(BrushController, Eventful);\n\t\n\t\n\t    function doEnableBrush(controller, brushOption) {\n\t        var zr = controller._zr;\n\t\n\t        // Consider roam, which takes globalPan too.\n\t        if (!controller._enableGlobalPan) {\n\t            interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n\t        }\n\t\n\t        each(controller._handlers, function (handler, eventName) {\n\t            zr.on(eventName, handler);\n\t        });\n\t\n\t        controller._brushType = brushOption.brushType;\n\t        controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n\t    }\n\t\n\t    function doDisableBrush(controller) {\n\t        var zr = controller._zr;\n\t\n\t        interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n\t\n\t        each(controller._handlers, function (handler, eventName) {\n\t            zr.off(eventName, handler);\n\t        });\n\t\n\t        controller._brushType = controller._brushOption = null;\n\t    }\n\t\n\t    function createCover(controller, brushOption) {\n\t        var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n\t        updateZ(cover);\n\t        cover.__brushOption = brushOption;\n\t        controller.group.add(cover);\n\t        return cover;\n\t    }\n\t\n\t    function endCreating(controller, creatingCover) {\n\t        var coverRenderer = getCoverRenderer(creatingCover);\n\t        if (coverRenderer.endCreating) {\n\t            coverRenderer.endCreating(controller, creatingCover);\n\t            updateZ(creatingCover);\n\t        }\n\t        return creatingCover;\n\t    }\n\t\n\t    function updateCoverShape(controller, cover) {\n\t        var brushOption = cover.__brushOption;\n\t        getCoverRenderer(cover).updateCoverShape(\n\t            controller, cover, brushOption.range, brushOption\n\t        );\n\t    }\n\t\n\t    function updateZ(group) {\n\t        group.traverse(function (el) {\n\t            el.z = COVER_Z;\n\t            el.z2 = COVER_Z; // Consider in given container.\n\t        });\n\t    }\n\t\n\t    function updateCoverAfterCreation(controller, cover) {\n\t        getCoverRenderer(cover).updateCommon(controller, cover);\n\t        updateCoverShape(controller, cover);\n\t    }\n\t\n\t    function getCoverRenderer(cover) {\n\t        return coverRenderers[cover.__brushOption.brushType];\n\t    }\n\t\n\t    function getPanelByPoint(controller, x, y) {\n\t        var panels = controller._panels;\n\t        if (!panels) {\n\t            return true; // Global panel\n\t        }\n\t        var panel;\n\t        each(panels, function (pn) {\n\t            pn.contain(x, y) && (panel = pn);\n\t        });\n\t        return panel;\n\t    }\n\t\n\t    function getPanelByCover(controller, cover) {\n\t        var panels = controller._panels;\n\t        if (!panels) {\n\t            return true; // Global panel\n\t        }\n\t        var panelId = cover.__brushOption.panelId;\n\t        // User may give cover without coord sys info,\n\t        // which is then treated as global panel.\n\t        return panelId != null ? panels[panelId] : true;\n\t    }\n\t\n\t    function clearCovers(controller) {\n\t        var covers = controller._covers;\n\t        var originalLength = covers.length;\n\t        each(covers, function (cover) {\n\t            controller.group.remove(cover);\n\t        }, controller);\n\t        covers.length = 0;\n\t\n\t        return !!originalLength;\n\t    }\n\t\n\t    function trigger(controller, opt) {\n\t        var areas = map(controller._covers, function (cover) {\n\t            var brushOption = cover.__brushOption;\n\t            var range = zrUtil.clone(brushOption.range);\n\t\n\t            return {\n\t                brushType: brushOption.brushType,\n\t                panelId: brushOption.panelId,\n\t                range: range\n\t            };\n\t        });\n\t\n\t        controller.trigger('brush', areas, {\n\t            isEnd: !!opt.isEnd,\n\t            removeOnClick: !!opt.removeOnClick\n\t        });\n\t    }\n\t\n\t    function shouldShowCover(controller) {\n\t        var track = controller._track;\n\t\n\t        if (!track.length) {\n\t            return false;\n\t        }\n\t\n\t        var p2 = track[track.length - 1];\n\t        var p1 = track[0];\n\t        var dx = p2[0] - p1[0];\n\t        var dy = p2[1] - p1[1];\n\t        var dist = mathPow(dx * dx + dy * dy, 0.5);\n\t\n\t        return dist > UNSELECT_THRESHOLD;\n\t    }\n\t\n\t    function getTrackEnds(track) {\n\t        var tail = track.length - 1;\n\t        tail < 0 && (tail = 0);\n\t        return [track[0], track[tail]];\n\t    }\n\t\n\t    function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n\t        var cover = new graphic.Group();\n\t\n\t        cover.add(new graphic.Rect({\n\t            name: 'main',\n\t            style: makeStyle(brushOption),\n\t            silent: true,\n\t            draggable: true,\n\t            cursor: 'move',\n\t            drift: curry(doDrift, controller, cover, 'nswe'),\n\t            ondragend: curry(trigger, controller, {isEnd: true})\n\t        }));\n\t\n\t        each(\n\t            edgeNames,\n\t            function (name) {\n\t                cover.add(new graphic.Rect({\n\t                    name: name,\n\t                    style: {opacity: 0},\n\t                    draggable: true,\n\t                    silent: true,\n\t                    invisible: true,\n\t                    drift: curry(doDrift, controller, cover, name),\n\t                    ondragend: curry(trigger, controller, {isEnd: true})\n\t                }));\n\t            }\n\t        );\n\t\n\t        return cover;\n\t    }\n\t\n\t    function updateBaseRect(controller, cover, localRange, brushOption) {\n\t        var lineWidth = brushOption.brushStyle.lineWidth || 0;\n\t        var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n\t        var x = localRange[0][0];\n\t        var y = localRange[1][0];\n\t        var xa = x - lineWidth / 2;\n\t        var ya = y - lineWidth / 2;\n\t        var x2 = localRange[0][1];\n\t        var y2 = localRange[1][1];\n\t        var x2a = x2 - handleSize + lineWidth / 2;\n\t        var y2a = y2 - handleSize + lineWidth / 2;\n\t        var width = x2 - x;\n\t        var height = y2 - y;\n\t        var widtha = width + lineWidth;\n\t        var heighta = height + lineWidth;\n\t\n\t        updateRectShape(controller, cover, 'main', x, y, width, height);\n\t\n\t        if (brushOption.transformable) {\n\t            updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n\t            updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n\t            updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n\t            updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n\t\n\t            updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n\t            updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n\t            updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n\t            updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n\t        }\n\t    }\n\t\n\t    function updateCommon(controller, cover) {\n\t        var brushOption = cover.__brushOption;\n\t        var transformable = brushOption.transformable;\n\t\n\t        var mainEl = cover.childAt(0);\n\t        mainEl.useStyle(makeStyle(brushOption));\n\t        mainEl.attr({\n\t            silent: !transformable,\n\t            cursor: transformable ? 'move' : 'default'\n\t        });\n\t\n\t        each(\n\t            ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'],\n\t            function (name) {\n\t                var el = cover.childOfName(name);\n\t                var globalDir = getGlobalDirection(controller, name);\n\t\n\t                el && el.attr({\n\t                    silent: !transformable,\n\t                    invisible: !transformable,\n\t                    cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n\t                });\n\t            }\n\t        );\n\t    }\n\t\n\t    function updateRectShape(controller, cover, name, x, y, w, h) {\n\t        var el = cover.childOfName(name);\n\t        el && el.setShape(pointsToRect(\n\t            clipByPanel(controller, cover, [[x, y], [x + w, y + h]])\n\t        ));\n\t    }\n\t\n\t    function makeStyle(brushOption) {\n\t        return zrUtil.defaults({strokeNoScale: true}, brushOption.brushStyle);\n\t    }\n\t\n\t    function formatRectRange(x, y, x2, y2) {\n\t        var min = [mathMin(x, x2), mathMin(y, y2)];\n\t        var max = [mathMax(x, x2), mathMax(y, y2)];\n\t\n\t        return [\n\t            [min[0], max[0]], // x range\n\t            [min[1], max[1]] // y range\n\t        ];\n\t    }\n\t\n\t    function getTransform(controller) {\n\t        return graphic.getTransform(controller.group);\n\t    }\n\t\n\t    function getGlobalDirection(controller, localDirection) {\n\t        if (localDirection.length > 1) {\n\t            localDirection = localDirection.split('');\n\t            var globalDir = [\n\t                getGlobalDirection(controller, localDirection[0]),\n\t                getGlobalDirection(controller, localDirection[1])\n\t            ];\n\t            (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n\t            return globalDir.join('');\n\t        }\n\t        else {\n\t            var map = {w: 'left', e: 'right', n: 'top', s: 'bottom'};\n\t            var inverseMap = {left: 'w', right: 'e', top: 'n', bottom: 's'};\n\t            var globalDir = graphic.transformDirection(\n\t                map[localDirection], getTransform(controller)\n\t            );\n\t            return inverseMap[globalDir];\n\t        }\n\t    }\n\t\n\t    function driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n\t        var brushOption = cover.__brushOption;\n\t        var rectRange = toRectRange(brushOption.range);\n\t        var localDelta = toLocalDelta(controller, dx, dy);\n\t\n\t        each(name.split(''), function (namePart) {\n\t            var ind = DIRECTION_MAP[namePart];\n\t            rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n\t        });\n\t\n\t        brushOption.range = fromRectRange(formatRectRange(\n\t            rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]\n\t        ));\n\t\n\t        updateCoverAfterCreation(controller, cover);\n\t        trigger(controller, {isEnd: false});\n\t    }\n\t\n\t    function driftPolygon(controller, cover, dx, dy, e) {\n\t        var range = cover.__brushOption.range;\n\t        var localDelta = toLocalDelta(controller, dx, dy);\n\t\n\t        each(range, function (point) {\n\t            point[0] += localDelta[0];\n\t            point[1] += localDelta[1];\n\t        });\n\t\n\t        updateCoverAfterCreation(controller, cover);\n\t        trigger(controller, {isEnd: false});\n\t    }\n\t\n\t    function toLocalDelta(controller, dx, dy) {\n\t        var thisGroup = controller.group;\n\t        var localD = thisGroup.transformCoordToLocal(dx, dy);\n\t        var localZero = thisGroup.transformCoordToLocal(0, 0);\n\t\n\t        return [localD[0] - localZero[0], localD[1] - localZero[1]];\n\t    }\n\t\n\t    function clipByPanel(controller, cover, data) {\n\t        var panel = getPanelByCover(controller, cover);\n\t        if (panel === true) { // Global panel\n\t            return zrUtil.clone(data);\n\t        }\n\t\n\t        var panelRect = panel.getBoundingRect();\n\t\n\t        return zrUtil.map(data, function (point) {\n\t            var x = point[0];\n\t            x = mathMax(x, panelRect.x);\n\t            x = mathMin(x, panelRect.x + panelRect.width);\n\t            var y = point[1];\n\t            y = mathMax(y, panelRect.y);\n\t            y = mathMin(y, panelRect.y + panelRect.height);\n\t            return [x, y];\n\t        });\n\t    }\n\t\n\t    function pointsToRect(points) {\n\t        var xmin = mathMin(points[0][0], points[1][0]);\n\t        var ymin = mathMin(points[0][1], points[1][1]);\n\t        var xmax = mathMax(points[0][0], points[1][0]);\n\t        var ymax = mathMax(points[0][1], points[1][1]);\n\t\n\t        return {\n\t            x: xmin,\n\t            y: ymin,\n\t            width: xmax - xmin,\n\t            height: ymax - ymin\n\t        };\n\t    }\n\t\n\t    function resetCursor(controller, e) {\n\t        var x = e.offsetX;\n\t        var y = e.offsetY;\n\t        var zr = controller._zr;\n\t\n\t        if (controller._brushType) { // If active\n\t            var panels = controller._panels;\n\t            var covers = controller._covers;\n\t            var inCover;\n\t\n\t            for (var i = 0; i < covers.length; i++) {\n\t                if (coverRenderers[covers[i].__brushOption.brushType].contain(covers[i], x, y)) {\n\t                    inCover = true;\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (!inCover) {\n\t                if (panels) { // Brush on panels\n\t                    each(panels, function (panel) {\n\t                        panel.contain(x, y) && zr.setCursorStyle('crosshair');\n\t                    });\n\t                }\n\t                else { // Global brush\n\t                    zr.setCursorStyle('crosshair');\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function preventDefault(e) {\n\t        var rawE = e.event;\n\t        rawE.preventDefault && rawE.preventDefault();\n\t    }\n\t\n\t    function mainShapeContain(cover, x, y) {\n\t        return cover.childOfName('main').contain(x, y);\n\t    }\n\t\n\t    function updateCoverByMouse(controller, e, isEnd) {\n\t        var x = e.offsetX;\n\t        var y = e.offsetY;\n\t        var creatingCover = controller._creatingCover;\n\t        var panel = controller._creatingPanel;\n\t        var thisBrushOption = controller._brushOption;\n\t        var eventParams;\n\t\n\t        controller._track.push(controller.group.transformCoordToLocal(x, y));\n\t\n\t        if (shouldShowCover(controller) || creatingCover) {\n\t\n\t            if (panel && !creatingCover) {\n\t                thisBrushOption.brushMode === 'single' && clearCovers(controller);\n\t                var brushOption = zrUtil.clone(thisBrushOption);\n\t                brushOption.panelId = panel === true ? null : panel.__brushPanelId;\n\t                creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\t                controller._covers.push(creatingCover);\n\t            }\n\t\n\t            if (creatingCover) {\n\t                var coverRenderer = coverRenderers[controller._brushType];\n\t                var coverBrushOption = creatingCover.__brushOption;\n\t\n\t                coverBrushOption.range = coverRenderer.getCreatingRange(\n\t                    clipByPanel(controller, creatingCover, controller._track)\n\t                );\n\t\n\t                if (isEnd) {\n\t                    endCreating(controller, creatingCover);\n\t                    coverRenderer.updateCommon(controller, creatingCover);\n\t                }\n\t\n\t                updateCoverShape(controller, creatingCover);\n\t\n\t                eventParams = {isEnd: isEnd};\n\t            }\n\t        }\n\t        else if (\n\t            isEnd\n\t            && thisBrushOption.brushMode === 'single'\n\t            && thisBrushOption.removeOnClick\n\t        ) {\n\t            // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n\t            // But a single click do not clear covers, because user may have casual\n\t            // clicks (for example, click on other component and do not expect covers\n\t            // disappear).\n\t            // Only some cover removed, trigger action, but not every click trigger action.\n\t            if (getPanelByPoint(controller, x, y) && clearCovers(controller)) {\n\t                eventParams = {isEnd: isEnd, removeOnClick: true};\n\t            }\n\t        }\n\t\n\t        return eventParams;\n\t    }\n\t\n\t    var mouseHandlers = {\n\t\n\t        mousedown: function (e) {\n\t            if (this._dragging) {\n\t                // In case some browser do not support globalOut,\n\t                // and release mose out side the browser.\n\t                handleDragEnd.call(this, e);\n\t            }\n\t            else if (!e.target || !e.target.draggable) {\n\t\n\t                preventDefault(e);\n\t\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t\n\t                this._creatingCover = null;\n\t                var panel = this._creatingPanel = getPanelByPoint(this, x, y);\n\t\n\t                if (panel) {\n\t                    this._dragging = true;\n\t                    this._track = [this.group.transformCoordToLocal(x, y)];\n\t                }\n\t            }\n\t        },\n\t\n\t        mousemove: function (e) {\n\t            // set Cursor\n\t            resetCursor(this, e);\n\t\n\t            if (this._dragging) {\n\t\n\t                preventDefault(e);\n\t\n\t                var eventParams = updateCoverByMouse(this, e, false);\n\t\n\t                eventParams && trigger(this, eventParams);\n\t            }\n\t        },\n\t\n\t        mouseup: handleDragEnd //,\n\t\n\t        // FIXME\n\t        // in tooltip, globalout should not be triggered.\n\t        // globalout: handleDragEnd\n\t    };\n\t\n\t    function handleDragEnd(e) {\n\t        if (this._dragging) {\n\t\n\t            preventDefault(e);\n\t\n\t            var eventParams = updateCoverByMouse(this, e, true);\n\t\n\t            this._dragging = false;\n\t            this._track = [];\n\t            this._creatingCover = null;\n\t\n\t            // trigger event shoule be at final, after procedure will be nested.\n\t            eventParams && trigger(this, eventParams);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * key: brushType\n\t     * @type {Object}\n\t     */\n\t    var coverRenderers = {\n\t\n\t        lineX: getLineRenderer(0),\n\t\n\t        lineY: getLineRenderer(1),\n\t\n\t        rect: {\n\t            createCover: function (controller, brushOption) {\n\t                return createBaseRectCover(\n\t                    curry(\n\t                        driftRect,\n\t                        function (range) {\n\t                            return range;\n\t                        },\n\t                        function (range) {\n\t                            return range;\n\t                        }\n\t                    ),\n\t                    controller,\n\t                    brushOption,\n\t                    ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']\n\t                );\n\t            },\n\t            getCreatingRange: function (localTrack) {\n\t                var ends = getTrackEnds(localTrack);\n\t                return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n\t            },\n\t            updateCoverShape: function (controller, cover, localRange, brushOption) {\n\t                updateBaseRect(controller, cover, localRange, brushOption);\n\t            },\n\t            updateCommon: updateCommon,\n\t            contain: mainShapeContain\n\t        },\n\t\n\t        polygon: {\n\t            createCover: function (controller, brushOption) {\n\t                var cover = new graphic.Group();\n\t\n\t                // Do not use graphic.Polygon because graphic.Polyline do not close the\n\t                // border of the shape when drawing, which is a better experience for user.\n\t                cover.add(new graphic.Polyline({\n\t                    name: 'main',\n\t                    style: makeStyle(brushOption),\n\t                    silent: true\n\t                }));\n\t\n\t                return cover;\n\t            },\n\t            getCreatingRange: function (localTrack) {\n\t                return localTrack;\n\t            },\n\t            endCreating: function (controller, cover) {\n\t                cover.remove(cover.childAt(0));\n\t                // Use graphic.Polygon close the shape.\n\t                cover.add(new graphic.Polygon({\n\t                    name: 'main',\n\t                    draggable: true,\n\t                    drift: curry(driftPolygon, controller, cover),\n\t                    ondragend: curry(trigger, controller, {isEnd: true})\n\t                }));\n\t            },\n\t            updateCoverShape: function (controller, cover, localRange, brushOption) {\n\t                cover.childAt(0).setShape({\n\t                    points: clipByPanel(controller, cover, localRange)\n\t                });\n\t            },\n\t            updateCommon: updateCommon,\n\t            contain: mainShapeContain\n\t        }\n\t    };\n\t\n\t    function getLineRenderer(xyIndex) {\n\t        return {\n\t            createCover: function (controller, brushOption) {\n\t                return createBaseRectCover(\n\t                    curry(\n\t                        driftRect,\n\t                        function (range) {\n\t                            var rectRange = [range, [0, 100]];\n\t                            xyIndex && rectRange.reverse();\n\t                            return rectRange;\n\t                        },\n\t                        function (rectRange) {\n\t                            return rectRange[xyIndex];\n\t                        }\n\t                    ),\n\t                    controller,\n\t                    brushOption,\n\t                    [['w', 'e'], ['n', 's']][xyIndex]\n\t                );\n\t            },\n\t            getCreatingRange: function (localTrack) {\n\t                var ends = getTrackEnds(localTrack);\n\t                var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n\t                var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n\t\n\t                return [min, max];\n\t            },\n\t            updateCoverShape: function (controller, cover, localRange, brushOption) {\n\t                var brushWidth = brushOption.brushStyle.width;\n\t                var otherExtent;\n\t                // If brushWidth not specified, fit the panel.\n\t                if (brushWidth == null) {\n\t                    var panel = getPanelByCover(controller, cover);\n\t                    var base = 0;\n\t                    if (panel !== true) {\n\t                        var rect = panel.getBoundingRect();\n\t                        brushWidth = xyIndex ? rect.width : rect.height;\n\t                        base = xyIndex ? rect.x : rect.y;\n\t                    }\n\t                    // FIXME\n\t                    // do not support global panel yet.\n\t                    otherExtent = [base, base + (brushWidth || 0)];\n\t                }\n\t                else {\n\t                    otherExtent = [-brushWidth / 2, brushWidth / 2];\n\t                }\n\t                var rectRange = [localRange, otherExtent];\n\t                xyIndex && rectRange.reverse();\n\t\n\t                updateBaseRect(controller, cover, rectRange, brushOption);\n\t            },\n\t            updateCommon: updateCommon,\n\t            contain: mainShapeContain\n\t        };\n\t    }\n\t\n\t    module.exports = BrushController;\n\n\n/***/ },\n/* 114 */\n/*!*********************************************!*\\\n  !*** ./lib/component/helper/brushHelper.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t\n\t    var each = zrUtil.each;\n\t\n\t    var helper = {};\n\t\n\t    var COMPONENT_NAMES = ['geo', 'xAxis', 'yAxis'];\n\t    var PANEL_ID_SPLIT = '--';\n\t    var COORD_CONVERTS = ['dataToPoint', 'pointToData'];\n\t\n\t    helper.parseOutputRanges = function (areas, coordInfoList, ecModel, rangesCoordInfo) {\n\t        each(areas, function (area, index) {\n\t            var panelId = area.panelId;\n\t\n\t            if (panelId) {\n\t                panelId = panelId.split(PANEL_ID_SPLIT);\n\t\n\t                area[panelId[0] + 'Index'] = +panelId[1];\n\t\n\t                var coordInfo = findCoordInfo(area, coordInfoList);\n\t                area.coordRange = coordConvert[area.brushType](\n\t                    1, coordInfo, area.range\n\t                );\n\t                rangesCoordInfo && (rangesCoordInfo[index] = coordInfo);\n\t            }\n\t        });\n\t    };\n\t\n\t    helper.parseInputRanges = function (brushModel, ecModel) {\n\t        each(brushModel.areas, function (area) {\n\t            var coordInfo = findCoordInfo(area, brushModel.coordInfoList);\n\t\n\t            if (false) {\n\t                zrUtil.assert(\n\t                    !coordInfo || coordInfo === true || area.coordRange,\n\t                    'coordRange must be specified when coord index specified.'\n\t                );\n\t                zrUtil.assert(\n\t                    !coordInfo || coordInfo !== true || area.range,\n\t                    'range must be specified.'\n\t                );\n\t            }\n\t\n\t            area.range = area.range || [];\n\t\n\t            // convert coordRange to global range and set panelId.\n\t            if (coordInfo && coordInfo !== true) {\n\t                area.range = coordConvert[area.brushType](\n\t                    0, coordInfo, area.coordRange\n\t                );\n\t                area.panelId = coordInfo.panelId;\n\t            }\n\t        });\n\t    };\n\t\n\t    helper.makePanelOpts = function (coordInfoList) {\n\t        var panelOpts = [];\n\t\n\t        each(coordInfoList, function (coordInfo) {\n\t            var coordSys = coordInfo.coordSys;\n\t            var rect;\n\t\n\t            if (coordInfo.geoIndex >= 0) {\n\t                rect = coordSys.getBoundingRect().clone();\n\t                // geo roam and zoom transform\n\t                rect.applyTransform(graphic.getTransform(coordSys));\n\t            }\n\t            else { // xAxis or yAxis\n\t                // grid is not Transformable.\n\t                rect = coordSys.grid.getRect().clone();\n\t            }\n\t\n\t            panelOpts.push({panelId: coordInfo.panelId, rect: rect});\n\t        });\n\t\n\t        return panelOpts;\n\t    };\n\t\n\t    /**\n\t     * @param {Object} option {xAxisIndex, yAxisIndex, geoIndex}\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @return {Array.<Obejct>} coordInfoList\n\t     */\n\t    helper.makeCoordInfoList = function (option, ecModel) {\n\t        var coordInfoList = [];\n\t\n\t        each(COMPONENT_NAMES, function (componentName) {\n\t            var componentIndices = option[componentName + 'Index'];\n\t            if (componentIndices == null || componentIndices === 'none') {\n\t                return;\n\t            }\n\t            if (componentIndices !== 'all' && !zrUtil.isArray(componentIndices)) {\n\t                componentIndices = [componentIndices];\n\t            }\n\t\n\t            ecModel.eachComponent({mainType: componentName}, function (componentModel, index) {\n\t                if (componentIndices !== 'all' && zrUtil.indexOf(componentIndices, index) < 0) {\n\t                    return;\n\t                }\n\t\n\t                var grid;\n\t                var coordSys;\n\t\n\t                (componentName === 'xAxis' || componentName === 'yAxis')\n\t                    ? (grid = componentModel.axis.grid)\n\t                    : (coordSys = componentModel.coordinateSystem); // geo\n\t\n\t                var coordInfo;\n\t\n\t                // Check duplicate and find cartesian when tranval to yAxis.\n\t                for (var i = 0, len = coordInfoList.length; i < len; i++) {\n\t                    var cInfo = coordInfoList[i];\n\t                    if (false) {\n\t                        zrUtil.assert(\n\t                            cInfo[componentName + 'Index'] != index,\n\t                            'Coord should not be defined duplicately: ' + componentName + index\n\t                        );\n\t                    }\n\t                    // CoordSys is always required for `rect brush` or `polygon brush`.\n\t                    // If both xAxisIndex and yAxisIndex specified, fetch cartesian by them.\n\t                    if (componentName === 'yAxis' && !cInfo.yAxis && cInfo.xAxis) {\n\t                        var aCoordSys = grid.getCartesian(cInfo.xAxisIndex, index);\n\t                        if (aCoordSys) { // The yAxis and xAxis are in the same cartesian.\n\t                            coordSys = aCoordSys;\n\t                            coordInfo = cInfo;\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t\n\t                !coordInfo && coordInfoList.push(coordInfo = {});\n\t\n\t                coordInfo[componentName] = componentModel;\n\t                coordInfo[componentName + 'Index'] = index;\n\t                // If both xAxisIndex and yAxisIndex specified, panelId only use yAxisIndex,\n\t                // which is enough to index panel.\n\t                coordInfo.panelId = componentName + PANEL_ID_SPLIT + index;\n\t                coordInfo.coordSys = coordSys\n\t                    // If only xAxisIndex or only yAxisIndex specified, find its first cartesian.\n\t                    || grid.getCartesian(coordInfo.xAxisIndex, coordInfo.yAxisIndex);\n\t\n\t                coordInfo.coordSys\n\t                    ? (coordInfoList[componentName + 'Has'] = true)\n\t                    : coordInfoList.pop(); // If a coordInfo exists originally, existance of coordSys is ensured.\n\t            });\n\t        });\n\t\n\t        return coordInfoList;\n\t    };\n\t\n\t    helper.controlSeries = function (area, brushModel, seriesModel) {\n\t        // Check whether area is bound in coord, and series do not belong to that coord.\n\t        // If do not do this check, some brush (like lineX) will controll all axes.\n\t        var coordInfo = findCoordInfo(area, brushModel.coordInfoList);\n\t        return coordInfo === true || (coordInfo && coordInfo.coordSys === seriesModel.coordinateSystem);\n\t    };\n\t\n\t    function formatMinMax(minMax) {\n\t        minMax[0] > minMax[1] && minMax.reverse();\n\t        return minMax;\n\t    }\n\t\n\t    /**\n\t     * If return Object, a coord found.\n\t     * If reutrn true, global found.\n\t     * Otherwise nothing found.\n\t     *\n\t     * @param {Object} area {<componentName>Index}\n\t     * @param {Array} coordInfoList\n\t     * @return {Obejct|boolean}\n\t     */\n\t    function findCoordInfo(area, coordInfoList) {\n\t        var isGlobal = true;\n\t        for (var j = 0; j < COMPONENT_NAMES.length; j++) {\n\t            var indexAttr = COMPONENT_NAMES[j] + 'Index';\n\t            if (area[indexAttr] >= 0) {\n\t                isGlobal = false;\n\t                for (var i = 0; i < coordInfoList.length; i++) {\n\t                    if (coordInfoList[i][indexAttr] === area[indexAttr]) {\n\t                        return coordInfoList[i];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return isGlobal;\n\t    }\n\t\n\t    function axisConvert(axisName, to, coordInfo, coordRange) {\n\t        var axis = coordInfo.coordSys.getAxis(axisName);\n\t\n\t        if (false) {\n\t            zrUtil.assert(axis, 'line brush is only available in cartesian (grid).');\n\t        }\n\t\n\t        return formatMinMax(zrUtil.map([0, 1], function (i) {\n\t            return to\n\t                ? axis.coordToData(axis.toLocalCoord(coordRange[i]))\n\t                : axis.toGlobalCoord(axis.dataToCoord(coordRange[i]));\n\t        }));\n\t    }\n\t\n\t    var coordConvert = {\n\t\n\t        lineX: zrUtil.curry(axisConvert, 'x'),\n\t\n\t        lineY: zrUtil.curry(axisConvert, 'y'),\n\t\n\t        rect: function (to, coordInfo, coordRange) {\n\t            var coordSys = coordInfo.coordSys;\n\t            var xminymin = coordSys[COORD_CONVERTS[to]]([coordRange[0][0], coordRange[1][0]]);\n\t            var xmaxymax = coordSys[COORD_CONVERTS[to]]([coordRange[0][1], coordRange[1][1]]);\n\t            return [\n\t                formatMinMax([xminymin[0], xmaxymax[0]]),\n\t                formatMinMax([xminymin[1], xmaxymax[1]])\n\t            ];\n\t        },\n\t\n\t        polygon: function (to, coordInfo, coordRange) {\n\t            var coordSys = coordInfo.coordSys;\n\t            return zrUtil.map(coordRange, coordSys[COORD_CONVERTS[to]], coordSys);\n\t        }\n\t    };\n\t\n\t    module.exports = helper;\n\t\n\n\n/***/ },\n/* 115 */\n/*!**************************************************!*\\\n  !*** ./lib/component/helper/interactionMutex.js ***!\n  \\**************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var ATTR = '\\0_ec_interaction_mutex';\n\t\n\t    var interactionMutex = {\n\t\n\t        take: function (zr, resourceKey, userKey) {\n\t            var store = getStore(zr);\n\t            store[resourceKey] = userKey;\n\t        },\n\t\n\t        release: function (zr, resourceKey, userKey) {\n\t            var store = getStore(zr);\n\t            var uKey = store[resourceKey];\n\t\n\t            if (uKey === userKey) {\n\t                store[resourceKey] = null;\n\t            }\n\t        },\n\t\n\t        isTaken: function (zr, resourceKey) {\n\t            return !!getStore(zr)[resourceKey];\n\t        }\n\t    };\n\t\n\t    function getStore(zr) {\n\t        return zr[ATTR] || (zr[ATTR] = {});\n\t    }\n\t\n\t    /**\n\t     * payload: {\n\t     *     type: 'takeGlobalCursor',\n\t     *     key: 'dataZoomSelect', or 'brush', or ...,\n\t     *         If no userKey, release global cursor.\n\t     * }\n\t     */\n\t    __webpack_require__(/*! ../../echarts */ 2).registerAction(\n\t        {type: 'takeGlobalCursor', event: 'globalCursorTaken', update: 'update'},\n\t        function () {}\n\t    );\n\t\n\t    module.exports = interactionMutex;\n\n\n/***/ },\n/* 116 */\n/*!***********************************************!*\\\n  !*** ./lib/component/helper/listComponent.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    // List layout\n\t    var layout = __webpack_require__(/*! ../../util/layout */ 13);\n\t    var formatUtil = __webpack_require__(/*! ../../util/format */ 9);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t\n\t    function positionGroup(group, model, api) {\n\t        layout.positionGroup(\n\t            group, model.getBoxLayoutParams(),\n\t            {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            },\n\t            model.get('padding')\n\t        );\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Layout list like component.\n\t         * It will box layout each items in group of component and then position the whole group in the viewport\n\t         * @param {module:zrender/group/Group} group\n\t         * @param {module:echarts/model/Component} componentModel\n\t         * @param {module:echarts/ExtensionAPI}\n\t         */\n\t        layout: function (group, componentModel, api) {\n\t            var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            }, componentModel.get('padding'));\n\t            layout.box(\n\t                componentModel.get('orient'),\n\t                group,\n\t                componentModel.get('itemGap'),\n\t                rect.width,\n\t                rect.height\n\t            );\n\t\n\t            positionGroup(group, componentModel, api);\n\t        },\n\t\n\t        addBackground: function (group, componentModel) {\n\t            var padding = formatUtil.normalizeCssArray(\n\t                componentModel.get('padding')\n\t            );\n\t            var boundingRect = group.getBoundingRect();\n\t            var style = componentModel.getItemStyle(['color', 'opacity']);\n\t            style.fill = componentModel.get('backgroundColor');\n\t            var rect = new graphic.Rect({\n\t                shape: {\n\t                    x: boundingRect.x - padding[3],\n\t                    y: boundingRect.y - padding[0],\n\t                    width: boundingRect.width + padding[1] + padding[3],\n\t                    height: boundingRect.height + padding[0] + padding[2]\n\t                },\n\t                style: style,\n\t                silent: true,\n\t                z2: -1\n\t            });\n\t            graphic.subPixelOptimizeRect(rect);\n\t\n\t            group.add(rect);\n\t        }\n\t    };\n\n\n/***/ },\n/* 117 */\n/*!***************************************!*\\\n  !*** ./lib/coord/cartesian/Axis2D.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var Axis = __webpack_require__(/*! ../Axis */ 42);\n\t    var axisLabelInterval = __webpack_require__(/*! ./axisLabelInterval */ 121);\n\t\n\t    /**\n\t     * Extend axis 2d\n\t     * @constructor module:echarts/coord/cartesian/Axis2D\n\t     * @extends {module:echarts/coord/cartesian/Axis}\n\t     * @param {string} dim\n\t     * @param {*} scale\n\t     * @param {Array.<number>} coordExtent\n\t     * @param {string} axisType\n\t     * @param {string} position\n\t     */\n\t    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n\t        Axis.call(this, dim, scale, coordExtent);\n\t        /**\n\t         * Axis type\n\t         *  - 'category'\n\t         *  - 'value'\n\t         *  - 'time'\n\t         *  - 'log'\n\t         * @type {string}\n\t         */\n\t        this.type = axisType || 'value';\n\t\n\t        /**\n\t         * Axis position\n\t         *  - 'top'\n\t         *  - 'bottom'\n\t         *  - 'left'\n\t         *  - 'right'\n\t         */\n\t        this.position = position || 'bottom';\n\t    };\n\t\n\t    Axis2D.prototype = {\n\t\n\t        constructor: Axis2D,\n\t\n\t        /**\n\t         * Index of axis, can be used as key\n\t         */\n\t        index: 0,\n\t        /**\n\t         * If axis is on the zero position of the other axis\n\t         * @type {boolean}\n\t         */\n\t        onZero: false,\n\t\n\t        /**\n\t         * Axis model\n\t         * @param {module:echarts/coord/cartesian/AxisModel}\n\t         */\n\t        model: null,\n\t\n\t        isHorizontal: function () {\n\t            var position = this.position;\n\t            return position === 'top' || position === 'bottom';\n\t        },\n\t\n\t        getGlobalExtent: function () {\n\t            var ret = this.getExtent();\n\t            ret[0] = this.toGlobalCoord(ret[0]);\n\t            ret[1] = this.toGlobalCoord(ret[1]);\n\t            return ret;\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        getLabelInterval: function () {\n\t            var labelInterval = this._labelInterval;\n\t            if (!labelInterval) {\n\t                labelInterval = this._labelInterval = axisLabelInterval(this);\n\t            }\n\t            return labelInterval;\n\t        },\n\t\n\t        /**\n\t         * If label is ignored.\n\t         * Automatically used when axis is category and label can not be all shown\n\t         * @param  {number}  idx\n\t         * @return {boolean}\n\t         */\n\t        isLabelIgnored: function (idx) {\n\t            if (this.type === 'category') {\n\t                var labelInterval = this.getLabelInterval();\n\t                return ((typeof labelInterval === 'function')\n\t                    && !labelInterval(idx, this.scale.getLabel(idx)))\n\t                    || idx % (labelInterval + 1);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Transform global coord to local coord,\n\t         * i.e. var localCoord = axis.toLocalCoord(80);\n\t         * designate by module:echarts/coord/cartesian/Grid.\n\t         * @type {Function}\n\t         */\n\t        toLocalCoord: null,\n\t\n\t        /**\n\t         * Transform global coord to local coord,\n\t         * i.e. var globalCoord = axis.toLocalCoord(40);\n\t         * designate by module:echarts/coord/cartesian/Grid.\n\t         * @type {Function}\n\t         */\n\t        toGlobalCoord: null\n\t\n\t    };\n\t    zrUtil.inherits(Axis2D, Axis);\n\t\n\t    module.exports = Axis2D;\n\n\n/***/ },\n/* 118 */\n/*!******************************************!*\\\n  !*** ./lib/coord/cartesian/Cartesian.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Cartesian coordinate system\n\t * @module  echarts/coord/Cartesian\n\t *\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    function dimAxisMapper(dim) {\n\t        return this._axes[dim];\n\t    }\n\t\n\t    /**\n\t     * @alias module:echarts/coord/Cartesian\n\t     * @constructor\n\t     */\n\t    var Cartesian = function (name) {\n\t        this._axes = {};\n\t\n\t        this._dimList = [];\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.name = name || '';\n\t    };\n\t\n\t    Cartesian.prototype = {\n\t\n\t        constructor: Cartesian,\n\t\n\t        type: 'cartesian',\n\t\n\t        /**\n\t         * Get axis\n\t         * @param  {number|string} dim\n\t         * @return {module:echarts/coord/Cartesian~Axis}\n\t         */\n\t        getAxis: function (dim) {\n\t            return this._axes[dim];\n\t        },\n\t\n\t        /**\n\t         * Get axes list\n\t         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n\t         */\n\t        getAxes: function () {\n\t            return zrUtil.map(this._dimList, dimAxisMapper, this);\n\t        },\n\t\n\t        /**\n\t         * Get axes list by given scale type\n\t         */\n\t        getAxesByScale: function (scaleType) {\n\t            scaleType = scaleType.toLowerCase();\n\t            return zrUtil.filter(\n\t                this.getAxes(),\n\t                function (axis) {\n\t                    return axis.scale.type === scaleType;\n\t                }\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Add axis\n\t         * @param {module:echarts/coord/Cartesian.Axis}\n\t         */\n\t        addAxis: function (axis) {\n\t            var dim = axis.dim;\n\t\n\t            this._axes[dim] = axis;\n\t\n\t            this._dimList.push(dim);\n\t        },\n\t\n\t        /**\n\t         * Convert data to coord in nd space\n\t         * @param {Array.<number>|Object.<string, number>} val\n\t         * @return {Array.<number>|Object.<string, number>}\n\t         */\n\t        dataToCoord: function (val) {\n\t            return this._dataCoordConvert(val, 'dataToCoord');\n\t        },\n\t\n\t        /**\n\t         * Convert coord in nd space to data\n\t         * @param  {Array.<number>|Object.<string, number>} val\n\t         * @return {Array.<number>|Object.<string, number>}\n\t         */\n\t        coordToData: function (val) {\n\t            return this._dataCoordConvert(val, 'coordToData');\n\t        },\n\t\n\t        _dataCoordConvert: function (input, method) {\n\t            var dimList = this._dimList;\n\t\n\t            var output = input instanceof Array ? [] : {};\n\t\n\t            for (var i = 0; i < dimList.length; i++) {\n\t                var dim = dimList[i];\n\t                var axis = this._axes[dim];\n\t\n\t                output[dim] = axis[method](input[dim]);\n\t            }\n\t\n\t            return output;\n\t        }\n\t    };\n\t\n\t    module.exports = Cartesian;\n\n\n/***/ },\n/* 119 */\n/*!********************************************!*\\\n  !*** ./lib/coord/cartesian/Cartesian2D.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var Cartesian = __webpack_require__(/*! ./Cartesian */ 118);\n\t\n\t    function Cartesian2D(name) {\n\t\n\t        Cartesian.call(this, name);\n\t    }\n\t\n\t    Cartesian2D.prototype = {\n\t\n\t        constructor: Cartesian2D,\n\t\n\t        type: 'cartesian2d',\n\t\n\t        /**\n\t         * @type {Array.<string>}\n\t         * @readOnly\n\t         */\n\t        dimensions: ['x', 'y'],\n\t\n\t        /**\n\t         * Base axis will be used on stacking.\n\t         *\n\t         * @return {module:echarts/coord/cartesian/Axis2D}\n\t         */\n\t        getBaseAxis: function () {\n\t            return this.getAxesByScale('ordinal')[0]\n\t                || this.getAxesByScale('time')[0]\n\t                || this.getAxis('x');\n\t        },\n\t\n\t        /**\n\t         * If contain point\n\t         * @param {Array.<number>} point\n\t         * @return {boolean}\n\t         */\n\t        containPoint: function (point) {\n\t            var axisX = this.getAxis('x');\n\t            var axisY = this.getAxis('y');\n\t            return axisX.contain(axisX.toLocalCoord(point[0]))\n\t                && axisY.contain(axisY.toLocalCoord(point[1]));\n\t        },\n\t\n\t        /**\n\t         * If contain data\n\t         * @param {Array.<number>} data\n\t         * @return {boolean}\n\t         */\n\t        containData: function (data) {\n\t            return this.getAxis('x').containData(data[0])\n\t                && this.getAxis('y').containData(data[1]);\n\t        },\n\t\n\t        /**\n\t         * Convert series data to an array of points\n\t         * @param {module:echarts/data/List} data\n\t         * @param {boolean} stack\n\t         * @return {Array}\n\t         *  Return array of points. For example:\n\t         *  `[[10, 10], [20, 20], [30, 30]]`\n\t         */\n\t        dataToPoints: function (data, stack) {\n\t            return data.mapArray(['x', 'y'], function (x, y) {\n\t                return this.dataToPoint([x, y]);\n\t            }, stack, this);\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} data\n\t         * @param {boolean} [clamp=false]\n\t         * @return {Array.<number>}\n\t         */\n\t        dataToPoint: function (data, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n\t                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n\t            ];\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} point\n\t         * @param {boolean} [clamp=false]\n\t         * @return {Array.<number>}\n\t         */\n\t        pointToData: function (point, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n\t                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n\t            ];\n\t        },\n\t\n\t        /**\n\t         * Get other axis\n\t         * @param {module:echarts/coord/cartesian/Axis2D} axis\n\t         */\n\t        getOtherAxis: function (axis) {\n\t            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Cartesian2D, Cartesian);\n\t\n\t    module.exports = Cartesian2D;\n\n\n/***/ },\n/* 120 */\n/*!******************************************!*\\\n  !*** ./lib/coord/cartesian/GridModel.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Grid \n\t//  Cartesian2D \n\t\n\t\n\t    __webpack_require__(/*! ./AxisModel */ 53);\n\t    var ComponentModel = __webpack_require__(/*! ../../model/Component */ 12);\n\t\n\t    module.exports = ComponentModel.extend({\n\t\n\t        type: 'grid',\n\t\n\t        dependencies: ['xAxis', 'yAxis'],\n\t\n\t        layoutMode: 'box',\n\t\n\t        /**\n\t         * @type {module:echarts/coord/cartesian/Grid}\n\t         */\n\t        coordinateSystem: null,\n\t\n\t        defaultOption: {\n\t            show: false,\n\t            zlevel: 0,\n\t            z: 0,\n\t            left: '10%',\n\t            top: 60,\n\t            right: '10%',\n\t            bottom: 60,\n\t            // If grid size contain label\n\t            containLabel: false,\n\t            // width: {totalWidth} - left - right,\n\t            // height: {totalHeight} - top - bottom,\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            borderWidth: 1,\n\t            borderColor: '#ccc'\n\t        }\n\t    });\n\n\n/***/ },\n/* 121 */\n/*!**************************************************!*\\\n  !*** ./lib/coord/cartesian/axisLabelInterval.js ***!\n  \\**************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Helper function for axisLabelInterval calculation\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var axisHelper = __webpack_require__(/*! ../axisHelper */ 22);\n\t\n\t    module.exports = function (axis) {\n\t        var axisModel = axis.model;\n\t        var labelModel = axisModel.getModel('axisLabel');\n\t        var labelInterval = labelModel.get('interval');\n\t        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n\t            return labelInterval === 'auto' ? 0 : labelInterval;\n\t        }\n\t\n\t        return axisHelper.getAxisLabelInterval(\n\t            zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis),\n\t            axisModel.getFormattedLabels(),\n\t            labelModel.getModel('textStyle').getFont(),\n\t            axis.isHorizontal()\n\t        );\n\t    };\n\n\n/***/ },\n/* 122 */\n/*!*******************************!*\\\n  !*** ./lib/layout/barGrid.js ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var numberUtil = __webpack_require__(/*! ../util/number */ 4);\n\t    var parsePercent = numberUtil.parsePercent;\n\t\n\t    function getSeriesStackId(seriesModel) {\n\t        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n\t    }\n\t\n\t    function getAxisKey(axis) {\n\t        return axis.dim + axis.index;\n\t    }\n\t\n\t    function calBarWidthAndOffset(barSeries, api) {\n\t        // Columns info on each category axis. Key is cartesian name\n\t        var columnsMap = {};\n\t\n\t        zrUtil.each(barSeries, function (seriesModel, idx) {\n\t            var data = seriesModel.getData();\n\t            var cartesian = seriesModel.coordinateSystem;\n\t\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var axisExtent = baseAxis.getExtent();\n\t            var bandWidth = baseAxis.type === 'category'\n\t                ? baseAxis.getBandWidth()\n\t                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\t\n\t            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n\t                bandWidth: bandWidth,\n\t                remainedWidth: bandWidth,\n\t                autoWidthCount: 0,\n\t                categoryGap: '20%',\n\t                gap: '30%',\n\t                stacks: {}\n\t            };\n\t            var stacks = columnsOnAxis.stacks;\n\t            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n\t\n\t            var stackId = getSeriesStackId(seriesModel);\n\t\n\t            if (!stacks[stackId]) {\n\t                columnsOnAxis.autoWidthCount++;\n\t            }\n\t            stacks[stackId] = stacks[stackId] || {\n\t                width: 0,\n\t                maxWidth: 0\n\t            };\n\t\n\t            var barWidth = parsePercent(\n\t                seriesModel.get('barWidth'), bandWidth\n\t            );\n\t            var barMaxWidth = parsePercent(\n\t                seriesModel.get('barMaxWidth'), bandWidth\n\t            );\n\t            var barGap = seriesModel.get('barGap');\n\t            var barCategoryGap = seriesModel.get('barCategoryGap');\n\t            // TODO\n\t            if (barWidth && !stacks[stackId].width) {\n\t                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n\t                stacks[stackId].width = barWidth;\n\t                columnsOnAxis.remainedWidth -= barWidth;\n\t            }\n\t\n\t            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n\t            (barGap != null) && (columnsOnAxis.gap = barGap);\n\t            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n\t        });\n\t\n\t        var result = {};\n\t\n\t        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\t\n\t            result[coordSysName] = {};\n\t\n\t            var stacks = columnsOnAxis.stacks;\n\t            var bandWidth = columnsOnAxis.bandWidth;\n\t            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n\t            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\t\n\t            var remainedWidth = columnsOnAxis.remainedWidth;\n\t            var autoWidthCount = columnsOnAxis.autoWidthCount;\n\t            var autoWidth = (remainedWidth - categoryGap)\n\t                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n\t            autoWidth = Math.max(autoWidth, 0);\n\t\n\t            // Find if any auto calculated bar exceeded maxBarWidth\n\t            zrUtil.each(stacks, function (column, stack) {\n\t                var maxWidth = column.maxWidth;\n\t                if (!column.width && maxWidth && maxWidth < autoWidth) {\n\t                    maxWidth = Math.min(maxWidth, remainedWidth);\n\t                    remainedWidth -= maxWidth;\n\t                    column.width = maxWidth;\n\t                    autoWidthCount--;\n\t                }\n\t            });\n\t\n\t            // Recalculate width again\n\t            autoWidth = (remainedWidth - categoryGap)\n\t                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n\t            autoWidth = Math.max(autoWidth, 0);\n\t\n\t            var widthSum = 0;\n\t            var lastColumn;\n\t            zrUtil.each(stacks, function (column, idx) {\n\t                if (!column.width) {\n\t                    column.width = autoWidth;\n\t                }\n\t                lastColumn = column;\n\t                widthSum += column.width * (1 + barGapPercent);\n\t            });\n\t            if (lastColumn) {\n\t                widthSum -= lastColumn.width * barGapPercent;\n\t            }\n\t\n\t            var offset = -widthSum / 2;\n\t            zrUtil.each(stacks, function (column, stackId) {\n\t                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n\t                    offset: offset,\n\t                    width: column.width\n\t                };\n\t\n\t                offset += column.width * (1 + barGapPercent);\n\t            });\n\t        });\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {string} seriesType\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function barLayoutGrid(seriesType, ecModel, api) {\n\t\n\t        var barWidthAndOffset = calBarWidthAndOffset(\n\t            zrUtil.filter(\n\t                ecModel.getSeriesByType(seriesType),\n\t                function (seriesModel) {\n\t                    return !ecModel.isSeriesFiltered(seriesModel)\n\t                        && seriesModel.coordinateSystem\n\t                        && seriesModel.coordinateSystem.type === 'cartesian2d';\n\t                }\n\t            )\n\t        );\n\t\n\t        var lastStackCoords = {};\n\t        var lastStackCoordsOrigin = {};\n\t\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t\n\t            var data = seriesModel.getData();\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t\n\t            var stackId = getSeriesStackId(seriesModel);\n\t            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n\t            var columnOffset = columnLayoutInfo.offset;\n\t            var columnWidth = columnLayoutInfo.width;\n\t            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\t\n\t            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\t\n\t            var valueAxisStart = baseAxis.onZero\n\t                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n\t                : valueAxis.getGlobalExtent()[0];\n\t\n\t            var coords = cartesian.dataToPoints(data, true);\n\t            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n\t            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\t\n\t            data.setLayout({\n\t                offset: columnOffset,\n\t                size: columnWidth\n\t            });\n\t\n\t            data.each(valueAxis.dim, function (value, idx) {\n\t                // \n\t                if (isNaN(value)) {\n\t                    return;\n\t                }\n\t                if (!lastStackCoords[stackId][idx]) {\n\t                    lastStackCoords[stackId][idx] = {\n\t                        p: valueAxisStart, // Positive stack\n\t                        n: valueAxisStart  // Negative stack\n\t                    };\n\t                    lastStackCoordsOrigin[stackId][idx] = {\n\t                        p: valueAxisStart, // Positive stack\n\t                        n: valueAxisStart  // Negative stack\n\t                    };\n\t                }\n\t                var sign = value >= 0 ? 'p' : 'n';\n\t                var coord = coords[idx];\n\t                var lastCoord = lastStackCoords[stackId][idx][sign];\n\t                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n\t                var x;\n\t                var y;\n\t                var width;\n\t                var height;\n\t\n\t                if (valueAxis.isHorizontal()) {\n\t                    x = lastCoord;\n\t                    y = coord[1] + columnOffset;\n\t                    width = coord[0] - lastCoordOrigin;\n\t                    height = columnWidth;\n\t\n\t                    lastStackCoordsOrigin[stackId][idx][sign] += width;\n\t                    if (Math.abs(width) < barMinHeight) {\n\t                        width = (width < 0 ? -1 : 1) * barMinHeight;\n\t                    }\n\t                    lastStackCoords[stackId][idx][sign] += width;\n\t                }\n\t                else {\n\t                    x = coord[0] + columnOffset;\n\t                    y = lastCoord;\n\t                    width = columnWidth;\n\t                    height = coord[1] - lastCoordOrigin;\n\t\n\t                    lastStackCoordsOrigin[stackId][idx][sign] += height;\n\t                    if (Math.abs(height) < barMinHeight) {\n\t                        // Include zero to has a positive bar\n\t                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n\t                    }\n\t                    lastStackCoords[stackId][idx][sign] += height;\n\t                }\n\t\n\t                data.setItemLayout(idx, {\n\t                    x: x,\n\t                    y: y,\n\t                    width: width,\n\t                    height: height\n\t                });\n\t            }, true);\n\t\n\t        }, this);\n\t    }\n\t\n\t    module.exports = barLayoutGrid;\n\n\n/***/ },\n/* 123 */\n/*!********************************!*\\\n  !*** ./lib/loading/default.js ***!\n  \\********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var graphic = __webpack_require__(/*! ../util/graphic */ 3);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var PI = Math.PI;\n\t    /**\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     * @param {Object} [opts]\n\t     * @param {string} [opts.text]\n\t     * @param {string} [opts.color]\n\t     * @param {string} [opts.textColor]\n\t     * @return {module:zrender/Element}\n\t     */\n\t    module.exports = function (api, opts) {\n\t        opts = opts || {};\n\t        zrUtil.defaults(opts, {\n\t            text: 'loading',\n\t            color: '#c23531',\n\t            textColor: '#000',\n\t            maskColor: 'rgba(255, 255, 255, 0.8)',\n\t            zlevel: 0\n\t        });\n\t        var mask = new graphic.Rect({\n\t            style: {\n\t                fill: opts.maskColor\n\t            },\n\t            zlevel: opts.zlevel,\n\t            z: 10000\n\t        });\n\t        var arc = new graphic.Arc({\n\t            shape: {\n\t                startAngle: -PI / 2,\n\t                endAngle: -PI / 2 + 0.1,\n\t                r: 10\n\t            },\n\t            style: {\n\t                stroke: opts.color,\n\t                lineCap: 'round',\n\t                lineWidth: 5\n\t            },\n\t            zlevel: opts.zlevel,\n\t            z: 10001\n\t        });\n\t        var labelRect = new graphic.Rect({\n\t            style: {\n\t                fill: 'none',\n\t                text: opts.text,\n\t                textPosition: 'right',\n\t                textDistance: 10,\n\t                textFill: opts.textColor\n\t            },\n\t            zlevel: opts.zlevel,\n\t            z: 10001\n\t        });\n\t\n\t        arc.animateShape(true)\n\t            .when(1000, {\n\t                endAngle: PI * 3 / 2\n\t            })\n\t            .start('circularInOut');\n\t        arc.animateShape(true)\n\t            .when(1000, {\n\t                startAngle: PI * 3 / 2\n\t            })\n\t            .delay(300)\n\t            .start('circularInOut');\n\t\n\t        var group = new graphic.Group();\n\t        group.add(arc);\n\t        group.add(labelRect);\n\t        group.add(mask);\n\t        // Inject resize\n\t        group.resize = function () {\n\t            var cx = api.getWidth() / 2;\n\t            var cy = api.getHeight() / 2;\n\t            arc.setShape({\n\t                cx: cx,\n\t                cy: cy\n\t            });\n\t            var r = arc.shape.r;\n\t            labelRect.setShape({\n\t                x: cx - r,\n\t                y: cy - r,\n\t                width: r * 2,\n\t                height: r * 2\n\t            });\n\t\n\t            mask.setShape({\n\t                x: 0,\n\t                y: 0,\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t        };\n\t        group.resize();\n\t        return group;\n\t    };\n\n\n/***/ },\n/* 124 */\n/*!*****************************!*\\\n  !*** ./lib/model/Global.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * ECharts global model\n\t *\n\t * @module {echarts/model/Global}\n\t */\n\t\n\t\n\t\n\t    /**\n\t     * Caution: If the mechanism should be changed some day, these cases\n\t     * should be considered:\n\t     *\n\t     * (1) In `merge option` mode, if using the same option to call `setOption`\n\t     * many times, the result should be the same (try our best to ensure that).\n\t     * (2) In `merge option` mode, if a component has no id/name specified, it\n\t     * will be merged by index, and the result sequence of the components is\n\t     * consistent to the original sequence.\n\t     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n\t     * `mergeOption` in module:echarts/model/OptionManager.\n\t     */\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var modelUtil = __webpack_require__(/*! ../util/model */ 7);\n\t    var Model = __webpack_require__(/*! ./Model */ 10);\n\t    var each = zrUtil.each;\n\t    var filter = zrUtil.filter;\n\t    var map = zrUtil.map;\n\t    var isArray = zrUtil.isArray;\n\t    var indexOf = zrUtil.indexOf;\n\t    var isObject = zrUtil.isObject;\n\t\n\t    var ComponentModel = __webpack_require__(/*! ./Component */ 12);\n\t\n\t    var globalDefault = __webpack_require__(/*! ./globalDefault */ 126);\n\t\n\t    var OPTION_INNER_KEY = '\\0_ec_inner';\n\t\n\t    /**\n\t     * @alias module:echarts/model/Global\n\t     *\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {Object} theme\n\t     */\n\t    var GlobalModel = Model.extend({\n\t\n\t        constructor: GlobalModel,\n\t\n\t        init: function (option, parentModel, theme, optionManager) {\n\t            theme = theme || {};\n\t\n\t            this.option = null; // Mark as not initialized.\n\t\n\t            /**\n\t             * @type {module:echarts/model/Model}\n\t             * @private\n\t             */\n\t            this._theme = new Model(theme);\n\t\n\t            /**\n\t             * @type {module:echarts/model/OptionManager}\n\t             */\n\t            this._optionManager = optionManager;\n\t        },\n\t\n\t        setOption: function (option, optionPreprocessorFuncs) {\n\t            zrUtil.assert(\n\t                !(OPTION_INNER_KEY in option),\n\t                'please use chart.getOption()'\n\t            );\n\t\n\t            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\t\n\t            this.resetOption();\n\t        },\n\t\n\t        /**\n\t         * @param {string} type null/undefined: reset all.\n\t         *                      'recreate': force recreate all.\n\t         *                      'timeline': only reset timeline option\n\t         *                      'media': only reset media query option\n\t         * @return {boolean} Whether option changed.\n\t         */\n\t        resetOption: function (type) {\n\t            var optionChanged = false;\n\t            var optionManager = this._optionManager;\n\t\n\t            if (!type || type === 'recreate') {\n\t                var baseOption = optionManager.mountOption(type === 'recreate');\n\t\n\t                if (!this.option || type === 'recreate') {\n\t                    initBase.call(this, baseOption);\n\t                }\n\t                else {\n\t                    this.restoreData();\n\t                    this.mergeOption(baseOption);\n\t                }\n\t                optionChanged = true;\n\t            }\n\t\n\t            if (type === 'timeline' || type === 'media') {\n\t                this.restoreData();\n\t            }\n\t\n\t            if (!type || type === 'recreate' || type === 'timeline') {\n\t                var timelineOption = optionManager.getTimelineOption(this);\n\t                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n\t            }\n\t\n\t            if (!type || type === 'recreate' || type === 'media') {\n\t                var mediaOptions = optionManager.getMediaOption(this, this._api);\n\t                if (mediaOptions.length) {\n\t                    each(mediaOptions, function (mediaOption) {\n\t                        this.mergeOption(mediaOption, optionChanged = true);\n\t                    }, this);\n\t                }\n\t            }\n\t\n\t            return optionChanged;\n\t        },\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        mergeOption: function (newOption) {\n\t            var option = this.option;\n\t            var componentsMap = this._componentsMap;\n\t            var newCptTypes = [];\n\t\n\t            //  component model  merge\n\t            each(newOption, function (componentOption, mainType) {\n\t                if (componentOption == null) {\n\t                    return;\n\t                }\n\t\n\t                if (!ComponentModel.hasClass(mainType)) {\n\t                    option[mainType] = option[mainType] == null\n\t                        ? zrUtil.clone(componentOption)\n\t                        : zrUtil.merge(option[mainType], componentOption, true);\n\t                }\n\t                else {\n\t                    newCptTypes.push(mainType);\n\t                }\n\t            });\n\t\n\t            // FIXME OPTION \n\t            ComponentModel.topologicalTravel(\n\t                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n\t            );\n\t\n\t            this._seriesIndices = this._seriesIndices || [];\n\t\n\t            function visitComponent(mainType, dependencies) {\n\t                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\t\n\t                var mapResult = modelUtil.mappingToExists(\n\t                    componentsMap[mainType], newCptOptionList\n\t                );\n\t\n\t                makeKeyInfo(mainType, mapResult);\n\t\n\t                var dependentModels = getComponentsByTypes(\n\t                    componentsMap, dependencies\n\t                );\n\t\n\t                option[mainType] = [];\n\t                componentsMap[mainType] = [];\n\t\n\t                each(mapResult, function (resultItem, index) {\n\t                    var componentModel = resultItem.exist;\n\t                    var newCptOption = resultItem.option;\n\t\n\t                    zrUtil.assert(\n\t                        isObject(newCptOption) || componentModel,\n\t                        'Empty component definition'\n\t                    );\n\t\n\t                    // Consider where is no new option and should be merged using {},\n\t                    // see removeEdgeAndAdd in topologicalTravel and\n\t                    // ComponentModel.getAllClassMainTypes.\n\t                    if (!newCptOption) {\n\t                        componentModel.mergeOption({}, this);\n\t                        componentModel.optionUpdated({}, false);\n\t                    }\n\t                    else {\n\t                        var ComponentModelClass = ComponentModel.getClass(\n\t                            mainType, resultItem.keyInfo.subType, true\n\t                        );\n\t\n\t                        if (componentModel && componentModel instanceof ComponentModelClass) {\n\t                            componentModel.name = resultItem.keyInfo.name;\n\t                            componentModel.mergeOption(newCptOption, this);\n\t                            componentModel.optionUpdated(newCptOption, false);\n\t                        }\n\t                        else {\n\t                            // PENDING Global as parent ?\n\t                            var extraOpt = zrUtil.extend(\n\t                                {\n\t                                    dependentModels: dependentModels,\n\t                                    componentIndex: index\n\t                                },\n\t                                resultItem.keyInfo\n\t                            );\n\t                            componentModel = new ComponentModelClass(\n\t                                newCptOption, this, this, extraOpt\n\t                            );\n\t                            zrUtil.extend(componentModel, extraOpt);\n\t                            componentModel.init(newCptOption, this, this, extraOpt);\n\t                            // Call optionUpdated after init.\n\t                            // newCptOption has been used as componentModel.option\n\t                            // and may be merged with theme and default, so pass null\n\t                            // to avoid confusion.\n\t                            componentModel.optionUpdated(null, true);\n\t                        }\n\t                    }\n\t\n\t                    componentsMap[mainType][index] = componentModel;\n\t                    option[mainType][index] = componentModel.option;\n\t                }, this);\n\t\n\t                // Backup series for filtering.\n\t                if (mainType === 'series') {\n\t                    this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get option for output (cloned option and inner info removed)\n\t         * @public\n\t         * @return {Object}\n\t         */\n\t        getOption: function () {\n\t            var option = zrUtil.clone(this.option);\n\t\n\t            each(option, function (opts, mainType) {\n\t                if (ComponentModel.hasClass(mainType)) {\n\t                    var opts = modelUtil.normalizeToArray(opts);\n\t                    for (var i = opts.length - 1; i >= 0; i--) {\n\t                        // Remove options with inner id.\n\t                        if (modelUtil.isIdInner(opts[i])) {\n\t                            opts.splice(i, 1);\n\t                        }\n\t                    }\n\t                    option[mainType] = opts;\n\t                }\n\t            });\n\t\n\t            delete option[OPTION_INNER_KEY];\n\t\n\t            return option;\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/model/Model}\n\t         */\n\t        getTheme: function () {\n\t            return this._theme;\n\t        },\n\t\n\t        /**\n\t         * @param {string} mainType\n\t         * @param {number} [idx=0]\n\t         * @return {module:echarts/model/Component}\n\t         */\n\t        getComponent: function (mainType, idx) {\n\t            var list = this._componentsMap[mainType];\n\t            if (list) {\n\t                return list[idx || 0];\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object} condition\n\t         * @param {string} condition.mainType\n\t         * @param {string} [condition.subType] If ignore, only query by mainType\n\t         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n\t         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n\t         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n\t         * @return {Array.<module:echarts/model/Component>}\n\t         */\n\t        queryComponents: function (condition) {\n\t            var mainType = condition.mainType;\n\t            if (!mainType) {\n\t                return [];\n\t            }\n\t\n\t            var index = condition.index;\n\t            var id = condition.id;\n\t            var name = condition.name;\n\t\n\t            var cpts = this._componentsMap[mainType];\n\t\n\t            if (!cpts || !cpts.length) {\n\t                return [];\n\t            }\n\t\n\t            var result;\n\t\n\t            if (index != null) {\n\t                if (!isArray(index)) {\n\t                    index = [index];\n\t                }\n\t                result = filter(map(index, function (idx) {\n\t                    return cpts[idx];\n\t                }), function (val) {\n\t                    return !!val;\n\t                });\n\t            }\n\t            else if (id != null) {\n\t                var isIdArray = isArray(id);\n\t                result = filter(cpts, function (cpt) {\n\t                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n\t                        || (!isIdArray && cpt.id === id);\n\t                });\n\t            }\n\t            else if (name != null) {\n\t                var isNameArray = isArray(name);\n\t                result = filter(cpts, function (cpt) {\n\t                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n\t                        || (!isNameArray && cpt.name === name);\n\t                });\n\t            }\n\t            else {\n\t                // Return all components with mainType\n\t                result = cpts;\n\t            }\n\t\n\t            return filterBySubType(result, condition);\n\t        },\n\t\n\t        /**\n\t         * The interface is different from queryComponents,\n\t         * which is convenient for inner usage.\n\t         *\n\t         * @usage\n\t         * var result = findComponents(\n\t         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n\t         * );\n\t         * var result = findComponents(\n\t         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n\t         * );\n\t         * var result = findComponents(\n\t         *     {mainType: 'series'},\n\t         *     function (model, index) {...}\n\t         * );\n\t         * // result like [component0, componnet1, ...]\n\t         *\n\t         * @param {Object} condition\n\t         * @param {string} condition.mainType Mandatory.\n\t         * @param {string} [condition.subType] Optional.\n\t         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n\t         *        where xxx is mainType.\n\t         *        If query attribute is null/undefined or has no index/id/name,\n\t         *        do not filtering by query conditions, which is convenient for\n\t         *        no-payload situations or when target of action is global.\n\t         * @param {Function} [condition.filter] parameter: component, return boolean.\n\t         * @return {Array.<module:echarts/model/Component>}\n\t         */\n\t        findComponents: function (condition) {\n\t            var query = condition.query;\n\t            var mainType = condition.mainType;\n\t\n\t            var queryCond = getQueryCond(query);\n\t            var result = queryCond\n\t                ? this.queryComponents(queryCond)\n\t                : this._componentsMap[mainType];\n\t\n\t            return doFilter(filterBySubType(result, condition));\n\t\n\t            function getQueryCond(q) {\n\t                var indexAttr = mainType + 'Index';\n\t                var idAttr = mainType + 'Id';\n\t                var nameAttr = mainType + 'Name';\n\t                return q && (\n\t                        q.hasOwnProperty(indexAttr)\n\t                        || q.hasOwnProperty(idAttr)\n\t                        || q.hasOwnProperty(nameAttr)\n\t                    )\n\t                    ? {\n\t                        mainType: mainType,\n\t                        // subType will be filtered finally.\n\t                        index: q[indexAttr],\n\t                        id: q[idAttr],\n\t                        name: q[nameAttr]\n\t                    }\n\t                    : null;\n\t            }\n\t\n\t            function doFilter(res) {\n\t                return condition.filter\n\t                     ? filter(res, condition.filter)\n\t                     : res;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @usage\n\t         * eachComponent('legend', function (legendModel, index) {\n\t         *     ...\n\t         * });\n\t         * eachComponent(function (componentType, model, index) {\n\t         *     // componentType does not include subType\n\t         *     // (componentType is 'xxx' but not 'xxx.aa')\n\t         * });\n\t         * eachComponent(\n\t         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n\t         *     function (model, index) {...}\n\t         * );\n\t         * eachComponent(\n\t         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n\t         *     function (model, index) {...}\n\t         * );\n\t         *\n\t         * @param {string|Object=} mainType When mainType is object, the definition\n\t         *                                  is the same as the method 'findComponents'.\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachComponent: function (mainType, cb, context) {\n\t            var componentsMap = this._componentsMap;\n\t\n\t            if (typeof mainType === 'function') {\n\t                context = cb;\n\t                cb = mainType;\n\t                each(componentsMap, function (components, componentType) {\n\t                    each(components, function (component, index) {\n\t                        cb.call(context, componentType, component, index);\n\t                    });\n\t                });\n\t            }\n\t            else if (zrUtil.isString(mainType)) {\n\t                each(componentsMap[mainType], cb, context);\n\t            }\n\t            else if (isObject(mainType)) {\n\t                var queryResult = this.findComponents(mainType);\n\t                each(queryResult, cb, context);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         * @return {Array.<module:echarts/model/Series>}\n\t         */\n\t        getSeriesByName: function (name) {\n\t            var series = this._componentsMap.series;\n\t            return filter(series, function (oneSeries) {\n\t                return oneSeries.name === name;\n\t            });\n\t        },\n\t\n\t        /**\n\t         * @param {number} seriesIndex\n\t         * @return {module:echarts/model/Series}\n\t         */\n\t        getSeriesByIndex: function (seriesIndex) {\n\t            return this._componentsMap.series[seriesIndex];\n\t        },\n\t\n\t        /**\n\t         * @param {string} subType\n\t         * @return {Array.<module:echarts/model/Series>}\n\t         */\n\t        getSeriesByType: function (subType) {\n\t            var series = this._componentsMap.series;\n\t            return filter(series, function (oneSeries) {\n\t                return oneSeries.subType === subType;\n\t            });\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:echarts/model/Series>}\n\t         */\n\t        getSeries: function () {\n\t            return this._componentsMap.series.slice();\n\t        },\n\t\n\t        /**\n\t         * After filtering, series may be different\n\t         * frome raw series.\n\t         *\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachSeries: function (cb, context) {\n\t            assertSeriesInitialized(this);\n\t            each(this._seriesIndices, function (rawSeriesIndex) {\n\t                var series = this._componentsMap.series[rawSeriesIndex];\n\t                cb.call(context, series, rawSeriesIndex);\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * Iterate raw series before filtered.\n\t         *\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachRawSeries: function (cb, context) {\n\t            each(this._componentsMap.series, cb, context);\n\t        },\n\t\n\t        /**\n\t         * After filtering, series may be different.\n\t         * frome raw series.\n\t         *\n\t         * @parma {string} subType\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachSeriesByType: function (subType, cb, context) {\n\t            assertSeriesInitialized(this);\n\t            each(this._seriesIndices, function (rawSeriesIndex) {\n\t                var series = this._componentsMap.series[rawSeriesIndex];\n\t                if (series.subType === subType) {\n\t                    cb.call(context, series, rawSeriesIndex);\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * Iterate raw series before filtered of given type.\n\t         *\n\t         * @parma {string} subType\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachRawSeriesByType: function (subType, cb, context) {\n\t            return each(this.getSeriesByType(subType), cb, context);\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/model/Series} seriesModel\n\t         */\n\t        isSeriesFiltered: function (seriesModel) {\n\t            assertSeriesInitialized(this);\n\t            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n\t        },\n\t\n\t        /**\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        filterSeries: function (cb, context) {\n\t            assertSeriesInitialized(this);\n\t            var filteredSeries = filter(\n\t                this._componentsMap.series, cb, context\n\t            );\n\t            this._seriesIndices = createSeriesIndices(filteredSeries);\n\t        },\n\t\n\t        restoreData: function () {\n\t            var componentsMap = this._componentsMap;\n\t\n\t            this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t\n\t            var componentTypes = [];\n\t            each(componentsMap, function (components, componentType) {\n\t                componentTypes.push(componentType);\n\t            });\n\t\n\t            ComponentModel.topologicalTravel(\n\t                componentTypes,\n\t                ComponentModel.getAllClassMainTypes(),\n\t                function (componentType, dependencies) {\n\t                    each(componentsMap[componentType], function (component) {\n\t                        component.restoreData();\n\t                    });\n\t                }\n\t            );\n\t        }\n\t\n\t    });\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function mergeTheme(option, theme) {\n\t        zrUtil.each(theme, function (themeItem, name) {\n\t            //  component model  merge  model \n\t            if (!ComponentModel.hasClass(name)) {\n\t                if (typeof themeItem === 'object') {\n\t                    option[name] = !option[name]\n\t                        ? zrUtil.clone(themeItem)\n\t                        : zrUtil.merge(option[name], themeItem, false);\n\t                }\n\t                else {\n\t                    if (option[name] == null) {\n\t                        option[name] = themeItem;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    }\n\t\n\t    function initBase(baseOption) {\n\t        baseOption = baseOption;\n\t\n\t        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n\t        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\t        this.option = {};\n\t        this.option[OPTION_INNER_KEY] = 1;\n\t\n\t        /**\n\t         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t\n\t        /**\n\t         * Mapping between filtered series list and raw series list.\n\t         * key: filtered series indices, value: raw series indices.\n\t         * @type {Array.<nubmer>}\n\t         * @private\n\t         */\n\t        this._seriesIndices = null;\n\t\n\t        mergeTheme(baseOption, this._theme.option);\n\t\n\t        // TODO Needs clone when merging to the unexisted property\n\t        zrUtil.merge(baseOption, globalDefault, false);\n\t\n\t        this.mergeOption(baseOption);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     * @param {Array.<string>|string} types model types\n\t     * @return {Object} key: {string} type, value: {Array.<Object>} models\n\t     */\n\t    function getComponentsByTypes(componentsMap, types) {\n\t        if (!zrUtil.isArray(types)) {\n\t            types = types ? [types] : [];\n\t        }\n\t\n\t        var ret = {};\n\t        each(types, function (type) {\n\t            ret[type] = (componentsMap[type] || []).slice();\n\t        });\n\t\n\t        return ret;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeKeyInfo(mainType, mapResult) {\n\t        // We use this id to hash component models and view instances\n\t        // in echarts. id can be specified by user, or auto generated.\n\t\n\t        // The id generation rule ensures new view instance are able\n\t        // to mapped to old instance when setOption are called in\n\t        // no-merge mode. So we generate model id by name and plus\n\t        // type in view id.\n\t\n\t        // name can be duplicated among components, which is convenient\n\t        // to specify multi components (like series) by one name.\n\t\n\t        // Ensure that each id is distinct.\n\t        var idMap = {};\n\t\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            existCpt && (idMap[existCpt.id] = item);\n\t        });\n\t\n\t        each(mapResult, function (item, index) {\n\t            var opt = item.option;\n\t\n\t            zrUtil.assert(\n\t                !opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item,\n\t                'id duplicates: ' + (opt && opt.id)\n\t            );\n\t\n\t            opt && opt.id != null && (idMap[opt.id] = item);\n\t\n\t            // Complete subType\n\t            if (isObject(opt)) {\n\t                var subType = determineSubType(mainType, opt, item.exist);\n\t                item.keyInfo = {mainType: mainType, subType: subType};\n\t            }\n\t        });\n\t\n\t        // Make name and id.\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            var opt = item.option;\n\t            var keyInfo = item.keyInfo;\n\t\n\t            if (!isObject(opt)) {\n\t                return;\n\t            }\n\t\n\t            // name can be overwitten. Consider case: axis.name = '20km'.\n\t            // But id generated by name will not be changed, which affect\n\t            // only in that case: setOption with 'not merge mode' and view\n\t            // instance will be recreated, which can be accepted.\n\t            keyInfo.name = opt.name != null\n\t                ? opt.name + ''\n\t                : existCpt\n\t                ? existCpt.name\n\t                : '\\0-';\n\t\n\t            if (existCpt) {\n\t                keyInfo.id = existCpt.id;\n\t            }\n\t            else if (opt.id != null) {\n\t                keyInfo.id = opt.id + '';\n\t            }\n\t            else {\n\t                // Consider this situatoin:\n\t                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n\t                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n\t                // Series with the same name between optionA and optionB\n\t                // should be mapped.\n\t                var idNum = 0;\n\t                do {\n\t                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n\t                }\n\t                while (idMap[keyInfo.id]);\n\t            }\n\t\n\t            idMap[keyInfo.id] = item;\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function determineSubType(mainType, newCptOption, existComponent) {\n\t        var subType = newCptOption.type\n\t            ? newCptOption.type\n\t            : existComponent\n\t            ? existComponent.subType\n\t            // Use determineSubType only when there is no existComponent.\n\t            : ComponentModel.determineSubType(mainType, newCptOption);\n\t\n\t        // tooltip, markline, markpoint may always has no subType\n\t        return subType;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function createSeriesIndices(seriesModels) {\n\t        return map(seriesModels, function (series) {\n\t            return series.componentIndex;\n\t        }) || [];\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function filterBySubType(components, condition) {\n\t        // Using hasOwnProperty for restrict. Consider\n\t        // subType is undefined in user payload.\n\t        return condition.hasOwnProperty('subType')\n\t            ? filter(components, function (cpt) {\n\t                return cpt.subType === condition.subType;\n\t            })\n\t            : components;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function assertSeriesInitialized(ecModel) {\n\t        // Components that use _seriesIndices should depends on series component,\n\t        // which make sure that their initialization is after series.\n\t        if (false) {\n\t            if (!ecModel._seriesIndices) {\n\t                throw new Error('Series has not been initialized yet.');\n\t            }\n\t        }\n\t    }\n\t\n\t    zrUtil.mixin(GlobalModel, __webpack_require__(/*! ./mixin/colorPalette */ 56));\n\t\n\t    module.exports = GlobalModel;\n\n\n/***/ },\n/* 125 */\n/*!************************************!*\\\n  !*** ./lib/model/OptionManager.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * ECharts option manager\n\t *\n\t * @module {echarts/model/OptionManager}\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var modelUtil = __webpack_require__(/*! ../util/model */ 7);\n\t    var ComponentModel = __webpack_require__(/*! ./Component */ 12);\n\t    var each = zrUtil.each;\n\t    var clone = zrUtil.clone;\n\t    var map = zrUtil.map;\n\t    var merge = zrUtil.merge;\n\t\n\t    var QUERY_REG = /^(min|max)?(.+)$/;\n\t\n\t    /**\n\t     * TERM EXPLANATIONS:\n\t     *\n\t     * [option]:\n\t     *\n\t     *     An object that contains definitions of components. For example:\n\t     *     var option = {\n\t     *         title: {...},\n\t     *         legend: {...},\n\t     *         visualMap: {...},\n\t     *         series: [\n\t     *             {data: [...]},\n\t     *             {data: [...]},\n\t     *             ...\n\t     *         ]\n\t     *     };\n\t     *\n\t     * [rawOption]:\n\t     *\n\t     *     An object input to echarts.setOption. 'rawOption' may be an\n\t     *     'option', or may be an object contains multi-options. For example:\n\t     *     var option = {\n\t     *         baseOption: {\n\t     *             title: {...},\n\t     *             legend: {...},\n\t     *             series: [\n\t     *                 {data: [...]},\n\t     *                 {data: [...]},\n\t     *                 ...\n\t     *             ]\n\t     *         },\n\t     *         timeline: {...},\n\t     *         options: [\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             ...\n\t     *         ],\n\t     *         media: [\n\t     *             {\n\t     *                 query: {maxWidth: 320},\n\t     *                 option: {series: {x: 20}, visualMap: {show: false}}\n\t     *             },\n\t     *             {\n\t     *                 query: {minWidth: 320, maxWidth: 720},\n\t     *                 option: {series: {x: 500}, visualMap: {show: true}}\n\t     *             },\n\t     *             {\n\t     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n\t     *             }\n\t     *         ]\n\t     *     };\n\t     *\n\t     * @alias module:echarts/model/OptionManager\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function OptionManager(api) {\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:echarts/ExtensionAPI}\n\t         */\n\t        this._api = api;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._timelineOptions = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._mediaList = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._mediaDefault;\n\t\n\t        /**\n\t         * -1, means default.\n\t         * empty means no media.\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._currentMediaIndices = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._optionBackup;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._newBaseOption;\n\t    }\n\t\n\t    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n\t    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n\t    // rawOption cloned and backuped when timeline changed, which does no\n\t    // good to performance. What's more, that both timeline and setOption\n\t    // method supply 'notMerge' brings complex and some problems.\n\t    // Consider this case:\n\t    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n\t    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\t\n\t    OptionManager.prototype = {\n\t\n\t        constructor: OptionManager,\n\t\n\t        /**\n\t         * @public\n\t         * @param {Object} rawOption Raw option.\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @param {Array.<Function>} optionPreprocessorFuncs\n\t         * @return {Object} Init option\n\t         */\n\t        setOption: function (rawOption, optionPreprocessorFuncs) {\n\t            rawOption = clone(rawOption, true);\n\t\n\t            // FIXME\n\t            //  timeline options  media baseOption\n\t\n\t            var oldOptionBackup = this._optionBackup;\n\t            var newParsedOption = parseRawOption.call(\n\t                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n\t            );\n\t            this._newBaseOption = newParsedOption.baseOption;\n\t\n\t            // For setOption at second time (using merge mode);\n\t            if (oldOptionBackup) {\n\t                // Only baseOption can be merged.\n\t                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\t\n\t                // For simplicity, timeline options and media options do not support merge,\n\t                // that is, if you `setOption` twice and both has timeline options, the latter\n\t                // timeline opitons will not be merged to the formers, but just substitude them.\n\t                if (newParsedOption.timelineOptions.length) {\n\t                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n\t                }\n\t                if (newParsedOption.mediaList.length) {\n\t                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n\t                }\n\t                if (newParsedOption.mediaDefault) {\n\t                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n\t                }\n\t            }\n\t            else {\n\t                this._optionBackup = newParsedOption;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {boolean} isRecreate\n\t         * @return {Object}\n\t         */\n\t        mountOption: function (isRecreate) {\n\t            var optionBackup = this._optionBackup;\n\t\n\t            // TODO\n\t            // resetclone\n\t\n\t            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n\t            this._mediaList = map(optionBackup.mediaList, clone);\n\t            this._mediaDefault = clone(optionBackup.mediaDefault);\n\t            this._currentMediaIndices = [];\n\t\n\t            return clone(isRecreate\n\t                // this._optionBackup.baseOption, which is created at the first `setOption`\n\t                // called, and is merged into every new option by inner method `mergeOption`\n\t                // each time `setOption` called, can be only used in `isRecreate`, because\n\t                // its reliability is under suspicion. In other cases option merge is\n\t                // proformed by `model.mergeOption`.\n\t                ? optionBackup.baseOption : this._newBaseOption\n\t            );\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @return {Object}\n\t         */\n\t        getTimelineOption: function (ecModel) {\n\t            var option;\n\t            var timelineOptions = this._timelineOptions;\n\t\n\t            if (timelineOptions.length) {\n\t                // getTimelineOption can only be called after ecModel inited,\n\t                // so we can get currentIndex from timelineModel.\n\t                var timelineModel = ecModel.getComponent('timeline');\n\t                if (timelineModel) {\n\t                    option = clone(\n\t                        timelineOptions[timelineModel.getCurrentIndex()],\n\t                        true\n\t                    );\n\t                }\n\t            }\n\t\n\t            return option;\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @return {Array.<Object>}\n\t         */\n\t        getMediaOption: function (ecModel) {\n\t            var ecWidth = this._api.getWidth();\n\t            var ecHeight = this._api.getHeight();\n\t            var mediaList = this._mediaList;\n\t            var mediaDefault = this._mediaDefault;\n\t            var indices = [];\n\t            var result = [];\n\t\n\t            // No media defined.\n\t            if (!mediaList.length && !mediaDefault) {\n\t                return result;\n\t            }\n\t\n\t            // Multi media may be applied, the latter defined media has higher priority.\n\t            for (var i = 0, len = mediaList.length; i < len; i++) {\n\t                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n\t                    indices.push(i);\n\t                }\n\t            }\n\t\n\t            // FIXME\n\t            // mediaDefault\n\t            if (!indices.length && mediaDefault) {\n\t                indices = [-1];\n\t            }\n\t\n\t            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n\t                result = map(indices, function (index) {\n\t                    return clone(\n\t                        index === -1 ? mediaDefault.option : mediaList[index].option\n\t                    );\n\t                });\n\t            }\n\t            // Otherwise return nothing.\n\t\n\t            this._currentMediaIndices = indices;\n\t\n\t            return result;\n\t        }\n\t    };\n\t\n\t    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n\t        var timelineOptions = [];\n\t        var mediaList = [];\n\t        var mediaDefault;\n\t        var baseOption;\n\t\n\t        // Compatible with ec2.\n\t        var timelineOpt = rawOption.timeline;\n\t\n\t        if (rawOption.baseOption) {\n\t            baseOption = rawOption.baseOption;\n\t        }\n\t\n\t        // For timeline\n\t        if (timelineOpt || rawOption.options) {\n\t            baseOption = baseOption || {};\n\t            timelineOptions = (rawOption.options || []).slice();\n\t        }\n\t\n\t        // For media query\n\t        if (rawOption.media) {\n\t            baseOption = baseOption || {};\n\t            var media = rawOption.media;\n\t            each(media, function (singleMedia) {\n\t                if (singleMedia && singleMedia.option) {\n\t                    if (singleMedia.query) {\n\t                        mediaList.push(singleMedia);\n\t                    }\n\t                    else if (!mediaDefault) {\n\t                        // Use the first media default.\n\t                        mediaDefault = singleMedia;\n\t                    }\n\t                }\n\t            });\n\t        }\n\t\n\t        // For normal option\n\t        if (!baseOption) {\n\t            baseOption = rawOption;\n\t        }\n\t\n\t        // Set timelineOpt to baseOption in ec3,\n\t        // which is convenient for merge option.\n\t        if (!baseOption.timeline) {\n\t            baseOption.timeline = timelineOpt;\n\t        }\n\t\n\t        // Preprocess.\n\t        each([baseOption].concat(timelineOptions)\n\t            .concat(zrUtil.map(mediaList, function (media) {\n\t                return media.option;\n\t            })),\n\t            function (option) {\n\t                each(optionPreprocessorFuncs, function (preProcess) {\n\t                    preProcess(option, isNew);\n\t                });\n\t            }\n\t        );\n\t\n\t        return {\n\t            baseOption: baseOption,\n\t            timelineOptions: timelineOptions,\n\t            mediaDefault: mediaDefault,\n\t            mediaList: mediaList\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n\t     * Support: width, height, aspectRatio\n\t     * Can use max or min as prefix.\n\t     */\n\t    function applyMediaQuery(query, ecWidth, ecHeight) {\n\t        var realMap = {\n\t            width: ecWidth,\n\t            height: ecHeight,\n\t            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n\t        };\n\t\n\t        var applicatable = true;\n\t\n\t        zrUtil.each(query, function (value, attr) {\n\t            var matched = attr.match(QUERY_REG);\n\t\n\t            if (!matched || !matched[1] || !matched[2]) {\n\t                return;\n\t            }\n\t\n\t            var operator = matched[1];\n\t            var realAttr = matched[2].toLowerCase();\n\t\n\t            if (!compare(realMap[realAttr], value, operator)) {\n\t                applicatable = false;\n\t            }\n\t        });\n\t\n\t        return applicatable;\n\t    }\n\t\n\t    function compare(real, expect, operator) {\n\t        if (operator === 'min') {\n\t            return real >= expect;\n\t        }\n\t        else if (operator === 'max') {\n\t            return real <= expect;\n\t        }\n\t        else { // Equals\n\t            return real === expect;\n\t        }\n\t    }\n\t\n\t    function indicesEquals(indices1, indices2) {\n\t        // indices is always order by asc and has only finite number.\n\t        return indices1.join(',') === indices2.join(',');\n\t    }\n\t\n\t    /**\n\t     * Consider case:\n\t     * `chart.setOption(opt1);`\n\t     * Then user do some interaction like dataZoom, dataView changing.\n\t     * `chart.setOption(opt2);`\n\t     * Then user press 'reset button' in toolbox.\n\t     *\n\t     * After doing that all of the interaction effects should be reset, the\n\t     * chart should be the same as the result of invoke\n\t     * `chart.setOption(opt1); chart.setOption(opt2);`.\n\t     *\n\t     * Although it is not able ensure that\n\t     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n\t     * `chart.setOption(merge(opt1, opt2));` exactly,\n\t     * this might be the only simple way to implement that feature.\n\t     *\n\t     * MEMO: We've considered some other approaches:\n\t     * 1. Each model handle its self restoration but not uniform treatment.\n\t     *     (Too complex in logic and error-prone)\n\t     * 2. Use a shadow ecModel. (Performace expensive)\n\t     */\n\t    function mergeOption(oldOption, newOption) {\n\t        newOption = newOption || {};\n\t\n\t        each(newOption, function (newCptOpt, mainType) {\n\t            if (newCptOpt == null) {\n\t                return;\n\t            }\n\t\n\t            var oldCptOpt = oldOption[mainType];\n\t\n\t            if (!ComponentModel.hasClass(mainType)) {\n\t                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n\t            }\n\t            else {\n\t                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n\t                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\t\n\t                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\t\n\t                oldOption[mainType] = map(mapResult, function (item) {\n\t                    return (item.option && item.exist)\n\t                        ? merge(item.exist, item.option, true)\n\t                        : (item.exist || item.option);\n\t                });\n\t            }\n\t        });\n\t    }\n\t\n\t    module.exports = OptionManager;\n\n\n/***/ },\n/* 126 */\n/*!************************************!*\\\n  !*** ./lib/model/globalDefault.js ***!\n  \\************************************/\n/***/ function(module, exports) {\n\n\t\n\t    var platform = '';\n\t    // Navigator not exists in node\n\t    if (typeof navigator !== 'undefined') {\n\t        platform = navigator.platform || '';\n\t    }\n\t    module.exports = {\n\t        // \n\t        // backgroundColor: 'rgba(0,0,0,0)',\n\t\n\t        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n\t        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n\t        // \n\t        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n\t        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n\t        // \n\t        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\t\n\t        //  Grid \n\t        // grid: {},\n\t        // \n\t        textStyle: {\n\t            // color: '#000',\n\t            // decoration: 'none',\n\t            // PENDING\n\t            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n\t            // fontFamily: 'Arial, Verdana, sans-serif',\n\t            fontSize: 12,\n\t            fontStyle: 'normal',\n\t            fontWeight: 'normal'\n\t        },\n\t\n\t        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n\t        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t        // Default is source-over\n\t        blendMode: null,\n\t\n\t        animation: true,\n\t        animationDuration: 1000,\n\t        animationDurationUpdate: 300,\n\t        animationEasing: 'exponentialOut',\n\t        animationEasingUpdate: 'cubicOut',\n\t\n\t        animationThreshold: 2000,\n\t        // Configuration for progressive/incremental rendering\n\t        progressiveThreshold: 3000,\n\t        progressive: 400,\n\t\n\t        // Threshold of if use single hover layer to optimize.\n\t        hoverLayerThreshold: 3000\n\t    };\n\n\n/***/ },\n/* 127 */\n/*!**************************************!*\\\n  !*** ./lib/model/mixin/areaStyle.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    module.exports = {\n\t        getAreaStyle: __webpack_require__(/*! ./makeStyleMapper */ 31)(\n\t            [\n\t                ['fill', 'color'],\n\t                ['shadowBlur'],\n\t                ['shadowOffsetX'],\n\t                ['shadowOffsetY'],\n\t                ['opacity'],\n\t                ['shadowColor']\n\t            ]\n\t        )\n\t    };\n\n\n/***/ },\n/* 128 */\n/*!**************************************!*\\\n  !*** ./lib/model/mixin/boxLayout.js ***!\n  \\**************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        getBoxLayoutParams: function () {\n\t            return {\n\t                left: this.get('left'),\n\t                top: this.get('top'),\n\t                right: this.get('right'),\n\t                bottom: this.get('bottom'),\n\t                width: this.get('width'),\n\t                height: this.get('height')\n\t            };\n\t        }\n\t    };\n\n\n/***/ },\n/* 129 */\n/*!**************************************!*\\\n  !*** ./lib/model/mixin/itemStyle.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var getItemStyle = __webpack_require__(/*! ./makeStyleMapper */ 31)(\n\t        [\n\t            ['fill', 'color'],\n\t            ['stroke', 'borderColor'],\n\t            ['lineWidth', 'borderWidth'],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor'],\n\t            ['textPosition'],\n\t            ['textAlign']\n\t        ]\n\t    );\n\t    module.exports = {\n\t        getItemStyle: function (excludes) {\n\t            var style = getItemStyle.call(this, excludes);\n\t            var lineDash = this.getBorderLineDash();\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t\n\t        getBorderLineDash: function () {\n\t            var lineType = this.get('borderType');\n\t            return (lineType === 'solid' || lineType == null) ? null\n\t                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n\t        }\n\t    };\n\n\n/***/ },\n/* 130 */\n/*!**************************************!*\\\n  !*** ./lib/model/mixin/lineStyle.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var getLineStyle = __webpack_require__(/*! ./makeStyleMapper */ 31)(\n\t        [\n\t            ['lineWidth', 'width'],\n\t            ['stroke', 'color'],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]\n\t    );\n\t    module.exports = {\n\t        getLineStyle: function (excludes) {\n\t            var style = getLineStyle.call(this, excludes);\n\t            var lineDash = this.getLineDash(style.lineWidth);\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t\n\t        getLineDash: function (lineWidth) {\n\t            if (lineWidth == null) {\n\t                lineWidth = 1;\n\t            }\n\t            var lineType = this.get('type');\n\t            var dotSize = Math.max(lineWidth, 2);\n\t            var dashSize = lineWidth * 4;\n\t            return (lineType === 'solid' || lineType == null) ? null\n\t                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n\t        }\n\t    };\n\n\n/***/ },\n/* 131 */\n/*!**************************************!*\\\n  !*** ./lib/model/mixin/textStyle.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 16);\n\t\n\t    function getShallow(model, path) {\n\t        return model && model.getShallow(path);\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Get color property or get color from option.textStyle.color\n\t         * @return {string}\n\t         */\n\t        getTextColor: function () {\n\t            var ecModel = this.ecModel;\n\t            return this.getShallow('color')\n\t                || (ecModel && ecModel.get('textStyle.color'));\n\t        },\n\t\n\t        /**\n\t         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n\t         * @return {string}\n\t         */\n\t        getFont: function () {\n\t            var ecModel = this.ecModel;\n\t            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n\t            return [\n\t                // FIXME in node-canvas fontWeight is before fontStyle\n\t                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n\t                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n\t                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n\t                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n\t            ].join(' ');\n\t        },\n\t\n\t        getTextRect: function (text) {\n\t            var textStyle = this.get('textStyle') || {};\n\t            return textContain.getBoundingRect(\n\t                text,\n\t                this.getFont(),\n\t                textStyle.align,\n\t                textStyle.baseline\n\t            );\n\t        },\n\t\n\t        truncateText: function (text, containerWidth, ellipsis, options) {\n\t            return textContain.truncateText(\n\t                text, containerWidth, this.getFont(), ellipsis, options\n\t            );\n\t        }\n\t    };\n\n\n/***/ },\n/* 132 */\n/*!********************************************!*\\\n  !*** ./lib/preprocessor/backwardCompat.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Compatitable with 2.0\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var compatStyle = __webpack_require__(/*! ./helper/compatStyle */ 133);\n\t\n\t    function get(opt, path) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        for (var i = 0; i < path.length; i++) {\n\t            obj = obj && obj[path[i]];\n\t            if (obj == null) {\n\t                break;\n\t            }\n\t        }\n\t        return obj;\n\t    }\n\t\n\t    function set(opt, path, val, overwrite) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        var key;\n\t        for (var i = 0; i < path.length - 1; i++) {\n\t            key = path[i];\n\t            if (obj[key] == null) {\n\t                obj[key] = {};\n\t            }\n\t            obj = obj[key];\n\t        }\n\t        if (overwrite || obj[path[i]] == null) {\n\t            obj[path[i]] = val;\n\t        }\n\t    }\n\t\n\t    function compatLayoutProperties(option) {\n\t        each(LAYOUT_PROPERTIES, function (prop) {\n\t            if (prop[0] in option && !(prop[1] in option)) {\n\t                option[prop[1]] = option[prop[0]];\n\t            }\n\t        });\n\t    }\n\t\n\t    var LAYOUT_PROPERTIES = [\n\t        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n\t    ];\n\t\n\t    var COMPATITABLE_COMPONENTS = [\n\t        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n\t    ];\n\t\n\t    var COMPATITABLE_SERIES = [\n\t        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n\t        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n\t        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n\t    ];\n\t\n\t    var each = zrUtil.each;\n\t\n\t    module.exports = function (option) {\n\t        each(option.series, function (seriesOpt) {\n\t            if (!zrUtil.isObject(seriesOpt)) {\n\t                return;\n\t            }\n\t\n\t            var seriesType = seriesOpt.type;\n\t\n\t            compatStyle(seriesOpt);\n\t\n\t            if (seriesType === 'pie' || seriesType === 'gauge') {\n\t                if (seriesOpt.clockWise != null) {\n\t                    seriesOpt.clockwise = seriesOpt.clockWise;\n\t                }\n\t            }\n\t            if (seriesType === 'gauge') {\n\t                var pointerColor = get(seriesOpt, 'pointer.color');\n\t                pointerColor != null\n\t                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n\t            }\n\t\n\t            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n\t                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n\t                    compatLayoutProperties(seriesOpt);\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t\n\t        // dataRange has changed to visualMap\n\t        if (option.dataRange) {\n\t            option.visualMap = option.dataRange;\n\t        }\n\t\n\t        each(COMPATITABLE_COMPONENTS, function (componentName) {\n\t            var options = option[componentName];\n\t            if (options) {\n\t                if (!zrUtil.isArray(options)) {\n\t                    options = [options];\n\t                }\n\t                each(options, function (option) {\n\t                    compatLayoutProperties(option);\n\t                });\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n/* 133 */\n/*!************************************************!*\\\n  !*** ./lib/preprocessor/helper/compatStyle.js ***!\n  \\************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var POSSIBLE_STYLES = [\n\t        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n\t        'chordStyle', 'label', 'labelLine'\n\t    ];\n\t\n\t    function compatItemStyle(opt) {\n\t        var itemStyleOpt = opt && opt.itemStyle;\n\t        if (itemStyleOpt) {\n\t            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n\t                var normalItemStyleOpt = itemStyleOpt.normal;\n\t                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n\t                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].normal) {\n\t                        opt[styleName].normal = normalItemStyleOpt[styleName];\n\t                    }\n\t                    else {\n\t                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n\t                    }\n\t                    normalItemStyleOpt[styleName] = null;\n\t                }\n\t                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].emphasis) {\n\t                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n\t                    }\n\t                    else {\n\t                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n\t                    }\n\t                    emphasisItemStyleOpt[styleName] = null;\n\t                }\n\t            });\n\t        }\n\t    }\n\t\n\t    module.exports = function (seriesOpt) {\n\t        if (!seriesOpt) {\n\t            return;\n\t        }\n\t        compatItemStyle(seriesOpt);\n\t        compatItemStyle(seriesOpt.markPoint);\n\t        compatItemStyle(seriesOpt.markLine);\n\t        var data = seriesOpt.data;\n\t        if (data) {\n\t            for (var i = 0; i < data.length; i++) {\n\t                compatItemStyle(data[i]);\n\t            }\n\t            // mark point data\n\t            var markPoint = seriesOpt.markPoint;\n\t            if (markPoint && markPoint.data) {\n\t                var mpData = markPoint.data;\n\t                for (var i = 0; i < mpData.length; i++) {\n\t                    compatItemStyle(mpData[i]);\n\t                }\n\t            }\n\t            // mark line data\n\t            var markLine = seriesOpt.markLine;\n\t            if (markLine && markLine.data) {\n\t                var mlData = markLine.data;\n\t                for (var i = 0; i < mlData.length; i++) {\n\t                    if (zrUtil.isArray(mlData[i])) {\n\t                        compatItemStyle(mlData[i][0]);\n\t                        compatItemStyle(mlData[i][1]);\n\t                    }\n\t                    else {\n\t                        compatItemStyle(mlData[i]);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\n\n/***/ },\n/* 134 */\n/*!*************************************!*\\\n  !*** ./lib/processor/dataSample.js ***!\n  \\*************************************/\n/***/ function(module, exports) {\n\n\t\n\t    var samplers = {\n\t        average: function (frame) {\n\t            var sum = 0;\n\t            var count = 0;\n\t            for (var i = 0; i < frame.length; i++) {\n\t                if (!isNaN(frame[i])) {\n\t                    sum += frame[i];\n\t                    count++;\n\t                }\n\t            }\n\t            // Return NaN if count is 0\n\t            return count === 0 ? NaN : sum / count;\n\t        },\n\t        sum: function (frame) {\n\t            var sum = 0;\n\t            for (var i = 0; i < frame.length; i++) {\n\t                // Ignore NaN\n\t                sum += frame[i] || 0;\n\t            }\n\t            return sum;\n\t        },\n\t        max: function (frame) {\n\t            var max = -Infinity;\n\t            for (var i = 0; i < frame.length; i++) {\n\t                frame[i] > max && (max = frame[i]);\n\t            }\n\t            return max;\n\t        },\n\t        min: function (frame) {\n\t            var min = Infinity;\n\t            for (var i = 0; i < frame.length; i++) {\n\t                frame[i] < min && (min = frame[i]);\n\t            }\n\t            return min;\n\t        },\n\t        // TODO\n\t        // Median\n\t        nearest: function (frame) {\n\t            return frame[0];\n\t        }\n\t    };\n\t\n\t    var indexSampler = function (frame, value) {\n\t        return Math.round(frame.length / 2);\n\t    };\n\t    module.exports = function (seriesType, ecModel, api) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var sampling = seriesModel.get('sampling');\n\t            var coordSys = seriesModel.coordinateSystem;\n\t            // Only cartesian2d support down sampling\n\t            if (coordSys.type === 'cartesian2d' && sampling) {\n\t                var baseAxis = coordSys.getBaseAxis();\n\t                var valueAxis = coordSys.getOtherAxis(baseAxis);\n\t                var extent = baseAxis.getExtent();\n\t                // Coordinste system has been resized\n\t                var size = extent[1] - extent[0];\n\t                var rate = Math.round(data.count() / size);\n\t                if (rate > 1) {\n\t                    var sampler;\n\t                    if (typeof sampling === 'string') {\n\t                        sampler = samplers[sampling];\n\t                    }\n\t                    else if (typeof sampling === 'function') {\n\t                        sampler = sampling;\n\t                    }\n\t                    if (sampler) {\n\t                        data = data.downSample(\n\t                            valueAxis.dim, 1 / rate, sampler, indexSampler\n\t                        );\n\t                        seriesModel.setData(data);\n\t                    }\n\t                }\n\t            }\n\t        }, this);\n\t    };\n\n\n/***/ },\n/* 135 */\n/*!**************************!*\\\n  !*** ./lib/scale/Log.js ***!\n  \\**************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Log scale\n\t * @module echarts/scale/Log\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var Scale = __webpack_require__(/*! ./Scale */ 32);\n\t    var numberUtil = __webpack_require__(/*! ../util/number */ 4);\n\t\n\t    // Use some method of IntervalScale\n\t    var IntervalScale = __webpack_require__(/*! ./Interval */ 38);\n\t\n\t    var scaleProto = Scale.prototype;\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t\n\t    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n\t    var roundingErrorFix = numberUtil.round;\n\t\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t    var mathPow = Math.pow;\n\t\n\t    var mathLog = Math.log;\n\t\n\t    var LogScale = Scale.extend({\n\t\n\t        type: 'log',\n\t\n\t        base: 10,\n\t\n\t        $constructor: function () {\n\t            Scale.apply(this, arguments);\n\t            this._originalScale = new IntervalScale();\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getTicks: function () {\n\t            var originalScale = this._originalScale;\n\t            var extent = this._extent;\n\t            var originalExtent = originalScale.getExtent();\n\t\n\t            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n\t                var powVal = numberUtil.round(mathPow(this.base, val));\n\t\n\t                // Fix #4158\n\t                powVal = (val === extent[0] && originalScale.__fixMin)\n\t                    ? fixRoundingError(powVal, originalExtent[0])\n\t                    : powVal;\n\t                powVal = (val === extent[1] && originalScale.__fixMax)\n\t                    ? fixRoundingError(powVal, originalExtent[1])\n\t                    : powVal;\n\t\n\t                return powVal;\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * @param {number} val\n\t         * @return {string}\n\t         */\n\t        getLabel: intervalScaleProto.getLabel,\n\t\n\t        /**\n\t         * @param  {number} val\n\t         * @return {number}\n\t         */\n\t        scale: function (val) {\n\t            val = scaleProto.scale.call(this, val);\n\t            return mathPow(this.base, val);\n\t        },\n\t\n\t        /**\n\t         * @param {number} start\n\t         * @param {number} end\n\t         */\n\t        setExtent: function (start, end) {\n\t            var base = this.base;\n\t            start = mathLog(start) / mathLog(base);\n\t            end = mathLog(end) / mathLog(base);\n\t            intervalScaleProto.setExtent.call(this, start, end);\n\t        },\n\t\n\t        /**\n\t         * @return {number} end\n\t         */\n\t        getExtent: function () {\n\t            var base = this.base;\n\t            var extent = scaleProto.getExtent.call(this);\n\t            extent[0] = mathPow(base, extent[0]);\n\t            extent[1] = mathPow(base, extent[1]);\n\t\n\t            // Fix #4158\n\t            var originalScale = this._originalScale;\n\t            var originalExtent = originalScale.getExtent();\n\t            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n\t            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\t\n\t            return extent;\n\t        },\n\t\n\t        /**\n\t         * @param  {Array.<number>} extent\n\t         */\n\t        unionExtent: function (extent) {\n\t            this._originalScale.unionExtent(extent);\n\t\n\t            var base = this.base;\n\t            extent[0] = mathLog(extent[0]) / mathLog(base);\n\t            extent[1] = mathLog(extent[1]) / mathLog(base);\n\t            scaleProto.unionExtent.call(this, extent);\n\t        },\n\t\n\t        /**\n\t         * Update interval and extent of intervals for nice ticks\n\t         * @param  {number} [approxTickNum = 10] Given approx tick number\n\t         */\n\t        niceTicks: function (approxTickNum) {\n\t            approxTickNum = approxTickNum || 10;\n\t            var extent = this._extent;\n\t            var span = extent[1] - extent[0];\n\t            if (span === Infinity || span <= 0) {\n\t                return;\n\t            }\n\t\n\t            var interval = numberUtil.quantity(span);\n\t            var err = approxTickNum / span * interval;\n\t\n\t            // Filter ticks to get closer to the desired count.\n\t            if (err <= 0.5) {\n\t                interval *= 10;\n\t            }\n\t\n\t            // Interval should be integer\n\t            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n\t                interval *= 10;\n\t            }\n\t\n\t            var niceExtent = [\n\t                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n\t                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n\t            ];\n\t\n\t            this._interval = interval;\n\t            this._niceExtent = niceExtent;\n\t        },\n\t\n\t        /**\n\t         * Nice extent.\n\t         * @param {number} [approxTickNum = 10] Given approx tick number\n\t         * @param {boolean} [fixMin=false]\n\t         * @param {boolean} [fixMax=false]\n\t         */\n\t        niceExtent: function (splitNumber, fixMin, fixMax) {\n\t            intervalScaleProto.niceExtent.call(this, splitNumber, fixMin, fixMax);\n\t\n\t            var originalScale = this._originalScale;\n\t            originalScale.__fixMin = fixMin;\n\t            originalScale.__fixMax = fixMax;\n\t        }\n\t\n\t    });\n\t\n\t    zrUtil.each(['contain', 'normalize'], function (methodName) {\n\t        LogScale.prototype[methodName] = function (val) {\n\t            val = mathLog(val) / mathLog(this.base);\n\t            return scaleProto[methodName].call(this, val);\n\t        };\n\t    });\n\t\n\t    LogScale.create = function () {\n\t        return new LogScale();\n\t    };\n\t\n\t    function fixRoundingError(val, originalVal) {\n\t        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n\t    }\n\t\n\t    module.exports = LogScale;\n\n\n/***/ },\n/* 136 */\n/*!******************************!*\\\n  !*** ./lib/scale/Ordinal.js ***!\n  \\******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Linear continuous scale\n\t * @module echarts/coord/scale/Ordinal\n\t *\n\t * http://en.wikipedia.org/wiki/Level_of_measurement\n\t */\n\t\n\t// FIXME only one data\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var Scale = __webpack_require__(/*! ./Scale */ 32);\n\t\n\t    var scaleProto = Scale.prototype;\n\t\n\t    var OrdinalScale = Scale.extend({\n\t\n\t        type: 'ordinal',\n\t\n\t        init: function (data, extent) {\n\t            this._data = data;\n\t            this._extent = extent || [0, data.length - 1];\n\t        },\n\t\n\t        parse: function (val) {\n\t            return typeof val === 'string'\n\t                ? zrUtil.indexOf(this._data, val)\n\t                // val might be float.\n\t                : Math.round(val);\n\t        },\n\t\n\t        contain: function (rank) {\n\t            rank = this.parse(rank);\n\t            return scaleProto.contain.call(this, rank)\n\t                && this._data[rank] != null;\n\t        },\n\t\n\t        /**\n\t         * Normalize given rank or name to linear [0, 1]\n\t         * @param {number|string} [val]\n\t         * @return {number}\n\t         */\n\t        normalize: function (val) {\n\t            return scaleProto.normalize.call(this, this.parse(val));\n\t        },\n\t\n\t        scale: function (val) {\n\t            return Math.round(scaleProto.scale.call(this, val));\n\t        },\n\t\n\t        /**\n\t         * @return {Array}\n\t         */\n\t        getTicks: function () {\n\t            var ticks = [];\n\t            var extent = this._extent;\n\t            var rank = extent[0];\n\t\n\t            while (rank <= extent[1]) {\n\t                ticks.push(rank);\n\t                rank++;\n\t            }\n\t\n\t            return ticks;\n\t        },\n\t\n\t        /**\n\t         * Get item on rank n\n\t         * @param {number} n\n\t         * @return {string}\n\t         */\n\t        getLabel: function (n) {\n\t            return this._data[n];\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        count: function () {\n\t            return this._extent[1] - this._extent[0] + 1;\n\t        },\n\t\n\t        niceTicks: zrUtil.noop,\n\t        niceExtent: zrUtil.noop\n\t    });\n\t\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    OrdinalScale.create = function () {\n\t        return new OrdinalScale();\n\t    };\n\t\n\t    module.exports = OrdinalScale;\n\n\n/***/ },\n/* 137 */\n/*!***************************!*\\\n  !*** ./lib/scale/Time.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Interval scale\n\t * @module echarts/coord/scale/Time\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var numberUtil = __webpack_require__(/*! ../util/number */ 4);\n\t    var formatUtil = __webpack_require__(/*! ../util/format */ 9);\n\t\n\t    var IntervalScale = __webpack_require__(/*! ./Interval */ 38);\n\t\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t\n\t    var mathCeil = Math.ceil;\n\t    var mathFloor = Math.floor;\n\t    var ONE_SECOND = 1000;\n\t    var ONE_MINUTE = ONE_SECOND * 60;\n\t    var ONE_HOUR = ONE_MINUTE * 60;\n\t    var ONE_DAY = ONE_HOUR * 24;\n\t\n\t    // FIXME \n\t    var bisect = function (a, x, lo, hi) {\n\t        while (lo < hi) {\n\t            var mid = lo + hi >>> 1;\n\t            if (a[mid][2] < x) {\n\t                lo = mid + 1;\n\t            }\n\t            else {\n\t                hi  = mid;\n\t            }\n\t        }\n\t        return lo;\n\t    };\n\t\n\t    /**\n\t     * @alias module:echarts/coord/scale/Time\n\t     * @constructor\n\t     */\n\t    var TimeScale = IntervalScale.extend({\n\t        type: 'time',\n\t\n\t        // Overwrite\n\t        getLabel: function (val) {\n\t            var stepLvl = this._stepLvl;\n\t\n\t            var date = new Date(val);\n\t\n\t            return formatUtil.formatTime(stepLvl[0], date);\n\t        },\n\t\n\t        // Overwrite\n\t        niceExtent: function (approxTickNum, fixMin, fixMax) {\n\t            var extent = this._extent;\n\t            // If extent start and end are same, expand them\n\t            if (extent[0] === extent[1]) {\n\t                // Expand extent\n\t                extent[0] -= ONE_DAY;\n\t                extent[1] += ONE_DAY;\n\t            }\n\t            // If there are no data and extent are [Infinity, -Infinity]\n\t            if (extent[1] === -Infinity && extent[0] === Infinity) {\n\t                var d = new Date();\n\t                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n\t                extent[0] = extent[1] - ONE_DAY;\n\t            }\n\t\n\t            this.niceTicks(approxTickNum);\n\t\n\t            // var extent = this._extent;\n\t            var interval = this._interval;\n\t\n\t            if (!fixMin) {\n\t                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n\t            }\n\t            if (!fixMax) {\n\t                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n\t            }\n\t        },\n\t\n\t        // Overwrite\n\t        niceTicks: function (approxTickNum) {\n\t            approxTickNum = approxTickNum || 10;\n\t\n\t            var extent = this._extent;\n\t            var span = extent[1] - extent[0];\n\t            var approxInterval = span / approxTickNum;\n\t            var scaleLevelsLen = scaleLevels.length;\n\t            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\t\n\t            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n\t            var interval = level[2];\n\t            // Same with interval scale if span is much larger than 1 year\n\t            if (level[0] === 'year') {\n\t                var yearSpan = span / interval;\n\t\n\t                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n\t                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\t\n\t                interval *= yearStep;\n\t            }\n\t\n\t            var niceExtent = [\n\t                mathCeil(extent[0] / interval) * interval,\n\t                mathFloor(extent[1] / interval) * interval\n\t            ];\n\t\n\t            this._stepLvl = level;\n\t            // Interval will be used in getTicks\n\t            this._interval = interval;\n\t            this._niceExtent = niceExtent;\n\t        },\n\t\n\t        parse: function (val) {\n\t            // val might be float.\n\t            return +numberUtil.parseDate(val);\n\t        }\n\t    });\n\t\n\t    zrUtil.each(['contain', 'normalize'], function (methodName) {\n\t        TimeScale.prototype[methodName] = function (val) {\n\t            return intervalScaleProto[methodName].call(this, this.parse(val));\n\t        };\n\t    });\n\t\n\t    // Steps from d3\n\t    var scaleLevels = [\n\t        // Format       step    interval\n\t        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n\t        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n\t        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n\t        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n\t        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n\t        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n\t        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n\t        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n\t        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n\t        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n\t        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n\t        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n\t        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n\t        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n\t        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n\t        ['week',        7,      ONE_DAY * 7],        // 7d\n\t        ['month',       1,      ONE_DAY * 31],       // 1M\n\t        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n\t        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n\t        ['year',        1,      ONE_DAY * 380]       // 1Y\n\t    ];\n\t\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    TimeScale.create = function () {\n\t        return new TimeScale();\n\t    };\n\t\n\t    module.exports = TimeScale;\n\n\n/***/ },\n/* 138 */\n/*!***********************************!*\\\n  !*** ./lib/visual/seriesColor.js ***!\n  \\***********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var Gradient = __webpack_require__(/*! zrender/lib/graphic/Gradient */ 29);\n\t    module.exports = function (ecModel) {\n\t        function encodeColor(seriesModel) {\n\t            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n\t            var data = seriesModel.getData();\n\t            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n\t                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\t\n\t            // FIXME Set color function or use the platte color\n\t            data.setVisual('color', color);\n\t\n\t            // Only visible series has each data be visual encoded\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                if (typeof color === 'function' && !(color instanceof Gradient)) {\n\t                    data.each(function (idx) {\n\t                        data.setItemVisual(\n\t                            idx, 'color', color(seriesModel.getDataParams(idx))\n\t                        );\n\t                    });\n\t                }\n\t\n\t                // itemStyle in each data item\n\t                data.each(function (idx) {\n\t                    var itemModel = data.getItemModel(idx);\n\t                    var color = itemModel.get(colorAccessPath, true);\n\t                    if (color != null) {\n\t                        data.setItemVisual(idx, 'color', color);\n\t                    }\n\t                });\n\t            }\n\t        }\n\t        ecModel.eachRawSeries(encodeColor);\n\t    };\n\n\n/***/ },\n/* 139 */\n/*!**********************************!*\\\n  !*** ./~/zrender/lib/Handler.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Handler\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(/*! ./core/util */ 1);\n\t    var Draggable = __webpack_require__(/*! ./mixin/Draggable */ 167);\n\t\n\t    var Eventful = __webpack_require__(/*! ./mixin/Eventful */ 20);\n\t\n\t    function makeEventPacket(eveType, target, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            target: target,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta,\n\t            zrByTouch: event.zrByTouch\n\t        };\n\t    }\n\t\n\t    function EmptyProxy () {}\n\t    EmptyProxy.prototype.dispose = function () {};\n\t\n\t    var handlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n\t     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n\t     */\n\t    var Handler = function(storage, painter, proxy, painterRoot) {\n\t        Eventful.call(this);\n\t\n\t        this.storage = storage;\n\t\n\t        this.painter = painter;\n\t\n\t        this.painterRoot = painterRoot;\n\t\n\t        proxy = proxy || new EmptyProxy();\n\t\n\t        /**\n\t         * Proxy of event. can be Dom, WebGLSurface, etc.\n\t         */\n\t        this.proxy = proxy;\n\t\n\t        // Attach handler\n\t        proxy.handler = this;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._hovered;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t\n\t\n\t        Draggable.call(this);\n\t\n\t        util.each(handlerNames, function (name) {\n\t            proxy.on && proxy.on(name, this[name], this);\n\t        }, this);\n\t    };\n\t\n\t    Handler.prototype = {\n\t\n\t        constructor: Handler,\n\t\n\t        mousemove: function (event) {\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t\n\t            var hovered = this.findHover(x, y, null);\n\t            var lastHovered = this._hovered;\n\t            var proxy = this.proxy;\n\t\n\t            this._hovered = hovered;\n\t\n\t            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\t\n\t            // Mouse out on previous hovered element\n\t            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n\t                this.dispatchToElement(lastHovered, 'mouseout', event);\n\t            }\n\t\n\t            // Mouse moving on one element\n\t            this.dispatchToElement(hovered, 'mousemove', event);\n\t\n\t            // Mouse over on a new element\n\t            if (hovered && hovered !== lastHovered) {\n\t                this.dispatchToElement(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t\n\t        mouseout: function (event) {\n\t            this.dispatchToElement(this._hovered, 'mouseout', event);\n\t\n\t            // There might be some doms created by upper layer application\n\t            // at the same level of painter.getViewportRoot() (e.g., tooltip\n\t            // dom created by echarts), where 'globalout' event should not\n\t            // be triggered when mouse enters these doms. (But 'mouseout'\n\t            // should be triggered at the original hovered element as usual).\n\t            var element = event.toElement || event.relatedTarget;\n\t            var innerDom;\n\t            do {\n\t                element = element && element.parentNode;\n\t            }\n\t            while (element && element.nodeType != 9 && !(\n\t                innerDom = element === this.painterRoot\n\t            ));\n\t\n\t            !innerDom && this.trigger('globalout', {event: event});\n\t        },\n\t\n\t        /**\n\t         * Resize\n\t         */\n\t        resize: function (event) {\n\t            this._hovered = null;\n\t        },\n\t\n\t        /**\n\t         * Dispatch event\n\t         * @param {string} eventName\n\t         * @param {event=} eventArgs\n\t         */\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t\n\t        /**\n\t         * Dispose\n\t         */\n\t        dispose: function () {\n\t\n\t            this.proxy.dispose();\n\t\n\t            this.storage =\n\t            this.proxy =\n\t            this.painter = null;\n\t        },\n\t\n\t        /**\n\t         * cursor style\n\t         * @param {string} [cursorStyle='default']  crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            var proxy = this.proxy;\n\t            proxy.setCursor && proxy.setCursor(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * \n\t         *\n\t         * @private\n\t         * @param {Object} targetEl \n\t         * @param {string} eventName \n\t         * @param {Object} event \n\t         */\n\t        dispatchToElement: function (targetEl, eventName, event) {\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\t\n\t            var el = targetEl;\n\t\n\t            while (el) {\n\t                el[eventHandler]\n\t                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t\n\t                el.trigger(eventName, eventPacket);\n\t\n\t                el = el.parent;\n\t\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (!eventPacket.cancelBubble) {\n\t                //  zrender \n\t                this.trigger(eventName, eventPacket);\n\t                // \n\t                //  click  dispose painter \n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof(layer[eventHandler]) == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {module:zrender/graphic/Displayable} exclude\n\t         * @method\n\t         */\n\t        findHover: function(x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            for (var i = list.length - 1; i >= 0 ; i--) {\n\t                if (!list[i].silent\n\t                 && list[i] !== exclude\n\t                 // getDisplayList may include ignored item in VML mode\n\t                 && !list[i].ignore\n\t                 && isHover(list[i], x, y)) {\n\t                    return list[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        Handler.prototype[name] = function (event) {\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY, null);\n\t\n\t            if (name === 'mousedown') {\n\t                this._downel = hovered;\n\t                // In case click triggered before mouseup\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'mosueup') {\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'click') {\n\t                if (this._downel !== this._upel) {\n\t                    return;\n\t                }\n\t            }\n\t\n\t            this.dispatchToElement(hovered, name, event);\n\t        };\n\t    });\n\t\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var el = displayable;\n\t            while (el) {\n\t                // If ancestor is silent or clipped by ancestor\n\t                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n\t                    return false;\n\t                }\n\t                el = el.parent;\n\t            }\n\t            return true;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t\n\t    module.exports = Handler;\n\n\n/***/ },\n/* 140 */\n/*!********************************!*\\\n  !*** ./~/zrender/lib/Layer.js ***!\n  \\********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/Layer\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(/*! ./core/util */ 1);\n\t    var config = __webpack_require__(/*! ./config */ 33);\n\t    var Style = __webpack_require__(/*! ./graphic/Style */ 64);\n\t    var Pattern = __webpack_require__(/*! ./graphic/Pattern */ 63);\n\t\n\t    function returnFalse() {\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * dom\n\t     *\n\t     * @inner\n\t     * @param {string} id dom id \n\t     * @param {string} type dom typesuch as canvas, div etc.\n\t     * @param {Painter} painter painter instance\n\t     * @param {number} number\n\t     */\n\t    function createDom(id, type, painter, dpr) {\n\t        var newDom = document.createElement(type);\n\t        var width = painter.getWidth();\n\t        var height = painter.getHeight();\n\t\n\t        var newDomStyle = newDom.style;\n\t        // append~\n\t        newDomStyle.position = 'absolute';\n\t        newDomStyle.left = 0;\n\t        newDomStyle.top = 0;\n\t        newDomStyle.width = width + 'px';\n\t        newDomStyle.height = height + 'px';\n\t        newDom.width = width * dpr;\n\t        newDom.height = height * dpr;\n\t\n\t        // id\n\t        newDom.setAttribute('data-zr-dom-id', id);\n\t        return newDom;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Layer\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @param {string} id\n\t     * @param {module:zrender/Painter} painter\n\t     * @param {number} [dpr]\n\t     */\n\t    var Layer = function(id, painter, dpr) {\n\t        var dom;\n\t        dpr = dpr || config.devicePixelRatio;\n\t        if (typeof id === 'string') {\n\t            dom = createDom(id, 'canvas', painter, dpr);\n\t        }\n\t        // Not using isDom because in node it will return false\n\t        else if (util.isObject(id)) {\n\t            dom = id;\n\t            id = dom.id;\n\t        }\n\t        this.id = id;\n\t        this.dom = dom;\n\t\n\t        var domStyle = dom.style;\n\t        if (domStyle) { // Not in node\n\t            dom.onselectstart = returnFalse; // \n\t            domStyle['-webkit-user-select'] = 'none';\n\t            domStyle['user-select'] = 'none';\n\t            domStyle['-webkit-touch-callout'] = 'none';\n\t            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t            domStyle['padding'] = 0;\n\t            domStyle['margin'] = 0;\n\t            domStyle['border-width'] = 0;\n\t        }\n\t\n\t        this.domBack = null;\n\t        this.ctxBack = null;\n\t\n\t        this.painter = painter;\n\t\n\t        this.config = null;\n\t\n\t        // Configs\n\t        /**\n\t         * \n\t         * @type {string}\n\t         * @default 0\n\t         */\n\t        this.clearColor = 0;\n\t        /**\n\t         * \n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        this.motionBlur = false;\n\t        /**\n\t         * alpha\n\t         * @type {number}\n\t         * @default 0.7\n\t         */\n\t        this.lastFrameAlpha = 0.7;\n\t\n\t        /**\n\t         * Layer dpr\n\t         * @type {number}\n\t         */\n\t        this.dpr = dpr;\n\t    };\n\t\n\t    Layer.prototype = {\n\t\n\t        constructor: Layer,\n\t\n\t        elCount: 0,\n\t\n\t        __dirty: true,\n\t\n\t        initContext: function () {\n\t            this.ctx = this.dom.getContext('2d');\n\t\n\t            this.ctx.dpr = this.dpr;\n\t        },\n\t\n\t        createBackBuffer: function () {\n\t            var dpr = this.dpr;\n\t\n\t            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n\t            this.ctxBack = this.domBack.getContext('2d');\n\t\n\t            if (dpr != 1) {\n\t                this.ctxBack.scale(dpr, dpr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param  {number} width\n\t         * @param  {number} height\n\t         */\n\t        resize: function (width, height) {\n\t            var dpr = this.dpr;\n\t\n\t            var dom = this.dom;\n\t            var domStyle = dom.style;\n\t            var domBack = this.domBack;\n\t\n\t            domStyle.width = width + 'px';\n\t            domStyle.height = height + 'px';\n\t\n\t            dom.width = width * dpr;\n\t            dom.height = height * dpr;\n\t\n\t            if (domBack) {\n\t                domBack.width = width * dpr;\n\t                domBack.height = height * dpr;\n\t\n\t                if (dpr != 1) {\n\t                    this.ctxBack.scale(dpr, dpr);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} clearAll Clear all with out motion blur\n\t         */\n\t        clear: function (clearAll) {\n\t            var dom = this.dom;\n\t            var ctx = this.ctx;\n\t            var width = dom.width;\n\t            var height = dom.height;\n\t\n\t            var clearColor = this.clearColor;\n\t            var haveMotionBLur = this.motionBlur && !clearAll;\n\t            var lastFrameAlpha = this.lastFrameAlpha;\n\t\n\t            var dpr = this.dpr;\n\t\n\t            if (haveMotionBLur) {\n\t                if (!this.domBack) {\n\t                    this.createBackBuffer();\n\t                }\n\t\n\t                this.ctxBack.globalCompositeOperation = 'copy';\n\t                this.ctxBack.drawImage(\n\t                    dom, 0, 0,\n\t                    width / dpr,\n\t                    height / dpr\n\t                );\n\t            }\n\t\n\t            ctx.clearRect(0, 0, width, height);\n\t            if (clearColor) {\n\t                var clearColorGradientOrPattern;\n\t                // Gradient\n\t                if (clearColor.colorStops) {\n\t                    // Cache canvas gradient\n\t                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t                        x: 0,\n\t                        y: 0,\n\t                        width: width,\n\t                        height: height\n\t                    });\n\t\n\t                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t                }\n\t                // Pattern\n\t                else if (clearColor.image) {\n\t                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t                }\n\t                ctx.save();\n\t                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t                ctx.fillRect(0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t\n\t            if (haveMotionBLur) {\n\t                var domBack = this.domBack;\n\t                ctx.save();\n\t                ctx.globalAlpha = lastFrameAlpha;\n\t                ctx.drawImage(domBack, 0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Layer;\n\n\n/***/ },\n/* 141 */\n/*!**********************************!*\\\n  !*** ./~/zrender/lib/Painter.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Default canvas painter\n\t * @module zrender/Painter\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t \n\t\n\t    var config = __webpack_require__(/*! ./config */ 33);\n\t    var util = __webpack_require__(/*! ./core/util */ 1);\n\t    var log = __webpack_require__(/*! ./core/log */ 47);\n\t    var BoundingRect = __webpack_require__(/*! ./core/BoundingRect */ 8);\n\t    var timsort = __webpack_require__(/*! ./core/timsort */ 44);\n\t\n\t    var Layer = __webpack_require__(/*! ./Layer */ 140);\n\t\n\t    var requestAnimationFrame = __webpack_require__(/*! ./animation/requestAnimationFrame */ 60);\n\t\n\t    // PENDIGN\n\t    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t    //\n\t    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\t    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    function isLayerValid(layer) {\n\t        if (!layer) {\n\t            return false;\n\t        }\n\t\n\t        if (layer.isBuildin) {\n\t            return true;\n\t        }\n\t\n\t        if (typeof(layer.resize) !== 'function'\n\t            || typeof(layer.refresh) !== 'function'\n\t        ) {\n\t            return false;\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    function preProcessLayer(layer) {\n\t        layer.__unusedCount++;\n\t    }\n\t\n\t    function postProcessLayer(layer) {\n\t        if (layer.__unusedCount == 1) {\n\t            layer.clear();\n\t        }\n\t    }\n\t\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var viewRect = new BoundingRect(0, 0, 0, 0);\n\t    function isDisplayableCulled(el, width, height) {\n\t        tmpRect.copy(el.getBoundingRect());\n\t        if (el.transform) {\n\t            tmpRect.applyTransform(el.transform);\n\t        }\n\t        viewRect.width = width;\n\t        viewRect.height = height;\n\t        return !tmpRect.intersect(viewRect);\n\t    }\n\t\n\t    function isClipPathChanged(clipPaths, prevClipPaths) {\n\t        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n\t            return false;\n\t        }\n\t\n\t        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n\t            return true;\n\t        }\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            if (clipPaths[i] !== prevClipPaths[i]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t\n\t    function doClip(clipPaths, ctx) {\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            var clipPath = clipPaths[i];\n\t            var path = clipPath.path;\n\t\n\t            clipPath.setTransform(ctx);\n\t            path.beginPath(ctx);\n\t            clipPath.buildPath(path, clipPath.shape);\n\t            ctx.clip();\n\t            // Transform back\n\t            clipPath.restoreTransform(ctx);\n\t        }\n\t    }\n\t\n\t    function createRoot(width, height) {\n\t        var domRoot = document.createElement('div');\n\t\n\t        // domRoot.onselectstart = returnFalse; // \n\t        domRoot.style.cssText = [\n\t            'position:relative',\n\t            'overflow:hidden',\n\t            'width:' + width + 'px',\n\t            'height:' + height + 'px',\n\t            'padding:0',\n\t            'margin:0',\n\t            'border-width:0'\n\t        ].join(';') + ';';\n\t\n\t        return domRoot;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Painter\n\t     * @constructor\n\t     * @param {HTMLElement} root \n\t     * @param {module:zrender/Storage} storage\n\t     * @param {Ojbect} opts\n\t     */\n\t    var Painter = function (root, storage, opts) {\n\t        // In node environment using node-canvas\n\t        var singleCanvas = !root.nodeName // In node ?\n\t            || root.nodeName.toUpperCase() === 'CANVAS';\n\t\n\t        this._opts = opts = util.extend({}, opts || {});\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._singleCanvas = singleCanvas;\n\t        /**\n\t         * \n\t         * @type {HTMLElement}\n\t         */\n\t        this.root = root;\n\t\n\t        var rootStyle = root.style;\n\t\n\t        if (rootStyle) {\n\t            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t            rootStyle['-webkit-user-select'] =\n\t            rootStyle['user-select'] =\n\t            rootStyle['-webkit-touch-callout'] = 'none';\n\t\n\t            root.innerHTML = '';\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/Storage}\n\t         */\n\t        this.storage = storage;\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        var zlevelList = this._zlevelList = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:zrender/Layer>}\n\t         * @private\n\t         */\n\t        var layers = this._layers = {};\n\t\n\t        /**\n\t         * @type {Object.<string, Object>}\n\t         * @type {private}\n\t         */\n\t        this._layerConfig = {};\n\t\n\t        if (!singleCanvas) {\n\t            this._width = this._getSize(0);\n\t            this._height = this._getSize(1);\n\t\n\t            var domRoot = this._domRoot = createRoot(\n\t                this._width, this._height\n\t            );\n\t            root.appendChild(domRoot);\n\t        }\n\t        else {\n\t            // Use canvas width and height directly\n\t            var width = root.width;\n\t            var height = root.height;\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            // Create layer if only one given canvas\n\t            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t            var mainLayer = new Layer(root, this, 1);\n\t            mainLayer.initContext();\n\t            // FIXME Use canvas width and height\n\t            // mainLayer.resize(width, height);\n\t            layers[0] = mainLayer;\n\t            zlevelList.push(0);\n\t        }\n\t\n\t        this.pathToImage = this._createPathToImage();\n\t\n\t        // Layers for progressive rendering\n\t        this._progressiveLayers = [];\n\t\n\t        /**\n\t         * @type {module:zrender/Layer}\n\t         * @private\n\t         */\n\t        this._hoverlayer;\n\t\n\t        this._hoverElements = [];\n\t    };\n\t\n\t    Painter.prototype = {\n\t\n\t        constructor: Painter,\n\t\n\t        /**\n\t         * If painter use a single canvas\n\t         * @return {boolean}\n\t         */\n\t        isSingleCanvas: function () {\n\t            return this._singleCanvas;\n\t        },\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} [paintAll=false] displayable\n\t         */\n\t        refresh: function (paintAll) {\n\t\n\t            var list = this.storage.getDisplayList(true);\n\t\n\t            var zlevelList = this._zlevelList;\n\t\n\t            this._paintList(list, paintAll);\n\t\n\t            // Paint custum layers\n\t            for (var i = 0; i < zlevelList.length; i++) {\n\t                var z = zlevelList[i];\n\t                var layer = this._layers[z];\n\t                if (!layer.isBuildin && layer.refresh) {\n\t                    layer.refresh();\n\t                }\n\t            }\n\t\n\t            this.refreshHover();\n\t\n\t            if (this._progressiveLayers.length) {\n\t                this._startProgessive();\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        addHover: function (el, hoverStyle) {\n\t            if (el.__hoverMir) {\n\t                return;\n\t            }\n\t            var elMirror = new el.constructor({\n\t                style: el.style,\n\t                shape: el.shape\n\t            });\n\t            elMirror.__from = el;\n\t            el.__hoverMir = elMirror;\n\t            elMirror.setStyle(hoverStyle);\n\t            this._hoverElements.push(elMirror);\n\t        },\n\t\n\t        removeHover: function (el) {\n\t            var elMirror = el.__hoverMir;\n\t            var hoverElements = this._hoverElements;\n\t            var idx = util.indexOf(hoverElements, elMirror);\n\t            if (idx >= 0) {\n\t                hoverElements.splice(idx, 1);\n\t            }\n\t            el.__hoverMir = null;\n\t        },\n\t\n\t        clearHover: function (el) {\n\t            var hoverElements = this._hoverElements;\n\t            for (var i = 0; i < hoverElements.length; i++) {\n\t                var from = hoverElements[i].__from;\n\t                if (from) {\n\t                    from.__hoverMir = null;\n\t                }\n\t            }\n\t            hoverElements.length = 0;\n\t        },\n\t\n\t        refreshHover: function () {\n\t            var hoverElements = this._hoverElements;\n\t            var len = hoverElements.length;\n\t            var hoverLayer = this._hoverlayer;\n\t            hoverLayer && hoverLayer.clear();\n\t\n\t            if (!len) {\n\t                return;\n\t            }\n\t            timsort(hoverElements, this.storage.displayableSortFunc);\n\t\n\t            // Use a extream large zlevel\n\t            // FIXME?\n\t            if (!hoverLayer) {\n\t                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n\t            }\n\t\n\t            var scope = {};\n\t            hoverLayer.ctx.save();\n\t            for (var i = 0; i < len;) {\n\t                var el = hoverElements[i];\n\t                var originalEl = el.__from;\n\t                // Original el is removed\n\t                // PENDING\n\t                if (!(originalEl && originalEl.__zr)) {\n\t                    hoverElements.splice(i, 1);\n\t                    originalEl.__hoverMir = null;\n\t                    len--;\n\t                    continue;\n\t                }\n\t                i++;\n\t\n\t                // Use transform\n\t                // FIXME style and shape ?\n\t                if (!originalEl.invisible) {\n\t                    el.transform = originalEl.transform;\n\t                    el.invTransform = originalEl.invTransform;\n\t                    el.__clipPaths = originalEl.__clipPaths;\n\t                    // el.\n\t                    this._doPaintEl(el, hoverLayer, true, scope);\n\t                }\n\t            }\n\t            hoverLayer.ctx.restore();\n\t        },\n\t\n\t        _startProgessive: function () {\n\t            var self = this;\n\t\n\t            if (!self._furtherProgressive) {\n\t                return;\n\t            }\n\t\n\t            // Use a token to stop progress steps triggered by\n\t            // previous zr.refresh calling.\n\t            var token = self._progressiveToken = +new Date();\n\t\n\t            self._progress++;\n\t            requestAnimationFrame(step);\n\t\n\t            function step() {\n\t                // In case refreshed or disposed\n\t                if (token === self._progressiveToken && self.storage) {\n\t\n\t                    self._doPaintList(self.storage.getDisplayList());\n\t\n\t                    if (self._furtherProgressive) {\n\t                        self._progress++;\n\t                        requestAnimationFrame(step);\n\t                    }\n\t                    else {\n\t                        self._progressiveToken = -1;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _clearProgressive: function () {\n\t            this._progressiveToken = -1;\n\t            this._progress = 0;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                layer.__dirty && layer.clear();\n\t            });\n\t        },\n\t\n\t        _paintList: function (list, paintAll) {\n\t\n\t            if (paintAll == null) {\n\t                paintAll = false;\n\t            }\n\t\n\t            this._updateLayerStatus(list);\n\t\n\t            this._clearProgressive();\n\t\n\t            this.eachBuildinLayer(preProcessLayer);\n\t\n\t            this._doPaintList(list, paintAll);\n\t\n\t            this.eachBuildinLayer(postProcessLayer);\n\t        },\n\t\n\t        _doPaintList: function (list, paintAll) {\n\t            var currentLayer;\n\t            var currentZLevel;\n\t            var ctx;\n\t\n\t            // var invTransform = [];\n\t            var scope;\n\t\n\t            var progressiveLayerIdx = 0;\n\t            var currentProgressiveLayer;\n\t\n\t            var width = this._width;\n\t            var height = this._height;\n\t            var layerProgress;\n\t            var frame = this._progress;\n\t            function flushProgressiveLayer(layer) {\n\t                var dpr = ctx.dpr || 1;\n\t                ctx.save();\n\t                ctx.globalAlpha = 1;\n\t                ctx.shadowBlur = 0;\n\t                // Avoid layer don't clear in next progressive frame\n\t                currentLayer.__dirty = true;\n\t                ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t                ctx.restore();\n\t            }\n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t\n\t                var elFrame = el.__frame;\n\t\n\t                // Flush at current context\n\t                // PENDING\n\t                if (elFrame < 0 && currentProgressiveLayer) {\n\t                    flushProgressiveLayer(currentProgressiveLayer);\n\t                    currentProgressiveLayer = null;\n\t                }\n\t\n\t                // Change draw layer\n\t                if (currentZLevel !== elZLevel) {\n\t                    if (ctx) {\n\t                        ctx.restore();\n\t                    }\n\t\n\t                    // Reset scope\n\t                    scope = {};\n\t\n\t                    // Only 0 zlevel if only has one canvas\n\t                    currentZLevel = elZLevel;\n\t                    currentLayer = this.getLayer(currentZLevel);\n\t\n\t                    if (!currentLayer.isBuildin) {\n\t                        log(\n\t                            'ZLevel ' + currentZLevel\n\t                            + ' has been used by unkown layer ' + currentLayer.id\n\t                        );\n\t                    }\n\t\n\t                    ctx = currentLayer.ctx;\n\t                    ctx.save();\n\t\n\t                    // Reset the count\n\t                    currentLayer.__unusedCount = 0;\n\t\n\t                    if (currentLayer.__dirty || paintAll) {\n\t                        currentLayer.clear();\n\t                    }\n\t                }\n\t\n\t                if (!(currentLayer.__dirty || paintAll)) {\n\t                    continue;\n\t                }\n\t\n\t                if (elFrame >= 0) {\n\t                    // Progressive layer changed\n\t                    if (!currentProgressiveLayer) {\n\t                        currentProgressiveLayer = this._progressiveLayers[\n\t                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n\t                        ];\n\t\n\t                        currentProgressiveLayer.ctx.save();\n\t                        currentProgressiveLayer.renderScope = {};\n\t\n\t                        if (currentProgressiveLayer\n\t                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n\t                        ) {\n\t                            // flushProgressiveLayer(currentProgressiveLayer);\n\t                            // Quick jump all progressive elements\n\t                            // All progressive element are not dirty, jump over and flush directly\n\t                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n\t                            // currentProgressiveLayer = null;\n\t                            continue;\n\t                        }\n\t\n\t                        layerProgress = currentProgressiveLayer.__progress;\n\t\n\t                        if (!currentProgressiveLayer.__dirty) {\n\t                            // Keep rendering\n\t                            frame = layerProgress;\n\t                        }\n\t\n\t                        currentProgressiveLayer.__progress = frame + 1;\n\t                    }\n\t\n\t                    if (elFrame === frame) {\n\t                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t                    }\n\t                }\n\t                else {\n\t                    this._doPaintEl(el, currentLayer, paintAll, scope);\n\t                }\n\t\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                flushProgressiveLayer(currentProgressiveLayer);\n\t            }\n\t\n\t            // Restore the lastLayer ctx\n\t            ctx && ctx.restore();\n\t            // If still has clipping state\n\t            // if (scope.prevElClipPaths) {\n\t            //     ctx.restore();\n\t            // }\n\t\n\t            this._furtherProgressive = false;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                if (layer.__maxProgress >= layer.__progress) {\n\t                    this._furtherProgressive = true;\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t            var ctx = currentLayer.ctx;\n\t            var m = el.transform;\n\t            if (\n\t                (currentLayer.__dirty || forcePaint)\n\t                // Ignore invisible element\n\t                && !el.invisible\n\t                // Ignore transparent element\n\t                && el.style.opacity !== 0\n\t                // Ignore scale 0 element, in some environment like node-canvas\n\t                // Draw a scale 0 element can cause all following draw wrong\n\t                // And setTransform with scale 0 will cause set back transform failed.\n\t                && !(m && !m[0] && !m[3])\n\t                // Ignore culled element\n\t                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n\t            ) {\n\t\n\t                var clipPaths = el.__clipPaths;\n\t\n\t                // Optimize when clipping on group with several elements\n\t                if (scope.prevClipLayer !== currentLayer\n\t                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n\t                ) {\n\t                    // If has previous clipping state, restore from it\n\t                    if (scope.prevElClipPaths) {\n\t                        scope.prevClipLayer.ctx.restore();\n\t                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\t\n\t                        // Reset prevEl since context has been restored\n\t                        scope.prevEl = null;\n\t                    }\n\t                    // New clipping state\n\t                    if (clipPaths) {\n\t                        ctx.save();\n\t                        doClip(clipPaths, ctx);\n\t                        scope.prevClipLayer = currentLayer;\n\t                        scope.prevElClipPaths = clipPaths;\n\t                    }\n\t                }\n\t                el.beforeBrush && el.beforeBrush(ctx);\n\t\n\t                el.brush(ctx, scope.prevEl || null);\n\t                scope.prevEl = el;\n\t\n\t                el.afterBrush && el.afterBrush(ctx);\n\t            }\n\t        },\n\t\n\t        /**\n\t         *  zlevel \n\t         * @param {number} zlevel\n\t         * @return {module:zrender/Layer}\n\t         */\n\t        getLayer: function (zlevel) {\n\t            if (this._singleCanvas) {\n\t                return this._layers[0];\n\t            }\n\t\n\t            var layer = this._layers[zlevel];\n\t            if (!layer) {\n\t                // Create a new layer\n\t                layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t                layer.isBuildin = true;\n\t\n\t                if (this._layerConfig[zlevel]) {\n\t                    util.merge(layer, this._layerConfig[zlevel], true);\n\t                }\n\t\n\t                this.insertLayer(zlevel, layer);\n\t\n\t                // Context is created after dom inserted to document\n\t                // Or excanvas will get 0px clientWidth and clientHeight\n\t                layer.initContext();\n\t            }\n\t\n\t            return layer;\n\t        },\n\t\n\t        insertLayer: function (zlevel, layer) {\n\t\n\t            var layersMap = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var len = zlevelList.length;\n\t            var prevLayer = null;\n\t            var i = -1;\n\t            var domRoot = this._domRoot;\n\t\n\t            if (layersMap[zlevel]) {\n\t                log('ZLevel ' + zlevel + ' has been used already');\n\t                return;\n\t            }\n\t            // Check if is a valid layer\n\t            if (!isLayerValid(layer)) {\n\t                log('Layer of zlevel ' + zlevel + ' is not valid');\n\t                return;\n\t            }\n\t\n\t            if (len > 0 && zlevel > zlevelList[0]) {\n\t                for (i = 0; i < len - 1; i++) {\n\t                    if (\n\t                        zlevelList[i] < zlevel\n\t                        && zlevelList[i + 1] > zlevel\n\t                    ) {\n\t                        break;\n\t                    }\n\t                }\n\t                prevLayer = layersMap[zlevelList[i]];\n\t            }\n\t            zlevelList.splice(i + 1, 0, zlevel);\n\t\n\t            if (prevLayer) {\n\t                var prevDom = prevLayer.dom;\n\t                if (prevDom.nextSibling) {\n\t                    domRoot.insertBefore(\n\t                        layer.dom,\n\t                        prevDom.nextSibling\n\t                    );\n\t                }\n\t                else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t            else {\n\t                if (domRoot.firstChild) {\n\t                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t                }\n\t                else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t\n\t            layersMap[zlevel] = layer;\n\t        },\n\t\n\t        // Iterate each layer\n\t        eachLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                cb.call(context, this._layers[z], z);\n\t            }\n\t        },\n\t\n\t        // Iterate each buildin layer\n\t        eachBuildinLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        // Iterate each other layer except buildin layer\n\t        eachOtherLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (! layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t         */\n\t        getLayers: function () {\n\t            return this._layers;\n\t        },\n\t\n\t        _updateLayerStatus: function (list) {\n\t\n\t            var layers = this._layers;\n\t            var progressiveLayers = this._progressiveLayers;\n\t\n\t            var elCountsLastFrame = {};\n\t            var progressiveElCountsLastFrame = {};\n\t\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                elCountsLastFrame[z] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                progressiveElCountsLastFrame[idx] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            var progressiveLayerCount = 0;\n\t            var currentProgressiveLayer;\n\t            var lastProgressiveKey;\n\t            var frameCount = 0;\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var layer = layers[zlevel];\n\t                var elProgress = el.progressive;\n\t                if (layer) {\n\t                    layer.elCount++;\n\t                    layer.__dirty = layer.__dirty || el.__dirty;\n\t                }\n\t\n\t                /////// Update progressive\n\t                if (elProgress >= 0) {\n\t                    // Fix wrong progressive sequence problem.\n\t                    if (lastProgressiveKey !== elProgress) {\n\t                        lastProgressiveKey = elProgress;\n\t                        frameCount++;\n\t                    }\n\t                    var elFrame = el.__frame = frameCount - 1;\n\t                    if (!currentProgressiveLayer) {\n\t                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t                        currentProgressiveLayer = progressiveLayers[idx];\n\t                        if (!currentProgressiveLayer) {\n\t                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n\t                                'progressive', this, this.dpr\n\t                            );\n\t                            currentProgressiveLayer.initContext();\n\t                        }\n\t                        currentProgressiveLayer.__maxProgress = 0;\n\t                    }\n\t                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t                    currentProgressiveLayer.elCount++;\n\t\n\t                    currentProgressiveLayer.__maxProgress = Math.max(\n\t                        currentProgressiveLayer.__maxProgress, elFrame\n\t                    );\n\t\n\t                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t                        // Should keep rendering this  layer because progressive rendering is not finished yet\n\t                        layer.__dirty = true;\n\t                    }\n\t                }\n\t                else {\n\t                    el.__frame = -1;\n\t\n\t                    if (currentProgressiveLayer) {\n\t                        currentProgressiveLayer.__nextIdxNotProg = i;\n\t                        progressiveLayerCount++;\n\t                        currentProgressiveLayer = null;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                progressiveLayerCount++;\n\t                currentProgressiveLayer.__nextIdxNotProg = i;\n\t            }\n\t\n\t            // \n\t            this.eachBuildinLayer(function (layer, z) {\n\t                if (elCountsLastFrame[z] !== layer.elCount) {\n\t                    layer.__dirty = true;\n\t                }\n\t            });\n\t\n\t            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t                    el.__dirty = true;\n\t                }\n\t                if (layer.__dirty) {\n\t                    layer.__progress = 0;\n\t                }\n\t            });\n\t        },\n\t\n\t        /**\n\t         * hover\n\t         */\n\t        clear: function () {\n\t            this.eachBuildinLayer(this._clearLayer);\n\t            return this;\n\t        },\n\t\n\t        _clearLayer: function (layer) {\n\t            layer.clear();\n\t        },\n\t\n\t        /**\n\t         * zlevel\n\t         *\n\t         * @param {string} zlevel\n\t         * @param {Object} config \n\t         * @param {string} [config.clearColor=0] \n\t         * @param {string} [config.motionBlur=false] \n\t         * @param {number} [config.lastFrameAlpha=0.7]\n\t         *                 alpha\n\t         */\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                }\n\t                else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t\n\t                var layer = this._layers[zlevel];\n\t\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {number} zlevel zlevel\n\t         */\n\t        delLayer: function (zlevel) {\n\t            var layers = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var layer = layers[zlevel];\n\t            if (!layer) {\n\t                return;\n\t            }\n\t            layer.dom.parentNode.removeChild(layer.dom);\n\t            delete layers[zlevel];\n\t\n\t            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        resize: function (width, height) {\n\t            var domRoot = this._domRoot;\n\t            // FIXME Why ?\n\t            domRoot.style.display = 'none';\n\t\n\t            // Save input w/h\n\t            var opts = this._opts;\n\t            width != null && (opts.width = width);\n\t            height != null && (opts.height = height);\n\t\n\t            width = this._getSize(0);\n\t            height = this._getSize(1);\n\t\n\t            domRoot.style.display = '';\n\t\n\t            // resize\n\t            if (this._width != width || height != this._height) {\n\t                domRoot.style.width = width + 'px';\n\t                domRoot.style.height = height + 'px';\n\t\n\t                for (var id in this._layers) {\n\t                    if (this._layers.hasOwnProperty(id)) {\n\t                        this._layers[id].resize(width, height);\n\t                    }\n\t                }\n\t                util.each(this._progressiveLayers, function (layer) {\n\t                    layer.resize(width, height);\n\t                });\n\t\n\t                this.refresh(true);\n\t            }\n\t\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {number} zlevel\n\t         */\n\t        clearLayer: function (zlevel) {\n\t            var layer = this._layers[zlevel];\n\t            if (layer) {\n\t                layer.clear();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this.root =\n\t            this.storage =\n\t\n\t            this._domRoot =\n\t            this._layers = null;\n\t        },\n\t\n\t        /**\n\t         * Get canvas which has all thing rendered\n\t         * @param {Object} opts\n\t         * @param {string} [opts.backgroundColor]\n\t         */\n\t        getRenderedCanvas: function (opts) {\n\t            opts = opts || {};\n\t            if (this._singleCanvas) {\n\t                return this._layers[0].dom;\n\t            }\n\t\n\t            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t            imageLayer.initContext();\n\t\n\t            imageLayer.clearColor = opts.backgroundColor;\n\t            imageLayer.clear();\n\t\n\t            var displayList = this.storage.getDisplayList(true);\n\t\n\t            var scope = {};\n\t            for (var i = 0; i < displayList.length; i++) {\n\t                var el = displayList[i];\n\t                this._doPaintEl(el, imageLayer, true, scope);\n\t            }\n\t\n\t            return imageLayer.dom;\n\t        },\n\t        /**\n\t         * \n\t         */\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        _getSize: function (whIdx) {\n\t            var opts = this._opts;\n\t            var wh = ['width', 'height'][whIdx];\n\t            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n\t            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n\t            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\t\n\t            if (opts[wh] != null && opts[wh] !== 'auto') {\n\t                return parseFloat(opts[wh]);\n\t            }\n\t\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t\n\t            return (\n\t                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n\t                - (parseInt10(stl[plt]) || 0)\n\t                - (parseInt10(stl[prb]) || 0)\n\t            ) | 0;\n\t        },\n\t\n\t        _pathToImage: function (id, path, width, height, dpr) {\n\t            var canvas = document.createElement('canvas');\n\t            var ctx = canvas.getContext('2d');\n\t\n\t            canvas.width = width * dpr;\n\t            canvas.height = height * dpr;\n\t\n\t            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\t\n\t            var pathTransform = {\n\t                position: path.position,\n\t                rotation: path.rotation,\n\t                scale: path.scale\n\t            };\n\t            path.position = [0, 0, 0];\n\t            path.rotation = 0;\n\t            path.scale = [1, 1];\n\t            if (path) {\n\t                path.brush(ctx);\n\t            }\n\t\n\t            var ImageShape = __webpack_require__(/*! ./graphic/Image */ 48);\n\t            var imgShape = new ImageShape({\n\t                id: id,\n\t                style: {\n\t                    x: 0,\n\t                    y: 0,\n\t                    image: canvas\n\t                }\n\t            });\n\t\n\t            if (pathTransform.position != null) {\n\t                imgShape.position = path.position = pathTransform.position;\n\t            }\n\t\n\t            if (pathTransform.rotation != null) {\n\t                imgShape.rotation = path.rotation = pathTransform.rotation;\n\t            }\n\t\n\t            if (pathTransform.scale != null) {\n\t                imgShape.scale = path.scale = pathTransform.scale;\n\t            }\n\t\n\t            return imgShape;\n\t        },\n\t\n\t        _createPathToImage: function () {\n\t            var me = this;\n\t\n\t            return function (id, e, width, height) {\n\t                return me._pathToImage(\n\t                    id, e, width, height, me.dpr\n\t                );\n\t            };\n\t        }\n\t    };\n\t\n\t    module.exports = Painter;\n\t\n\n\n/***/ },\n/* 142 */\n/*!**********************************!*\\\n  !*** ./~/zrender/lib/Storage.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Storage\n\t * @module zrender/Storage\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t * @author errorrik (errorrik@gmail.com)\n\t * @author pissang (https://github.com/pissang/)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(/*! ./core/util */ 1);\n\t    var env = __webpack_require__(/*! ./core/env */ 11);\n\t\n\t    var Group = __webpack_require__(/*! ./container/Group */ 34);\n\t\n\t    // Use timsort because in most case elements are partially sorted\n\t    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n\t    var timsort = __webpack_require__(/*! ./core/timsort */ 44);\n\t\n\t    function shapeCompareFunc(a, b) {\n\t        if (a.zlevel === b.zlevel) {\n\t            if (a.z === b.z) {\n\t                // if (a.z2 === b.z2) {\n\t                //     // FIXME Slow has renderidx compare\n\t                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t                //     return a.__renderidx - b.__renderidx;\n\t                // }\n\t                return a.z2 - b.z2;\n\t            }\n\t            return a.z - b.z;\n\t        }\n\t        return a.zlevel - b.zlevel;\n\t    }\n\t    /**\n\t     *  (M)\n\t     * @alias module:zrender/Storage\n\t     * @constructor\n\t     */\n\t    var Storage = function () {\n\t        // idmap\n\t        this._elements = {};\n\t\n\t        this._roots = [];\n\t\n\t        this._displayList = [];\n\t\n\t        this._displayListLen = 0;\n\t    };\n\t\n\t    Storage.prototype = {\n\t\n\t        constructor: Storage,\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         *\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._roots.length; i++) {\n\t                this._roots[i].traverse(cb, context);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} [update=false] \n\t         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n\t         *\n\t         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t         * @return {Array.<module:zrender/graphic/Displayable>}\n\t         */\n\t        getDisplayList: function (update, includeIgnore) {\n\t            includeIgnore = includeIgnore || false;\n\t            if (update) {\n\t                this.updateDisplayList(includeIgnore);\n\t            }\n\t            return this._displayList;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * GroupShapeShape\n\t         * zlevel > z > \n\t         * @param {boolean} [includeIgnore=false]  ignore \n\t         */\n\t        updateDisplayList: function (includeIgnore) {\n\t            this._displayListLen = 0;\n\t            var roots = this._roots;\n\t            var displayList = this._displayList;\n\t            for (var i = 0, len = roots.length; i < len; i++) {\n\t                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t            }\n\t            displayList.length = this._displayListLen;\n\t\n\t            // for (var i = 0, len = displayList.length; i < len; i++) {\n\t            //     displayList[i].__renderidx = i;\n\t            // }\n\t\n\t            // displayList.sort(shapeCompareFunc);\n\t            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t        },\n\t\n\t        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t\n\t            if (el.ignore && !includeIgnore) {\n\t                return;\n\t            }\n\t\n\t            el.beforeUpdate();\n\t\n\t            if (el.__dirty) {\n\t\n\t                el.update();\n\t\n\t            }\n\t\n\t            el.afterUpdate();\n\t\n\t            var clipPath = el.clipPath;\n\t            if (clipPath) {\n\t                // clipPath  group \n\t                clipPath.parent = el;\n\t                clipPath.updateTransform();\n\t\n\t                // FIXME \n\t                if (clipPaths) {\n\t                    clipPaths = clipPaths.slice();\n\t                    clipPaths.push(clipPath);\n\t                }\n\t                else {\n\t                    clipPaths = [clipPath];\n\t                }\n\t            }\n\t\n\t            if (el.isGroup) {\n\t                var children = el._children;\n\t\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var child = children[i];\n\t\n\t                    // Force to mark as dirty if group is dirty\n\t                    // FIXME __dirtyPath ?\n\t                    if (el.__dirty) {\n\t                        child.__dirty = true;\n\t                    }\n\t\n\t                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t                }\n\t\n\t                // Mark group clean here\n\t                el.__dirty = false;\n\t\n\t            }\n\t            else {\n\t                el.__clipPaths = clipPaths;\n\t\n\t                this._displayList[this._displayListLen++] = el;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * (Shape)(Group)\n\t         * @param {module:zrender/Element} el\n\t         */\n\t        addRoot: function (el) {\n\t            // Element has been added\n\t            if (this._elements[el.id]) {\n\t                return;\n\t            }\n\t\n\t            if (el instanceof Group) {\n\t                el.addChildrenToStorage(this);\n\t            }\n\t\n\t            this.addToMap(el);\n\t            this._roots.push(el);\n\t        },\n\t\n\t        /**\n\t         * (Shape)(Group)\n\t         * @param {string|Array.<string>} [elId] Storage\n\t         */\n\t        delRoot: function (elId) {\n\t            if (elId == null) {\n\t                // elId\n\t                for (var i = 0; i < this._roots.length; i++) {\n\t                    var root = this._roots[i];\n\t                    if (root instanceof Group) {\n\t                        root.delChildrenFromStorage(this);\n\t                    }\n\t                }\n\t\n\t                this._elements = {};\n\t                this._roots = [];\n\t                this._displayList = [];\n\t                this._displayListLen = 0;\n\t\n\t                return;\n\t            }\n\t\n\t            if (elId instanceof Array) {\n\t                for (var i = 0, l = elId.length; i < l; i++) {\n\t                    this.delRoot(elId[i]);\n\t                }\n\t                return;\n\t            }\n\t\n\t            var el;\n\t            if (typeof(elId) == 'string') {\n\t                el = this._elements[elId];\n\t            }\n\t            else {\n\t                el = elId;\n\t            }\n\t\n\t            var idx = util.indexOf(this._roots, el);\n\t            if (idx >= 0) {\n\t                this.delFromMap(el.id);\n\t                this._roots.splice(idx, 1);\n\t                if (el instanceof Group) {\n\t                    el.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t        },\n\t\n\t        addToMap: function (el) {\n\t            if (el instanceof Group) {\n\t                el.__storage = this;\n\t            }\n\t            el.dirty(false);\n\t\n\t            this._elements[el.id] = el;\n\t\n\t            return this;\n\t        },\n\t\n\t        get: function (elId) {\n\t            return this._elements[elId];\n\t        },\n\t\n\t        delFromMap: function (elId) {\n\t            var elements = this._elements;\n\t            var el = elements[elId];\n\t            if (el) {\n\t                delete elements[elId];\n\t                if (el instanceof Group) {\n\t                    el.__storage = null;\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Storage\n\t         */\n\t        dispose: function () {\n\t            this._elements =\n\t            this._renderList =\n\t            this._roots = null;\n\t        },\n\t\n\t        displayableSortFunc: shapeCompareFunc\n\t    };\n\t\n\t    module.exports = Storage;\n\t\n\n\n/***/ },\n/* 143 */\n/*!**********************************************!*\\\n  !*** ./~/zrender/lib/animation/Animation.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * , \n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t\n\t    var util = __webpack_require__(/*! ../core/util */ 1);\n\t    var Dispatcher = __webpack_require__(/*! ../core/event */ 24).Dispatcher;\n\t\n\t    var requestAnimationFrame = __webpack_require__(/*! ./requestAnimationFrame */ 60);\n\t\n\t    var Animator = __webpack_require__(/*! ./Animator */ 59);\n\t    /**\n\t     * @typedef {Object} IZRenderStage\n\t     * @property {Function} update\n\t     */\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animation\n\t     * @constructor\n\t     * @param {Object} [options]\n\t     * @param {Function} [options.onframe]\n\t     * @param {IZRenderStage} [options.stage]\n\t     * @example\n\t     *     var animation = new Animation();\n\t     *     var obj = {\n\t     *         x: 100,\n\t     *         y: 100\n\t     *     };\n\t     *     animation.animate(node.position)\n\t     *         .when(1000, {\n\t     *             x: 500,\n\t     *             y: 500\n\t     *         })\n\t     *         .when(2000, {\n\t     *             x: 100,\n\t     *             y: 100\n\t     *         })\n\t     *         .start('spline');\n\t     */\n\t    var Animation = function (options) {\n\t\n\t        options = options || {};\n\t\n\t        this.stage = options.stage || {};\n\t\n\t        this.onframe = options.onframe || function() {};\n\t\n\t        // private properties\n\t        this._clips = [];\n\t\n\t        this._running = false;\n\t\n\t        this._time;\n\t\n\t        this._pausedTime;\n\t\n\t        this._pauseStart;\n\t\n\t        this._paused = false;\n\t\n\t        Dispatcher.call(this);\n\t    };\n\t\n\t    Animation.prototype = {\n\t\n\t        constructor: Animation,\n\t        /**\n\t         *  clip\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        addClip: function (clip) {\n\t            this._clips.push(clip);\n\t        },\n\t        /**\n\t         *  animator\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        addAnimator: function (animator) {\n\t            animator.animation = this;\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.addClip(clips[i]);\n\t            }\n\t        },\n\t        /**\n\t         * \n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        removeClip: function(clip) {\n\t            var idx = util.indexOf(this._clips, clip);\n\t            if (idx >= 0) {\n\t                this._clips.splice(idx, 1);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        removeAnimator: function (animator) {\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.removeClip(clips[i]);\n\t            }\n\t            animator.animation = null;\n\t        },\n\t\n\t        _update: function() {\n\t\n\t            var time = new Date().getTime() - this._pausedTime;\n\t            var delta = time - this._time;\n\t            var clips = this._clips;\n\t            var len = clips.length;\n\t\n\t            var deferredEvents = [];\n\t            var deferredClips = [];\n\t            for (var i = 0; i < len; i++) {\n\t                var clip = clips[i];\n\t                var e = clip.step(time);\n\t                // Throw out the events need to be called after\n\t                // stage.update, like destroy\n\t                if (e) {\n\t                    deferredEvents.push(e);\n\t                    deferredClips.push(clip);\n\t                }\n\t            }\n\t\n\t            // Remove the finished clip\n\t            for (var i = 0; i < len;) {\n\t                if (clips[i]._needsRemove) {\n\t                    clips[i] = clips[len - 1];\n\t                    clips.pop();\n\t                    len--;\n\t                }\n\t                else {\n\t                    i++;\n\t                }\n\t            }\n\t\n\t            len = deferredEvents.length;\n\t            for (var i = 0; i < len; i++) {\n\t                deferredClips[i].fire(deferredEvents[i]);\n\t            }\n\t\n\t            this._time = time;\n\t\n\t            this.onframe(delta);\n\t\n\t            this.trigger('frame', delta);\n\t\n\t            if (this.stage.update) {\n\t                this.stage.update();\n\t            }\n\t        },\n\t\n\t        _startLoop: function () {\n\t            var self = this;\n\t\n\t            this._running = true;\n\t\n\t            function step() {\n\t                if (self._running) {\n\t\n\t                    requestAnimationFrame(step);\n\t\n\t                    !self._paused && self._update();\n\t                }\n\t            }\n\t\n\t            requestAnimationFrame(step);\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        start: function () {\n\t\n\t            this._time = new Date().getTime();\n\t            this._pausedTime = 0;\n\t\n\t            this._startLoop();\n\t        },\n\t        /**\n\t         * \n\t         */\n\t        stop: function () {\n\t            this._running = false;\n\t        },\n\t\n\t        /**\n\t         * Pause\n\t         */\n\t        pause: function () {\n\t            if (!this._paused) {\n\t                this._pauseStart = new Date().getTime();\n\t                this._paused = true;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Resume\n\t         */\n\t        resume: function () {\n\t            if (this._paused) {\n\t                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n\t                this._paused = false;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        clear: function () {\n\t            this._clips = [];\n\t        },\n\t        /**\n\t         * animator\n\t         * @param  {Object} target\n\t         * @param  {Object} options\n\t         * @param  {boolean} [options.loop=false] \n\t         * @param  {Function} [options.getter=null]\n\t         *         gettergetter\n\t         * @param  {Function} [options.setter=null]\n\t         *         settersetter\n\t         * @return {module:zrender/animation/Animation~Animator}\n\t         */\n\t        // TODO Gap\n\t        animate: function (target, options) {\n\t            options = options || {};\n\t            var animator = new Animator(\n\t                target,\n\t                options.loop,\n\t                options.getter,\n\t                options.setter\n\t            );\n\t\n\t            return animator;\n\t        }\n\t    };\n\t\n\t    util.mixin(Animation, Dispatcher);\n\t\n\t    module.exports = Animation;\n\t\n\n\n/***/ },\n/* 144 */\n/*!*****************************************!*\\\n  !*** ./~/zrender/lib/animation/Clip.js ***!\n  \\*****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @config target onframe\n\t * @config life(1000) \n\t * @config delay(0) \n\t * @config loop(true)\n\t * @config gap(0) \n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\t\n\t\n\t    var easingFuncs = __webpack_require__(/*! ./easing */ 145);\n\t\n\t    function Clip(options) {\n\t\n\t        this._target = options.target;\n\t\n\t        // \n\t        this._life = options.life || 1000;\n\t        // \n\t        this._delay = options.delay || 0;\n\t        // \n\t        // this._startTime = new Date().getTime() + this._delay;// \n\t        this._initialized = false;\n\t\n\t        // \n\t        this.loop = options.loop == null ? false : options.loop;\n\t\n\t        this.gap = options.gap || 0;\n\t\n\t        this.easing = options.easing || 'Linear';\n\t\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t    }\n\t\n\t    Clip.prototype = {\n\t\n\t        constructor: Clip,\n\t\n\t        step: function (globalTime) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = globalTime + this._delay;\n\t                this._initialized = true;\n\t            }\n\t\n\t            var percent = (globalTime - this._startTime) / this._life;\n\t\n\t            // \n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t\n\t            percent = Math.min(percent, 1);\n\t\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t            var schedule = typeof easingFunc === 'function'\n\t                ? easingFunc(percent)\n\t                : percent;\n\t\n\t            this.fire('frame', schedule);\n\t\n\t            // \n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart (globalTime);\n\t                    // \n\t                    //  stage.update \n\t                    return 'restart';\n\t                }\n\t\n\t                // \n\t                // Animation.update\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t\n\t            return null;\n\t        },\n\t\n\t        restart: function (globalTime) {\n\t            var remainder = (globalTime - this._startTime) % this._life;\n\t            this._startTime = globalTime - remainder + this.gap;\n\t\n\t            this._needsRemove = false;\n\t        },\n\t\n\t        fire: function(eventType, arg) {\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\n\t                this[eventType](this._target, arg);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Clip;\n\t\n\n\n/***/ },\n/* 145 */\n/*!*******************************************!*\\\n  !*** ./~/zrender/lib/animation/easing.js ***!\n  \\*******************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\t\n\t    var easing = {\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        linear: function (k) {\n\t            return k;\n\t        },\n\t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticIn: function (k) {\n\t            return k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticOut: function (k) {\n\t            return k * (2 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k;\n\t            }\n\t            return -0.5 * (--k * (k - 2) - 1);\n\t        },\n\t\n\t        // t^3\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicIn: function (k) {\n\t            return k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicOut: function (k) {\n\t            return --k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k + 2);\n\t        },\n\t\n\t        // t^4\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticIn: function (k) {\n\t            return k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticOut: function (k) {\n\t            return 1 - (--k * k * k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k;\n\t            }\n\t            return -0.5 * ((k -= 2) * k * k * k - 2);\n\t        },\n\t\n\t        // t^5\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticIn: function (k) {\n\t            return k * k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticOut: function (k) {\n\t            return --k * k * k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t        },\n\t\n\t        // sin(t)\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalIn: function (k) {\n\t            return 1 - Math.cos(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalOut: function (k) {\n\t            return Math.sin(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalInOut: function (k) {\n\t            return 0.5 * (1 - Math.cos(Math.PI * k));\n\t        },\n\t\n\t        // 2^t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialIn: function (k) {\n\t            return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialOut: function (k) {\n\t            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialInOut: function (k) {\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * Math.pow(1024, k - 1);\n\t            }\n\t            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t        },\n\t\n\t        // sqrt(1-t^2)\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularIn: function (k) {\n\t            return 1 - Math.sqrt(1 - k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularOut: function (k) {\n\t            return Math.sqrt(1 - (--k * k));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t            }\n\t            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticIn: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return -(a * Math.pow(2, 10 * (k -= 1)) *\n\t                        Math.sin((k - s) * (2 * Math.PI) / p));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return (a * Math.pow(2, -10 * k) *\n\t                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticInOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            }\n\t            return a * Math.pow(2, -10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backIn: function (k) {\n\t            var s = 1.70158;\n\t            return k * k * ((s + 1) * k - s);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backOut: function (k) {\n\t            var s = 1.70158;\n\t            return --k * k * ((s + 1) * k + s) + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backInOut: function (k) {\n\t            var s = 1.70158 * 1.525;\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * (k * k * ((s + 1) * k - s));\n\t            }\n\t            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceIn: function (k) {\n\t            return 1 - easing.bounceOut(1 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceOut: function (k) {\n\t            if (k < (1 / 2.75)) {\n\t                return 7.5625 * k * k;\n\t            }\n\t            else if (k < (2 / 2.75)) {\n\t                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t            }\n\t            else if (k < (2.5 / 2.75)) {\n\t                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t            }\n\t            else {\n\t                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t            }\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceInOut: function (k) {\n\t            if (k < 0.5) {\n\t                return easing.bounceIn(k * 2) * 0.5;\n\t            }\n\t            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t        }\n\t    };\n\t\n\t    module.exports = easing;\n\t\n\t\n\n\n/***/ },\n/* 146 */\n/*!**************************************!*\\\n  !*** ./~/zrender/lib/contain/arc.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var normalizeRadian = __webpack_require__(/*! ./util */ 61).normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  cx\n\t         * @param  {number}  cy\n\t         * @param  {number}  r\n\t         * @param  {number}  startAngle\n\t         * @param  {number}  endAngle\n\t         * @param  {boolean}  anticlockwise\n\t         * @param  {number} lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {Boolean}\n\t         */\n\t        containStroke: function (\n\t            cx, cy, r, startAngle, endAngle, anticlockwise,\n\t            lineWidth, x, y\n\t        ) {\n\t\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t\n\t            if ((d - _l > r) || (d + _l < r)) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return (angle >= startAngle && angle <= endAngle)\n\t                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n\t        }\n\t    };\n\n\n/***/ },\n/* 147 */\n/*!****************************************!*\\\n  !*** ./~/zrender/lib/contain/cubic.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(/*! ../core/curve */ 17);\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  x3\n\t         * @param  {number}  y3\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(\n\t                x0, y0, x1, y1, x2, y2, x3, y3,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 148 */\n/*!***************************************!*\\\n  !*** ./~/zrender/lib/contain/path.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var CMD = __webpack_require__(/*! ../core/PathProxy */ 28).CMD;\n\t    var line = __webpack_require__(/*! ./line */ 84);\n\t    var cubic = __webpack_require__(/*! ./cubic */ 147);\n\t    var quadratic = __webpack_require__(/*! ./quadratic */ 85);\n\t    var arc = __webpack_require__(/*! ./arc */ 146);\n\t    var normalizeRadian = __webpack_require__(/*! ./util */ 61).normalizeRadian;\n\t    var curve = __webpack_require__(/*! ../core/curve */ 17);\n\t\n\t    var windingLine = __webpack_require__(/*! ./windingLine */ 86);\n\t\n\t    var containStroke = line.containStroke;\n\t\n\t    var PI2 = Math.PI * 2;\n\t\n\t    var EPSILON = 1e-4;\n\t\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t\n\t    // \n\t    var roots = [-1, -1, -1];\n\t    var extrema = [-1, -1];\n\t\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2 && y > y3)\n\t            || (y < y0 && y < y1 && y < y2 && y < y3)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t\n\t                // Avoid winding error when intersection point is the connect point of two line of polygon\n\t                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) { // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // \n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y1_ ? unit : -unit;\n\t                    }\n\t                }\n\t                else {\n\t                    // \n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y0_ ? unit : -unit;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2)\n\t            || (y < y0 && y < y1 && y < y2)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >= 0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    // Remove one endpoint.\n\t                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\t\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ < x) {   // Quick reject\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y2 < y_ ? unit : -unit;\n\t                    }\n\t                }\n\t                return w;\n\t            }\n\t            else {\n\t                // Remove one endpoint.\n\t                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ < x) {   // Quick reject\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? unit : -unit;\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO\n\t    // Arc \n\t    function windingArc(\n\t        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n\t    ) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 1e-4) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 1e-4) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        }\n\t        else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (\n\t                    (angle >= startAngle && angle <= endAngle)\n\t                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n\t                ) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }\n\t                //  subpath \n\t                // if (w !== 0) {\n\t                //     return true;\n\t                // }\n\t            }\n\t\n\t            if (i == 1) {\n\t                //  L, C, Q\n\t                //  previous point  point\n\t                //\n\t                //  Arc \n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t\n\t            switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo  subpath, \n\t                    //  closePath \n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    if (isStroke) {\n\t                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // NOTE  L, C, Q  NaN\n\t                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    if (isStroke) {\n\t                        if (cubic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingCubic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    if (isStroke) {\n\t                        if (quadratic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingQuadratic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc \n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var theta = data[i++];\n\t                    var dTheta = data[i++];\n\t                    // TODO Arc \n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    var x1 = Math.cos(theta) * rx + cx;\n\t                    var y1 = Math.sin(theta) * ry + cy;\n\t                    //  arc \n\t                    if (i > 1) {\n\t                        w += windingLine(xi, yi, x1, y1, x, y);\n\t                    }\n\t                    else {\n\t                        // \n\t                        x0 = x1;\n\t                        y0 = y1;\n\t                    }\n\t                    // zr scale, x\n\t                    var _x = (x - cx) * ry / rx + cx;\n\t                    if (isStroke) {\n\t                        if (arc.containStroke(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            lineWidth, _x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingArc(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            _x, y\n\t                        );\n\t                    }\n\t                    xi = Math.cos(theta + dTheta) * rx + cx;\n\t                    yi = Math.sin(theta + dTheta) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    var x1 = x0 + width;\n\t                    var y1 = y0 + height;\n\t                    if (isStroke) {\n\t                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n\t                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n\t                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n\t                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n\t                        ) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // FIXME Clockwise ?\n\t                        w += windingLine(x1, y0, x1, y1, x, y);\n\t                        w += windingLine(x0, y1, x0, y0, x, y);\n\t                    }\n\t                    break;\n\t                case CMD.Z:\n\t                    if (isStroke) {\n\t                        if (containStroke(\n\t                            xi, yi, x0, y0, lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Close a subpath\n\t                        w += windingLine(xi, yi, x0, y0, x, y);\n\t                        //  subpath \n\t                        // FIXME subpaths may overlap\n\t                        // if (w !== 0) {\n\t                        //     return true;\n\t                        // }\n\t                    }\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t\n\t    module.exports = {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 149 */\n/*!******************************************!*\\\n  !*** ./~/zrender/lib/core/GestureMgr.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Only implements needed gestures for mobile.\n\t */\n\t\n\t\n\t    var eventUtil = __webpack_require__(/*! ./event */ 24);\n\t\n\t    var GestureMgr = function () {\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._track = [];\n\t    };\n\t\n\t    GestureMgr.prototype = {\n\t\n\t        constructor: GestureMgr,\n\t\n\t        recognize: function (event, target, root) {\n\t            this._doTrack(event, target, root);\n\t            return this._recognize(event);\n\t        },\n\t\n\t        clear: function () {\n\t            this._track.length = 0;\n\t            return this;\n\t        },\n\t\n\t        _doTrack: function (event, target, root) {\n\t            var touches = event.touches;\n\t\n\t            if (!touches) {\n\t                return;\n\t            }\n\t\n\t            var trackItem = {\n\t                points: [],\n\t                touches: [],\n\t                target: target,\n\t                event: event\n\t            };\n\t\n\t            for (var i = 0, len = touches.length; i < len; i++) {\n\t                var touch = touches[i];\n\t                var pos = eventUtil.clientToLocal(root, touch, {});\n\t                trackItem.points.push([pos.zrX, pos.zrY]);\n\t                trackItem.touches.push(touch);\n\t            }\n\t\n\t            this._track.push(trackItem);\n\t        },\n\t\n\t        _recognize: function (event) {\n\t            for (var eventName in recognizers) {\n\t                if (recognizers.hasOwnProperty(eventName)) {\n\t                    var gestureInfo = recognizers[eventName](this._track, event);\n\t                    if (gestureInfo) {\n\t                        return gestureInfo;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function dist(pointPair) {\n\t        var dx = pointPair[1][0] - pointPair[0][0];\n\t        var dy = pointPair[1][1] - pointPair[0][1];\n\t\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t\n\t    function center(pointPair) {\n\t        return [\n\t            (pointPair[0][0] + pointPair[1][0]) / 2,\n\t            (pointPair[0][1] + pointPair[1][1]) / 2\n\t        ];\n\t    }\n\t\n\t    var recognizers = {\n\t\n\t        pinch: function (track, event) {\n\t            var trackLen = track.length;\n\t\n\t            if (!trackLen) {\n\t                return;\n\t            }\n\t\n\t            var pinchEnd = (track[trackLen - 1] || {}).points;\n\t            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t\n\t            if (pinchPre\n\t                && pinchPre.length > 1\n\t                && pinchEnd\n\t                && pinchEnd.length > 1\n\t            ) {\n\t                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t                !isFinite(pinchScale) && (pinchScale = 1);\n\t\n\t                event.pinchScale = pinchScale;\n\t\n\t                var pinchCenter = center(pinchEnd);\n\t                event.pinchX = pinchCenter[0];\n\t                event.pinchY = pinchCenter[1];\n\t\n\t                return {\n\t                    type: 'pinch',\n\t                    target: track[0].target,\n\t                    event: event\n\t                };\n\t            }\n\t        }\n\t\n\t        // Only pinch currently.\n\t    };\n\t\n\t    module.exports = GestureMgr;\n\t\n\n\n/***/ },\n/* 150 */\n/*!***********************************!*\\\n  !*** ./~/zrender/lib/core/LRU.js ***!\n  \\***********************************/\n/***/ function(module, exports) {\n\n\t// Simple LRU cache use doubly linked list\n\t// @module zrender/core/LRU\n\t\n\t\n\t    /**\n\t     * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t     * @constructor\n\t     */\n\t    var LinkedList = function() {\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.head = null;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.tail = null;\n\t\n\t        this._len = 0;\n\t    };\n\t\n\t    var linkedListProto = LinkedList.prototype;\n\t    /**\n\t     * Insert a new value at the tail\n\t     * @param  {} val\n\t     * @return {module:zrender/core/LRU~Entry}\n\t     */\n\t    linkedListProto.insert = function(val) {\n\t        var entry = new Entry(val);\n\t        this.insertEntry(entry);\n\t        return entry;\n\t    };\n\t\n\t    /**\n\t     * Insert an entry at the tail\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.insertEntry = function(entry) {\n\t        if (!this.head) {\n\t            this.head = this.tail = entry;\n\t        }\n\t        else {\n\t            this.tail.next = entry;\n\t            entry.prev = this.tail;\n\t            this.tail = entry;\n\t        }\n\t        this._len++;\n\t    };\n\t\n\t    /**\n\t     * Remove entry.\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.remove = function(entry) {\n\t        var prev = entry.prev;\n\t        var next = entry.next;\n\t        if (prev) {\n\t            prev.next = next;\n\t        }\n\t        else {\n\t            // Is head\n\t            this.head = next;\n\t        }\n\t        if (next) {\n\t            next.prev = prev;\n\t        }\n\t        else {\n\t            // Is tail\n\t            this.tail = prev;\n\t        }\n\t        entry.next = entry.prev = null;\n\t        this._len--;\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    linkedListProto.len = function() {\n\t        return this._len;\n\t    };\n\t\n\t    /**\n\t     * @constructor\n\t     * @param {} val\n\t     */\n\t    var Entry = function(val) {\n\t        /**\n\t         * @type {}\n\t         */\n\t        this.value = val;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.next;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.prev;\n\t    };\n\t\n\t    /**\n\t     * LRU Cache\n\t     * @constructor\n\t     * @alias module:zrender/core/LRU\n\t     */\n\t    var LRU = function(maxSize) {\n\t\n\t        this._list = new LinkedList();\n\t\n\t        this._map = {};\n\t\n\t        this._maxSize = maxSize || 10;\n\t    };\n\t\n\t    var LRUProto = LRU.prototype;\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @param  {} value\n\t     */\n\t    LRUProto.put = function(key, value) {\n\t        var list = this._list;\n\t        var map = this._map;\n\t        if (map[key] == null) {\n\t            var len = list.len();\n\t            if (len >= this._maxSize && len > 0) {\n\t                // Remove the least recently used\n\t                var leastUsedEntry = list.head;\n\t                list.remove(leastUsedEntry);\n\t                delete map[leastUsedEntry.key];\n\t            }\n\t\n\t            var entry = list.insert(value);\n\t            entry.key = key;\n\t            map[key] = entry;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @return {}\n\t     */\n\t    LRUProto.get = function(key) {\n\t        var entry = this._map[key];\n\t        var list = this._list;\n\t        if (entry != null) {\n\t            // Put the latest used entry in the tail\n\t            if (entry !== list.tail) {\n\t                list.remove(entry);\n\t                list.insertEntry(entry);\n\t            }\n\t\n\t            return entry.value;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Clear the cache\n\t     */\n\t    LRUProto.clear = function() {\n\t        this._list.clear();\n\t        this._map = {};\n\t    };\n\t\n\t    module.exports = LRU;\n\n\n/***/ },\n/* 151 */\n/*!*******************************************!*\\\n  !*** ./~/zrender/lib/dom/HandlerProxy.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var eventTool = __webpack_require__(/*! ../core/event */ 24);\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t    var Eventful = __webpack_require__(/*! ../mixin/Eventful */ 20);\n\t    var env = __webpack_require__(/*! ../core/env */ 11);\n\t    var GestureMgr = __webpack_require__(/*! ../core/GestureMgr */ 149);\n\t\n\t    var addEventListener = eventTool.addEventListener;\n\t    var removeEventListener = eventTool.removeEventListener;\n\t    var normalizeEvent = eventTool.normalizeEvent;\n\t\n\t    var TOUCH_CLICK_DELAY = 300;\n\t\n\t    var mouseHandlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t\n\t    var touchHandlerNames = [\n\t        'touchstart', 'touchend', 'touchmove'\n\t    ];\n\t\n\t    function eventNameFix(name) {\n\t        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n\t    }\n\t\n\t    function processGesture(proxy, event, stage) {\n\t        var gestureMgr = proxy._gestureMgr;\n\t\n\t        stage === 'start' && gestureMgr.clear();\n\t\n\t        var gestureInfo = gestureMgr.recognize(\n\t            event,\n\t            proxy.handler.findHover(event.zrX, event.zrY, null),\n\t            proxy.dom\n\t        );\n\t\n\t        stage === 'end' && gestureMgr.clear();\n\t\n\t        if (gestureInfo) {\n\t            // eventTool.stop(event);\n\t            var type = gestureInfo.type;\n\t            event.gestureEvent = type;\n\t\n\t            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Prevent mouse event from being dispatched after Touch Events action\n\t     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t     * Result: Blocking Mouse Events for 700ms.\n\t     */\n\t    function setTouchTimer(instance) {\n\t        instance._touching = true;\n\t        clearTimeout(instance._touchTimer);\n\t        instance._touchTimer = setTimeout(function () {\n\t            instance._touching = false;\n\t        }, 700);\n\t    }\n\t\n\t    function useTouchEvent() {\n\t        return env.touchEventsSupported;\n\t    }\n\t\n\t    var domHandlers = {\n\t        /**\n\t         * Mouse move handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mousemove: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            this.trigger('mousemove', event);\n\t        },\n\t\n\t        /**\n\t         * Mouse out handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mouseout: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            var element = event.toElement || event.relatedTarget;\n\t            if (element != this.dom) {\n\t                while (element && element.nodeType != 9) {\n\t                    // rootdommouseOut\n\t                    if (element === this.dom) {\n\t                        return;\n\t                    }\n\t\n\t                    element = element.parentNode;\n\t                }\n\t            }\n\t\n\t            this.trigger('mouseout', event);\n\t        },\n\t\n\t        /**\n\t         * Touch\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchstart: function (event) {\n\t            // Default mouse behaviour should not be disabled here.\n\t            // For example, page may needs to be slided.\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            this._lastTouchMoment = new Date();\n\t\n\t            processGesture(this, event, 'start');\n\t\n\t            // In touch device, trigger `mousemove`(`mouseover`) should\n\t            // be triggered.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            domHandlers.mousedown.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchmove: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            processGesture(this, event, 'change');\n\t\n\t            // Mouse move should always be triggered no matter whether\n\t            // there is gestrue event, because mouse move and pinch may\n\t            // be used at the same time.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchend: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            processGesture(this, event, 'end');\n\t\n\t            domHandlers.mouseup.call(this, event);\n\t\n\t            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n\t            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n\t            // we can conveniently implement \"hover style\" in both PC and touch device just\n\t            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n\t            // to remove \"hover style\" on an element, without any additional code for\n\t            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n\t            // style\" will remain for user view)\n\t\n\t            // click event should always be triggered no matter whether\n\t            // there is gestrue event. System click can not be prevented.\n\t            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t                domHandlers.click.call(this, event);\n\t            }\n\t\n\t            setTouchTimer(this);\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        domHandlers[name] = function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t            this.trigger(name, event);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * dom \n\t     *\n\t     * @inner\n\t     * @param {module:zrender/Handler} instance \n\t     */\n\t    function initDomHandler(instance) {\n\t        for (var i = 0; i < touchHandlerNames.length; i++) {\n\t            var name = touchHandlerNames[i];\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        }\n\t\n\t        for (var i = 0; i < mouseHandlerNames.length; i++) {\n\t            var name = mouseHandlerNames[i];\n\t            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t        }\n\t\n\t        function makeMouseHandler(fn, instance) {\n\t            return function () {\n\t                if (instance._touching) {\n\t                    return;\n\t                }\n\t                return fn.apply(instance, arguments);\n\t            };\n\t        }\n\t    }\n\t\n\t\n\t    function HandlerDomProxy(dom) {\n\t        Eventful.call(this);\n\t\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._touching = false;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._touchTimer;\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:zrender/core/GestureMgr}\n\t         */\n\t        this._gestureMgr = new GestureMgr();\n\t\n\t        this._handlers = {};\n\t\n\t        initDomHandler(this);\n\t\n\t        if (useTouchEvent()) {\n\t            mountHandlers(touchHandlerNames, this);\n\t\n\t            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t            // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t        }\n\t\n\t        // Considering some devices that both enable touch and mouse event (like MS Surface\n\t        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t        // mouse event can not be handle in those devices.\n\t        mountHandlers(mouseHandlerNames, this);\n\t\n\t        function mountHandlers(handlerNames, instance) {\n\t            zrUtil.each(handlerNames, function (name) {\n\t                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t            }, instance);\n\t        }\n\t    }\n\t\n\t    var handlerDomProxyProto = HandlerDomProxy.prototype;\n\t    handlerDomProxyProto.dispose = function () {\n\t        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t\n\t        for (var i = 0; i < handlerNames.length; i++) {\n\t            var name = handlerNames[i];\n\t            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t        }\n\t    };\n\t\n\t    handlerDomProxyProto.setCursor = function (cursorStyle) {\n\t        this.dom.style.cursor = cursorStyle || 'default';\n\t    };\n\t\n\t    zrUtil.mixin(HandlerDomProxy, Eventful);\n\t\n\t    module.exports = HandlerDomProxy;\n\n\n/***/ },\n/* 152 */\n/*!***********************************************!*\\\n  !*** ./~/zrender/lib/graphic/CompoundPath.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CompoundPath to improve performance\n\t\n\t\n\t    var Path = __webpack_require__(/*! ./Path */ 6);\n\t    module.exports = Path.extend({\n\t\n\t        type: 'compound',\n\t\n\t        shape: {\n\t\n\t            paths: null\n\t        },\n\t\n\t        _updatePathDirty: function () {\n\t            var dirtyPath = this.__dirtyPath;\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                // Mark as dirty if any subpath is dirty\n\t                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n\t            }\n\t            this.__dirtyPath = dirtyPath;\n\t            this.__dirty = this.__dirty || dirtyPath;\n\t        },\n\t\n\t        beforeBrush: function () {\n\t            this._updatePathDirty();\n\t            var paths = this.shape.paths || [];\n\t            var scale = this.getGlobalScale();\n\t            // Update path scale\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].path.setScale(scale[0], scale[1]);\n\t            }\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var paths = shape.paths || [];\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].buildPath(ctx, paths[i].shape, true);\n\t            }\n\t        },\n\t\n\t        afterBrush: function () {\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].__dirtyPath = false;\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            this._updatePathDirty();\n\t            return Path.prototype.getBoundingRect.call(this);\n\t        }\n\t    });\n\n\n/***/ },\n/* 153 */\n/*!*************************************************!*\\\n  !*** ./~/zrender/lib/graphic/RadialGradient.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t\n\t    var Gradient = __webpack_require__(/*! ./Gradient */ 29);\n\t\n\t    /**\n\t     * x, y, r are all percent from 0 to 1\n\t     * @param {number} [x=0.5]\n\t     * @param {number} [y=0.5]\n\t     * @param {number} [r=0.5]\n\t     * @param {Array.<Object>} [colorStops]\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t        this.x = x == null ? 0.5 : x;\n\t\n\t        this.y = y == null ? 0.5 : y;\n\t\n\t        this.r = r == null ? 0.5 : r;\n\t\n\t        // Can be cloned\n\t        this.type = 'radial';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    RadialGradient.prototype = {\n\t\n\t        constructor: RadialGradient\n\t    };\n\t\n\t    zrUtil.inherits(RadialGradient, Gradient);\n\t\n\t    module.exports = RadialGradient;\n\n\n/***/ },\n/* 154 */\n/*!***************************************************!*\\\n  !*** ./~/zrender/lib/graphic/helper/roundRect.js ***!\n  \\***************************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            }\n\t            else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                }\n\t                else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                }\n\t                else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                }\n\t                else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            }\n\t            else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y, x + width, y + r2\n\t            );\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y + height, x + width - r3, y + height\n\t            );\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(\n\t                x, y + height, x, y + height - r4\n\t            );\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 155 */\n/*!******************************************************!*\\\n  !*** ./~/zrender/lib/graphic/helper/smoothBezier.js ***!\n  \\******************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(/*! ../../core/vector */ 5);\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t\n\t    /**\n\t     * \n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points \n\t     * @param {number} smooth , 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint \n\t     *                            [[0, 0], [100, 100]], \n\t     *                           \n\t     * @param {Array} \n\t     */\n\t    module.exports = function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [Infinity, Infinity];\n\t            max = [-Infinity, -Infinity];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // \n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            }\n\t            else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                }\n\t                else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t\n\t        return cps;\n\t    };\n\t\n\n\n/***/ },\n/* 156 */\n/*!******************************************************!*\\\n  !*** ./~/zrender/lib/graphic/helper/smoothSpline.js ***!\n  \\******************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Catmull-Rom spline \n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t    var vec2 = __webpack_require__(/*! ../../core/vector */ 5);\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points \n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    module.exports = function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t\n\t            var w = pos - idx;\n\t\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            }\n\t            else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t\n\n\n/***/ },\n/* 157 */\n/*!********************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Arc.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Arc\n\t */\n\t \n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t\n\t        type: 'arc',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        style: {\n\t\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t        }\n\t    });\n\n\n/***/ },\n/* 158 */\n/*!****************************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/BezierCurve.js ***!\n  \\****************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/shape/BezierCurve\n\t */\n\t\n\t\n\t    var curveTool = __webpack_require__(/*! ../../core/curve */ 17);\n\t    var vec2 = __webpack_require__(/*! ../../core/vector */ 5);\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\n\t    var quadraticAt = curveTool.quadraticAt;\n\t    var cubicAt = curveTool.cubicAt;\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\t\n\t    var out = [];\n\t\n\t    function someVectorAt(shape, t, isTangent) {\n\t        var cpx2 = shape.cpx2;\n\t        var cpy2 = shape.cpy2;\n\t        if (cpx2 === null || cpy2 === null) {\n\t            return [\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n\t            ];\n\t        }\n\t        else {\n\t            return [\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n\t            ];\n\t        }\n\t    }\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t\n\t        type: 'bezier-curve',\n\t\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            cpx1: 0,\n\t            cpy1: 0,\n\t            // cpx2: 0,\n\t            // cpy2: 0\n\t\n\t            // Curve show percent, for animating\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var cpx1 = shape.cpx1;\n\t            var cpy1 = shape.cpy1;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (cpx2 == null || cpy2 == null) {\n\t                if (percent < 1) {\n\t                    quadraticSubdivide(\n\t                        x1, cpx1, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    x2 = out[2];\n\t                    quadraticSubdivide(\n\t                        y1, cpy1, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    y2 = out[2];\n\t                }\n\t\n\t                ctx.quadraticCurveTo(\n\t                    cpx1, cpy1,\n\t                    x2, y2\n\t                );\n\t            }\n\t            else {\n\t                if (percent < 1) {\n\t                    cubicSubdivide(\n\t                        x1, cpx1, cpx2, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    cpx2 = out[2];\n\t                    x2 = out[3];\n\t                    cubicSubdivide(\n\t                        y1, cpy1, cpy2, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    cpy2 = out[2];\n\t                    y2 = out[3];\n\t                }\n\t                ctx.bezierCurveTo(\n\t                    cpx1, cpy1,\n\t                    cpx2, cpy2,\n\t                    x2, y2\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (t) {\n\t            return someVectorAt(this.shape, t, false);\n\t        },\n\t\n\t        /**\n\t         * Get tangent at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        tangentAt: function (t) {\n\t            var p = someVectorAt(this.shape, t, true);\n\t            return vec2.normalize(p, p);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 159 */\n/*!***********************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Circle.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/shape/Circle\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t\n\t        type: 'circle',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0\n\t        },\n\t\n\t\n\t        buildPath : function (ctx, shape, inBundle) {\n\t            // Better stroking in ShapeBundle\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\n\t            if (inBundle) {\n\t                ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            }\n\t            // Better stroking in ShapeBundle\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 160 */\n/*!*********************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Line.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Line\n\t */\n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t\n\t        type: 'line',\n\t\n\t        shape: {\n\t            // Start point\n\t            x1: 0,\n\t            y1: 0,\n\t            // End point\n\t            x2: 0,\n\t            y2: 0,\n\t\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var percent = shape.percent;\n\t\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (percent < 1) {\n\t                x2 = x1 * (1 - percent) + x2 * percent;\n\t                y2 = y1 * (1 - percent) + y2 * percent;\n\t            }\n\t            ctx.lineTo(x2, y2);\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} percent\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            return [\n\t                shape.x1 * (1 - p) + shape.x2 * p,\n\t                shape.y1 * (1 - p) + shape.y2 * p\n\t            ];\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 161 */\n/*!************************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Polygon.js ***!\n  \\************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/shape/Polygon\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(/*! ../helper/poly */ 65);\n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t        \n\t        type: 'polygon',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, true);\n\t        }\n\t    });\n\n\n/***/ },\n/* 162 */\n/*!*************************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Polyline.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(/*! ../helper/poly */ 65);\n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t        \n\t        type: 'polyline',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, false);\n\t        }\n\t    });\n\n\n/***/ },\n/* 163 */\n/*!*********************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Rect.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Rect\n\t */\n\t\n\t\n\t    var roundRectHelper = __webpack_require__(/*! ../helper/roundRect */ 154);\n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t\n\t        type: 'rect',\n\t\n\t        shape: {\n\t            // r1r2r3r4\n\t            // r1          [1, 1, 1, 1]\n\t            // r[1]        [1, 1, 1, 1]\n\t            // r[1, 2]     [1, 2, 1, 2]\n\t            // r[1, 2, 3]  [1, 2, 3, 2]\n\t            r: 0,\n\t\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            if (!shape.r) {\n\t                ctx.rect(x, y, width, height);\n\t            }\n\t            else {\n\t                roundRectHelper.buildPath(ctx, shape);\n\t            }\n\t            ctx.closePath();\n\t            return;\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 164 */\n/*!*********************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Ring.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Ring\n\t */\n\t\n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t\n\t        type: 'ring',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            r0: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var PI2 = Math.PI * 2;\n\t            ctx.moveTo(x + shape.r, y);\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\n\t            ctx.moveTo(x + shape.r0, y);\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 165 */\n/*!***********************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Sector.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Sector\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t\n\t        type: 'sector',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r0: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r0 = Math.max(shape.r0 || 0, 0);\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\n\t\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t\n\t            ctx.lineTo(\n\t                Math.cos(endAngle) * r0 + x,\n\t                Math.sin(endAngle) * r0 + y\n\t            );\n\t\n\t            if (r0 !== 0) {\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t            }\n\t\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 166 */\n/*!*******************************************!*\\\n  !*** ./~/zrender/lib/mixin/Animatable.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/mixin/Animatable\n\t */\n\t\n\t\n\t    var Animator = __webpack_require__(/*! ../animation/Animator */ 59);\n\t    var util = __webpack_require__(/*! ../core/util */ 1);\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = __webpack_require__(/*! ../core/log */ 47);\n\t\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t\n\t    Animatable.prototype = {\n\t\n\t        constructor: Animatable,\n\t\n\t        /**\n\t         * \n\t         *\n\t         * @param {string} path a.b.c\n\t         * @param {boolean} [loop] \n\t         * @return {module:zrender/animation/Animator}\n\t         * @example:\n\t         *     el.animate('style', false)\n\t         *         .when(1000, {x: 10} )\n\t         *         .done(function(){ // Animation done })\n\t         *         .start()\n\t         */\n\t        animate: function (path, loop) {\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            }\n\t            else {\n\t                target = el;\n\t            }\n\t\n\t            if (!target) {\n\t                log(\n\t                    'Property \"'\n\t                    + path\n\t                    + '\" is not existed in element '\n\t                    + el.id\n\t                );\n\t                return;\n\t            }\n\t\n\t            var animators = el.animators;\n\t\n\t            var animator = new Animator(target, loop);\n\t\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            })\n\t            .done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t\n\t            animators.push(animator);\n\t\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\n\t\n\t            return animator;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {Object} target\n\t         * @param {number} [time=500] Time in ms\n\t         * @param {string} [easing='linear']\n\t         * @param {number} [delay=0]\n\t         * @param {Function} [callback]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el.animateTo({\n\t         *      position: [10, 10]\n\t         *  }, function () { // done })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t         *  el.animateTo({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100, 'cubicOut', function () { // done })\n\t         */\n\t         // TODO Return animation key\n\t        animateTo: function (target, time, delay, easing, callback) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }\n\t            // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i]\n\t                    .done(done)\n\t                    .start(easing);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {string} path=''\n\t         * @param {Object} source=this\n\t         * @param {Object} target\n\t         * @param {number} [time=500]\n\t         * @param {number} [delay=0]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el._animateToShallow({\n\t         *      position: [10, 10]\n\t         *  })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms\n\t         *  el._animateToShallow({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100)\n\t         */\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (!target.hasOwnProperty(name)) {\n\t                    continue;\n\t                }\n\t\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(\n\t                            path ? path + '.' + name : name,\n\t                            source[name],\n\t                            target[name],\n\t                            time,\n\t                            delay\n\t                        );\n\t                    }\n\t                    else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                }\n\t                else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    }\n\t                    else {  // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false)\n\t                    .when(time == null ? 500 : time, objShallow)\n\t                    .delay(delay || 0);\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    module.exports = Animatable;\n\n\n/***/ },\n/* 167 */\n/*!******************************************!*\\\n  !*** ./~/zrender/lib/mixin/Draggable.js ***!\n  \\******************************************/\n/***/ function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\t\n\t    function Draggable() {\n\t\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);\n\t        // this._dropTarget = null;\n\t        // this._draggingTarget = null;\n\t\n\t        // this._x = 0;\n\t        // this._y = 0;\n\t    }\n\t\n\t    Draggable.prototype = {\n\t\n\t        constructor: Draggable,\n\t\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t\n\t                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n\t            }\n\t        },\n\t\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t\n\t                draggingTarget.drift(dx, dy, e);\n\t                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\t\n\t                var dropTarget = this.findHover(x, y, draggingTarget);\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t\n\t            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\t\n\t            if (this._dropTarget) {\n\t                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n\t            }\n\t\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t\n\t    };\n\t\n\t    module.exports = Draggable;\n\n\n/***/ },\n/* 168 */\n/*!************************************!*\\\n  !*** ./~/zrender/lib/tool/path.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Path = __webpack_require__(/*! ../graphic/Path */ 6);\n\t    var PathProxy = __webpack_require__(/*! ../core/PathProxy */ 28);\n\t    var transformPath = __webpack_require__(/*! ./transformPath */ 169);\n\t    var matrix = __webpack_require__(/*! ../core/matrix */ 19);\n\t\n\t    // command chars\n\t    var cc = [\n\t        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n\t        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n\t    ];\n\t\n\t    var mathSqrt = Math.sqrt;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var PI = Math.PI;\n\t\n\t    var vMag = function(v) {\n\t        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t    };\n\t    var vRatio = function(u, v) {\n\t        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t    };\n\t    var vAngle = function(u, v) {\n\t        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n\t                * Math.acos(vRatio(u, v));\n\t    };\n\t\n\t    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t        var psi = psiDeg * (PI / 180.0);\n\t        var xp = mathCos(psi) * (x1 - x2) / 2.0\n\t                 + mathSin(psi) * (y1 - y2) / 2.0;\n\t        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n\t                 + mathCos(psi) * (y1 - y2) / 2.0;\n\t\n\t        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\t\n\t        if (lambda > 1) {\n\t            rx *= mathSqrt(lambda);\n\t            ry *= mathSqrt(lambda);\n\t        }\n\t\n\t        var f = (fa === fs ? -1 : 1)\n\t            * mathSqrt((((rx * rx) * (ry * ry))\n\t                    - ((rx * rx) * (yp * yp))\n\t                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n\t                    + (ry * ry) * (xp * xp))\n\t                ) || 0;\n\t\n\t        var cxp = f * rx * yp / ry;\n\t        var cyp = f * -ry * xp / rx;\n\t\n\t        var cx = (x1 + x2) / 2.0\n\t                 + mathCos(psi) * cxp\n\t                 - mathSin(psi) * cyp;\n\t        var cy = (y1 + y2) / 2.0\n\t                + mathSin(psi) * cxp\n\t                + mathCos(psi) * cyp;\n\t\n\t        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n\t        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n\t        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n\t        var dTheta = vAngle(u, v);\n\t\n\t        if (vRatio(u, v) <= -1) {\n\t            dTheta = PI;\n\t        }\n\t        if (vRatio(u, v) >= 1) {\n\t            dTheta = 0;\n\t        }\n\t        if (fs === 0 && dTheta > 0) {\n\t            dTheta = dTheta - 2 * PI;\n\t        }\n\t        if (fs === 1 && dTheta < 0) {\n\t            dTheta = dTheta + 2 * PI;\n\t        }\n\t\n\t        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t    }\n\t\n\t    function createPathProxyFromString(data) {\n\t        if (!data) {\n\t            return [];\n\t        }\n\t\n\t        // command string\n\t        var cs = data.replace(/-/g, ' -')\n\t            .replace(/  /g, ' ')\n\t            .replace(/ /g, ',')\n\t            .replace(/,,/g, ',');\n\t\n\t        var n;\n\t        // create pipes so that we can split the data\n\t        for (n = 0; n < cc.length; n++) {\n\t            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t        }\n\t\n\t        // create array\n\t        var arr = cs.split('|');\n\t        // init context point\n\t        var cpx = 0;\n\t        var cpy = 0;\n\t\n\t        var path = new PathProxy();\n\t        var CMD = PathProxy.CMD;\n\t\n\t        var prevCmd;\n\t        for (n = 1; n < arr.length; n++) {\n\t            var str = arr[n];\n\t            var c = str.charAt(0);\n\t            var off = 0;\n\t            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t            var cmd;\n\t\n\t            if (p.length > 0 && p[0] === '') {\n\t                p.shift();\n\t            }\n\t\n\t            for (var i = 0; i < p.length; i++) {\n\t                p[i] = parseFloat(p[i]);\n\t            }\n\t            while (off < p.length && !isNaN(p[off])) {\n\t                if (isNaN(p[0])) {\n\t                    break;\n\t                }\n\t                var ctlPtx;\n\t                var ctlPty;\n\t\n\t                var rx;\n\t                var ry;\n\t                var psi;\n\t                var fa;\n\t                var fs;\n\t\n\t                var x1 = cpx;\n\t                var y1 = cpy;\n\t\n\t                // convert l, H, h, V, and v to L\n\t                switch (c) {\n\t                    case 'l':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'L':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'm':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'l';\n\t                        break;\n\t                    case 'M':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'L';\n\t                        break;\n\t                    case 'h':\n\t                        cpx += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'H':\n\t                        cpx = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'v':\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'V':\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'C':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n\t                        );\n\t                        cpx = p[off - 2];\n\t                        cpy = p[off - 1];\n\t                        break;\n\t                    case 'c':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy\n\t                        );\n\t                        cpx += p[off - 2];\n\t                        cpy += p[off - 1];\n\t                        break;\n\t                    case 'S':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 's':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = cpx + p[off++];\n\t                        y1 = cpy + p[off++];\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'Q':\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'q':\n\t                        x1 = p[off++] + cpx;\n\t                        y1 = p[off++] + cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'T':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 't':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 'A':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                    case 'a':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                }\n\t            }\n\t\n\t            if (c === 'z' || c === 'Z') {\n\t                cmd = CMD.Z;\n\t                path.addData(cmd);\n\t            }\n\t\n\t            prevCmd = cmd;\n\t        }\n\t\n\t        path.toStatic();\n\t\n\t        return path;\n\t    }\n\t\n\t    // TODO Optimize double memory cost problem\n\t    function createPathOptions(str, opts) {\n\t        var pathProxy = createPathProxyFromString(str);\n\t        var transform;\n\t        opts = opts || {};\n\t        opts.buildPath = function (path) {\n\t            path.setData(pathProxy.data);\n\t            transform && transformPath(path, transform);\n\t            // Svg and vml renderer don't have context\n\t            var ctx = path.getContext();\n\t            if (ctx) {\n\t                path.rebuildPath(ctx);\n\t            }\n\t        };\n\t\n\t        opts.applyTransform = function (m) {\n\t            if (!transform) {\n\t                transform = matrix.create();\n\t            }\n\t            matrix.mul(transform, m, transform);\n\t            this.dirty(true);\n\t        };\n\t\n\t        return opts;\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Create a Path object from path string data\n\t         * http://www.w3.org/TR/SVG/paths.html#PathData\n\t         * @param  {Object} opts Other options\n\t         */\n\t        createFromString: function (str, opts) {\n\t            return new Path(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Create a Path class from path string data\n\t         * @param  {string} str\n\t         * @param  {Object} opts Other options\n\t         */\n\t        extendFromString: function (str, opts) {\n\t            return Path.extend(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Merge multiple paths\n\t         */\n\t        // TODO Apply transform\n\t        // TODO stroke dash\n\t        // TODO Optimize double memory cost problem\n\t        mergePath: function (pathEls, opts) {\n\t            var pathList = [];\n\t            var len = pathEls.length;\n\t            for (var i = 0; i < len; i++) {\n\t                var pathEl = pathEls[i];\n\t                if (pathEl.__dirty) {\n\t                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t                }\n\t                pathList.push(pathEl.path);\n\t            }\n\t\n\t            var pathBundle = new Path(opts);\n\t            pathBundle.buildPath = function (path) {\n\t                path.appendPath(pathList);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            };\n\t\n\t            return pathBundle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 169 */\n/*!*********************************************!*\\\n  !*** ./~/zrender/lib/tool/transformPath.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var CMD = __webpack_require__(/*! ../core/PathProxy */ 28).CMD;\n\t    var vec2 = __webpack_require__(/*! ../core/vector */ 5);\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t\n\t    var points = [[], [], []];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAtan2 = Math.atan2;\n\t    function transformPath(path, m) {\n\t        var data = path.data;\n\t        var cmd;\n\t        var nPoint;\n\t        var i;\n\t        var j;\n\t        var k;\n\t        var p;\n\t\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var R = CMD.R;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        for (i = 0, j = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            j = i;\n\t            nPoint = 0;\n\t\n\t            switch (cmd) {\n\t                case M:\n\t                    nPoint = 1;\n\t                    break;\n\t                case L:\n\t                    nPoint = 1;\n\t                    break;\n\t                case C:\n\t                    nPoint = 3;\n\t                    break;\n\t                case Q:\n\t                    nPoint = 2;\n\t                    break;\n\t                case A:\n\t                    var x = m[4];\n\t                    var y = m[5];\n\t                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n\t                    // cx\n\t                    data[i++] += x;\n\t                    // cy\n\t                    data[i++] += y;\n\t                    // Scale rx and ry\n\t                    // FIXME Assume psi is 0 here\n\t                    data[i++] *= sx;\n\t                    data[i++] *= sy;\n\t\n\t                    // Start angle\n\t                    data[i++] += angle;\n\t                    // end angle\n\t                    data[i++] += angle;\n\t                    // FIXME psi\n\t                    i += 2;\n\t                    j = i;\n\t                    break;\n\t                case R:\n\t                    // x0, y0\n\t                    p[0] = data[i++];\n\t                    p[1] = data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t                    // x1, y1\n\t                    p[0] += data[i++];\n\t                    p[1] += data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t            }\n\t\n\t            for (k = 0; k < nPoint; k++) {\n\t                var p = points[k];\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t\n\t                v2ApplyTransform(p, p, m);\n\t                // Write back\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = transformPath;\n\n\n/***/ },\n/* 170 */\n/*!***********************************!*\\\n  !*** ./~/zrender/lib/vml/core.js ***!\n  \\***********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\tif (!__webpack_require__(/*! ../core/env */ 11).canvasSupported) {\n\t    var urn = 'urn:schemas-microsoft-com:vml';\n\t\n\t    var createNode;\n\t    var win = window;\n\t    var doc = win.document;\n\t\n\t    var vmlInited = false;\n\t\n\t    try {\n\t        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\t        createNode = function (tagName) {\n\t            return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n\t        };\n\t    }\n\t    catch (e) {\n\t        createNode = function (tagName) {\n\t            return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n\t        };\n\t    }\n\t\n\t    // From raphael\n\t    var initVML = function () {\n\t        if (vmlInited) {\n\t            return;\n\t        }\n\t        vmlInited = true;\n\t\n\t        var styleSheets = doc.styleSheets;\n\t        if (styleSheets.length < 31) {\n\t            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n\t        }\n\t        else {\n\t            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n\t            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n\t        }\n\t    };\n\t\n\t    // Not useing return to avoid error when converting to CommonJS module\n\t    module.exports = {\n\t        doc: doc,\n\t        initVML: initVML,\n\t        createNode: createNode\n\t    };\n\t}\n\n\n/***/ },\n/* 171 */,\n/* 172 */,\n/* 173 */,\n/* 174 */\n/*!*********************************************!*\\\n  !*** ./lib/chart/helper/LargeSymbolDraw.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// TODO Batch by color\n\t\n\t\n\t\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var symbolUtil = __webpack_require__(/*! ../../util/symbol */ 26);\n\t\n\t    var LargeSymbolPath = graphic.extendShape({\n\t\n\t        shape: {\n\t            points: null,\n\t            sizes: null\n\t        },\n\t\n\t        symbolProxy: null,\n\t\n\t        buildPath: function (path, shape) {\n\t            var points = shape.points;\n\t            var sizes = shape.sizes;\n\t\n\t            var symbolProxy = this.symbolProxy;\n\t            var symbolProxyShape = symbolProxy.shape;\n\t            for (var i = 0; i < points.length; i++) {\n\t                var pt = points[i];\n\t                var size = sizes[i];\n\t                if (size[0] < 4) {\n\t                    // Optimize for small symbol\n\t                    path.rect(\n\t                        pt[0] - size[0] / 2, pt[1] - size[1] / 2,\n\t                        size[0], size[1]\n\t                    );\n\t                }\n\t                else {\n\t                    symbolProxyShape.x = pt[0] - size[0] / 2;\n\t                    symbolProxyShape.y = pt[1] - size[1] / 2;\n\t                    symbolProxyShape.width = size[0];\n\t                    symbolProxyShape.height = size[1];\n\t\n\t                    symbolProxy.buildPath(path, symbolProxyShape, true);\n\t                }\n\t            }\n\t        },\n\t\n\t        findDataIndex: function (x, y) {\n\t            var shape = this.shape;\n\t            var points = shape.points;\n\t            var sizes = shape.sizes;\n\t\n\t            // Not consider transform\n\t            // Treat each element as a rect\n\t            // top down traverse\n\t            for (var i = points.length - 1; i >= 0; i--) {\n\t                var pt = points[i];\n\t                var size = sizes[i];\n\t                var x0 = pt[0] - size[0] / 2;\n\t                var y0 = pt[1] - size[1] / 2;\n\t                if (x >= x0 && y >= y0 && x <= x0 + size[0] && y <= y0 + size[1]) {\n\t                    // i is dataIndex\n\t                    return i;\n\t                }\n\t            }\n\t\n\t            return -1;\n\t        }\n\t    });\n\t\n\t    function LargeSymbolDraw() {\n\t        this.group = new graphic.Group();\n\t\n\t        this._symbolEl = new LargeSymbolPath({\n\t            // rectHover: true,\n\t            // cursor: 'default'\n\t        });\n\t    }\n\t\n\t    var largeSymbolProto = LargeSymbolDraw.prototype;\n\t\n\t    /**\n\t     * Update symbols draw by new data\n\t     * @param {module:echarts/data/List} data\n\t     */\n\t    largeSymbolProto.updateData = function (data) {\n\t        this.group.removeAll();\n\t\n\t        var symbolEl = this._symbolEl;\n\t\n\t        var seriesModel = data.hostModel;\n\t\n\t        symbolEl.setShape({\n\t            points: data.mapArray(data.getItemLayout),\n\t            sizes: data.mapArray(\n\t                function (idx) {\n\t                    var size = data.getItemVisual(idx, 'symbolSize');\n\t                    if (!(size instanceof Array)) {\n\t                        size = [size, size];\n\t                    }\n\t                    return size;\n\t                }\n\t            )\n\t        });\n\t\n\t        // Create symbolProxy to build path for each data\n\t        symbolEl.symbolProxy = symbolUtil.createSymbol(\n\t            data.getVisual('symbol'), 0, 0, 0, 0\n\t        );\n\t        // Use symbolProxy setColor method\n\t        symbolEl.setColor = symbolEl.symbolProxy.setColor;\n\t\n\t        symbolEl.useStyle(\n\t            seriesModel.getModel('itemStyle.normal').getItemStyle(['color'])\n\t        );\n\t\n\t        var visualColor = data.getVisual('color');\n\t        if (visualColor) {\n\t            symbolEl.setColor(visualColor);\n\t        }\n\t\n\t        // Enable tooltip\n\t        // PENDING May have performance issue when path is extremely large\n\t        symbolEl.seriesIndex = seriesModel.seriesIndex;\n\t        symbolEl.on('mousemove', function (e) {\n\t            symbolEl.dataIndex = null;\n\t            var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);\n\t            if (dataIndex > 0) {\n\t                // Provide dataIndex for tooltip\n\t                symbolEl.dataIndex = dataIndex;\n\t            }\n\t        });\n\t\n\t        // Add back\n\t        this.group.add(symbolEl);\n\t    };\n\t\n\t    largeSymbolProto.updateLayout = function (seriesModel) {\n\t        var data = seriesModel.getData();\n\t        this._symbolEl.setShape({\n\t            points: data.mapArray(data.getItemLayout)\n\t        });\n\t    };\n\t\n\t    largeSymbolProto.remove = function () {\n\t        this.group.removeAll();\n\t    };\n\t\n\t    module.exports = LargeSymbolDraw;\n\n\n/***/ },\n/* 175 */\n/*!**************************************!*\\\n  !*** ./lib/chart/helper/LinePath.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Line path for bezier and straight line draw\n\t */\n\t\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var vec2 = __webpack_require__(/*! zrender/lib/core/vector */ 5);\n\t\n\t    var straightLineProto = graphic.Line.prototype;\n\t    var bezierCurveProto = graphic.BezierCurve.prototype;\n\t\n\t    function isLine(shape) {\n\t        return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);\n\t    }\n\t\n\t    module.exports = graphic.extendShape({\n\t\n\t        type: 'ec-line',\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            percent: 1,\n\t            cpx1: null,\n\t            cpy1: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);\n\t        },\n\t\n\t        pointAt: function (t) {\n\t            return isLine(this.shape)\n\t                ? straightLineProto.pointAt.call(this, t)\n\t                : bezierCurveProto.pointAt.call(this, t);\n\t        },\n\t\n\t        tangentAt: function (t) {\n\t            var shape = this.shape;\n\t            var p = isLine(shape)\n\t                ? [shape.x2 - shape.x1, shape.y2 - shape.y1]\n\t                : bezierCurveProto.tangentAt.call(this, t);\n\t            return vec2.normalize(p, p);\n\t        }\n\t    });\n\n\n/***/ },\n/* 176 */\n/*!******************************!*\\\n  !*** ./lib/chart/scatter.js ***!\n  \\******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var echarts = __webpack_require__(/*! ../echarts */ 2);\n\t\n\t    __webpack_require__(/*! ./scatter/ScatterSeries */ 177);\n\t    __webpack_require__(/*! ./scatter/ScatterView */ 178);\n\t\n\t    echarts.registerVisual(zrUtil.curry(\n\t        __webpack_require__(/*! ../visual/symbol */ 46), 'scatter', 'circle', null\n\t    ));\n\t    echarts.registerLayout(zrUtil.curry(\n\t        __webpack_require__(/*! ../layout/points */ 55), 'scatter'\n\t    ));\n\t\n\t    // In case developer forget to include grid component\n\t    __webpack_require__(/*! ../component/grid */ 36);\n\n\n/***/ },\n/* 177 */\n/*!********************************************!*\\\n  !*** ./lib/chart/scatter/ScatterSeries.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var createListFromArray = __webpack_require__(/*! ../helper/createListFromArray */ 35);\n\t    var SeriesModel = __webpack_require__(/*! ../../model/Series */ 15);\n\t\n\t    module.exports = SeriesModel.extend({\n\t\n\t        type: 'series.scatter',\n\t\n\t        dependencies: ['grid', 'polar'],\n\t\n\t        getInitialData: function (option, ecModel) {\n\t            var list = createListFromArray(option.data, this, ecModel);\n\t            return list;\n\t        },\n\t\n\t        brushSelector: 'point',\n\t\n\t        defaultOption: {\n\t            coordinateSystem: 'cartesian2d',\n\t            zlevel: 0,\n\t            z: 2,\n\t            legendHoverLink: true,\n\t\n\t            hoverAnimation: true,\n\t            // Cartesian coordinate system\n\t            // xAxisIndex: 0,\n\t            // yAxisIndex: 0,\n\t\n\t            // Polar coordinate system\n\t            // polarIndex: 0,\n\t\n\t            // Geo coordinate system\n\t            // geoIndex: 0,\n\t\n\t            // symbol: null,        // \n\t            symbolSize: 10,          // symbolSize * 2\n\t            // symbolRotate: null,  // \n\t\n\t            large: false,\n\t            // Available when large is true\n\t            largeThreshold: 2000,\n\t\n\t            // label: {\n\t                // normal: {\n\t                    // show: false\n\t                    // distance: 5,\n\t                    // formatter: Tooltip.formatter\n\t                    // position: 'top''right'\n\t                    //           'inside'|'left'|'right'|'top'|'bottom'\n\t                    // textStyle: null      // TEXTSTYLE\n\t            //     }\n\t            // },\n\t            itemStyle: {\n\t                normal: {\n\t                    opacity: 0.8\n\t                    // color: \n\t                }\n\t            }\n\t        }\n\t\n\t    });\n\n\n/***/ },\n/* 178 */\n/*!******************************************!*\\\n  !*** ./lib/chart/scatter/ScatterView.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var SymbolDraw = __webpack_require__(/*! ../helper/SymbolDraw */ 39);\n\t    var LargeSymbolDraw = __webpack_require__(/*! ../helper/LargeSymbolDraw */ 174);\n\t\n\t    __webpack_require__(/*! ../../echarts */ 2).extendChartView({\n\t\n\t        type: 'scatter',\n\t\n\t        init: function () {\n\t            this._normalSymbolDraw = new SymbolDraw();\n\t            this._largeSymbolDraw = new LargeSymbolDraw();\n\t        },\n\t\n\t        render: function (seriesModel, ecModel, api) {\n\t            var data = seriesModel.getData();\n\t            var largeSymbolDraw = this._largeSymbolDraw;\n\t            var normalSymbolDraw = this._normalSymbolDraw;\n\t            var group = this.group;\n\t\n\t            var symbolDraw = seriesModel.get('large') && data.count() > seriesModel.get('largeThreshold')\n\t                ? largeSymbolDraw : normalSymbolDraw;\n\t\n\t            this._symbolDraw = symbolDraw;\n\t            symbolDraw.updateData(data);\n\t            group.add(symbolDraw.group);\n\t\n\t            group.remove(\n\t                symbolDraw === largeSymbolDraw\n\t                ? normalSymbolDraw.group : largeSymbolDraw.group\n\t            );\n\t        },\n\t\n\t        updateLayout: function (seriesModel) {\n\t            this._symbolDraw.updateLayout(seriesModel);\n\t        },\n\t\n\t        remove: function (ecModel, api) {\n\t            this._symbolDraw && this._symbolDraw.remove(api, true);\n\t        },\n\t\n\t        dispose: function () {}\n\t    });\n\n\n/***/ },\n/* 179 */\n/*!***********************************!*\\\n  !*** ./lib/component/dataZoom.js ***!\n  \\***********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * DataZoom component entry\n\t */\n\t\n\t\n\t    __webpack_require__(/*! ./dataZoom/typeDefaulter */ 112);\n\t\n\t    __webpack_require__(/*! ./dataZoom/DataZoomModel */ 40);\n\t    __webpack_require__(/*! ./dataZoom/DataZoomView */ 41);\n\t\n\t    __webpack_require__(/*! ./dataZoom/SliderZoomModel */ 185);\n\t    __webpack_require__(/*! ./dataZoom/SliderZoomView */ 186);\n\t\n\t    __webpack_require__(/*! ./dataZoom/InsideZoomModel */ 181);\n\t    __webpack_require__(/*! ./dataZoom/InsideZoomView */ 182);\n\t\n\t    __webpack_require__(/*! ./dataZoom/dataZoomProcessor */ 109);\n\t    __webpack_require__(/*! ./dataZoom/dataZoomAction */ 108);\n\t\n\n\n/***/ },\n/* 180 */\n/*!*********************************************!*\\\n  !*** ./lib/component/dataZoom/AxisProxy.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file Axis operator\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var numberUtil = __webpack_require__(/*! ../../util/number */ 4);\n\t    var each = zrUtil.each;\n\t    var asc = numberUtil.asc;\n\t\n\t    /**\n\t     * Operate single axis.\n\t     * One axis can only operated by one axis operator.\n\t     * Different dataZoomModels may be defined to operate the same axis.\n\t     * (i.e. 'inside' data zoom and 'slider' data zoom components)\n\t     * So dataZoomModels share one axisProxy in that case.\n\t     *\n\t     * @class\n\t     */\n\t    var AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n\t\n\t        /**\n\t         * @private\n\t         * @type {string}\n\t         */\n\t        this._dimName = dimName;\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        this._axisIndex = axisIndex;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._valueWindow;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._percentWindow;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._dataExtent;\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {module: echarts/model/Global}\n\t         */\n\t        this.ecModel = ecModel;\n\t\n\t        /**\n\t         * @private\n\t         * @type {module: echarts/component/dataZoom/DataZoomModel}\n\t         */\n\t        this._dataZoomModel = dataZoomModel;\n\t    };\n\t\n\t    AxisProxy.prototype = {\n\t\n\t        constructor: AxisProxy,\n\t\n\t        /**\n\t         * Whether the axisProxy is hosted by dataZoomModel.\n\t         *\n\t         * @public\n\t         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n\t         * @return {boolean}\n\t         */\n\t        hostedBy: function (dataZoomModel) {\n\t            return this._dataZoomModel === dataZoomModel;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getDataExtent: function () {\n\t            return this._dataExtent.slice();\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getDataValueWindow: function () {\n\t            return this._valueWindow.slice();\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getDataPercentWindow: function () {\n\t            return this._percentWindow.slice();\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @param {number} axisIndex\n\t         * @return {Array} seriesModels\n\t         */\n\t        getTargetSeriesModels: function () {\n\t            var seriesModels = [];\n\t            var ecModel = this.ecModel;\n\t\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                var coordSysName = seriesModel.get('coordinateSystem');\n\t                if (coordSysName === 'cartesian2d' || coordSysName === 'polar') {\n\t                    var dimName = this._dimName;\n\t                    var axisModel = ecModel.queryComponents({\n\t                        mainType: dimName + 'Axis',\n\t                        index: seriesModel.get(dimName + 'AxisIndex'),\n\t                        id: seriesModel.get(dimName + 'AxisId')\n\t                    })[0];\n\t                    if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n\t                        seriesModels.push(seriesModel);\n\t                    }\n\t                }\n\t            }, this);\n\t\n\t            return seriesModels;\n\t        },\n\t\n\t        getAxisModel: function () {\n\t            return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n\t        },\n\t\n\t        getOtherAxisModel: function () {\n\t            var axisDim = this._dimName;\n\t            var ecModel = this.ecModel;\n\t            var axisModel = this.getAxisModel();\n\t            var isCartesian = axisDim === 'x' || axisDim === 'y';\n\t            var otherAxisDim;\n\t            var coordSysIndexName;\n\t            if (isCartesian) {\n\t                coordSysIndexName = 'gridIndex';\n\t                otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n\t            }\n\t            else {\n\t                coordSysIndexName = 'polarIndex';\n\t                otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n\t            }\n\t            var foundOtherAxisModel;\n\t            ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n\t                if ((otherAxisModel.get(coordSysIndexName) || 0)\n\t                    === (axisModel.get(coordSysIndexName) || 0)\n\t                ) {\n\t                    foundOtherAxisModel = otherAxisModel;\n\t                }\n\t            });\n\t            return foundOtherAxisModel;\n\t        },\n\t\n\t        /**\n\t         * Notice: reset should not be called before series.restoreData() called,\n\t         * so it is recommanded to be called in \"process stage\" but not \"model init\n\t         * stage\".\n\t         *\n\t         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n\t         */\n\t        reset: function (dataZoomModel) {\n\t            if (dataZoomModel !== this._dataZoomModel) {\n\t                return;\n\t            }\n\t\n\t            // Culculate data window and data extent, and record them.\n\t            var dataExtent = this._dataExtent = calculateDataExtent(\n\t                this._dimName, this.getTargetSeriesModels()\n\t            );\n\t            var dataWindow = calculateDataWindow(\n\t                dataZoomModel.option, dataExtent, this\n\t            );\n\t            this._valueWindow = dataWindow.valueWindow;\n\t            this._percentWindow = dataWindow.percentWindow;\n\t\n\t            // Update axis setting then.\n\t            setAxisModel(this);\n\t        },\n\t\n\t        /**\n\t         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n\t         */\n\t        restore: function (dataZoomModel) {\n\t            if (dataZoomModel !== this._dataZoomModel) {\n\t                return;\n\t            }\n\t\n\t            this._valueWindow = this._percentWindow = null;\n\t            setAxisModel(this, true);\n\t        },\n\t\n\t        /**\n\t         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n\t         */\n\t        filterData: function (dataZoomModel) {\n\t            if (dataZoomModel !== this._dataZoomModel) {\n\t                return;\n\t            }\n\t\n\t            var axisDim = this._dimName;\n\t            var seriesModels = this.getTargetSeriesModels();\n\t            var filterMode = dataZoomModel.get('filterMode');\n\t            var valueWindow = this._valueWindow;\n\t\n\t            // FIXME\n\t            // Toolbox may has dataZoom injected. And if there are stacked bar chart\n\t            // with NaN data, NaN will be filtered and stack will be wrong.\n\t            // So we need to force the mode to be set empty.\n\t            // In fect, it is not a big deal that do not support filterMode-'filter'\n\t            // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n\t            // selection\" some day, which might need \"adapt to data extent on the\n\t            // otherAxis\", which is disabled by filterMode-'empty'.\n\t            var otherAxisModel = this.getOtherAxisModel();\n\t            if (dataZoomModel.get('$fromToolbox')\n\t                && otherAxisModel\n\t                && otherAxisModel.get('type') === 'category'\n\t            ) {\n\t                filterMode = 'empty';\n\t            }\n\t\n\t            // Process series data\n\t            each(seriesModels, function (seriesModel) {\n\t                var seriesData = seriesModel.getData();\n\t\n\t                seriesData && each(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n\t                    if (filterMode === 'empty') {\n\t                        seriesModel.setData(\n\t                            seriesData.map(dim, function (value) {\n\t                                return !isInWindow(value) ? NaN : value;\n\t                            })\n\t                        );\n\t                    }\n\t                    else {\n\t                        seriesData.filterSelf(dim, isInWindow);\n\t                    }\n\t                });\n\t            });\n\t\n\t            function isInWindow(value) {\n\t                return value >= valueWindow[0] && value <= valueWindow[1];\n\t            }\n\t        }\n\t    };\n\t\n\t    function calculateDataExtent(axisDim, seriesModels) {\n\t        var dataExtent = [Infinity, -Infinity];\n\t\n\t        each(seriesModels, function (seriesModel) {\n\t            var seriesData = seriesModel.getData();\n\t            if (seriesData) {\n\t                each(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n\t                    var seriesExtent = seriesData.getDataExtent(dim);\n\t                    seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n\t                    seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n\t                });\n\t            }\n\t        }, this);\n\t\n\t        return dataExtent;\n\t    }\n\t\n\t    function calculateDataWindow(opt, dataExtent, axisProxy) {\n\t        var axisModel = axisProxy.getAxisModel();\n\t        var scale = axisModel.axis.scale;\n\t        var percentExtent = [0, 100];\n\t        var percentWindow = [\n\t            opt.start,\n\t            opt.end\n\t        ];\n\t        var valueWindow = [];\n\t\n\t        // In percent range is used and axis min/max/scale is set,\n\t        // window should be based on min/max/0, but should not be\n\t        // based on the extent of filtered data.\n\t        dataExtent = dataExtent.slice();\n\t        fixExtendByAxis(dataExtent, axisModel, scale);\n\t\n\t        each(['startValue', 'endValue'], function (prop) {\n\t            valueWindow.push(\n\t                opt[prop] != null\n\t                    ? scale.parse(opt[prop])\n\t                    : null\n\t            );\n\t        });\n\t\n\t        // Normalize bound.\n\t        each([0, 1], function (idx) {\n\t            var boundValue = valueWindow[idx];\n\t            var boundPercent = percentWindow[idx];\n\t\n\t            // start/end has higher priority over startValue/endValue,\n\t            // because start/end can be consistent among different type\n\t            // of axis but startValue/endValue not.\n\t\n\t            if (boundPercent != null || boundValue == null) {\n\t                if (boundPercent == null) {\n\t                    boundPercent = percentExtent[idx];\n\t                }\n\t                // Use scale.parse to math round for category or time axis.\n\t                boundValue = scale.parse(numberUtil.linearMap(\n\t                    boundPercent, percentExtent, dataExtent, true\n\t                ));\n\t            }\n\t            else { // boundPercent == null && boundValue != null\n\t                boundPercent = numberUtil.linearMap(\n\t                    boundValue, dataExtent, percentExtent, true\n\t                );\n\t            }\n\t            // valueWindow[idx] = round(boundValue);\n\t            // percentWindow[idx] = round(boundPercent);\n\t            valueWindow[idx] = boundValue;\n\t            percentWindow[idx] = boundPercent;\n\t        });\n\t\n\t        return {\n\t            valueWindow: asc(valueWindow),\n\t            percentWindow: asc(percentWindow)\n\t        };\n\t    }\n\t\n\t    function fixExtendByAxis(dataExtent, axisModel, scale) {\n\t        each(['min', 'max'], function (minMax, index) {\n\t            var axisMax = axisModel.get(minMax, true);\n\t            // Consider 'dataMin', 'dataMax'\n\t            if (axisMax != null && (axisMax + '').toLowerCase() !== 'data' + minMax) {\n\t                dataExtent[index] = scale.parse(axisMax);\n\t            }\n\t        });\n\t\n\t        if (!axisModel.get('scale', true)) {\n\t            dataExtent[0] > 0 && (dataExtent[0] = 0);\n\t            dataExtent[1] < 0 && (dataExtent[1] = 0);\n\t        }\n\t\n\t        return dataExtent;\n\t    }\n\t\n\t    function setAxisModel(axisProxy, isRestore) {\n\t        var axisModel = axisProxy.getAxisModel();\n\t\n\t        var percentWindow = axisProxy._percentWindow;\n\t        var valueWindow = axisProxy._valueWindow;\n\t\n\t        if (!percentWindow) {\n\t            return;\n\t        }\n\t\n\t        var isFull = isRestore || (percentWindow[0] === 0 && percentWindow[1] === 100);\n\t        // [0, 500]: arbitrary value, guess axis extent.\n\t        var precision = !isRestore && numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n\t        // toFixed() digits argument must be between 0 and 20\n\t        var invalidPrecision = !isRestore && !(precision < 20 && precision >= 0);\n\t\n\t        var useOrigin = isRestore || isFull || invalidPrecision;\n\t\n\t        axisModel.setRange && axisModel.setRange(\n\t            useOrigin ? null : +valueWindow[0].toFixed(precision),\n\t            useOrigin ? null : +valueWindow[1].toFixed(precision)\n\t        );\n\t    }\n\t\n\t    module.exports = AxisProxy;\n\t\n\n\n/***/ },\n/* 181 */\n/*!***************************************************!*\\\n  !*** ./lib/component/dataZoom/InsideZoomModel.js ***!\n  \\***************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file Data zoom model\n\t */\n\t\n\t\n\t    module.exports = __webpack_require__(/*! ./DataZoomModel */ 40).extend({\n\t\n\t        type: 'dataZoom.inside',\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        defaultOption: {\n\t            silent: false,   // Whether disable this inside zoom.\n\t            zoomLock: false  // Whether disable zoom but only pan.\n\t        }\n\t    });\n\n\n/***/ },\n/* 182 */\n/*!**************************************************!*\\\n  !*** ./lib/component/dataZoom/InsideZoomView.js ***!\n  \\**************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var DataZoomView = __webpack_require__(/*! ./DataZoomView */ 41);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var sliderMove = __webpack_require__(/*! ../helper/sliderMove */ 80);\n\t    var roams = __webpack_require__(/*! ./roams */ 187);\n\t    var bind = zrUtil.bind;\n\t\n\t    var InsideZoomView = DataZoomView.extend({\n\t\n\t        type: 'dataZoom.inside',\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        init: function (ecModel, api) {\n\t            /**\n\t             * 'throttle' is used in this.dispatchAction, so we save range\n\t             * to avoid missing some 'pan' info.\n\t             * @private\n\t             * @type {Array.<number>}\n\t             */\n\t            this._range;\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        render: function (dataZoomModel, ecModel, api, payload) {\n\t            InsideZoomView.superApply(this, 'render', arguments);\n\t\n\t            // Notice: origin this._range should be maintained, and should not be re-fetched\n\t            // from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'\n\t            // info will be missed because of 'throttle' of this.dispatchAction.\n\t            if (roams.shouldRecordRange(payload, dataZoomModel.id)) {\n\t                this._range = dataZoomModel.getPercentRange();\n\t            }\n\t\n\t            var targetInfo = this.getTargetInfo();\n\t\n\t            // Reset controllers.\n\t            zrUtil.each(['cartesians', 'polars'], function (coordSysName) {\n\t\n\t                var coordInfoList = targetInfo[coordSysName];\n\t                var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {\n\t                    return roams.generateCoordId(coordInfo.model);\n\t                });\n\t\n\t                zrUtil.each(coordInfoList, function (coordInfo) {\n\t                    var coordModel = coordInfo.model;\n\t                    var coordinateSystem = coordModel.coordinateSystem;\n\t\n\t                    roams.register(\n\t                        api,\n\t                        {\n\t                            coordId: roams.generateCoordId(coordModel),\n\t                            allCoordIds: allCoordIds,\n\t                            coordinateSystem: coordinateSystem,\n\t                            containsPoint: bind(operations[coordSysName].containsPoint, this, coordinateSystem),\n\t                            dataZoomId: dataZoomModel.id,\n\t                            throttleRate: dataZoomModel.get('throttle', true),\n\t                            panGetRange: bind(this._onPan, this, coordInfo, coordSysName),\n\t                            zoomGetRange: bind(this._onZoom, this, coordInfo, coordSysName)\n\t                        }\n\t                    );\n\t                }, this);\n\t\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        dispose: function () {\n\t            roams.unregister(this.api, this.dataZoomModel.id);\n\t            InsideZoomView.superApply(this, 'dispose', arguments);\n\t            this._range = null;\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) {\n\t            if (this.dataZoomModel.option.silent) {\n\t                return this._range;\n\t            }\n\t\n\t            var range = this._range.slice();\n\t\n\t            // Calculate transform by the first axis.\n\t            var axisModel = coordInfo.axisModels[0];\n\t            if (!axisModel) {\n\t                return;\n\t            }\n\t\n\t            var directionInfo = operations[coordSysName].getDirectionInfo(\n\t                [oldX, oldY], [newX, newY], axisModel, controller, coordInfo\n\t            );\n\t\n\t            var percentDelta = directionInfo.signal\n\t                * (range[1] - range[0])\n\t                * directionInfo.pixel / directionInfo.pixelLength;\n\t\n\t            sliderMove(percentDelta, range, [0, 100], 'rigid');\n\t\n\t            return (this._range = range);\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) {\n\t            var option = this.dataZoomModel.option;\n\t\n\t            if (option.silent || option.zoomLock) {\n\t                return this._range;\n\t            }\n\t\n\t            var range = this._range.slice();\n\t\n\t            // Calculate transform by the first axis.\n\t            var axisModel = coordInfo.axisModels[0];\n\t            if (!axisModel) {\n\t                return;\n\t            }\n\t\n\t            var directionInfo = operations[coordSysName].getDirectionInfo(\n\t                null, [mouseX, mouseY], axisModel, controller, coordInfo\n\t            );\n\t\n\t            var percentPoint = (directionInfo.pixel - directionInfo.pixelStart) /\n\t                directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n\t\n\t            scale = Math.max(1 / scale, 0);\n\t            range[0] = (range[0] - percentPoint) * scale + percentPoint;\n\t            range[1] = (range[1] - percentPoint) * scale + percentPoint;\n\t            return (this._range = fixRange(range));\n\t        }\n\t\n\t    });\n\t\n\t    var operations = {\n\t\n\t        cartesians: {\n\t\n\t            getDirectionInfo: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n\t                var axis = axisModel.axis;\n\t                var ret = {};\n\t                var rect = coordInfo.model.coordinateSystem.getRect();\n\t                oldPoint = oldPoint || [0, 0];\n\t\n\t                if (axis.dim === 'x') {\n\t                    ret.pixel = newPoint[0] - oldPoint[0];\n\t                    ret.pixelLength = rect.width;\n\t                    ret.pixelStart = rect.x;\n\t                    ret.signal = axis.inverse ? 1 : -1;\n\t                }\n\t                else { // axis.dim === 'y'\n\t                    ret.pixel = newPoint[1] - oldPoint[1];\n\t                    ret.pixelLength = rect.height;\n\t                    ret.pixelStart = rect.y;\n\t                    ret.signal = axis.inverse ? -1 : 1;\n\t                }\n\t\n\t                return ret;\n\t            },\n\t\n\t            containsPoint: function (coordinateSystem, x, y) {\n\t                return coordinateSystem.getRect().contain(x, y);\n\t            }\n\t        },\n\t\n\t        polars: {\n\t\n\t            getDirectionInfo: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n\t                var axis = axisModel.axis;\n\t                var ret = {};\n\t                var polar = coordInfo.model.coordinateSystem;\n\t                var radiusExtent = polar.getRadiusAxis().getExtent();\n\t                var angleExtent = polar.getAngleAxis().getExtent();\n\t\n\t                oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n\t                newPoint = polar.pointToCoord(newPoint);\n\t\n\t                if (axisModel.mainType === 'radiusAxis') {\n\t                    ret.pixel = newPoint[0] - oldPoint[0];\n\t                    // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);\n\t                    // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);\n\t                    ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n\t                    ret.pixelStart = radiusExtent[0];\n\t                    ret.signal = axis.inverse ? 1 : -1;\n\t                }\n\t                else { // 'angleAxis'\n\t                    ret.pixel = newPoint[1] - oldPoint[1];\n\t                    // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);\n\t                    // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);\n\t                    ret.pixelLength = angleExtent[1] - angleExtent[0];\n\t                    ret.pixelStart = angleExtent[0];\n\t                    ret.signal = axis.inverse ? -1 : 1;\n\t                }\n\t\n\t                return ret;\n\t            },\n\t\n\t            containsPoint: function (coordinateSystem, x, y) {\n\t                var radius = coordinateSystem.getRadiusAxis().getExtent()[1];\n\t                var cx = coordinateSystem.cx;\n\t                var cy = coordinateSystem.cy;\n\t\n\t                return Math.pow(x - cx, 2) + Math.pow(y - cy, 2) <= Math.pow(radius, 2);\n\t            }\n\t        }\n\t    };\n\t\n\t    function fixRange(range) {\n\t        // Clamp, using !(<= or >=) to handle NaN.\n\t        // jshint ignore:start\n\t        var bound = [0, 100];\n\t        !(range[0] <= bound[1]) && (range[0] = bound[1]);\n\t        !(range[1] <= bound[1]) && (range[1] = bound[1]);\n\t        !(range[0] >= bound[0]) && (range[0] = bound[0]);\n\t        !(range[1] >= bound[0]) && (range[1] = bound[0]);\n\t        // jshint ignore:end\n\t\n\t        return range;\n\t    }\n\t\n\t    module.exports = InsideZoomView;\n\n\n/***/ },\n/* 183 */\n/*!***************************************************!*\\\n  !*** ./lib/component/dataZoom/SelectZoomModel.js ***!\n  \\***************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file Data zoom model\n\t */\n\t\n\t\n\t    var DataZoomModel = __webpack_require__(/*! ./DataZoomModel */ 40);\n\t\n\t    module.exports = DataZoomModel.extend({\n\t\n\t        type: 'dataZoom.select'\n\t\n\t    });\n\t\n\n\n/***/ },\n/* 184 */\n/*!**************************************************!*\\\n  !*** ./lib/component/dataZoom/SelectZoomView.js ***!\n  \\**************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    module.exports = __webpack_require__(/*! ./DataZoomView */ 41).extend({\n\t\n\t        type: 'dataZoom.select'\n\t\n\t    });\n\t\n\n\n/***/ },\n/* 185 */\n/*!***************************************************!*\\\n  !*** ./lib/component/dataZoom/SliderZoomModel.js ***!\n  \\***************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file Data zoom model\n\t */\n\t\n\t\n\t    var DataZoomModel = __webpack_require__(/*! ./DataZoomModel */ 40);\n\t\n\t    var SliderZoomModel = DataZoomModel.extend({\n\t\n\t        type: 'dataZoom.slider',\n\t\n\t        layoutMode: 'box',\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        defaultOption: {\n\t            show: true,\n\t\n\t            // ph => placeholder. Using placehoder here because\n\t            // deault value can only be drived in view stage.\n\t            right: 'ph',  // Default align to grid rect.\n\t            top: 'ph',    // Default align to grid rect.\n\t            width: 'ph',  // Default align to grid rect.\n\t            height: 'ph', // Default align to grid rect.\n\t            left: null,   // Default align to grid rect.\n\t            bottom: null, // Default align to grid rect.\n\t\n\t            backgroundColor: 'rgba(47,69,84,0)',    // Background of slider zoom component.\n\t            // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,\n\t                                                    // highest priority, remain for compatibility of\n\t                                                    // previous version, but not recommended any more.\n\t            dataBackground: {\n\t                lineStyle: {\n\t                    color: '#2f4554',\n\t                    width: 0.5,\n\t                    opacity: 0.3\n\t                },\n\t                areaStyle: {\n\t                    color: 'rgba(47,69,84,0.3)',\n\t                    opacity: 0.3\n\t                }\n\t            },\n\t            borderColor: '#ddd',                    // border color of the box. For compatibility,\n\t                                                    // if dataBackgroundColor is set, borderColor\n\t                                                    // is ignored.\n\t\n\t            fillerColor: 'rgba(167,183,204,0.4)',     // Color of selected area.\n\t            // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.\n\t            // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',\n\t            handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',\n\t            // Percent of the slider height\n\t            handleSize: '100%',\n\t\n\t            handleStyle: {\n\t                color: '#a7b7cc'\n\t            },\n\t\n\t            labelPrecision: null,\n\t            labelFormatter: null,\n\t            showDetail: true,\n\t            showDataShadow: 'auto',                 // Default auto decision.\n\t            realtime: true,\n\t            zoomLock: false,                        // Whether disable zoom.\n\t            textStyle: {\n\t                color: '#333'\n\t            }\n\t        }\n\t\n\t    });\n\t\n\t    module.exports = SliderZoomModel;\n\t\n\n\n/***/ },\n/* 186 */\n/*!**************************************************!*\\\n  !*** ./lib/component/dataZoom/SliderZoomView.js ***!\n  \\**************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var throttle = __webpack_require__(/*! ../../util/throttle */ 83);\n\t    var DataZoomView = __webpack_require__(/*! ./DataZoomView */ 41);\n\t    var Rect = graphic.Rect;\n\t    var numberUtil = __webpack_require__(/*! ../../util/number */ 4);\n\t    var linearMap = numberUtil.linearMap;\n\t    var layout = __webpack_require__(/*! ../../util/layout */ 13);\n\t    var sliderMove = __webpack_require__(/*! ../helper/sliderMove */ 80);\n\t    var asc = numberUtil.asc;\n\t    var bind = zrUtil.bind;\n\t    // var mathMax = Math.max;\n\t    var each = zrUtil.each;\n\t\n\t    // Constants\n\t    var DEFAULT_LOCATION_EDGE_GAP = 7;\n\t    var DEFAULT_FRAME_BORDER_WIDTH = 1;\n\t    var DEFAULT_FILLER_SIZE = 30;\n\t    var HORIZONTAL = 'horizontal';\n\t    var VERTICAL = 'vertical';\n\t    var LABEL_GAP = 5;\n\t    var SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];\n\t\n\t    var SliderZoomView = DataZoomView.extend({\n\t\n\t        type: 'dataZoom.slider',\n\t\n\t        init: function (ecModel, api) {\n\t\n\t            /**\n\t             * @private\n\t             * @type {Object}\n\t             */\n\t            this._displayables = {};\n\t\n\t            /**\n\t             * @private\n\t             * @type {string}\n\t             */\n\t            this._orient;\n\t\n\t            /**\n\t             * [0, 100]\n\t             * @private\n\t             */\n\t            this._range;\n\t\n\t            /**\n\t             * [coord of the first handle, coord of the second handle]\n\t             * @private\n\t             */\n\t            this._handleEnds;\n\t\n\t            /**\n\t             * [length, thick]\n\t             * @private\n\t             * @type {Array.<number>}\n\t             */\n\t            this._size;\n\t\n\t            /**\n\t             * @private\n\t             * @type {number}\n\t             */\n\t            this._handleWidth;\n\t\n\t            /**\n\t             * @private\n\t             * @type {number}\n\t             */\n\t            this._handleHeight;\n\t\n\t            /**\n\t             * @private\n\t             */\n\t            this._location;\n\t\n\t            /**\n\t             * @private\n\t             */\n\t            this._dragging;\n\t\n\t            /**\n\t             * @private\n\t             */\n\t            this._dataShadowInfo;\n\t\n\t            this.api = api;\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        render: function (dataZoomModel, ecModel, api, payload) {\n\t            SliderZoomView.superApply(this, 'render', arguments);\n\t\n\t            throttle.createOrUpdate(\n\t                this,\n\t                '_dispatchZoomAction',\n\t                this.dataZoomModel.get('throttle'),\n\t                'fixRate'\n\t            );\n\t\n\t            this._orient = dataZoomModel.get('orient');\n\t\n\t            if (this.dataZoomModel.get('show') === false) {\n\t                this.group.removeAll();\n\t                return;\n\t            }\n\t\n\t            // Notice: this._resetInterval() should not be executed when payload.type\n\t            // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'\n\t            // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,\n\t            if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {\n\t                this._buildView();\n\t            }\n\t\n\t            this._updateView();\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        remove: function () {\n\t            SliderZoomView.superApply(this, 'remove', arguments);\n\t            throttle.clear(this, '_dispatchZoomAction');\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        dispose: function () {\n\t            SliderZoomView.superApply(this, 'dispose', arguments);\n\t            throttle.clear(this, '_dispatchZoomAction');\n\t        },\n\t\n\t        _buildView: function () {\n\t            var thisGroup = this.group;\n\t\n\t            thisGroup.removeAll();\n\t\n\t            this._resetLocation();\n\t            this._resetInterval();\n\t\n\t            var barGroup = this._displayables.barGroup = new graphic.Group();\n\t\n\t            this._renderBackground();\n\t\n\t            this._renderHandle();\n\t\n\t            this._renderDataShadow();\n\t\n\t            thisGroup.add(barGroup);\n\t\n\t            this._positionGroup();\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _resetLocation: function () {\n\t            var dataZoomModel = this.dataZoomModel;\n\t            var api = this.api;\n\t\n\t            // If some of x/y/width/height are not specified,\n\t            // auto-adapt according to target grid.\n\t            var coordRect = this._findCoordRect();\n\t            var ecSize = {width: api.getWidth(), height: api.getHeight()};\n\t            // Default align by coordinate system rect.\n\t            var positionInfo = this._orient === HORIZONTAL\n\t                ? {\n\t                    // Why using 'right', because right should be used in vertical,\n\t                    // and it is better to be consistent for dealing with position param merge.\n\t                    right: ecSize.width - coordRect.x - coordRect.width,\n\t                    top: (ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP),\n\t                    width: coordRect.width,\n\t                    height: DEFAULT_FILLER_SIZE\n\t                }\n\t                : { // vertical\n\t                    right: DEFAULT_LOCATION_EDGE_GAP,\n\t                    top: coordRect.y,\n\t                    width: DEFAULT_FILLER_SIZE,\n\t                    height: coordRect.height\n\t                };\n\t\n\t            // Do not write back to option and replace value 'ph', because\n\t            // the 'ph' value should be recalculated when resize.\n\t            var layoutParams = layout.getLayoutParams(dataZoomModel.option);\n\t\n\t            // Replace the placeholder value.\n\t            zrUtil.each(['right', 'top', 'width', 'height'], function (name) {\n\t                if (layoutParams[name] === 'ph') {\n\t                    layoutParams[name] = positionInfo[name];\n\t                }\n\t            });\n\t\n\t            var layoutRect = layout.getLayoutRect(\n\t                layoutParams,\n\t                ecSize,\n\t                dataZoomModel.padding\n\t            );\n\t\n\t            this._location = {x: layoutRect.x, y: layoutRect.y};\n\t            this._size = [layoutRect.width, layoutRect.height];\n\t            this._orient === VERTICAL && this._size.reverse();\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _positionGroup: function () {\n\t            var thisGroup = this.group;\n\t            var location = this._location;\n\t            var orient = this._orient;\n\t\n\t            // Just use the first axis to determine mapping.\n\t            var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();\n\t            var inverse = targetAxisModel && targetAxisModel.get('inverse');\n\t\n\t            var barGroup = this._displayables.barGroup;\n\t            var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;\n\t\n\t            // Transform barGroup.\n\t            barGroup.attr(\n\t                (orient === HORIZONTAL && !inverse)\n\t                ? {scale: otherAxisInverse ? [1, 1] : [1, -1]}\n\t                : (orient === HORIZONTAL && inverse)\n\t                ? {scale: otherAxisInverse ? [-1, 1] : [-1, -1]}\n\t                : (orient === VERTICAL && !inverse)\n\t                ? {scale: otherAxisInverse ? [1, -1] : [1, 1], rotation: Math.PI / 2}\n\t                // Dont use Math.PI, considering shadow direction.\n\t                : {scale: otherAxisInverse ? [-1, -1] : [-1, 1], rotation: Math.PI / 2}\n\t            );\n\t\n\t            // Position barGroup\n\t            var rect = thisGroup.getBoundingRect([barGroup]);\n\t            thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _getViewExtent: function () {\n\t            return [0, this._size[0]];\n\t        },\n\t\n\t        _renderBackground : function () {\n\t            var dataZoomModel = this.dataZoomModel;\n\t            var size = this._size;\n\t\n\t            this._displayables.barGroup.add(new Rect({\n\t                silent: true,\n\t                shape: {\n\t                    x: 0, y: 0, width: size[0], height: size[1]\n\t                },\n\t                style: {\n\t                    fill: dataZoomModel.get('backgroundColor')\n\t                },\n\t                z2: -40\n\t            }));\n\t        },\n\t\n\t        _renderDataShadow: function () {\n\t            var info = this._dataShadowInfo = this._prepareDataShadowInfo();\n\t\n\t            if (!info) {\n\t                return;\n\t            }\n\t\n\t            var size = this._size;\n\t            var seriesModel = info.series;\n\t            var data = seriesModel.getRawData();\n\t            var otherDim = seriesModel.getShadowDim\n\t                ? seriesModel.getShadowDim() // @see candlestick\n\t                : info.otherDim;\n\t\n\t            var otherDataExtent = data.getDataExtent(otherDim);\n\t            // Nice extent.\n\t            var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;\n\t            otherDataExtent = [\n\t                otherDataExtent[0] - otherOffset,\n\t                otherDataExtent[1] + otherOffset\n\t            ];\n\t            var otherShadowExtent = [0, size[1]];\n\t\n\t            var thisShadowExtent = [0, size[0]];\n\t\n\t            var areaPoints = [[size[0], 0], [0, 0]];\n\t            var linePoints = [];\n\t            var step = thisShadowExtent[1] / (data.count() - 1);\n\t            var thisCoord = 0;\n\t\n\t            // Optimize for large data shadow\n\t            var stride = Math.round(data.count() / size[0]);\n\t            var lastIsEmpty;\n\t            data.each([otherDim], function (value, index) {\n\t                if (stride > 0 && (index % stride)) {\n\t                    thisCoord += step;\n\t                    return;\n\t                }\n\t\n\t                // FIXME\n\t                // Should consider axis.min/axis.max when drawing dataShadow.\n\t\n\t                // FIXME\n\t                // list\n\t                var isEmpty = value == null || isNaN(value) || value === '';\n\t                // See #4235.\n\t                var otherCoord = isEmpty\n\t                    ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true);\n\t\n\t                // Attempt to draw data shadow precisely when there are empty value.\n\t                if (isEmpty && !lastIsEmpty && index) {\n\t                    areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);\n\t                    linePoints.push([linePoints[linePoints.length - 1][0], 0]);\n\t                }\n\t                else if (!isEmpty && lastIsEmpty) {\n\t                    areaPoints.push([thisCoord, 0]);\n\t                    linePoints.push([thisCoord, 0]);\n\t                }\n\t\n\t                areaPoints.push([thisCoord, otherCoord]);\n\t                linePoints.push([thisCoord, otherCoord]);\n\t\n\t                thisCoord += step;\n\t                lastIsEmpty = isEmpty;\n\t            });\n\t\n\t            var dataZoomModel = this.dataZoomModel;\n\t            // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');\n\t            this._displayables.barGroup.add(new graphic.Polygon({\n\t                shape: {points: areaPoints},\n\t                style: zrUtil.defaults(\n\t                    {fill: dataZoomModel.get('dataBackgroundColor')},\n\t                    dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()\n\t                ),\n\t                silent: true,\n\t                z2: -20\n\t            }));\n\t            this._displayables.barGroup.add(new graphic.Polyline({\n\t                shape: {points: linePoints},\n\t                style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),\n\t                silent: true,\n\t                z2: -19\n\t            }));\n\t        },\n\t\n\t        _prepareDataShadowInfo: function () {\n\t            var dataZoomModel = this.dataZoomModel;\n\t            var showDataShadow = dataZoomModel.get('showDataShadow');\n\t\n\t            if (showDataShadow === false) {\n\t                return;\n\t            }\n\t\n\t            // Find a representative series.\n\t            var result;\n\t            var ecModel = this.ecModel;\n\t\n\t            dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n\t                var seriesModels = dataZoomModel\n\t                    .getAxisProxy(dimNames.name, axisIndex)\n\t                    .getTargetSeriesModels();\n\t\n\t                zrUtil.each(seriesModels, function (seriesModel) {\n\t                    if (result) {\n\t                        return;\n\t                    }\n\t\n\t                    if (showDataShadow !== true && zrUtil.indexOf(\n\t                            SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')\n\t                        ) < 0\n\t                    ) {\n\t                        return;\n\t                    }\n\t\n\t                    var otherDim = getOtherDim(dimNames.name);\n\t\n\t                    var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;\n\t\n\t                    result = {\n\t                        thisAxis: thisAxis,\n\t                        series: seriesModel,\n\t                        thisDim: dimNames.name,\n\t                        otherDim: otherDim,\n\t                        otherAxisInverse: seriesModel\n\t                            .coordinateSystem.getOtherAxis(thisAxis).inverse\n\t                    };\n\t\n\t                }, this);\n\t\n\t            }, this);\n\t\n\t            return result;\n\t        },\n\t\n\t        _renderHandle: function () {\n\t            var displaybles = this._displayables;\n\t            var handles = displaybles.handles = [];\n\t            var handleLabels = displaybles.handleLabels = [];\n\t            var barGroup = this._displayables.barGroup;\n\t            var size = this._size;\n\t            var dataZoomModel = this.dataZoomModel;\n\t\n\t            barGroup.add(displaybles.filler = new Rect({\n\t                draggable: true,\n\t                cursor: 'move',\n\t                drift: bind(this._onDragMove, this, 'all'),\n\t                ondragstart: bind(this._showDataInfo, this, true),\n\t                ondragend: bind(this._onDragEnd, this),\n\t                onmouseover: bind(this._showDataInfo, this, true),\n\t                onmouseout: bind(this._showDataInfo, this, false),\n\t                style: {\n\t                    fill: dataZoomModel.get('fillerColor'),\n\t                    textPosition : 'inside'\n\t                }\n\t            }));\n\t\n\t            // Frame border.\n\t            barGroup.add(new Rect(graphic.subPixelOptimizeRect({\n\t                silent: true,\n\t                shape: {\n\t                    x: 0,\n\t                    y: 0,\n\t                    width: size[0],\n\t                    height: size[1]\n\t                },\n\t                style: {\n\t                    stroke: dataZoomModel.get('dataBackgroundColor')\n\t                        || dataZoomModel.get('borderColor'),\n\t                    lineWidth: DEFAULT_FRAME_BORDER_WIDTH,\n\t                    fill: 'rgba(0,0,0,0)'\n\t                }\n\t            })));\n\t\n\t            var iconStr = dataZoomModel.get('handleIcon');\n\t            each([0, 1], function (handleIndex) {\n\t                var path = graphic.makePath(iconStr, {\n\t                    style: {\n\t                        strokeNoScale: true\n\t                    },\n\t                    rectHover: true,\n\t                    cursor: this._orient === 'vertical' ? 'ns-resize' : 'ew-resize',\n\t                    draggable: true,\n\t                    drift: bind(this._onDragMove, this, handleIndex),\n\t                    ondragend: bind(this._onDragEnd, this),\n\t                    onmouseover: bind(this._showDataInfo, this, true),\n\t                    onmouseout: bind(this._showDataInfo, this, false)\n\t                }, {\n\t                    x: -0.5,\n\t                    y: 0,\n\t                    width: 1,\n\t                    height: 1\n\t                }, 'center');\n\t\n\t                var bRect = path.getBoundingRect();\n\t                this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);\n\t                this._handleWidth = bRect.width / bRect.height * this._handleHeight;\n\t\n\t                path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());\n\t                var handleColor = dataZoomModel.get('handleColor');\n\t                // Compatitable with previous version\n\t                if (handleColor != null) {\n\t                    path.style.fill = handleColor;\n\t                }\n\t\n\t                barGroup.add(handles[handleIndex] = path);\n\t\n\t                var textStyleModel = dataZoomModel.textStyleModel;\n\t\n\t                this.group.add(\n\t                    handleLabels[handleIndex] = new graphic.Text({\n\t                    silent: true,\n\t                    invisible: true,\n\t                    style: {\n\t                        x: 0, y: 0, text: '',\n\t                        textVerticalAlign: 'middle',\n\t                        textAlign: 'center',\n\t                        fill: textStyleModel.getTextColor(),\n\t                        textFont: textStyleModel.getFont()\n\t                    },\n\t                    z2: 10\n\t                }));\n\t\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _resetInterval: function () {\n\t            var range = this._range = this.dataZoomModel.getPercentRange();\n\t            var viewExtent = this._getViewExtent();\n\t\n\t            this._handleEnds = [\n\t                linearMap(range[0], [0, 100], viewExtent, true),\n\t                linearMap(range[1], [0, 100], viewExtent, true)\n\t            ];\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {(number|string)} handleIndex 0 or 1 or 'all'\n\t         * @param {number} dx\n\t         * @param {number} dy\n\t         */\n\t        _updateInterval: function (handleIndex, delta) {\n\t            var handleEnds = this._handleEnds;\n\t            var viewExtend = this._getViewExtent();\n\t\n\t            sliderMove(\n\t                delta,\n\t                handleEnds,\n\t                viewExtend,\n\t                (handleIndex === 'all' || this.dataZoomModel.get('zoomLock'))\n\t                    ? 'rigid' : 'cross',\n\t                handleIndex\n\t            );\n\t\n\t            this._range = asc([\n\t                linearMap(handleEnds[0], viewExtend, [0, 100], true),\n\t                linearMap(handleEnds[1], viewExtend, [0, 100], true)\n\t            ]);\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _updateView: function () {\n\t            var displaybles = this._displayables;\n\t            var handleEnds = this._handleEnds;\n\t            var handleInterval = asc(handleEnds.slice());\n\t            var size = this._size;\n\t\n\t            each([0, 1], function (handleIndex) {\n\t                // Handles\n\t                var handle = displaybles.handles[handleIndex];\n\t                var handleHeight = this._handleHeight;\n\t                handle.attr({\n\t                    scale: [handleHeight, handleHeight],\n\t                    position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]\n\t                });\n\t            }, this);\n\t\n\t            // Filler\n\t            displaybles.filler.setShape({\n\t                x: handleInterval[0],\n\t                y: 0,\n\t                width: handleInterval[1] - handleInterval[0],\n\t                height: size[1]\n\t            });\n\t\n\t            this._updateDataInfo();\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _updateDataInfo: function () {\n\t            var dataZoomModel = this.dataZoomModel;\n\t            var displaybles = this._displayables;\n\t            var handleLabels = displaybles.handleLabels;\n\t            var orient = this._orient;\n\t            var labelTexts = ['', ''];\n\t\n\t            // FIXME\n\t            // dateformatterautoformatterec2 date.getAutoFormatter\n\t            if (dataZoomModel.get('showDetail')) {\n\t                var dataInterval;\n\t                var axis;\n\t                dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n\t                    // Using dataInterval of the first axis.\n\t                    if (!dataInterval) {\n\t                        dataInterval = dataZoomModel\n\t                            .getAxisProxy(dimNames.name, axisIndex)\n\t                            .getDataValueWindow();\n\t                        axis = this.ecModel.getComponent(dimNames.axis, axisIndex).axis;\n\t                    }\n\t                }, this);\n\t\n\t                if (dataInterval) {\n\t                    labelTexts = [\n\t                        this._formatLabel(dataInterval[0], axis),\n\t                        this._formatLabel(dataInterval[1], axis)\n\t                    ];\n\t                }\n\t            }\n\t\n\t            var orderedHandleEnds = asc(this._handleEnds.slice());\n\t\n\t            setLabel.call(this, 0);\n\t            setLabel.call(this, 1);\n\t\n\t            function setLabel(handleIndex) {\n\t                // Label\n\t                // Text should not transform by barGroup.\n\t                // Ignore handlers transform\n\t                var barTransform = graphic.getTransform(\n\t                    displaybles.handles[handleIndex].parent, this.group\n\t                );\n\t                var direction = graphic.transformDirection(\n\t                    handleIndex === 0 ? 'right' : 'left', barTransform\n\t                );\n\t                var offset = this._handleWidth / 2 + LABEL_GAP;\n\t                var textPoint = graphic.applyTransform(\n\t                    [\n\t                        orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset),\n\t                        this._size[1] / 2\n\t                    ],\n\t                    barTransform\n\t                );\n\t                handleLabels[handleIndex].setStyle({\n\t                    x: textPoint[0],\n\t                    y: textPoint[1],\n\t                    textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,\n\t                    textAlign: orient === HORIZONTAL ? direction : 'center',\n\t                    text: labelTexts[handleIndex]\n\t                });\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _formatLabel: function (value, axis) {\n\t            var dataZoomModel = this.dataZoomModel;\n\t            var labelFormatter = dataZoomModel.get('labelFormatter');\n\t\n\t            var labelPrecision = dataZoomModel.get('labelPrecision');\n\t            if (labelPrecision == null || labelPrecision === 'auto') {\n\t                labelPrecision = axis.getPixelPrecision();\n\t            }\n\t\n\t            var valueStr = (value == null && isNaN(value))\n\t                ? ''\n\t                // FIXME Glue code\n\t                : (axis.type === 'category' || axis.type === 'time')\n\t                    ? axis.scale.getLabel(Math.round(value))\n\t                    // param of toFixed should less then 20.\n\t                    : value.toFixed(Math.min(labelPrecision, 20));\n\t\n\t            return zrUtil.isFunction(labelFormatter)\n\t                ? labelFormatter(value, valueStr)\n\t                : zrUtil.isString(labelFormatter)\n\t                ? labelFormatter.replace('{value}', valueStr)\n\t                : valueStr;\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {boolean} showOrHide true: show, false: hide\n\t         */\n\t        _showDataInfo: function (showOrHide) {\n\t            // Always show when drgging.\n\t            showOrHide = this._dragging || showOrHide;\n\t\n\t            var handleLabels = this._displayables.handleLabels;\n\t            handleLabels[0].attr('invisible', !showOrHide);\n\t            handleLabels[1].attr('invisible', !showOrHide);\n\t        },\n\t\n\t        _onDragMove: function (handleIndex, dx, dy) {\n\t            this._dragging = true;\n\t\n\t            // Transform dx, dy to bar coordination.\n\t            var vertex = this._applyBarTransform([dx, dy], true);\n\t\n\t            this._updateInterval(handleIndex, vertex[0]);\n\t            this._updateView();\n\t\n\t            if (this.dataZoomModel.get('realtime')) {\n\t                this._dispatchZoomAction();\n\t            }\n\t        },\n\t\n\t        _onDragEnd: function () {\n\t            this._dragging = false;\n\t            this._showDataInfo(false);\n\t            this._dispatchZoomAction();\n\t        },\n\t\n\t        /**\n\t         * This action will be throttled.\n\t         * @private\n\t         */\n\t        _dispatchZoomAction: function () {\n\t            var range = this._range;\n\t\n\t            this.api.dispatchAction({\n\t                type: 'dataZoom',\n\t                from: this.uid,\n\t                dataZoomId: this.dataZoomModel.id,\n\t                start: range[0],\n\t                end: range[1]\n\t            });\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _applyBarTransform: function (vertex, inverse) {\n\t            var barTransform = this._displayables.barGroup.getLocalTransform();\n\t            return graphic.applyTransform(vertex, barTransform, inverse);\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        _findCoordRect: function () {\n\t            // Find the grid coresponding to the first axis referred by dataZoom.\n\t            var targetInfo = this.getTargetInfo();\n\t\n\t            // FIXME\n\t            // catesianpolar\n\t            var rect;\n\t            if (targetInfo.cartesians.length) {\n\t                rect = targetInfo.cartesians[0].model.coordinateSystem.getRect();\n\t            }\n\t            else { // Polar\n\t                // FIXME\n\t                // \n\t                var width = this.api.getWidth();\n\t                var height = this.api.getHeight();\n\t                rect = {\n\t                    x: width * 0.2,\n\t                    y: height * 0.2,\n\t                    width: width * 0.6,\n\t                    height: height * 0.6\n\t                };\n\t            }\n\t\n\t            return rect;\n\t        }\n\t\n\t    });\n\t\n\t    function getOtherDim(thisDim) {\n\t        // FIXME\n\t        // getOtherAxis\n\t        return thisDim === 'x' ? 'y' : 'x';\n\t    }\n\t\n\t    module.exports = SliderZoomView;\n\t\n\n\n/***/ },\n/* 187 */\n/*!*****************************************!*\\\n  !*** ./lib/component/dataZoom/roams.js ***!\n  \\*****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file Roam controller manager.\n\t */\n\t\n\t\n\t    // Only create one roam controller for each coordinate system.\n\t    // one roam controller might be refered by two inside data zoom\n\t    // components (for example, one for x and one for y). When user\n\t    // pan or zoom, only dispatch one action for those data zoom\n\t    // components.\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var RoamController = __webpack_require__(/*! ../../component/helper/RoamController */ 79);\n\t    var throttle = __webpack_require__(/*! ../../util/throttle */ 83);\n\t    var curry = zrUtil.curry;\n\t\n\t    var ATTR = '\\0_ec_dataZoom_roams';\n\t\n\t    var roams = {\n\t\n\t        /**\n\t         * @public\n\t         * @param {module:echarts/ExtensionAPI} api\n\t         * @param {Object} dataZoomInfo\n\t         * @param {string} dataZoomInfo.coordId\n\t         * @param {Function} dataZoomInfo.containsPoint\n\t         * @param {Array.<string>} dataZoomInfo.allCoordIds\n\t         * @param {string} dataZoomInfo.dataZoomId\n\t         * @param {number} dataZoomInfo.throttleRate\n\t         * @param {Function} dataZoomInfo.panGetRange\n\t         * @param {Function} dataZoomInfo.zoomGetRange\n\t         */\n\t        register: function (api, dataZoomInfo) {\n\t            var store = giveStore(api);\n\t            var theDataZoomId = dataZoomInfo.dataZoomId;\n\t            var theCoordId = dataZoomInfo.coordId;\n\t\n\t            // Do clean when a dataZoom changes its target coordnate system.\n\t            // Avoid memory leak, dispose all not-used-registered.\n\t            zrUtil.each(store, function (record, coordId) {\n\t                var dataZoomInfos = record.dataZoomInfos;\n\t                if (dataZoomInfos[theDataZoomId]\n\t                    && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0\n\t                ) {\n\t                    delete dataZoomInfos[theDataZoomId];\n\t                    record.count--;\n\t                }\n\t            });\n\t\n\t            cleanStore(store);\n\t\n\t            var record = store[theCoordId];\n\t            // Create if needed.\n\t            if (!record) {\n\t                record = store[theCoordId] = {\n\t                    coordId: theCoordId,\n\t                    dataZoomInfos: {},\n\t                    count: 0\n\t                };\n\t                record.controller = createController(api, dataZoomInfo, record);\n\t                record.dispatchAction = zrUtil.curry(dispatchAction, api);\n\t            }\n\t\n\t            // Consider resize, area should be always updated.\n\t            record.controller.setContainsPoint(dataZoomInfo.containsPoint);\n\t\n\t            // Update throttle.\n\t            throttle.createOrUpdate(\n\t                record,\n\t                'dispatchAction',\n\t                dataZoomInfo.throttleRate,\n\t                'fixRate'\n\t            );\n\t\n\t            // Update reference of dataZoom.\n\t            !(record.dataZoomInfos[theDataZoomId]) && record.count++;\n\t            record.dataZoomInfos[theDataZoomId] = dataZoomInfo;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @param {module:echarts/ExtensionAPI} api\n\t         * @param {string} dataZoomId\n\t         */\n\t        unregister: function (api, dataZoomId) {\n\t            var store = giveStore(api);\n\t\n\t            zrUtil.each(store, function (record) {\n\t                record.controller.dispose();\n\t                var dataZoomInfos = record.dataZoomInfos;\n\t                if (dataZoomInfos[dataZoomId]) {\n\t                    delete dataZoomInfos[dataZoomId];\n\t                    record.count--;\n\t                }\n\t            });\n\t\n\t            cleanStore(store);\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         */\n\t        shouldRecordRange: function (payload, dataZoomId) {\n\t            if (payload && payload.type === 'dataZoom' && payload.batch) {\n\t                for (var i = 0, len = payload.batch.length; i < len; i++) {\n\t                    if (payload.batch[i].dataZoomId === dataZoomId) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t            return true;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         */\n\t        generateCoordId: function (coordModel) {\n\t            return coordModel.type + '\\0_' + coordModel.id;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Key: coordId, value: {dataZoomInfos: [], count, controller}\n\t     * @type {Array.<Object>}\n\t     */\n\t    function giveStore(api) {\n\t        // Mount store on zrender instance, so that we do not\n\t        // need to worry about dispose.\n\t        var zr = api.getZr();\n\t        return zr[ATTR] || (zr[ATTR] = {});\n\t    }\n\t\n\t    function createController(api, dataZoomInfo, newRecord) {\n\t        var controller = new RoamController(api.getZr());\n\t        controller.enable();\n\t        controller.on('pan', curry(onPan, newRecord));\n\t        controller.on('zoom', curry(onZoom, newRecord));\n\t\n\t        return controller;\n\t    }\n\t\n\t    function cleanStore(store) {\n\t        zrUtil.each(store, function (record, coordId) {\n\t            if (!record.count) {\n\t                record.controller.dispose();\n\t                delete store[coordId];\n\t            }\n\t        });\n\t    }\n\t\n\t    function onPan(record, dx, dy, oldX, oldY, newX, newY) {\n\t        wrapAndDispatch(record, function (info) {\n\t            return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY);\n\t        });\n\t    }\n\t\n\t    function onZoom(record, scale, mouseX, mouseY) {\n\t        wrapAndDispatch(record, function (info) {\n\t            return info.zoomGetRange(record.controller, scale, mouseX, mouseY);\n\t        });\n\t    }\n\t\n\t    function wrapAndDispatch(record, getRange) {\n\t        var batch = [];\n\t\n\t        zrUtil.each(record.dataZoomInfos, function (info) {\n\t            var range = getRange(info);\n\t            range && batch.push({\n\t                dataZoomId: info.dataZoomId,\n\t                start: range[0],\n\t                end: range[1]\n\t            });\n\t        });\n\t\n\t        record.dispatchAction(batch);\n\t    }\n\t\n\t    /**\n\t     * This action will be throttled.\n\t     */\n\t    function dispatchAction(api, batch) {\n\t        api.dispatchAction({\n\t            type: 'dataZoom',\n\t            batch: batch\n\t        });\n\t    }\n\t\n\t    module.exports = roams;\n\t\n\n\n/***/ },\n/* 188 */\n/*!*****************************************!*\\\n  !*** ./lib/component/dataZoomSelect.js ***!\n  \\*****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * DataZoom component entry\n\t */\n\t\n\t\n\t    __webpack_require__(/*! ./dataZoom/typeDefaulter */ 112);\n\t\n\t    __webpack_require__(/*! ./dataZoom/DataZoomModel */ 40);\n\t    __webpack_require__(/*! ./dataZoom/DataZoomView */ 41);\n\t\n\t    __webpack_require__(/*! ./dataZoom/SelectZoomModel */ 183);\n\t    __webpack_require__(/*! ./dataZoom/SelectZoomView */ 184);\n\t\n\t    __webpack_require__(/*! ./dataZoom/dataZoomProcessor */ 109);\n\t    __webpack_require__(/*! ./dataZoom/dataZoomAction */ 108);\n\t\n\n\n/***/ },\n/* 189 */\n/*!*********************************!*\\\n  !*** ./lib/component/legend.js ***!\n  \\*********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Legend component entry file8\n\t */\n\t\n\t\n\t    __webpack_require__(/*! ./legend/LegendModel */ 190);\n\t    __webpack_require__(/*! ./legend/legendAction */ 192);\n\t    __webpack_require__(/*! ./legend/LegendView */ 191);\n\t\n\t    var echarts = __webpack_require__(/*! ../echarts */ 2);\n\t    // Series Filter\n\t    echarts.registerProcessor(__webpack_require__(/*! ./legend/legendFilter */ 193));\n\n\n/***/ },\n/* 190 */\n/*!*********************************************!*\\\n  !*** ./lib/component/legend/LegendModel.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var Model = __webpack_require__(/*! ../../model/Model */ 10);\n\t\n\t    var LegendModel = __webpack_require__(/*! ../../echarts */ 2).extendComponentModel({\n\t\n\t        type: 'legend',\n\t\n\t        dependencies: ['series'],\n\t\n\t        layoutMode: {\n\t            type: 'box',\n\t            ignoreSize: true\n\t        },\n\t\n\t        init: function (option, parentModel, ecModel) {\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t\n\t            option.selected = option.selected || {};\n\t        },\n\t\n\t        mergeOption: function (option) {\n\t            LegendModel.superCall(this, 'mergeOption', option);\n\t        },\n\t\n\t        optionUpdated: function () {\n\t            this._updateData(this.ecModel);\n\t\n\t            var legendData = this._data;\n\t\n\t            // If selectedMode is single, try to select one\n\t            if (legendData[0] && this.get('selectedMode') === 'single') {\n\t                var hasSelected = false;\n\t                // If has any selected in option.selected\n\t                for (var i = 0; i < legendData.length; i++) {\n\t                    var name = legendData[i].get('name');\n\t                    if (this.isSelected(name)) {\n\t                        // Force to unselect others\n\t                        this.select(name);\n\t                        hasSelected = true;\n\t                        break;\n\t                    }\n\t                }\n\t                // Try select the first if selectedMode is single\n\t                !hasSelected && this.select(legendData[0].get('name'));\n\t            }\n\t        },\n\t\n\t        _updateData: function (ecModel) {\n\t            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n\t                // Can be string or number\n\t                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n\t                    dataItem = {\n\t                        name: dataItem\n\t                    };\n\t                }\n\t                return new Model(dataItem, this, this.ecModel);\n\t            }, this);\n\t            this._data = legendData;\n\t\n\t            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n\t                return series.name;\n\t            });\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                if (seriesModel.legendDataProvider) {\n\t                    var data = seriesModel.legendDataProvider();\n\t                    availableNames = availableNames.concat(data.mapArray(data.getName));\n\t                }\n\t            });\n\t            /**\n\t             * @type {Array.<string>}\n\t             * @private\n\t             */\n\t            this._availableNames = availableNames;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:echarts/model/Model>}\n\t         */\n\t        getData: function () {\n\t            return this._data;\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        select: function (name) {\n\t            var selected = this.option.selected;\n\t            var selectedMode = this.get('selectedMode');\n\t            if (selectedMode === 'single') {\n\t                var data = this._data;\n\t                zrUtil.each(data, function (dataItem) {\n\t                    selected[dataItem.get('name')] = false;\n\t                });\n\t            }\n\t            selected[name] = true;\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        unSelect: function (name) {\n\t            if (this.get('selectedMode') !== 'single') {\n\t                this.option.selected[name] = false;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        toggleSelected: function (name) {\n\t            var selected = this.option.selected;\n\t            // Default is true\n\t            if (!selected.hasOwnProperty(name)) {\n\t                selected[name] = true;\n\t            }\n\t            this[selected[name] ? 'unSelect' : 'select'](name);\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        isSelected: function (name) {\n\t            var selected = this.option.selected;\n\t            return !(selected.hasOwnProperty(name) && !selected[name])\n\t                && zrUtil.indexOf(this._availableNames, name) >= 0;\n\t        },\n\t\n\t        defaultOption: {\n\t            // \n\t            zlevel: 0,\n\t            // \n\t            z: 4,\n\t            show: true,\n\t\n\t            // \n\t            // 'horizontal' | 'vertical'\n\t            orient: 'horizontal',\n\t\n\t            left: 'center',\n\t            // right: 'center',\n\t\n\t            top: 'top',\n\t            // bottom: 'top',\n\t\n\t            // \n\t            // 'auto' | 'left' | 'right'\n\t            //  'auto',  x \n\t            align: 'auto',\n\t\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            // \n\t            borderColor: '#ccc',\n\t            // px0\n\t            borderWidth: 0,\n\t            // px5\n\t            // css\n\t            padding: 5,\n\t            // itempx10\n\t            // \n\t            itemGap: 10,\n\t            // \n\t            itemWidth: 25,\n\t            // \n\t            itemHeight: 14,\n\t\n\t            // \n\t            inactiveColor: '#ccc',\n\t\n\t            textStyle: {\n\t                // \n\t                color: '#333'\n\t            },\n\t            // formatter: '',\n\t            // \n\t            selectedMode: true,\n\t            // LEGEND.SELECTED\n\t            // selected: null,\n\t            // legend.dataitem\n\t            // data: [],\n\t\n\t            // Tooltip \n\t            tooltip: {\n\t                show: false\n\t            }\n\t        }\n\t    });\n\t\n\t    module.exports = LegendModel;\n\n\n/***/ },\n/* 191 */\n/*!********************************************!*\\\n  !*** ./lib/component/legend/LegendView.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var symbolCreator = __webpack_require__(/*! ../../util/symbol */ 26);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var listComponentHelper = __webpack_require__(/*! ../helper/listComponent */ 116);\n\t\n\t    var curry = zrUtil.curry;\n\t\n\t    function dispatchSelectAction(name, api) {\n\t        api.dispatchAction({\n\t            type: 'legendToggleSelect',\n\t            name: name\n\t        });\n\t    }\n\t\n\t    function dispatchHighlightAction(seriesModel, dataName, api) {\n\t        // If element hover will move to a hoverLayer.\n\t        var el = api.getZr().storage.getDisplayList()[0];\n\t        if (!(el && el.useHoverLayer)) {\n\t            seriesModel.get('legendHoverLink') && api.dispatchAction({\n\t                type: 'highlight',\n\t                seriesName: seriesModel.name,\n\t                name: dataName\n\t            });\n\t        }\n\t    }\n\t\n\t    function dispatchDownplayAction(seriesModel, dataName, api) {\n\t        // If element hover will move to a hoverLayer.\n\t        var el = api.getZr().storage.getDisplayList()[0];\n\t        if (!(el && el.useHoverLayer)) {\n\t            seriesModel.get('legendHoverLink') && api.dispatchAction({\n\t                type: 'downplay',\n\t                seriesName: seriesModel.name,\n\t                name: dataName\n\t            });\n\t        }\n\t    }\n\t\n\t    module.exports = __webpack_require__(/*! ../../echarts */ 2).extendComponentView({\n\t\n\t        type: 'legend',\n\t\n\t        init: function () {\n\t            this._symbolTypeStore = {};\n\t        },\n\t\n\t        render: function (legendModel, ecModel, api) {\n\t            var group = this.group;\n\t            group.removeAll();\n\t\n\t            if (!legendModel.get('show')) {\n\t                return;\n\t            }\n\t\n\t            var selectMode = legendModel.get('selectedMode');\n\t            var itemAlign = legendModel.get('align');\n\t\n\t            if (itemAlign === 'auto') {\n\t                itemAlign = (legendModel.get('left') === 'right'\n\t                    && legendModel.get('orient') === 'vertical')\n\t                    ? 'right' : 'left';\n\t            }\n\t\n\t            var legendDrawedMap = {};\n\t\n\t            zrUtil.each(legendModel.getData(), function (itemModel) {\n\t                var name = itemModel.get('name');\n\t\n\t                // Use empty string or \\n as a newline string\n\t                if (name === '' || name === '\\n') {\n\t                    group.add(new graphic.Group({\n\t                        newline: true\n\t                    }));\n\t                    return;\n\t                }\n\t\n\t                var seriesModel = ecModel.getSeriesByName(name)[0];\n\t\n\t                if (legendDrawedMap[name]) {\n\t                    // Have been drawed\n\t                    return;\n\t                }\n\t\n\t                // Series legend\n\t                if (seriesModel) {\n\t                    var data = seriesModel.getData();\n\t                    var color = data.getVisual('color');\n\t\n\t                    // If color is a callback function\n\t                    if (typeof color === 'function') {\n\t                        // Use the first data\n\t                        color = color(seriesModel.getDataParams(0));\n\t                    }\n\t\n\t                    // Using rect symbol defaultly\n\t                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n\t                    var symbolType = data.getVisual('symbol');\n\t\n\t                    var itemGroup = this._createItem(\n\t                        name, itemModel, legendModel,\n\t                        legendSymbolType, symbolType,\n\t                        itemAlign, color,\n\t                        selectMode\n\t                    );\n\t\n\t                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n\t                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n\t                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\t\n\t                    legendDrawedMap[name] = true;\n\t                }\n\t                else {\n\t                    // Data legend of pie, funnel\n\t                    ecModel.eachRawSeries(function (seriesModel) {\n\t                        // In case multiple series has same data name\n\t                        if (legendDrawedMap[name]) {\n\t                            return;\n\t                        }\n\t                        if (seriesModel.legendDataProvider) {\n\t                            var data = seriesModel.legendDataProvider();\n\t                            var idx = data.indexOfName(name);\n\t                            if (idx < 0) {\n\t                                return;\n\t                            }\n\t\n\t                            var color = data.getItemVisual(idx, 'color');\n\t\n\t                            var legendSymbolType = 'roundRect';\n\t\n\t                            var itemGroup = this._createItem(\n\t                                name, itemModel, legendModel,\n\t                                legendSymbolType, null,\n\t                                itemAlign, color,\n\t                                selectMode\n\t                            );\n\t\n\t                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n\t                                // FIXME Should not specify the series name\n\t                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n\t                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\t\n\t                            legendDrawedMap[name] = true;\n\t                        }\n\t                    }, this);\n\t                }\n\t\n\t                if (false) {\n\t                    if (!legendDrawedMap[name]) {\n\t                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n\t                    }\n\t                }\n\t            }, this);\n\t\n\t            listComponentHelper.layout(group, legendModel, api);\n\t            // Render background after group is layout\n\t            // FIXME\n\t            listComponentHelper.addBackground(group, legendModel);\n\t        },\n\t\n\t        _createItem: function (\n\t            name, itemModel, legendModel,\n\t            legendSymbolType, symbolType,\n\t            itemAlign, color, selectMode\n\t        ) {\n\t            var itemWidth = legendModel.get('itemWidth');\n\t            var itemHeight = legendModel.get('itemHeight');\n\t            var inactiveColor = legendModel.get('inactiveColor');\n\t\n\t            var isSelected = legendModel.isSelected(name);\n\t            var itemGroup = new graphic.Group();\n\t\n\t            var textStyleModel = itemModel.getModel('textStyle');\n\t\n\t            var itemIcon = itemModel.get('icon');\n\t\n\t            var tooltipModel = itemModel.getModel('tooltip');\n\t            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\t\n\t            // Use user given icon first\n\t            legendSymbolType = itemIcon || legendSymbolType;\n\t            itemGroup.add(symbolCreator.createSymbol(\n\t                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n\t            ));\n\t\n\t            // Compose symbols\n\t            // PENDING\n\t            if (!itemIcon && symbolType\n\t                // At least show one symbol, can't be all none\n\t                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n\t            ) {\n\t                var size = itemHeight * 0.8;\n\t                if (symbolType === 'none') {\n\t                    symbolType = 'circle';\n\t                }\n\t                // Put symbol in the center\n\t                itemGroup.add(symbolCreator.createSymbol(\n\t                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n\t                    isSelected ? color : inactiveColor\n\t                ));\n\t            }\n\t\n\t            // Text\n\t            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n\t            var textAlign = itemAlign;\n\t\n\t            var formatter = legendModel.get('formatter');\n\t            var content = name;\n\t            if (typeof formatter === 'string' && formatter) {\n\t                content = formatter.replace('{name}', name);\n\t            }\n\t            else if (typeof formatter === 'function') {\n\t                content = formatter(name);\n\t            }\n\t\n\t            var text = new graphic.Text({\n\t                style: {\n\t                    text: content,\n\t                    x: textX,\n\t                    y: itemHeight / 2,\n\t                    fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n\t                    textFont: textStyleModel.getFont(),\n\t                    textAlign: textAlign,\n\t                    textVerticalAlign: 'middle'\n\t                }\n\t            });\n\t            itemGroup.add(text);\n\t\n\t            // Add a invisible rect to increase the area of mouse hover\n\t            var hitRect = new graphic.Rect({\n\t                shape: itemGroup.getBoundingRect(),\n\t                invisible: true,\n\t                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n\t                    content: name,\n\t                    // Defaul formatter\n\t                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n\t                        return name;\n\t                    },\n\t                    formatterParams: {\n\t                        componentType: 'legend',\n\t                        legendIndex: legendModel.componentIndex,\n\t                        name: name,\n\t                        $vars: ['name']\n\t                    }\n\t                }, tooltipModel.option) : null\n\t            });\n\t            itemGroup.add(hitRect);\n\t\n\t            itemGroup.eachChild(function (child) {\n\t                child.silent = true;\n\t            });\n\t\n\t            hitRect.silent = !selectMode;\n\t\n\t\n\t\n\t            this.group.add(itemGroup);\n\t\n\t            graphic.setHoverStyle(itemGroup);\n\t\n\t            return itemGroup;\n\t        }\n\t    });\n\n\n/***/ },\n/* 192 */\n/*!**********************************************!*\\\n  !*** ./lib/component/legend/legendAction.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file Legend action\n\t */\n\t\n\t\n\t    var echarts = __webpack_require__(/*! ../../echarts */ 2);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    function legendSelectActionHandler(methodName, payload, ecModel) {\n\t        var selectedMap = {};\n\t        var isToggleSelect = methodName === 'toggleSelected';\n\t        var isSelected;\n\t        // Update all legend components\n\t        ecModel.eachComponent('legend', function (legendModel) {\n\t            if (isToggleSelect && isSelected != null) {\n\t                // Force other legend has same selected status\n\t                // Or the first is toggled to true and other are toggled to false\n\t                // In the case one legend has some item unSelected in option. And if other legend\n\t                // doesn't has the item, they will assume it is selected.\n\t                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n\t            }\n\t            else {\n\t                legendModel[methodName](payload.name);\n\t                isSelected = legendModel.isSelected(payload.name);\n\t            }\n\t            var legendData = legendModel.getData();\n\t            zrUtil.each(legendData, function (model) {\n\t                var name = model.get('name');\n\t                // Wrap element\n\t                if (name === '\\n' || name === '') {\n\t                    return;\n\t                }\n\t                var isItemSelected = legendModel.isSelected(name);\n\t                if (name in selectedMap) {\n\t                    // Unselected if any legend is unselected\n\t                    selectedMap[name] = selectedMap[name] && isItemSelected;\n\t                }\n\t                else {\n\t                    selectedMap[name] = isItemSelected;\n\t                }\n\t            });\n\t        });\n\t        // Return the event explicitly\n\t        return {\n\t            name: payload.name,\n\t            selected: selectedMap\n\t        };\n\t    }\n\t    /**\n\t     * @event legendToggleSelect\n\t     * @type {Object}\n\t     * @property {string} type 'legendToggleSelect'\n\t     * @property {string} [from]\n\t     * @property {string} name Series name or data item name\n\t     */\n\t    echarts.registerAction(\n\t        'legendToggleSelect', 'legendselectchanged',\n\t        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n\t    );\n\t\n\t    /**\n\t     * @event legendSelect\n\t     * @type {Object}\n\t     * @property {string} type 'legendSelect'\n\t     * @property {string} name Series name or data item name\n\t     */\n\t    echarts.registerAction(\n\t        'legendSelect', 'legendselected',\n\t        zrUtil.curry(legendSelectActionHandler, 'select')\n\t    );\n\t\n\t    /**\n\t     * @event legendUnSelect\n\t     * @type {Object}\n\t     * @property {string} type 'legendUnSelect'\n\t     * @property {string} name Series name or data item name\n\t     */\n\t    echarts.registerAction(\n\t        'legendUnSelect', 'legendunselected',\n\t        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n\t    );\n\n\n/***/ },\n/* 193 */\n/*!**********************************************!*\\\n  !*** ./lib/component/legend/legendFilter.js ***!\n  \\**********************************************/\n/***/ function(module, exports) {\n\n\t\n\t   module.exports = function (ecModel) {\n\t        var legendModels = ecModel.findComponents({\n\t            mainType: 'legend'\n\t        });\n\t        if (legendModels && legendModels.length) {\n\t            ecModel.filterSeries(function (series) {\n\t                // If in any legend component the status is not selected.\n\t                // Because in legend series is assumed selected when it is not in the legend data.\n\t                for (var i = 0; i < legendModels.length; i++) {\n\t                    if (!legendModels[i].isSelected(series.name)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return true;\n\t            });\n\t        }\n\t    };\n\n\n/***/ },\n/* 194 */\n/*!***********************************!*\\\n  !*** ./lib/component/markArea.js ***!\n  \\***********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    __webpack_require__(/*! ./marker/MarkAreaModel */ 197);\n\t    __webpack_require__(/*! ./marker/MarkAreaView */ 198);\n\t\n\t    __webpack_require__(/*! ../echarts */ 2).registerPreprocessor(function (opt) {\n\t        // Make sure markArea component is enabled\n\t        opt.markArea = opt.markArea || {};\n\t    });\n\n\n/***/ },\n/* 195 */\n/*!***********************************!*\\\n  !*** ./lib/component/markLine.js ***!\n  \\***********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    __webpack_require__(/*! ./marker/MarkLineModel */ 199);\n\t    __webpack_require__(/*! ./marker/MarkLineView */ 200);\n\t\n\t    __webpack_require__(/*! ../echarts */ 2).registerPreprocessor(function (opt) {\n\t        // Make sure markLine component is enabled\n\t        opt.markLine = opt.markLine || {};\n\t    });\n\n\n/***/ },\n/* 196 */\n/*!************************************!*\\\n  !*** ./lib/component/markPoint.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// HINT Markpoint can't be used too much\n\t\n\t\n\t    __webpack_require__(/*! ./marker/MarkPointModel */ 201);\n\t    __webpack_require__(/*! ./marker/MarkPointView */ 202);\n\t\n\t    __webpack_require__(/*! ../echarts */ 2).registerPreprocessor(function (opt) {\n\t        // Make sure markPoint component is enabled\n\t        opt.markPoint = opt.markPoint || {};\n\t    });\n\n\n/***/ },\n/* 197 */\n/*!***********************************************!*\\\n  !*** ./lib/component/marker/MarkAreaModel.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    module.exports = __webpack_require__(/*! ./MarkerModel */ 67).extend({\n\t\n\t        type: 'markArea',\n\t\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            // PENDING\n\t            z: 1,\n\t            tooltip: {\n\t                trigger: 'item'\n\t            },\n\t            // markArea should fixed on the coordinate system\n\t            animation: false,\n\t            label: {\n\t                normal: {\n\t                    show: true,\n\t                    position: 'top'\n\t                },\n\t                emphasis: {\n\t                    show: true,\n\t                    position: 'top'\n\t                }\n\t            },\n\t            itemStyle: {\n\t                normal: {\n\t                    // color and borderColor default to use color from series\n\t                    // color: 'auto'\n\t                    // borderColor: 'auto'\n\t                    borderWidth: 0\n\t                }\n\t            }\n\t        }\n\t    });\n\n\n/***/ },\n/* 198 */\n/*!**********************************************!*\\\n  !*** ./lib/component/marker/MarkAreaView.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// TODO Better on polar\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var List = __webpack_require__(/*! ../../data/List */ 14);\n\t    var numberUtil = __webpack_require__(/*! ../../util/number */ 4);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var colorUtil = __webpack_require__(/*! zrender/lib/tool/color */ 18);\n\t\n\t    var markerHelper = __webpack_require__(/*! ./markerHelper */ 69);\n\t\n\t    var markAreaTransform = function (seriesModel, coordSys, maModel, item) {\n\t        var lt = markerHelper.dataTransform(seriesModel, item[0]);\n\t        var rb = markerHelper.dataTransform(seriesModel, item[1]);\n\t        var retrieve = zrUtil.retrieve;\n\t\n\t        // FIXME make sure lt is less than rb\n\t        var ltCoord = lt.coord;\n\t        var rbCoord = rb.coord;\n\t        ltCoord[0] = retrieve(ltCoord[0], -Infinity);\n\t        ltCoord[1] = retrieve(ltCoord[1], -Infinity);\n\t\n\t        rbCoord[0] = retrieve(rbCoord[0], Infinity);\n\t        rbCoord[1] = retrieve(rbCoord[1], Infinity);\n\t\n\t        // Merge option into one\n\t        var result = zrUtil.mergeAll([{}, lt, rb]);\n\t\n\t        result.coord = [\n\t            lt.coord, rb.coord\n\t        ];\n\t        result.x0 = lt.x;\n\t        result.y0 = lt.y;\n\t        result.x1 = rb.x;\n\t        result.y1 = rb.y;\n\t        return result;\n\t    };\n\t\n\t    function isInifinity(val) {\n\t        return !isNaN(val) && !isFinite(val);\n\t    }\n\t\n\t    // If a markArea has one dim\n\t    function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n\t        var otherDimIndex = 1 - dimIndex;\n\t        return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);\n\t    }\n\t\n\t    function markAreaFilter(coordSys, item) {\n\t        var fromCoord = item.coord[0];\n\t        var toCoord = item.coord[1];\n\t        if (coordSys.type === 'cartesian2d') {\n\t            // In case\n\t            // {\n\t            //  markArea: {\n\t            //    data: [{ yAxis: 2 }]\n\t            //  }\n\t            // }\n\t            if (\n\t                fromCoord && toCoord &&\n\t                (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys)\n\t                || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))\n\t            ) {\n\t                return true;\n\t            }\n\t        }\n\t        return markerHelper.dataFilter(coordSys, {\n\t                coord: fromCoord,\n\t                x: item.x0,\n\t                y: item.y0\n\t            })\n\t            || markerHelper.dataFilter(coordSys, {\n\t                coord: toCoord,\n\t                x: item.x1,\n\t                y: item.y1\n\t            });\n\t    }\n\t\n\t    // dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']\n\t    function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {\n\t        var coordSys = seriesModel.coordinateSystem;\n\t        var itemModel = data.getItemModel(idx);\n\t\n\t        var point;\n\t        var xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth());\n\t        var yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight());\n\t        if (!isNaN(xPx) && !isNaN(yPx)) {\n\t            point = [xPx, yPx];\n\t        }\n\t        else {\n\t            // Chart like bar may have there own marker positioning logic\n\t            if (seriesModel.getMarkerPosition) {\n\t                // Use the getMarkerPoisition\n\t                point = seriesModel.getMarkerPosition(\n\t                    data.getValues(dims, idx)\n\t                );\n\t            }\n\t            else {\n\t                var x = data.get(dims[0], idx);\n\t                var y = data.get(dims[1], idx);\n\t                point = coordSys.dataToPoint([x, y], true);\n\t            }\n\t            if (coordSys.type === 'cartesian2d') {\n\t                var xAxis = coordSys.getAxis('x');\n\t                var yAxis = coordSys.getAxis('y');\n\t                var x = data.get(dims[0], idx);\n\t                var y = data.get(dims[1], idx);\n\t                if (isInifinity(x)) {\n\t                    point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);\n\t                }\n\t                else if (isInifinity(y)) {\n\t                    point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);\n\t                }\n\t            }\n\t\n\t            // Use x, y if has any\n\t            if (!isNaN(xPx)) {\n\t                point[0] = xPx;\n\t            }\n\t            if (!isNaN(yPx)) {\n\t                point[1] = yPx;\n\t            }\n\t        }\n\t\n\t        return point;\n\t    }\n\t\n\t    var dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];\n\t\n\t    __webpack_require__(/*! ./MarkerView */ 68).extend({\n\t\n\t        type: 'markArea',\n\t\n\t        updateLayout: function (markAreaModel, ecModel, api) {\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                var maModel = seriesModel.markAreaModel;\n\t                if (maModel) {\n\t                    var areaData = maModel.getData();\n\t                    areaData.each(function (idx) {\n\t                        var points = zrUtil.map(dimPermutations, function (dim) {\n\t                            return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n\t                        });\n\t                        // Layout\n\t                        areaData.setItemLayout(idx, points);\n\t                        var el = areaData.getItemGraphicEl(idx);\n\t                        el.setShape('points', points);\n\t                    });\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        renderSeries: function (seriesModel, maModel, ecModel, api) {\n\t            var coordSys = seriesModel.coordinateSystem;\n\t            var seriesName = seriesModel.name;\n\t            var seriesData = seriesModel.getData();\n\t\n\t            var areaGroupMap = this.markerGroupMap;\n\t            var polygonGroup = areaGroupMap[seriesName];\n\t            if (!polygonGroup) {\n\t                polygonGroup = areaGroupMap[seriesName] = {\n\t                    group: new graphic.Group()\n\t                };\n\t            }\n\t            this.group.add(polygonGroup.group);\n\t            polygonGroup.__keep = true;\n\t\n\t            var areaData = createList(coordSys, seriesModel, maModel);\n\t\n\t            // Line data for tooltip and formatter\n\t            maModel.setData(areaData);\n\t\n\t            // Update visual and layout of line\n\t            areaData.each(function (idx) {\n\t                // Layout\n\t                areaData.setItemLayout(idx, zrUtil.map(dimPermutations, function (dim) {\n\t                    return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n\t                }));\n\t\n\t                // Visual\n\t                areaData.setItemVisual(idx, {\n\t                    color: seriesData.getVisual('color')\n\t                });\n\t            });\n\t\n\t\n\t            areaData.diff(polygonGroup.__data)\n\t                .add(function (idx) {\n\t                    var polygon = new graphic.Polygon({\n\t                        shape: {\n\t                            points: areaData.getItemLayout(idx)\n\t                        }\n\t                    });\n\t                    areaData.setItemGraphicEl(idx, polygon);\n\t                    polygonGroup.group.add(polygon);\n\t                })\n\t                .update(function (newIdx, oldIdx) {\n\t                    var polygon = polygonGroup.__data.getItemGraphicEl(oldIdx);\n\t                    graphic.updateProps(polygon, {\n\t                        shape: {\n\t                            points: areaData.getItemLayout(newIdx)\n\t                        }\n\t                    }, maModel, newIdx);\n\t                    polygonGroup.group.add(polygon);\n\t                    areaData.setItemGraphicEl(newIdx, polygon);\n\t                })\n\t                .remove(function (idx) {\n\t                    var polygon = polygonGroup.__data.getItemGraphicEl(idx);\n\t                    polygonGroup.group.remove(polygon);\n\t                })\n\t                .execute();\n\t\n\t            areaData.eachItemGraphicEl(function (polygon, idx) {\n\t                var itemModel = areaData.getItemModel(idx);\n\t                var labelModel = itemModel.getModel('label.normal');\n\t                var labelHoverModel = itemModel.getModel('label.emphasis');\n\t                var color = areaData.getItemVisual(idx, 'color');\n\t                polygon.useStyle(\n\t                    zrUtil.defaults(\n\t                        itemModel.getModel('itemStyle.normal').getItemStyle(),\n\t                        {\n\t                            fill: colorUtil.modifyAlpha(color, 0.4),\n\t                            stroke: color\n\t                        }\n\t                    )\n\t                );\n\t\n\t                polygon.hoverStyle = itemModel.getModel('itemStyle.normal').getItemStyle();\n\t\n\t                var defaultValue = areaData.getName(idx) || '';\n\t                var textColor = color || polygon.style.fill;\n\t                graphic.setText(polygon.style, labelModel, textColor);\n\t                polygon.style.text = zrUtil.retrieve(\n\t                    maModel.getFormattedLabel(idx, 'normal'),\n\t                    defaultValue\n\t                );\n\t\n\t                graphic.setText(polygon.hoverStyle, labelHoverModel, textColor);\n\t                polygon.hoverStyle.text = zrUtil.retrieve(\n\t                    maModel.getFormattedLabel(idx, 'emphasis'),\n\t                    defaultValue\n\t                );\n\t\n\t                graphic.setHoverStyle(polygon, {});\n\t\n\t                polygon.dataModel = maModel;\n\t            });\n\t\n\t            polygonGroup.__data = areaData;\n\t\n\t            polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');\n\t        }\n\t    });\n\t\n\t    /**\n\t     * @inner\n\t     * @param {module:echarts/coord/*} coordSys\n\t     * @param {module:echarts/model/Series} seriesModel\n\t     * @param {module:echarts/model/Model} mpModel\n\t     */\n\t    function createList(coordSys, seriesModel, maModel) {\n\t\n\t        var coordDimsInfos;\n\t        var areaData;\n\t        var dims = ['x0', 'y0', 'x1', 'y1'];\n\t        if (coordSys) {\n\t            coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n\t                var info = seriesModel.getData().getDimensionInfo(\n\t                    seriesModel.coordDimToDataDim(coordDim)[0]\n\t                ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\t                info.name = coordDim;\n\t                return info;\n\t            });\n\t            areaData = new List(zrUtil.map(dims, function (dim, idx) {\n\t                return {\n\t                    name: dim,\n\t                    type: coordDimsInfos[idx % 2].type\n\t                };\n\t            }), maModel);\n\t        }\n\t        else {\n\t            coordDimsInfos =[{\n\t                name: 'value',\n\t                type: 'float'\n\t            }];\n\t            areaData = new List(coordDimsInfos, maModel);\n\t        }\n\t\n\t        var optData = zrUtil.map(maModel.get('data'), zrUtil.curry(\n\t            markAreaTransform, seriesModel, coordSys, maModel\n\t        ));\n\t        if (coordSys) {\n\t            optData = zrUtil.filter(\n\t                optData, zrUtil.curry(markAreaFilter, coordSys)\n\t            );\n\t        }\n\t\n\t        var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {\n\t            return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];\n\t        } : function (item) {\n\t            return item.value;\n\t        };\n\t        areaData.initData(optData, null, dimValueGetter);\n\t        areaData.hasItemOption = true;\n\t        return areaData;\n\t    }\n\n\n/***/ },\n/* 199 */\n/*!***********************************************!*\\\n  !*** ./lib/component/marker/MarkLineModel.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    module.exports = __webpack_require__(/*! ./MarkerModel */ 67).extend({\n\t\n\t        type: 'markLine',\n\t\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 5,\n\t\n\t            symbol: ['circle', 'arrow'],\n\t            symbolSize: [8, 16],\n\t\n\t            //symbolRotate: 0,\n\t\n\t            precision: 2,\n\t            tooltip: {\n\t                trigger: 'item'\n\t            },\n\t            label: {\n\t                normal: {\n\t                    show: true,\n\t                    position: 'end'\n\t                },\n\t                emphasis: {\n\t                    show: true\n\t                }\n\t            },\n\t            lineStyle: {\n\t                normal: {\n\t                    type: 'dashed'\n\t                },\n\t                emphasis: {\n\t                    width: 3\n\t                }\n\t            },\n\t            animationEasing: 'linear'\n\t        }\n\t    });\n\n\n/***/ },\n/* 200 */\n/*!**********************************************!*\\\n  !*** ./lib/component/marker/MarkLineView.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var List = __webpack_require__(/*! ../../data/List */ 14);\n\t    var numberUtil = __webpack_require__(/*! ../../util/number */ 4);\n\t\n\t    var markerHelper = __webpack_require__(/*! ./markerHelper */ 69);\n\t\n\t    var LineDraw = __webpack_require__(/*! ../../chart/helper/LineDraw */ 95);\n\t\n\t    var markLineTransform = function (seriesModel, coordSys, mlModel, item) {\n\t        var data = seriesModel.getData();\n\t        // Special type markLine like 'min', 'max', 'average'\n\t        var mlType = item.type;\n\t\n\t        if (!zrUtil.isArray(item)\n\t            && (\n\t                mlType === 'min' || mlType === 'max' || mlType === 'average'\n\t                // In case\n\t                // data: [{\n\t                //   yAxis: 10\n\t                // }]\n\t                || (item.xAxis != null || item.yAxis != null)\n\t            )\n\t        ) {\n\t            var valueAxis;\n\t            var valueDataDim;\n\t            var value;\n\t\n\t            if (item.yAxis != null || item.xAxis != null) {\n\t                valueDataDim = item.yAxis != null ? 'y' : 'x';\n\t                valueAxis = coordSys.getAxis(valueDataDim);\n\t\n\t                value = zrUtil.retrieve(item.yAxis, item.xAxis);\n\t            }\n\t            else {\n\t                var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);\n\t                valueDataDim = axisInfo.valueDataDim;\n\t                valueAxis = axisInfo.valueAxis;\n\t                value = markerHelper.numCalculate(data, valueDataDim, mlType);\n\t            }\n\t            var valueIndex = valueDataDim === 'x' ? 0 : 1;\n\t            var baseIndex = 1 - valueIndex;\n\t\n\t            var mlFrom = zrUtil.clone(item);\n\t            var mlTo = {};\n\t\n\t            mlFrom.type = null;\n\t\n\t            mlFrom.coord = [];\n\t            mlTo.coord = [];\n\t            mlFrom.coord[baseIndex] = -Infinity;\n\t            mlTo.coord[baseIndex] = Infinity;\n\t\n\t            var precision = mlModel.get('precision');\n\t            if (precision >= 0 && typeof value === 'number') {\n\t                value = +value.toFixed(precision);\n\t            }\n\t\n\t            mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;\n\t\n\t            item = [mlFrom, mlTo, { // Extra option for tooltip and label\n\t                type: mlType,\n\t                valueIndex: item.valueIndex,\n\t                // Force to use the value of calculated value.\n\t                value: value\n\t            }];\n\t        }\n\t\n\t        item = [\n\t            markerHelper.dataTransform(seriesModel, item[0]),\n\t            markerHelper.dataTransform(seriesModel, item[1]),\n\t            zrUtil.extend({}, item[2])\n\t        ];\n\t\n\t        // Avoid line data type is extended by from(to) data type\n\t        item[2].type = item[2].type || '';\n\t\n\t        // Merge from option and to option into line option\n\t        zrUtil.merge(item[2], item[0]);\n\t        zrUtil.merge(item[2], item[1]);\n\t\n\t        return item;\n\t    };\n\t\n\t    function isInifinity(val) {\n\t        return !isNaN(val) && !isFinite(val);\n\t    }\n\t\n\t    // If a markLine has one dim\n\t    function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n\t        var otherDimIndex = 1 - dimIndex;\n\t        var dimName = coordSys.dimensions[dimIndex];\n\t        return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex])\n\t            && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);\n\t    }\n\t\n\t    function markLineFilter(coordSys, item) {\n\t        if (coordSys.type === 'cartesian2d') {\n\t            var fromCoord = item[0].coord;\n\t            var toCoord = item[1].coord;\n\t            // In case\n\t            // {\n\t            //  markLine: {\n\t            //    data: [{ yAxis: 2 }]\n\t            //  }\n\t            // }\n\t            if (\n\t                fromCoord && toCoord &&\n\t                (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys)\n\t                || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))\n\t            ) {\n\t                return true;\n\t            }\n\t        }\n\t        return markerHelper.dataFilter(coordSys, item[0])\n\t            && markerHelper.dataFilter(coordSys, item[1]);\n\t    }\n\t\n\t    function updateSingleMarkerEndLayout(\n\t        data, idx, isFrom, seriesModel, api\n\t    ) {\n\t        var coordSys = seriesModel.coordinateSystem;\n\t        var itemModel = data.getItemModel(idx);\n\t\n\t        var point;\n\t        var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n\t        var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n\t        if (!isNaN(xPx) && !isNaN(yPx)) {\n\t            point = [xPx, yPx];\n\t        }\n\t        else {\n\t            // Chart like bar may have there own marker positioning logic\n\t            if (seriesModel.getMarkerPosition) {\n\t                // Use the getMarkerPoisition\n\t                point = seriesModel.getMarkerPosition(\n\t                    data.getValues(data.dimensions, idx)\n\t                );\n\t            }\n\t            else {\n\t                var dims = coordSys.dimensions;\n\t                var x = data.get(dims[0], idx);\n\t                var y = data.get(dims[1], idx);\n\t                point = coordSys.dataToPoint([x, y]);\n\t            }\n\t            // Expand line to the edge of grid if value on one axis is Inifnity\n\t            // In case\n\t            //  markLine: {\n\t            //    data: [{\n\t            //      yAxis: 2\n\t            //      // or\n\t            //      type: 'average'\n\t            //    }]\n\t            //  }\n\t            if (coordSys.type === 'cartesian2d') {\n\t                var xAxis = coordSys.getAxis('x');\n\t                var yAxis = coordSys.getAxis('y');\n\t                var dims = coordSys.dimensions;\n\t                if (isInifinity(data.get(dims[0], idx))) {\n\t                    point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);\n\t                }\n\t                else if (isInifinity(data.get(dims[1], idx))) {\n\t                    point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);\n\t                }\n\t            }\n\t\n\t            // Use x, y if has any\n\t            if (!isNaN(xPx)) {\n\t                point[0] = xPx;\n\t            }\n\t            if (!isNaN(yPx)) {\n\t                point[1] = yPx;\n\t            }\n\t        }\n\t\n\t        data.setItemLayout(idx, point);\n\t    }\n\t\n\t    __webpack_require__(/*! ./MarkerView */ 68).extend({\n\t\n\t        type: 'markLine',\n\t\n\t        updateLayout: function (markLineModel, ecModel, api) {\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                var mlModel = seriesModel.markLineModel;\n\t                if (mlModel) {\n\t                    var mlData = mlModel.getData();\n\t                    var fromData = mlModel.__from;\n\t                    var toData = mlModel.__to;\n\t                    // Update visual and layout of from symbol and to symbol\n\t                    fromData.each(function (idx) {\n\t                        updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);\n\t                        updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);\n\t                    });\n\t                    // Update layout of line\n\t                    mlData.each(function (idx) {\n\t                        mlData.setItemLayout(idx, [\n\t                            fromData.getItemLayout(idx),\n\t                            toData.getItemLayout(idx)\n\t                        ]);\n\t                    });\n\t\n\t                    this.markerGroupMap[seriesModel.name].updateLayout();\n\t\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        renderSeries: function (seriesModel, mlModel, ecModel, api) {\n\t            var coordSys = seriesModel.coordinateSystem;\n\t            var seriesName = seriesModel.name;\n\t            var seriesData = seriesModel.getData();\n\t\n\t            var lineDrawMap = this.markerGroupMap;\n\t            var lineDraw = lineDrawMap[seriesName];\n\t            if (!lineDraw) {\n\t                lineDraw = lineDrawMap[seriesName] = new LineDraw();\n\t            }\n\t            this.group.add(lineDraw.group);\n\t\n\t            var mlData = createList(coordSys, seriesModel, mlModel);\n\t\n\t            var fromData = mlData.from;\n\t            var toData = mlData.to;\n\t            var lineData = mlData.line;\n\t\n\t            mlModel.__from = fromData;\n\t            mlModel.__to = toData;\n\t            // Line data for tooltip and formatter\n\t            mlModel.setData(lineData);\n\t\n\t            var symbolType = mlModel.get('symbol');\n\t            var symbolSize = mlModel.get('symbolSize');\n\t            if (!zrUtil.isArray(symbolType)) {\n\t                symbolType = [symbolType, symbolType];\n\t            }\n\t            if (typeof symbolSize === 'number') {\n\t                symbolSize = [symbolSize, symbolSize];\n\t            }\n\t\n\t            // Update visual and layout of from symbol and to symbol\n\t            mlData.from.each(function (idx) {\n\t                updateDataVisualAndLayout(fromData, idx, true);\n\t                updateDataVisualAndLayout(toData, idx, false);\n\t            });\n\t\n\t            // Update visual and layout of line\n\t            lineData.each(function (idx) {\n\t                var lineColor = lineData.getItemModel(idx).get('lineStyle.normal.color');\n\t                lineData.setItemVisual(idx, {\n\t                    color: lineColor || fromData.getItemVisual(idx, 'color')\n\t                });\n\t                lineData.setItemLayout(idx, [\n\t                    fromData.getItemLayout(idx),\n\t                    toData.getItemLayout(idx)\n\t                ]);\n\t\n\t                lineData.setItemVisual(idx, {\n\t                    'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),\n\t                    'fromSymbol': fromData.getItemVisual(idx, 'symbol'),\n\t                    'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),\n\t                    'toSymbol': toData.getItemVisual(idx, 'symbol')\n\t                });\n\t            });\n\t\n\t            lineDraw.updateData(lineData);\n\t\n\t            // Set host model for tooltip\n\t            // FIXME\n\t            mlData.line.eachItemGraphicEl(function (el, idx) {\n\t                el.traverse(function (child) {\n\t                    child.dataModel = mlModel;\n\t                });\n\t            });\n\t\n\t            function updateDataVisualAndLayout(data, idx, isFrom) {\n\t                var itemModel = data.getItemModel(idx);\n\t\n\t                updateSingleMarkerEndLayout(\n\t                    data, idx, isFrom, seriesModel, api\n\t                );\n\t\n\t                data.setItemVisual(idx, {\n\t                    symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],\n\t                    symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],\n\t                    color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color')\n\t                });\n\t            }\n\t\n\t            lineDraw.__keep = true;\n\t\n\t            lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');\n\t        }\n\t    });\n\t\n\t    /**\n\t     * @inner\n\t     * @param {module:echarts/coord/*} coordSys\n\t     * @param {module:echarts/model/Series} seriesModel\n\t     * @param {module:echarts/model/Model} mpModel\n\t     */\n\t    function createList(coordSys, seriesModel, mlModel) {\n\t\n\t        var coordDimsInfos;\n\t        if (coordSys) {\n\t            coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n\t                var info = seriesModel.getData().getDimensionInfo(\n\t                    seriesModel.coordDimToDataDim(coordDim)[0]\n\t                ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\t                info.name = coordDim;\n\t                return info;\n\t            });\n\t        }\n\t        else {\n\t            coordDimsInfos =[{\n\t                name: 'value',\n\t                type: 'float'\n\t            }];\n\t        }\n\t\n\t        var fromData = new List(coordDimsInfos, mlModel);\n\t        var toData = new List(coordDimsInfos, mlModel);\n\t        // No dimensions\n\t        var lineData = new List([], mlModel);\n\t\n\t        var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry(\n\t            markLineTransform, seriesModel, coordSys, mlModel\n\t        ));\n\t        if (coordSys) {\n\t            optData = zrUtil.filter(\n\t                optData, zrUtil.curry(markLineFilter, coordSys)\n\t            );\n\t        }\n\t        var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {\n\t            return item.value;\n\t        };\n\t        fromData.initData(\n\t            zrUtil.map(optData, function (item) { return item[0]; }),\n\t            null, dimValueGetter\n\t        );\n\t        toData.initData(\n\t            zrUtil.map(optData, function (item) { return item[1]; }),\n\t            null, dimValueGetter\n\t        );\n\t        lineData.initData(\n\t            zrUtil.map(optData, function (item) { return item[2]; })\n\t        );\n\t        lineData.hasItemOption = true;\n\t        return {\n\t            from: fromData,\n\t            to: toData,\n\t            line: lineData\n\t        };\n\t    }\n\n\n/***/ },\n/* 201 */\n/*!************************************************!*\\\n  !*** ./lib/component/marker/MarkPointModel.js ***!\n  \\************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    module.exports = __webpack_require__(/*! ./MarkerModel */ 67).extend({\n\t\n\t        type: 'markPoint',\n\t\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 5,\n\t            symbol: 'pin',\n\t            symbolSize: 50,\n\t            //symbolRotate: 0,\n\t            //symbolOffset: [0, 0]\n\t            tooltip: {\n\t                trigger: 'item'\n\t            },\n\t            label: {\n\t                normal: {\n\t                    show: true,\n\t                    position: 'inside'\n\t                },\n\t                emphasis: {\n\t                    show: true\n\t                }\n\t            },\n\t            itemStyle: {\n\t                normal: {\n\t                    borderWidth: 2\n\t                }\n\t            }\n\t        }\n\t    });\n\n\n/***/ },\n/* 202 */\n/*!***********************************************!*\\\n  !*** ./lib/component/marker/MarkPointView.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var SymbolDraw = __webpack_require__(/*! ../../chart/helper/SymbolDraw */ 39);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var numberUtil = __webpack_require__(/*! ../../util/number */ 4);\n\t\n\t    var List = __webpack_require__(/*! ../../data/List */ 14);\n\t\n\t    var markerHelper = __webpack_require__(/*! ./markerHelper */ 69);\n\t\n\t    function updateMarkerLayout(mpData, seriesModel, api) {\n\t        var coordSys = seriesModel.coordinateSystem;\n\t        mpData.each(function (idx) {\n\t            var itemModel = mpData.getItemModel(idx);\n\t            var point;\n\t            var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n\t            var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n\t            if (!isNaN(xPx) && !isNaN(yPx)) {\n\t                point = [xPx, yPx];\n\t            }\n\t            // Chart like bar may have there own marker positioning logic\n\t            else if (seriesModel.getMarkerPosition) {\n\t                // Use the getMarkerPoisition\n\t                point = seriesModel.getMarkerPosition(\n\t                    mpData.getValues(mpData.dimensions, idx)\n\t                );\n\t            }\n\t            else if (coordSys) {\n\t                var x = mpData.get(coordSys.dimensions[0], idx);\n\t                var y = mpData.get(coordSys.dimensions[1], idx);\n\t                point = coordSys.dataToPoint([x, y]);\n\t\n\t            }\n\t\n\t            // Use x, y if has any\n\t            if (!isNaN(xPx)) {\n\t                point[0] = xPx;\n\t            }\n\t            if (!isNaN(yPx)) {\n\t                point[1] = yPx;\n\t            }\n\t\n\t            mpData.setItemLayout(idx, point);\n\t        });\n\t    }\n\t\n\t    __webpack_require__(/*! ./MarkerView */ 68).extend({\n\t\n\t        type: 'markPoint',\n\t\n\t        updateLayout: function (markPointModel, ecModel, api) {\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                var mpModel = seriesModel.markPointModel;\n\t                if (mpModel) {\n\t                    updateMarkerLayout(mpModel.getData(), seriesModel, api);\n\t                    this.markerGroupMap[seriesModel.name].updateLayout(mpModel);\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        renderSeries: function (seriesModel, mpModel, ecModel, api) {\n\t            var coordSys = seriesModel.coordinateSystem;\n\t            var seriesName = seriesModel.name;\n\t            var seriesData = seriesModel.getData();\n\t\n\t            var symbolDrawMap = this.markerGroupMap;\n\t            var symbolDraw = symbolDrawMap[seriesName];\n\t            if (!symbolDraw) {\n\t                symbolDraw = symbolDrawMap[seriesName] = new SymbolDraw();\n\t            }\n\t\n\t            var mpData = createList(coordSys, seriesModel, mpModel);\n\t\n\t            // FIXME\n\t            mpModel.setData(mpData);\n\t\n\t            updateMarkerLayout(mpModel.getData(), seriesModel, api);\n\t\n\t            mpData.each(function (idx) {\n\t                var itemModel = mpData.getItemModel(idx);\n\t                var symbolSize = itemModel.getShallow('symbolSize');\n\t                if (typeof symbolSize === 'function') {\n\t                    // FIXME  ECharts 2.x2.x \n\t                    symbolSize = symbolSize(\n\t                        mpModel.getRawValue(idx), mpModel.getDataParams(idx)\n\t                    );\n\t                }\n\t                mpData.setItemVisual(idx, {\n\t                    symbolSize: symbolSize,\n\t                    color: itemModel.get('itemStyle.normal.color')\n\t                        || seriesData.getVisual('color'),\n\t                    symbol: itemModel.getShallow('symbol')\n\t                });\n\t            });\n\t\n\t            // TODO Text are wrong\n\t            symbolDraw.updateData(mpData);\n\t            this.group.add(symbolDraw.group);\n\t\n\t            // Set host model for tooltip\n\t            // FIXME\n\t            mpData.eachItemGraphicEl(function (el) {\n\t                el.traverse(function (child) {\n\t                    child.dataModel = mpModel;\n\t                });\n\t            });\n\t\n\t            symbolDraw.__keep = true;\n\t\n\t            symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');\n\t        }\n\t    });\n\t\n\t    /**\n\t     * @inner\n\t     * @param {module:echarts/coord/*} [coordSys]\n\t     * @param {module:echarts/model/Series} seriesModel\n\t     * @param {module:echarts/model/Model} mpModel\n\t     */\n\t    function createList(coordSys, seriesModel, mpModel) {\n\t        var coordDimsInfos;\n\t        if (coordSys) {\n\t            coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n\t                var info = seriesModel.getData().getDimensionInfo(\n\t                    seriesModel.coordDimToDataDim(coordDim)[0]\n\t                ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\t                info.name = coordDim;\n\t                return info;\n\t            });\n\t        }\n\t        else {\n\t            coordDimsInfos =[{\n\t                name: 'value',\n\t                type: 'float'\n\t            }];\n\t        }\n\t\n\t        var mpData = new List(coordDimsInfos, mpModel);\n\t        var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(\n\t                markerHelper.dataTransform, seriesModel\n\t            ));\n\t        if (coordSys) {\n\t            dataOpt = zrUtil.filter(\n\t                dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys)\n\t            );\n\t        }\n\t\n\t        mpData.initData(dataOpt, null,\n\t            coordSys ? markerHelper.dimValueGetter : function (item) {\n\t                return item.value;\n\t            }\n\t        );\n\t        return mpData;\n\t    }\n\t\n\n\n/***/ },\n/* 203 */\n/*!********************************!*\\\n  !*** ./lib/component/title.js ***!\n  \\********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var echarts = __webpack_require__(/*! ../echarts */ 2);\n\t    var graphic = __webpack_require__(/*! ../util/graphic */ 3);\n\t    var layout = __webpack_require__(/*! ../util/layout */ 13);\n\t\n\t    // Model\n\t    echarts.extendComponentModel({\n\t\n\t        type: 'title',\n\t\n\t        layoutMode: {type: 'box', ignoreSize: true},\n\t\n\t        defaultOption: {\n\t            // \n\t            zlevel: 0,\n\t            // \n\t            z: 6,\n\t            show: true,\n\t\n\t            text: '',\n\t            // \n\t            // link: null,\n\t            // self | blank\n\t            target: 'blank',\n\t            subtext: '',\n\t\n\t            // \n\t            // sublink: null,\n\t            // self | blank\n\t            subtarget: 'blank',\n\t\n\t            // 'center'  'left'  'right'\n\t            //  {number}xpx\n\t            left: 0,\n\t            // 'top'  'bottom'  'center'\n\t            //  {number}ypx\n\t            top: 0,\n\t\n\t            // \n\t            // 'auto' | 'left' | 'right' | 'center'\n\t            //  left \n\t            // textAlign: null\n\t            //\n\t            // \n\t            // 'auto' | 'top' | 'bottom' | 'middle'\n\t            //  top \n\t            // textBaseline: null\n\t\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t\n\t            // \n\t            borderColor: '#ccc',\n\t\n\t            // px0\n\t            borderWidth: 0,\n\t\n\t            // px5\n\t            // css\n\t            padding: 5,\n\t\n\t            // px10\n\t            itemGap: 10,\n\t            textStyle: {\n\t                fontSize: 18,\n\t                fontWeight: 'bolder',\n\t                color: '#333'\n\t            },\n\t            subtextStyle: {\n\t                color: '#aaa'\n\t            }\n\t        }\n\t    });\n\t\n\t    // View\n\t    echarts.extendComponentView({\n\t\n\t        type: 'title',\n\t\n\t        render: function (titleModel, ecModel, api) {\n\t            this.group.removeAll();\n\t\n\t            if (!titleModel.get('show')) {\n\t                return;\n\t            }\n\t\n\t            var group = this.group;\n\t\n\t            var textStyleModel = titleModel.getModel('textStyle');\n\t            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\t\n\t            var textAlign = titleModel.get('textAlign');\n\t            var textBaseline = titleModel.get('textBaseline');\n\t\n\t            var textEl = new graphic.Text({\n\t                style: {\n\t                    text: titleModel.get('text'),\n\t                    textFont: textStyleModel.getFont(),\n\t                    fill: textStyleModel.getTextColor()\n\t                },\n\t                z2: 10\n\t            });\n\t\n\t            var textRect = textEl.getBoundingRect();\n\t\n\t            var subText = titleModel.get('subtext');\n\t            var subTextEl = new graphic.Text({\n\t                style: {\n\t                    text: subText,\n\t                    textFont: subtextStyleModel.getFont(),\n\t                    fill: subtextStyleModel.getTextColor(),\n\t                    y: textRect.height + titleModel.get('itemGap'),\n\t                    textBaseline: 'top'\n\t                },\n\t                z2: 10\n\t            });\n\t\n\t            var link = titleModel.get('link');\n\t            var sublink = titleModel.get('sublink');\n\t\n\t            textEl.silent = !link;\n\t            subTextEl.silent = !sublink;\n\t\n\t            if (link) {\n\t                textEl.on('click', function () {\n\t                    window.open(link, '_' + titleModel.get('target'));\n\t                });\n\t            }\n\t            if (sublink) {\n\t                subTextEl.on('click', function () {\n\t                    window.open(sublink, '_' + titleModel.get('subtarget'));\n\t                });\n\t            }\n\t\n\t            group.add(textEl);\n\t            subText && group.add(subTextEl);\n\t            // If no subText, but add subTextEl, there will be an empty line.\n\t\n\t            var groupRect = group.getBoundingRect();\n\t            var layoutOption = titleModel.getBoxLayoutParams();\n\t            layoutOption.width = groupRect.width;\n\t            layoutOption.height = groupRect.height;\n\t            var layoutRect = layout.getLayoutRect(\n\t                layoutOption, {\n\t                    width: api.getWidth(),\n\t                    height: api.getHeight()\n\t                }, titleModel.get('padding')\n\t            );\n\t            // Adjust text align based on position\n\t            if (!textAlign) {\n\t                // Align left if title is on the left. center and right is same\n\t                textAlign = titleModel.get('left') || titleModel.get('right');\n\t                if (textAlign === 'middle') {\n\t                    textAlign = 'center';\n\t                }\n\t                // Adjust layout by text align\n\t                if (textAlign === 'right') {\n\t                    layoutRect.x += layoutRect.width;\n\t                }\n\t                else if (textAlign === 'center') {\n\t                    layoutRect.x += layoutRect.width / 2;\n\t                }\n\t            }\n\t            if (!textBaseline) {\n\t                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n\t                if (textBaseline === 'center') {\n\t                    textBaseline = 'middle';\n\t                }\n\t                if (textBaseline === 'bottom') {\n\t                    layoutRect.y += layoutRect.height;\n\t                }\n\t                else if (textBaseline === 'middle') {\n\t                    layoutRect.y += layoutRect.height / 2;\n\t                }\n\t\n\t                textBaseline = textBaseline || 'top';\n\t            }\n\t\n\t            group.attr('position', [layoutRect.x, layoutRect.y]);\n\t            var alignStyle = {\n\t                textAlign: textAlign,\n\t                textVerticalAlign: textBaseline\n\t            };\n\t            textEl.setStyle(alignStyle);\n\t            subTextEl.setStyle(alignStyle);\n\t\n\t            // Render background\n\t            // Get groupRect again because textAlign has been changed\n\t            groupRect = group.getBoundingRect();\n\t            var padding = layoutRect.margin;\n\t            var style = titleModel.getItemStyle(['color', 'opacity']);\n\t            style.fill = titleModel.get('backgroundColor');\n\t            var rect = new graphic.Rect({\n\t                shape: {\n\t                    x: groupRect.x - padding[3],\n\t                    y: groupRect.y - padding[0],\n\t                    width: groupRect.width + padding[1] + padding[3],\n\t                    height: groupRect.height + padding[0] + padding[2]\n\t                },\n\t                style: style,\n\t                silent: true\n\t            });\n\t            graphic.subPixelOptimizeRect(rect);\n\t\n\t            group.add(rect);\n\t        }\n\t    });\n\n\n/***/ },\n/* 204 */\n/*!**********************************!*\\\n  !*** ./lib/component/toolbox.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    __webpack_require__(/*! ./toolbox/ToolboxModel */ 205);\n\t    __webpack_require__(/*! ./toolbox/ToolboxView */ 206);\n\t\n\t    __webpack_require__(/*! ./toolbox/feature/SaveAsImage */ 211);\n\t    __webpack_require__(/*! ./toolbox/feature/MagicType */ 209);\n\t    __webpack_require__(/*! ./toolbox/feature/DataView */ 207);\n\t    __webpack_require__(/*! ./toolbox/feature/DataZoom */ 208);\n\t    __webpack_require__(/*! ./toolbox/feature/Restore */ 210);\n\n\n/***/ },\n/* 205 */\n/*!***********************************************!*\\\n  !*** ./lib/component/toolbox/ToolboxModel.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var featureManager = __webpack_require__(/*! ./featureManager */ 25);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var ToolboxModel = __webpack_require__(/*! ../../echarts */ 2).extendComponentModel({\n\t\n\t        type: 'toolbox',\n\t\n\t        layoutMode: {\n\t            type: 'box',\n\t            ignoreSize: true\n\t        },\n\t\n\t        mergeDefaultAndTheme: function (option) {\n\t            ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);\n\t\n\t            zrUtil.each(this.option.feature, function (featureOpt, featureName) {\n\t                var Feature = featureManager.get(featureName);\n\t                Feature && zrUtil.merge(featureOpt, Feature.defaultOption);\n\t            });\n\t        },\n\t\n\t        defaultOption: {\n\t\n\t            show: true,\n\t\n\t            z: 6,\n\t\n\t            zlevel: 0,\n\t\n\t            orient: 'horizontal',\n\t\n\t            left: 'right',\n\t\n\t            top: 'top',\n\t\n\t            // right\n\t            // bottom\n\t\n\t            backgroundColor: 'transparent',\n\t\n\t            borderColor: '#ccc',\n\t\n\t            borderWidth: 0,\n\t\n\t            padding: 5,\n\t\n\t            itemSize: 15,\n\t\n\t            itemGap: 8,\n\t\n\t            showTitle: true,\n\t\n\t            iconStyle: {\n\t                normal: {\n\t                    borderColor: '#666',\n\t                    color: 'none'\n\t                },\n\t                emphasis: {\n\t                    borderColor: '#3E98C5'\n\t                }\n\t            }\n\t            // textStyle: {},\n\t\n\t            // feature\n\t        }\n\t    });\n\t\n\t    module.exports = ToolboxModel;\n\n\n/***/ },\n/* 206 */\n/*!**********************************************!*\\\n  !*** ./lib/component/toolbox/ToolboxView.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {\n\t\n\t    var featureManager = __webpack_require__(/*! ./featureManager */ 25);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var Model = __webpack_require__(/*! ../../model/Model */ 10);\n\t    var DataDiffer = __webpack_require__(/*! ../../data/DataDiffer */ 45);\n\t    var listComponentHelper = __webpack_require__(/*! ../helper/listComponent */ 116);\n\t    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 16);\n\t\n\t    module.exports = __webpack_require__(/*! ../../echarts */ 2).extendComponentView({\n\t\n\t        type: 'toolbox',\n\t\n\t        render: function (toolboxModel, ecModel, api, payload) {\n\t            var group = this.group;\n\t            group.removeAll();\n\t\n\t            if (!toolboxModel.get('show')) {\n\t                return;\n\t            }\n\t\n\t            var itemSize = +toolboxModel.get('itemSize');\n\t            var featureOpts = toolboxModel.get('feature') || {};\n\t            var features = this._features || (this._features = {});\n\t\n\t            var featureNames = [];\n\t            zrUtil.each(featureOpts, function (opt, name) {\n\t                featureNames.push(name);\n\t            });\n\t\n\t            (new DataDiffer(this._featureNames || [], featureNames))\n\t                .add(process)\n\t                .update(process)\n\t                .remove(zrUtil.curry(process, null))\n\t                .execute();\n\t\n\t            // Keep for diff.\n\t            this._featureNames = featureNames;\n\t\n\t            function process(newIndex, oldIndex) {\n\t                var featureName = featureNames[newIndex];\n\t                var oldName = featureNames[oldIndex];\n\t                var featureOpt = featureOpts[featureName];\n\t                var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);\n\t                var feature;\n\t\n\t                if (featureName && !oldName) { // Create\n\t                    if (isUserFeatureName(featureName)) {\n\t                        feature = {\n\t                            model: featureModel,\n\t                            onclick: featureModel.option.onclick,\n\t                            featureName: featureName\n\t                        };\n\t                    }\n\t                    else {\n\t                        var Feature = featureManager.get(featureName);\n\t                        if (!Feature) {\n\t                            return;\n\t                        }\n\t                        feature = new Feature(featureModel, ecModel, api);\n\t                    }\n\t                    features[featureName] = feature;\n\t                }\n\t                else {\n\t                    feature = features[oldName];\n\t                    // If feature does not exsit.\n\t                    if (!feature) {\n\t                        return;\n\t                    }\n\t                    feature.model = featureModel;\n\t                    feature.ecModel = ecModel;\n\t                    feature.api = api;\n\t                }\n\t\n\t                if (!featureName && oldName) {\n\t                    feature.dispose && feature.dispose(ecModel, api);\n\t                    return;\n\t                }\n\t\n\t                if (!featureModel.get('show') || feature.unusable) {\n\t                    feature.remove && feature.remove(ecModel, api);\n\t                    return;\n\t                }\n\t\n\t                createIconPaths(featureModel, feature, featureName);\n\t\n\t                featureModel.setIconStatus = function (iconName, status) {\n\t                    var option = this.option;\n\t                    var iconPaths = this.iconPaths;\n\t                    option.iconStatus = option.iconStatus || {};\n\t                    option.iconStatus[iconName] = status;\n\t                    // FIXME\n\t                    iconPaths[iconName] && iconPaths[iconName].trigger(status);\n\t                };\n\t\n\t                if (feature.render) {\n\t                    feature.render(featureModel, ecModel, api, payload);\n\t                }\n\t            }\n\t\n\t            function createIconPaths(featureModel, feature, featureName) {\n\t                var iconStyleModel = featureModel.getModel('iconStyle');\n\t\n\t                // If one feature has mutiple icon. they are orginaized as\n\t                // {\n\t                //     icon: {\n\t                //         foo: '',\n\t                //         bar: ''\n\t                //     },\n\t                //     title: {\n\t                //         foo: '',\n\t                //         bar: ''\n\t                //     }\n\t                // }\n\t                var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n\t                var titles = featureModel.get('title') || {};\n\t                if (typeof icons === 'string') {\n\t                    var icon = icons;\n\t                    var title = titles;\n\t                    icons = {};\n\t                    titles = {};\n\t                    icons[featureName] = icon;\n\t                    titles[featureName] = title;\n\t                }\n\t                var iconPaths = featureModel.iconPaths = {};\n\t                zrUtil.each(icons, function (icon, iconName) {\n\t                    var normalStyle = iconStyleModel.getModel('normal').getItemStyle();\n\t                    var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n\t\n\t                    var style = {\n\t                        x: -itemSize / 2,\n\t                        y: -itemSize / 2,\n\t                        width: itemSize,\n\t                        height: itemSize\n\t                    };\n\t                    var path = icon.indexOf('image://') === 0\n\t                        ? (\n\t                            style.image = icon.slice(8),\n\t                            new graphic.Image({style: style})\n\t                        )\n\t                        : graphic.makePath(\n\t                            icon.replace('path://', ''),\n\t                            {\n\t                                style: normalStyle,\n\t                                hoverStyle: hoverStyle,\n\t                                rectHover: true\n\t                            },\n\t                            style,\n\t                            'center'\n\t                        );\n\t\n\t                    graphic.setHoverStyle(path);\n\t\n\t                    if (toolboxModel.get('showTitle')) {\n\t                        path.__title = titles[iconName];\n\t                        path.on('mouseover', function () {\n\t                                // Should not reuse above hoverStyle, which might be modified.\n\t                                var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n\t                                path.setStyle({\n\t                                    text: titles[iconName],\n\t                                    textPosition: hoverStyle.textPosition || 'bottom',\n\t                                    textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\n\t                                    textAlign: hoverStyle.textAlign || 'center'\n\t                                });\n\t                            })\n\t                            .on('mouseout', function () {\n\t                                path.setStyle({\n\t                                    textFill: null\n\t                                });\n\t                            });\n\t                    }\n\t                    path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');\n\t\n\t                    group.add(path);\n\t                    path.on('click', zrUtil.bind(\n\t                        feature.onclick, feature, ecModel, api, iconName\n\t                    ));\n\t\n\t                    iconPaths[iconName] = path;\n\t                });\n\t            }\n\t\n\t            listComponentHelper.layout(group, toolboxModel, api);\n\t            // Render background after group is layout\n\t            // FIXME\n\t            listComponentHelper.addBackground(group, toolboxModel);\n\t\n\t            // Adjust icon title positions to avoid them out of screen\n\t            group.eachChild(function (icon) {\n\t                var titleText = icon.__title;\n\t                var hoverStyle = icon.hoverStyle;\n\t                // May be background element\n\t                if (hoverStyle && titleText) {\n\t                    var rect = textContain.getBoundingRect(\n\t                        titleText, hoverStyle.font\n\t                    );\n\t                    var offsetX = icon.position[0] + group.position[0];\n\t                    var offsetY = icon.position[1] + group.position[1] + itemSize;\n\t\n\t                    var needPutOnTop = false;\n\t                    if (offsetY + rect.height > api.getHeight()) {\n\t                        hoverStyle.textPosition = 'top';\n\t                        needPutOnTop = true;\n\t                    }\n\t                    var topOffset = needPutOnTop ? (-5 - rect.height) : (itemSize + 8);\n\t                    if (offsetX + rect.width /  2 > api.getWidth()) {\n\t                        hoverStyle.textPosition = ['100%', topOffset];\n\t                        hoverStyle.textAlign = 'right';\n\t                    }\n\t                    else if (offsetX - rect.width / 2 < 0) {\n\t                        hoverStyle.textPosition = [0, topOffset];\n\t                        hoverStyle.textAlign = 'left';\n\t                    }\n\t                }\n\t            });\n\t        },\n\t\n\t        updateView: function (toolboxModel, ecModel, api, payload) {\n\t            zrUtil.each(this._features, function (feature) {\n\t                feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n\t            });\n\t        },\n\t\n\t        updateLayout: function (toolboxModel, ecModel, api, payload) {\n\t            zrUtil.each(this._features, function (feature) {\n\t                feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);\n\t            });\n\t        },\n\t\n\t        remove: function (ecModel, api) {\n\t            zrUtil.each(this._features, function (feature) {\n\t                feature.remove && feature.remove(ecModel, api);\n\t            });\n\t            this.group.removeAll();\n\t        },\n\t\n\t        dispose: function (ecModel, api) {\n\t            zrUtil.each(this._features, function (feature) {\n\t                feature.dispose && feature.dispose(ecModel, api);\n\t            });\n\t        }\n\t    });\n\t\n\t    function isUserFeatureName(featureName) {\n\t        return featureName.indexOf('my') === 0;\n\t    }\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/process/browser.js */ 217)))\n\n/***/ },\n/* 207 */\n/*!***************************************************!*\\\n  !*** ./lib/component/toolbox/feature/DataView.js ***!\n  \\***************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/component/toolbox/feature/DataView\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var eventTool = __webpack_require__(/*! zrender/lib/core/event */ 24);\n\t\n\t\n\t    var BLOCK_SPLITER = new Array(60).join('-');\n\t    var ITEM_SPLITER = '\\t';\n\t    /**\n\t     * Group series into two types\n\t     *  1. on category axis, like line, bar\n\t     *  2. others, like scatter, pie\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @return {Object}\n\t     * @inner\n\t     */\n\t    function groupSeries(ecModel) {\n\t        var seriesGroupByCategoryAxis = {};\n\t        var otherSeries = [];\n\t        var meta = [];\n\t        ecModel.eachRawSeries(function (seriesModel) {\n\t            var coordSys = seriesModel.coordinateSystem;\n\t\n\t            if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n\t                var baseAxis = coordSys.getBaseAxis();\n\t                if (baseAxis.type === 'category') {\n\t                    var key = baseAxis.dim + '_' + baseAxis.index;\n\t                    if (!seriesGroupByCategoryAxis[key]) {\n\t                        seriesGroupByCategoryAxis[key] = {\n\t                            categoryAxis: baseAxis,\n\t                            valueAxis: coordSys.getOtherAxis(baseAxis),\n\t                            series: []\n\t                        };\n\t                        meta.push({\n\t                            axisDim: baseAxis.dim,\n\t                            axisIndex: baseAxis.index\n\t                        });\n\t                    }\n\t                    seriesGroupByCategoryAxis[key].series.push(seriesModel);\n\t                }\n\t                else {\n\t                    otherSeries.push(seriesModel);\n\t                }\n\t            }\n\t            else {\n\t                otherSeries.push(seriesModel);\n\t            }\n\t        });\n\t\n\t        return {\n\t            seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n\t            other: otherSeries,\n\t            meta: meta\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Assemble content of series on cateogory axis\n\t     * @param {Array.<module:echarts/model/Series>} series\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function assembleSeriesWithCategoryAxis(series) {\n\t        var tables = [];\n\t        zrUtil.each(series, function (group, key) {\n\t            var categoryAxis = group.categoryAxis;\n\t            var valueAxis = group.valueAxis;\n\t            var valueAxisDim = valueAxis.dim;\n\t\n\t            var headers = [' '].concat(zrUtil.map(group.series, function (series) {\n\t                return series.name;\n\t            }));\n\t            var columns = [categoryAxis.model.getCategories()];\n\t            zrUtil.each(group.series, function (series) {\n\t                columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {\n\t                    return val;\n\t                }));\n\t            });\n\t            // Assemble table content\n\t            var lines = [headers.join(ITEM_SPLITER)];\n\t            for (var i = 0; i < columns[0].length; i++) {\n\t                var items = [];\n\t                for (var j = 0; j < columns.length; j++) {\n\t                    items.push(columns[j][i]);\n\t                }\n\t                lines.push(items.join(ITEM_SPLITER));\n\t            }\n\t            tables.push(lines.join('\\n'));\n\t        });\n\t        return tables.join('\\n\\n' +  BLOCK_SPLITER + '\\n\\n');\n\t    }\n\t\n\t    /**\n\t     * Assemble content of other series\n\t     * @param {Array.<module:echarts/model/Series>} series\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function assembleOtherSeries(series) {\n\t        return zrUtil.map(series, function (series) {\n\t            var data = series.getRawData();\n\t            var lines = [series.name];\n\t            var vals = [];\n\t            data.each(data.dimensions, function () {\n\t                var argLen = arguments.length;\n\t                var dataIndex = arguments[argLen - 1];\n\t                var name = data.getName(dataIndex);\n\t                for (var i = 0; i < argLen - 1; i++) {\n\t                    vals[i] = arguments[i];\n\t                }\n\t                lines.push((name ? (name + ITEM_SPLITER) : '') + vals.join(ITEM_SPLITER));\n\t            });\n\t            return lines.join('\\n');\n\t        }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n\t    }\n\t\n\t    /**\n\t     * @param {module:echarts/model/Global}\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function getContentFromModel(ecModel) {\n\t\n\t        var result = groupSeries(ecModel);\n\t\n\t        return {\n\t            value: zrUtil.filter([\n\t                    assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis),\n\t                    assembleOtherSeries(result.other)\n\t                ], function (str) {\n\t                    return str.replace(/[\\n\\t\\s]/g, '');\n\t                }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n\t\n\t            meta: result.meta\n\t        };\n\t    }\n\t\n\t\n\t    function trim(str) {\n\t        return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\t    }\n\t    /**\n\t     * If a block is tsv format\n\t     */\n\t    function isTSVFormat(block) {\n\t        // Simple method to find out if a block is tsv format\n\t        var firstLine = block.slice(0, block.indexOf('\\n'));\n\t        if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n\t            return true;\n\t        }\n\t    }\n\t\n\t    var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n\t    /**\n\t     * @param {string} tsv\n\t     * @return {Array.<Object>}\n\t     */\n\t    function parseTSVContents(tsv) {\n\t        var tsvLines = tsv.split(/\\n+/g);\n\t        var headers = trim(tsvLines.shift()).split(itemSplitRegex);\n\t\n\t        var categories = [];\n\t        var series = zrUtil.map(headers, function (header) {\n\t            return {\n\t                name: header,\n\t                data: []\n\t            };\n\t        });\n\t        for (var i = 0; i < tsvLines.length; i++) {\n\t            var items = trim(tsvLines[i]).split(itemSplitRegex);\n\t            categories.push(items.shift());\n\t            for (var j = 0; j < items.length; j++) {\n\t                series[j] && (series[j].data[i] = items[j]);\n\t            }\n\t        }\n\t        return {\n\t            series: series,\n\t            categories: categories\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @param {string} str\n\t     * @return {Array.<Object>}\n\t     * @inner\n\t     */\n\t    function parseListContents(str) {\n\t        var lines = str.split(/\\n+/g);\n\t        var seriesName = trim(lines.shift());\n\t\n\t        var data = [];\n\t        for (var i = 0; i < lines.length; i++) {\n\t            var items = trim(lines[i]).split(itemSplitRegex);\n\t            var name = '';\n\t            var value;\n\t            var hasName = false;\n\t            if (isNaN(items[0])) { // First item is name\n\t                hasName = true;\n\t                name = items[0];\n\t                items = items.slice(1);\n\t                data[i] = {\n\t                    name: name,\n\t                    value: []\n\t                };\n\t                value = data[i].value;\n\t            }\n\t            else {\n\t                value = data[i] = [];\n\t            }\n\t            for (var j = 0; j < items.length; j++) {\n\t                value.push(+items[j]);\n\t            }\n\t            if (value.length === 1) {\n\t                hasName ? (data[i].value = value[0]) : (data[i] = value[0]);\n\t            }\n\t        }\n\t\n\t        return {\n\t            name: seriesName,\n\t            data: data\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @param {string} str\n\t     * @param {Array.<Object>} blockMetaList\n\t     * @return {Object}\n\t     * @inner\n\t     */\n\t    function parseContents(str, blockMetaList) {\n\t        var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n\t        var newOption = {\n\t            series: []\n\t        };\n\t        zrUtil.each(blocks, function (block, idx) {\n\t            if (isTSVFormat(block)) {\n\t                var result = parseTSVContents(block);\n\t                var blockMeta = blockMetaList[idx];\n\t                var axisKey = blockMeta.axisDim + 'Axis';\n\t\n\t                if (blockMeta) {\n\t                    newOption[axisKey] = newOption[axisKey] || [];\n\t                    newOption[axisKey][blockMeta.axisIndex] = {\n\t                        data: result.categories\n\t                    };\n\t                    newOption.series = newOption.series.concat(result.series);\n\t                }\n\t            }\n\t            else {\n\t                var result = parseListContents(block);\n\t                newOption.series.push(result);\n\t            }\n\t        });\n\t        return newOption;\n\t    }\n\t\n\t    /**\n\t     * @alias {module:echarts/component/toolbox/feature/DataView}\n\t     * @constructor\n\t     * @param {module:echarts/model/Model} model\n\t     */\n\t    function DataView(model) {\n\t\n\t        this._dom = null;\n\t\n\t        this.model = model;\n\t    }\n\t\n\t    DataView.defaultOption = {\n\t        show: true,\n\t        readOnly: false,\n\t        optionToContent: null,\n\t        contentToOption: null,\n\t\n\t        icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n\t        title: '',\n\t        lang: ['', '', ''],\n\t        backgroundColor: '#fff',\n\t        textColor: '#000',\n\t        textareaColor: '#fff',\n\t        textareaBorderColor: '#333',\n\t        buttonColor: '#c23531',\n\t        buttonTextColor: '#fff'\n\t    };\n\t\n\t    DataView.prototype.onclick = function (ecModel, api) {\n\t        var container = api.getDom();\n\t        var model = this.model;\n\t        if (this._dom) {\n\t            container.removeChild(this._dom);\n\t        }\n\t        var root = document.createElement('div');\n\t        root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';\n\t        root.style.backgroundColor = model.get('backgroundColor') || '#fff';\n\t\n\t        // Create elements\n\t        var header = document.createElement('h4');\n\t        var lang = model.get('lang') || [];\n\t        header.innerHTML = lang[0] || model.get('title');\n\t        header.style.cssText = 'margin: 10px 20px;';\n\t        header.style.color = model.get('textColor');\n\t\n\t        var viewMain = document.createElement('div');\n\t        var textarea = document.createElement('textarea');\n\t        viewMain.style.cssText = 'display:block;width:100%;overflow:hidden;';\n\t\n\t        var optionToContent = model.get('optionToContent');\n\t        var contentToOption = model.get('contentToOption');\n\t        var result = getContentFromModel(ecModel);\n\t        if (typeof optionToContent === 'function') {\n\t            var htmlOrDom = optionToContent(api.getOption());\n\t            if (typeof htmlOrDom === 'string') {\n\t                viewMain.innerHTML = htmlOrDom;\n\t            }\n\t            else if (zrUtil.isDom(htmlOrDom)) {\n\t                viewMain.appendChild(htmlOrDom);\n\t            }\n\t        }\n\t        else {\n\t            // Use default textarea\n\t            viewMain.appendChild(textarea);\n\t            textarea.readOnly = model.get('readOnly');\n\t            textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';\n\t            textarea.style.color = model.get('textColor');\n\t            textarea.style.borderColor = model.get('textareaBorderColor');\n\t            textarea.style.backgroundColor = model.get('textareaColor');\n\t            textarea.value = result.value;\n\t        }\n\t\n\t        var blockMetaList = result.meta;\n\t\n\t        var buttonContainer = document.createElement('div');\n\t        buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';\n\t\n\t        var buttonStyle = 'float:right;margin-right:20px;border:none;'\n\t            + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n\t        var closeButton = document.createElement('div');\n\t        var refreshButton = document.createElement('div');\n\t\n\t        buttonStyle += ';background-color:' + model.get('buttonColor');\n\t        buttonStyle += ';color:' + model.get('buttonTextColor');\n\t\n\t        var self = this;\n\t\n\t        function close() {\n\t            container.removeChild(root);\n\t            self._dom = null;\n\t        }\n\t        eventTool.addEventListener(closeButton, 'click', close);\n\t\n\t        eventTool.addEventListener(refreshButton, 'click', function () {\n\t            var newOption;\n\t            try {\n\t                if (typeof contentToOption === 'function') {\n\t                    newOption = contentToOption(viewMain, api.getOption());\n\t                }\n\t                else {\n\t                    newOption = parseContents(textarea.value, blockMetaList);\n\t                }\n\t            }\n\t            catch (e) {\n\t                close();\n\t                throw new Error('Data view format error ' + e);\n\t            }\n\t            if (newOption) {\n\t                api.dispatchAction({\n\t                    type: 'changeDataView',\n\t                    newOption: newOption\n\t                });\n\t            }\n\t\n\t            close();\n\t        });\n\t\n\t        closeButton.innerHTML = lang[1];\n\t        refreshButton.innerHTML = lang[2];\n\t        refreshButton.style.cssText = buttonStyle;\n\t        closeButton.style.cssText = buttonStyle;\n\t\n\t        !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n\t        buttonContainer.appendChild(closeButton);\n\t\n\t        // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea\n\t        eventTool.addEventListener(textarea, 'keydown', function (e) {\n\t            if ((e.keyCode || e.which) === 9) {\n\t                // get caret position/selection\n\t                var val = this.value;\n\t                var start = this.selectionStart;\n\t                var end = this.selectionEnd;\n\t\n\t                // set textarea value to: text before caret + tab + text after caret\n\t                this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end);\n\t\n\t                // put caret at right position again\n\t                this.selectionStart = this.selectionEnd = start + 1;\n\t\n\t                // prevent the focus lose\n\t                eventTool.stop(e);\n\t            }\n\t        });\n\t\n\t        root.appendChild(header);\n\t        root.appendChild(viewMain);\n\t        root.appendChild(buttonContainer);\n\t\n\t        viewMain.style.height = (container.clientHeight - 80) + 'px';\n\t\n\t        container.appendChild(root);\n\t        this._dom = root;\n\t    };\n\t\n\t    DataView.prototype.remove = function (ecModel, api) {\n\t        this._dom && api.getDom().removeChild(this._dom);\n\t    };\n\t\n\t    DataView.prototype.dispose = function (ecModel, api) {\n\t        this.remove(ecModel, api);\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function tryMergeDataOption(newData, originalData) {\n\t        return zrUtil.map(newData, function (newVal, idx) {\n\t            var original = originalData && originalData[idx];\n\t            if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {\n\t                if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {\n\t                    newVal = newVal.value;\n\t                }\n\t                // Original data has option\n\t                return zrUtil.defaults({\n\t                    value: newVal\n\t                }, original);\n\t            }\n\t            else {\n\t                return newVal;\n\t            }\n\t        });\n\t    }\n\t\n\t    __webpack_require__(/*! ../featureManager */ 25).register('dataView', DataView);\n\t\n\t    __webpack_require__(/*! ../../../echarts */ 2).registerAction({\n\t        type: 'changeDataView',\n\t        event: 'dataViewChanged',\n\t        update: 'prepareAndUpdate'\n\t    }, function (payload, ecModel) {\n\t        var newSeriesOptList = [];\n\t        zrUtil.each(payload.newOption.series, function (seriesOpt) {\n\t            var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n\t            if (!seriesModel) {\n\t                // New created series\n\t                // Geuss the series type\n\t                newSeriesOptList.push(zrUtil.extend({\n\t                    // Default is scatter\n\t                    type: 'scatter'\n\t                }, seriesOpt));\n\t            }\n\t            else {\n\t                var originalData = seriesModel.get('data');\n\t                newSeriesOptList.push({\n\t                    name: seriesOpt.name,\n\t                    data: tryMergeDataOption(seriesOpt.data, originalData)\n\t                });\n\t            }\n\t        });\n\t\n\t        ecModel.mergeOption(zrUtil.defaults({\n\t            series: newSeriesOptList\n\t        }, payload.newOption));\n\t    });\n\t\n\t    module.exports = DataView;\n\n\n/***/ },\n/* 208 */\n/*!***************************************************!*\\\n  !*** ./lib/component/toolbox/feature/DataZoom.js ***!\n  \\***************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var BrushController = __webpack_require__(/*! ../../helper/BrushController */ 113);\n\t    var brushHelper = __webpack_require__(/*! ../../helper/brushHelper */ 114);\n\t    var history = __webpack_require__(/*! ../../dataZoom/history */ 111);\n\t\n\t    var each = zrUtil.each;\n\t\n\t    // Use dataZoomSelect\n\t    __webpack_require__(/*! ../../dataZoomSelect */ 188);\n\t\n\t    // Spectial component id start with \\0ec\\0, see echarts/model/Global.js~hasInnerId\n\t    var DATA_ZOOM_ID_BASE = '\\0_ec_\\0toolbox-dataZoom_';\n\t\n\t    function DataZoom(model, ecModel, api) {\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:echarts/component/helper/BrushController}\n\t         */\n\t        (this._brushController = new BrushController(api.getZr()))\n\t            .on('brush', zrUtil.bind(this._onBrush, this))\n\t            .mount();\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._isZoomActive;\n\t    }\n\t\n\t    DataZoom.defaultOption = {\n\t        show: true,\n\t        // Icon group\n\t        icon: {\n\t            zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n\t            back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n\t        },\n\t        title: {\n\t            zoom: '',\n\t            back: ''\n\t        }\n\t    };\n\t\n\t    var proto = DataZoom.prototype;\n\t\n\t    proto.render = function (featureModel, ecModel, api, payload) {\n\t        this.model = featureModel;\n\t        this.ecModel = ecModel;\n\t        this.api = api;\n\t\n\t        updateZoomBtnStatus(featureModel, ecModel, this, payload);\n\t        updateBackBtnStatus(featureModel, ecModel);\n\t    };\n\t\n\t    proto.onclick = function (ecModel, api, type) {\n\t        handlers[type].call(this);\n\t    };\n\t\n\t    proto.remove = function (ecModel, api) {\n\t        this._brushController.unmount();\n\t    };\n\t\n\t    proto.dispose = function (ecModel, api) {\n\t        this._brushController.dispose();\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    var handlers = {\n\t\n\t        zoom: function () {\n\t            var nextActive = !this._isZoomActive;\n\t\n\t            this.api.dispatchAction({\n\t                type: 'takeGlobalCursor',\n\t                key: 'dataZoomSelect',\n\t                dataZoomSelectActive: nextActive\n\t            });\n\t        },\n\t\n\t        back: function () {\n\t            this._dispatchZoomAction(history.pop(this.ecModel));\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    proto._onBrush = function (areas, opt) {\n\t        if (!opt.isEnd || !areas.length) {\n\t            return;\n\t        }\n\t        var snapshot = {};\n\t        var ecModel = this.ecModel;\n\t\n\t        this._brushController.updateCovers([]); // remove cover\n\t\n\t        var coordInfoList = brushHelper.makeCoordInfoList(\n\t            retrieveAxisSetting(this.model.option), ecModel\n\t        );\n\t        var rangesCoordInfoList = [];\n\t        brushHelper.parseOutputRanges(areas, coordInfoList, ecModel, rangesCoordInfoList);\n\t\n\t        var area = areas[0]; // dataZoom can not multiple area.\n\t        var coordInfo = rangesCoordInfoList[0];\n\t        var coordRange = area.coordRange;\n\t        var brushType = area.brushType;\n\t\n\t        if (coordInfo && coordRange) {\n\t            if (brushType === 'rect') {\n\t                setBatch('xAxis', coordRange[0], coordInfo);\n\t                setBatch('yAxis', coordRange[1], coordInfo);\n\t            }\n\t            else {\n\t                var axisNames = {lineX: 'xAxis', lineY: 'yAxis'};\n\t                setBatch(axisNames[brushType], coordRange, coordInfo);\n\t            }\n\t        }\n\t\n\t        history.push(ecModel, snapshot);\n\t\n\t        this._dispatchZoomAction(snapshot);\n\t\n\t        function setBatch(axisName, minMax, coordInfo) {\n\t            var dataZoomModel = findDataZoom(axisName, coordInfo[axisName], ecModel);\n\t            if (dataZoomModel) {\n\t                snapshot[dataZoomModel.id] = {\n\t                    dataZoomId: dataZoomModel.id,\n\t                    startValue: minMax[0],\n\t                    endValue: minMax[1]\n\t                };\n\t            }\n\t        }\n\t\n\t        function findDataZoom(axisName, axisModel, ecModel) {\n\t            var dataZoomModel;\n\t            ecModel.eachComponent(\n\t                {mainType: 'dataZoom', subType: 'select'},\n\t                function (dzModel, dataZoomIndex) {\n\t                    var axisIndex = dzModel.get(axisName + 'Index');\n\t                    if (axisIndex != null\n\t                        && ecModel.getComponent(axisName, axisIndex) === axisModel\n\t                    ) {\n\t                        dataZoomModel = dzModel;\n\t                    }\n\t                }\n\t            );\n\t            return dataZoomModel;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    proto._dispatchZoomAction = function (snapshot) {\n\t        var batch = [];\n\t\n\t        // Convert from hash map to array.\n\t        each(snapshot, function (batchItem, dataZoomId) {\n\t            batch.push(zrUtil.clone(batchItem));\n\t        });\n\t\n\t        batch.length && this.api.dispatchAction({\n\t            type: 'dataZoom',\n\t            from: this.uid,\n\t            batch: batch\n\t        });\n\t    };\n\t\n\t    function retrieveAxisSetting(option) {\n\t        var setting = {};\n\t        // Compatible with previous setting: null => all axis, false => no axis.\n\t        zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {\n\t            setting[name] = option[name];\n\t            setting[name] == null && (setting[name] = 'all');\n\t            (setting[name] === false || setting[name] === 'none') && (setting[name] = []);\n\t        });\n\t        return setting;\n\t    }\n\t\n\t    function updateBackBtnStatus(featureModel, ecModel) {\n\t        featureModel.setIconStatus(\n\t            'back',\n\t            history.count(ecModel) > 1 ? 'emphasis' : 'normal'\n\t        );\n\t    }\n\t\n\t    function updateZoomBtnStatus(featureModel, ecModel, view, payload) {\n\t        var zoomActive = view._isZoomActive;\n\t\n\t        if (payload && payload.type === 'takeGlobalCursor') {\n\t            zoomActive = payload.key === 'dataZoomSelect'\n\t                ? payload.dataZoomSelectActive : false;\n\t        }\n\t\n\t        view._isZoomActive = zoomActive;\n\t\n\t        featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n\t\n\t        var coordInfoList = brushHelper.makeCoordInfoList(\n\t            retrieveAxisSetting(featureModel.option), ecModel\n\t        );\n\t        var brushType = (coordInfoList.xAxisHas && !coordInfoList.yAxisHas)\n\t            ? 'lineX'\n\t            : (!coordInfoList.xAxisHas && coordInfoList.yAxisHas)\n\t            ? 'lineY'\n\t            : 'rect';\n\t\n\t        view._brushController\n\t            .setPanels(brushHelper.makePanelOpts(coordInfoList))\n\t            .enableBrush(\n\t                zoomActive\n\t                ? {\n\t                    brushType: brushType,\n\t                    brushStyle: { // FIXME user customized?\n\t                        lineWidth: 0,\n\t                        // stroke: '#333',\n\t                        fill: 'rgba(0,0,0,0.2)'\n\t                    }\n\t                }\n\t                : false\n\t            );\n\t    }\n\t\n\t\n\t    __webpack_require__(/*! ../featureManager */ 25).register('dataZoom', DataZoom);\n\t\n\t\n\t    // Create special dataZoom option for select\n\t    __webpack_require__(/*! ../../../echarts */ 2).registerPreprocessor(function (option) {\n\t        if (!option) {\n\t            return;\n\t        }\n\t\n\t        var dataZoomOpts = option.dataZoom || (option.dataZoom = []);\n\t        if (!zrUtil.isArray(dataZoomOpts)) {\n\t            option.dataZoom = dataZoomOpts = [dataZoomOpts];\n\t        }\n\t\n\t        var toolboxOpt = option.toolbox;\n\t        if (toolboxOpt) {\n\t            // Assume there is only one toolbox\n\t            if (zrUtil.isArray(toolboxOpt)) {\n\t                toolboxOpt = toolboxOpt[0];\n\t            }\n\t\n\t            if (toolboxOpt && toolboxOpt.feature) {\n\t                var dataZoomOpt = toolboxOpt.feature.dataZoom;\n\t                addForAxis('xAxis', dataZoomOpt);\n\t                addForAxis('yAxis', dataZoomOpt);\n\t            }\n\t        }\n\t\n\t        function addForAxis(axisName, dataZoomOpt) {\n\t            if (!dataZoomOpt) {\n\t                return;\n\t            }\n\t\n\t            // Try not to modify model, because it is not merged yet.\n\t            var axisIndicesName = axisName + 'Index';\n\t            var givenAxisIndices = dataZoomOpt[axisIndicesName];\n\t            if (givenAxisIndices != null\n\t                && givenAxisIndices != 'all'\n\t                && !zrUtil.isArray(givenAxisIndices)\n\t            ) {\n\t                givenAxisIndices = (givenAxisIndices === false || givenAxisIndices === 'none') ? [] : [givenAxisIndices];\n\t            }\n\t\n\t            forEachComponent(axisName, function (axisOpt, axisIndex) {\n\t                if (givenAxisIndices != null\n\t                    && givenAxisIndices != 'all'\n\t                    && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1\n\t                ) {\n\t                    return;\n\t                }\n\t                var newOpt = {\n\t                    type: 'select',\n\t                    $fromToolbox: true,\n\t                    // Id for merge mapping.\n\t                    id: DATA_ZOOM_ID_BASE + axisName + axisIndex\n\t                };\n\t                // FIXME\n\t                // Only support one axis now.\n\t                newOpt[axisIndicesName] = axisIndex;\n\t                dataZoomOpts.push(newOpt);\n\t            });\n\t        }\n\t\n\t        function forEachComponent(mainType, cb) {\n\t            var opts = option[mainType];\n\t            if (!zrUtil.isArray(opts)) {\n\t                opts = opts ? [opts] : [];\n\t            }\n\t            each(opts, cb);\n\t        }\n\t    });\n\t\n\t    module.exports = DataZoom;\n\n\n/***/ },\n/* 209 */\n/*!****************************************************!*\\\n  !*** ./lib/component/toolbox/feature/MagicType.js ***!\n  \\****************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    function MagicType(model) {\n\t        this.model = model;\n\t    }\n\t\n\t    MagicType.defaultOption = {\n\t        show: true,\n\t        type: [],\n\t        // Icon group\n\t        icon: {\n\t            line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n\t            bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n\t            stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z', // jshint ignore:line\n\t            tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'\n\t        },\n\t        title: {\n\t            line: '',\n\t            bar: '',\n\t            stack: '',\n\t            tiled: ''\n\t        },\n\t        option: {},\n\t        seriesIndex: {}\n\t    };\n\t\n\t    var proto = MagicType.prototype;\n\t\n\t    proto.getIcons = function () {\n\t        var model = this.model;\n\t        var availableIcons = model.get('icon');\n\t        var icons = {};\n\t        zrUtil.each(model.get('type'), function (type) {\n\t            if (availableIcons[type]) {\n\t                icons[type] = availableIcons[type];\n\t            }\n\t        });\n\t        return icons;\n\t    };\n\t\n\t    var seriesOptGenreator = {\n\t        'line': function (seriesType, seriesId, seriesModel, model) {\n\t            if (seriesType === 'bar') {\n\t                return zrUtil.merge({\n\t                    id: seriesId,\n\t                    type: 'line',\n\t                    // Preserve data related option\n\t                    data: seriesModel.get('data'),\n\t                    stack: seriesModel.get('stack'),\n\t                    markPoint: seriesModel.get('markPoint'),\n\t                    markLine: seriesModel.get('markLine')\n\t                }, model.get('option.line') || {}, true);\n\t            }\n\t        },\n\t        'bar': function (seriesType, seriesId, seriesModel, model) {\n\t            if (seriesType === 'line') {\n\t                return zrUtil.merge({\n\t                    id: seriesId,\n\t                    type: 'bar',\n\t                    // Preserve data related option\n\t                    data: seriesModel.get('data'),\n\t                    stack: seriesModel.get('stack'),\n\t                    markPoint: seriesModel.get('markPoint'),\n\t                    markLine: seriesModel.get('markLine')\n\t                }, model.get('option.bar') || {}, true);\n\t            }\n\t        },\n\t        'stack': function (seriesType, seriesId, seriesModel, model) {\n\t            if (seriesType === 'line' || seriesType === 'bar') {\n\t                return zrUtil.merge({\n\t                    id: seriesId,\n\t                    stack: '__ec_magicType_stack__'\n\t                }, model.get('option.stack') || {}, true);\n\t            }\n\t        },\n\t        'tiled': function (seriesType, seriesId, seriesModel, model) {\n\t            if (seriesType === 'line' || seriesType === 'bar') {\n\t                return zrUtil.merge({\n\t                    id: seriesId,\n\t                    stack: ''\n\t                }, model.get('option.tiled') || {}, true);\n\t            }\n\t        }\n\t    };\n\t\n\t    var radioTypes = [\n\t        ['line', 'bar'],\n\t        ['stack', 'tiled']\n\t    ];\n\t\n\t    proto.onclick = function (ecModel, api, type) {\n\t        var model = this.model;\n\t        var seriesIndex = model.get('seriesIndex.' + type);\n\t        // Not supported magicType\n\t        if (!seriesOptGenreator[type]) {\n\t            return;\n\t        }\n\t        var newOption = {\n\t            series: []\n\t        };\n\t        var generateNewSeriesTypes = function (seriesModel) {\n\t            var seriesType = seriesModel.subType;\n\t            var seriesId = seriesModel.id;\n\t            var newSeriesOpt = seriesOptGenreator[type](\n\t                seriesType, seriesId, seriesModel, model\n\t            );\n\t            if (newSeriesOpt) {\n\t                // PENDING If merge original option?\n\t                zrUtil.defaults(newSeriesOpt, seriesModel.option);\n\t                newOption.series.push(newSeriesOpt);\n\t            }\n\t            // Modify boundaryGap\n\t            var coordSys = seriesModel.coordinateSystem;\n\t            if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n\t                var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\t                if (categoryAxis) {\n\t                    var axisDim = categoryAxis.dim;\n\t                    var axisType = axisDim + 'Axis';\n\t                    var axisModel = ecModel.queryComponents({\n\t                        mainType: axisType,\n\t                        index: seriesModel.get(name + 'Index'),\n\t                        id: seriesModel.get(name + 'Id')\n\t                    })[0];\n\t                    var axisIndex = axisModel.componentIndex;\n\t\n\t                    newOption[axisType] = newOption[axisType] || [];\n\t                    for (var i = 0; i <= axisIndex; i++) {\n\t                        newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n\t                    }\n\t                    newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;\n\t                }\n\t            }\n\t        };\n\t\n\t        zrUtil.each(radioTypes, function (radio) {\n\t            if (zrUtil.indexOf(radio, type) >= 0) {\n\t                zrUtil.each(radio, function (item) {\n\t                    model.setIconStatus(item, 'normal');\n\t                });\n\t            }\n\t        });\n\t\n\t        model.setIconStatus(type, 'emphasis');\n\t\n\t        ecModel.eachComponent(\n\t            {\n\t                mainType: 'series',\n\t                query: seriesIndex == null ? null : {\n\t                    seriesIndex: seriesIndex\n\t                }\n\t            }, generateNewSeriesTypes\n\t        );\n\t        api.dispatchAction({\n\t            type: 'changeMagicType',\n\t            currentType: type,\n\t            newOption: newOption\n\t        });\n\t    };\n\t\n\t    var echarts = __webpack_require__(/*! ../../../echarts */ 2);\n\t    echarts.registerAction({\n\t        type: 'changeMagicType',\n\t        event: 'magicTypeChanged',\n\t        update: 'prepareAndUpdate'\n\t    }, function (payload, ecModel) {\n\t        ecModel.mergeOption(payload.newOption);\n\t    });\n\t\n\t    __webpack_require__(/*! ../featureManager */ 25).register('magicType', MagicType);\n\t\n\t    module.exports = MagicType;\n\n\n/***/ },\n/* 210 */\n/*!**************************************************!*\\\n  !*** ./lib/component/toolbox/feature/Restore.js ***!\n  \\**************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var history = __webpack_require__(/*! ../../dataZoom/history */ 111);\n\t\n\t    function Restore(model) {\n\t        this.model = model;\n\t    }\n\t\n\t    Restore.defaultOption = {\n\t        show: true,\n\t        icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n\t        title: ''\n\t    };\n\t\n\t    var proto = Restore.prototype;\n\t\n\t    proto.onclick = function (ecModel, api, type) {\n\t        history.clear(ecModel);\n\t\n\t        api.dispatchAction({\n\t            type: 'restore',\n\t            from: this.uid\n\t        });\n\t    };\n\t\n\t\n\t    __webpack_require__(/*! ../featureManager */ 25).register('restore', Restore);\n\t\n\t\n\t    __webpack_require__(/*! ../../../echarts */ 2).registerAction(\n\t        {type: 'restore', event: 'restore', update: 'prepareAndUpdate'},\n\t        function (payload, ecModel) {\n\t            ecModel.resetOption('recreate');\n\t        }\n\t    );\n\t\n\t    module.exports = Restore;\n\n\n/***/ },\n/* 211 */\n/*!******************************************************!*\\\n  !*** ./lib/component/toolbox/feature/SaveAsImage.js ***!\n  \\******************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var env = __webpack_require__(/*! zrender/lib/core/env */ 11);\n\t\n\t    function SaveAsImage (model) {\n\t        this.model = model;\n\t    }\n\t\n\t    SaveAsImage.defaultOption = {\n\t        show: true,\n\t        icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n\t        title: '',\n\t        type: 'png',\n\t        // Default use option.backgroundColor\n\t        // backgroundColor: '#fff',\n\t        name: '',\n\t        excludeComponents: ['toolbox'],\n\t        pixelRatio: 1,\n\t        lang: ['']\n\t    };\n\t\n\t    SaveAsImage.prototype.unusable = !env.canvasSupported;\n\t\n\t    var proto = SaveAsImage.prototype;\n\t\n\t    proto.onclick = function (ecModel, api) {\n\t        var model = this.model;\n\t        var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n\t        var $a = document.createElement('a');\n\t        var type = model.get('type', true) || 'png';\n\t        $a.download = title + '.' + type;\n\t        $a.target = '_blank';\n\t        var url = api.getConnectedDataURL({\n\t            type: type,\n\t            backgroundColor: model.get('backgroundColor', true)\n\t                || ecModel.get('backgroundColor') || '#fff',\n\t            excludeComponents: model.get('excludeComponents'),\n\t            pixelRatio: model.get('pixelRatio')\n\t        });\n\t        $a.href = url;\n\t        // Chrome and Firefox\n\t        if (typeof MouseEvent === 'function') {\n\t            var evt = new MouseEvent('click', {\n\t                view: window,\n\t                bubbles: true,\n\t                cancelable: false\n\t            });\n\t            $a.dispatchEvent(evt);\n\t        }\n\t        // IE\n\t        else {\n\t            var lang = model.get('lang');\n\t            var html = ''\n\t                + '<body style=\"margin:0;\">'\n\t                + '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + ((lang && lang[0]) || '') + '\" />'\n\t                + '</body>';\n\t            var tab = window.open();\n\t            tab.document.write(html);\n\t        }\n\t    };\n\t\n\t    __webpack_require__(/*! ../featureManager */ 25).register(\n\t        'saveAsImage', SaveAsImage\n\t    );\n\t\n\t    module.exports = SaveAsImage;\n\n\n/***/ },\n/* 212 */\n/*!**********************************!*\\\n  !*** ./lib/component/tooltip.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// FIXME Better way to pack data in graphic element\n\t\n\t\n\t    __webpack_require__(/*! ./tooltip/TooltipModel */ 214);\n\t\n\t    __webpack_require__(/*! ./tooltip/TooltipView */ 215);\n\t\n\t    // Show tip action\n\t    /**\n\t     * @action\n\t     * @property {string} type\n\t     * @property {number} seriesIndex\n\t     * @property {number} dataIndex\n\t     * @property {number} [x]\n\t     * @property {number} [y]\n\t     */\n\t    __webpack_require__(/*! ../echarts */ 2).registerAction(\n\t        {\n\t            type: 'showTip',\n\t            event: 'showTip',\n\t            update: 'none'\n\t        },\n\t        // noop\n\t        function () {}\n\t    );\n\t    // Hide tip action\n\t    __webpack_require__(/*! ../echarts */ 2).registerAction(\n\t        {\n\t            type: 'hideTip',\n\t            event: 'hideTip',\n\t            update: 'none'\n\t        },\n\t        // noop\n\t        function () {}\n\t    );\n\n\n/***/ },\n/* 213 */\n/*!*************************************************!*\\\n  !*** ./lib/component/tooltip/TooltipContent.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/component/tooltip/TooltipContent\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var zrColor = __webpack_require__(/*! zrender/lib/tool/color */ 18);\n\t    var eventUtil = __webpack_require__(/*! zrender/lib/core/event */ 24);\n\t    var formatUtil = __webpack_require__(/*! ../../util/format */ 9);\n\t    var each = zrUtil.each;\n\t    var toCamelCase = formatUtil.toCamelCase;\n\t    var env = __webpack_require__(/*! zrender/lib/core/env */ 11);\n\t\n\t    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\t\n\t    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\t\n\t    /**\n\t     * @param {number} duration\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function assembleTransition(duration) {\n\t        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n\t        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n\t                            + 'top ' + duration + 's ' + transitionCurve;\n\t        return zrUtil.map(vendors, function (vendorPrefix) {\n\t            return vendorPrefix + 'transition:' + transitionText;\n\t        }).join(';');\n\t    }\n\t\n\t    /**\n\t     * @param {Object} textStyle\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function assembleFont(textStyleModel) {\n\t        var cssText = [];\n\t\n\t        var fontSize = textStyleModel.get('fontSize');\n\t        var color = textStyleModel.getTextColor();\n\t\n\t        color && cssText.push('color:' + color);\n\t\n\t        cssText.push('font:' + textStyleModel.getFont());\n\t\n\t        fontSize &&\n\t            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\t\n\t        each(['decoration', 'align'], function (name) {\n\t            var val = textStyleModel.get(name);\n\t            val && cssText.push('text-' + name + ':' + val);\n\t        });\n\t\n\t        return cssText.join(';');\n\t    }\n\t\n\t    /**\n\t     * @param {Object} tooltipModel\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function assembleCssText(tooltipModel) {\n\t\n\t        tooltipModel = tooltipModel;\n\t\n\t        var cssText = [];\n\t\n\t        var transitionDuration = tooltipModel.get('transitionDuration');\n\t        var backgroundColor = tooltipModel.get('backgroundColor');\n\t        var textStyleModel = tooltipModel.getModel('textStyle');\n\t        var padding = tooltipModel.get('padding');\n\t\n\t        // Animation transition\n\t        transitionDuration &&\n\t            cssText.push(assembleTransition(transitionDuration));\n\t\n\t        if (backgroundColor) {\n\t            if (env.canvasSupported) {\n\t                cssText.push('background-Color:' + backgroundColor);\n\t            }\n\t            else {\n\t                // for ie\n\t                cssText.push(\n\t                    'background-Color:#' + zrColor.toHex(backgroundColor)\n\t                );\n\t                cssText.push('filter:alpha(opacity=70)');\n\t            }\n\t        }\n\t\n\t        // Border style\n\t        each(['width', 'color', 'radius'], function (name) {\n\t            var borderName = 'border-' + name;\n\t            var camelCase = toCamelCase(borderName);\n\t            var val = tooltipModel.get(camelCase);\n\t            val != null &&\n\t                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n\t        });\n\t\n\t        // Text style\n\t        cssText.push(assembleFont(textStyleModel));\n\t\n\t        // Padding\n\t        if (padding != null) {\n\t            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n\t        }\n\t\n\t        return cssText.join(';') + ';';\n\t    }\n\t\n\t    /**\n\t     * @alias module:echarts/component/tooltip/TooltipContent\n\t     * @constructor\n\t     */\n\t    function TooltipContent(container, api) {\n\t        var el = document.createElement('div');\n\t        var zr = api.getZr();\n\t\n\t        this.el = el;\n\t\n\t        this._x = api.getWidth() / 2;\n\t        this._y = api.getHeight() / 2;\n\t\n\t        container.appendChild(el);\n\t\n\t        this._container = container;\n\t\n\t        this._show = false;\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        this._hideTimeout;\n\t\n\t        var self = this;\n\t        el.onmouseenter = function () {\n\t            // clear the timeout in hideLater and keep showing tooltip\n\t            if (self.enterable) {\n\t                clearTimeout(self._hideTimeout);\n\t                self._show = true;\n\t            }\n\t            self._inContent = true;\n\t        };\n\t        el.onmousemove = function (e) {\n\t            e = e || window.event;\n\t            if (!self.enterable) {\n\t                // Try trigger zrender event to avoid mouse\n\t                // in and out shape too frequently\n\t                var handler = zr.handler;\n\t                eventUtil.normalizeEvent(container, e, true);\n\t                handler.dispatch('mousemove', e);\n\t            }\n\t        };\n\t        el.onmouseleave = function () {\n\t            if (self.enterable) {\n\t                if (self._show) {\n\t                    self.hideLater(self._hideDelay);\n\t                }\n\t            }\n\t            self._inContent = false;\n\t        };\n\t\n\t        compromiseMobile(el, container);\n\t    }\n\t\n\t    function compromiseMobile(tooltipContentEl, container) {\n\t        // Prevent default behavior on mobile. For example,\n\t        // default pinch gesture will cause browser zoom.\n\t        // We do not preventing event on tooltip content el,\n\t        // because user may need customization in tooltip el.\n\t        eventUtil.addEventListener(container, 'touchstart', preventDefault);\n\t        eventUtil.addEventListener(container, 'touchmove', preventDefault);\n\t        eventUtil.addEventListener(container, 'touchend', preventDefault);\n\t\n\t        function preventDefault(e) {\n\t            if (!contains(e.target)) {\n\t                e.preventDefault();\n\t            }\n\t        }\n\t\n\t        function contains(targetEl) {\n\t            while (targetEl && targetEl !== container) {\n\t                if (targetEl === tooltipContentEl) {\n\t                    return true;\n\t                }\n\t                targetEl = targetEl.parentNode;\n\t            }\n\t        }\n\t    }\n\t\n\t    TooltipContent.prototype = {\n\t\n\t        constructor: TooltipContent,\n\t\n\t        enterable: true,\n\t\n\t        /**\n\t         * Update when tooltip is rendered\n\t         */\n\t        update: function () {\n\t            var container = this._container;\n\t            var stl = container.currentStyle\n\t                || document.defaultView.getComputedStyle(container);\n\t            var domStyle = container.style;\n\t            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n\t                domStyle.position = 'relative';\n\t            }\n\t            // Hide the tooltip\n\t            // PENDING\n\t            // this.hide();\n\t        },\n\t\n\t        show: function (tooltipModel) {\n\t            clearTimeout(this._hideTimeout);\n\t            var el = this.el;\n\t\n\t            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n\t                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n\t                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n\t                + (tooltipModel.get('extraCssText') || '');\n\t\n\t            el.style.display = el.innerHTML ?  'block' : 'none';\n\t\n\t            this._show = true;\n\t        },\n\t\n\t        setContent: function (content) {\n\t            var el = this.el;\n\t            el.innerHTML = content;\n\t            el.style.display = content ? 'block' : 'none';\n\t        },\n\t\n\t        moveTo: function (x, y) {\n\t            var style = this.el.style;\n\t            style.left = x + 'px';\n\t            style.top = y + 'px';\n\t\n\t            this._x = x;\n\t            this._y = y;\n\t        },\n\t\n\t        hide: function () {\n\t            this.el.style.display = 'none';\n\t            this._show = false;\n\t        },\n\t\n\t        // showLater: function ()\n\t\n\t        hideLater: function (time) {\n\t            if (this._show && !(this._inContent && this.enterable)) {\n\t                if (time) {\n\t                    this._hideDelay = time;\n\t                    // Set show false to avoid invoke hideLater mutiple times\n\t                    this._show = false;\n\t                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n\t                }\n\t                else {\n\t                    this.hide();\n\t                }\n\t            }\n\t        },\n\t\n\t        isShow: function () {\n\t            return this._show;\n\t        }\n\t    };\n\t\n\t    module.exports = TooltipContent;\n\n\n/***/ },\n/* 214 */\n/*!***********************************************!*\\\n  !*** ./lib/component/tooltip/TooltipModel.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    __webpack_require__(/*! ../../echarts */ 2).extendComponentModel({\n\t\n\t        type: 'tooltip',\n\t\n\t        defaultOption: {\n\t            zlevel: 0,\n\t\n\t            z: 8,\n\t\n\t            show: true,\n\t\n\t            // tooltip\n\t            showContent: true,\n\t\n\t            // 'item'  'axis'\n\t            trigger: 'item',\n\t\n\t            //  'click' | 'mousemove' | 'none'\n\t            triggerOn: 'mousemove',\n\t\n\t            //  content\n\t            alwaysShowContent: false,\n\t\n\t            //  {Array} | {Function}\n\t            // position: null\n\t\n\t            // {string}Template  {Function}\n\t            // formatter: null\n\t\n\t            showDelay: 0,\n\t\n\t            // ms\n\t            hideDelay: 100,\n\t\n\t            // s\n\t            transitionDuration: 0.4,\n\t\n\t            enterable: false,\n\t\n\t            // 0.7\n\t            backgroundColor: 'rgba(50,50,50,0.7)',\n\t\n\t            // \n\t            borderColor: '#333',\n\t\n\t            // px4\n\t            borderRadius: 4,\n\t\n\t            // px0\n\t            borderWidth: 0,\n\t\n\t            // px5\n\t            // css\n\t            padding: 5,\n\t\n\t            // Extra css text\n\t            extraCssText: '',\n\t\n\t            // \n\t            axisPointer: {\n\t                // \n\t                // 'line' | 'shadow' | 'cross'\n\t                type: 'line',\n\t\n\t                // type  line  tooltip line \n\t                //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n\t                //  'auto' cateogry  x \n\t                //  angle \n\t                axis: 'auto',\n\t\n\t                animation: true,\n\t                animationDurationUpdate: 200,\n\t                animationEasingUpdate: 'exponentialOut',\n\t\n\t                // \n\t                lineStyle: {\n\t                    color: '#555',\n\t                    width: 1,\n\t                    type: 'solid'\n\t                },\n\t\n\t                crossStyle: {\n\t                    color: '#555',\n\t                    width: 1,\n\t                    type: 'dashed',\n\t\n\t                    // TODO formatter\n\t                    textStyle: {}\n\t                },\n\t\n\t                // \n\t                shadowStyle: {\n\t                    color: 'rgba(150,150,150,0.3)'\n\t                }\n\t            },\n\t            textStyle: {\n\t                color: '#fff',\n\t                fontSize: 14\n\t            }\n\t        }\n\t    });\n\n\n/***/ },\n/* 215 */\n/*!**********************************************!*\\\n  !*** ./lib/component/tooltip/TooltipView.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var TooltipContent = __webpack_require__(/*! ./TooltipContent */ 213);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var formatUtil = __webpack_require__(/*! ../../util/format */ 9);\n\t    var numberUtil = __webpack_require__(/*! ../../util/number */ 4);\n\t    var modelUtil = __webpack_require__(/*! ../../util/model */ 7);\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var env = __webpack_require__(/*! zrender/lib/core/env */ 11);\n\t    var Model = __webpack_require__(/*! ../../model/Model */ 10);\n\t\n\t    function dataEqual(a, b) {\n\t        if (!a || !b) {\n\t            return false;\n\t        }\n\t        var round = numberUtil.round;\n\t        return round(a[0]) === round(b[0])\n\t            && round(a[1]) === round(b[1]);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeLineShape(x1, y1, x2, y2) {\n\t        return {\n\t            x1: x1,\n\t            y1: y1,\n\t            x2: x2,\n\t            y2: y2\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeRectShape(x, y, width, height) {\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            width: width,\n\t            height: height\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n\t        return {\n\t            cx: cx,\n\t            cy: cy,\n\t            r0: r0,\n\t            r: r,\n\t            startAngle: startAngle,\n\t            endAngle: endAngle,\n\t            clockwise: true\n\t        };\n\t    }\n\t\n\t    function refixTooltipPosition(x, y, el, viewWidth, viewHeight) {\n\t        var width = el.clientWidth;\n\t        var height = el.clientHeight;\n\t        var gap = 20;\n\t\n\t        if (x + width + gap > viewWidth) {\n\t            x -= width + gap;\n\t        }\n\t        else {\n\t            x += gap;\n\t        }\n\t        if (y + height + gap > viewHeight) {\n\t            y -= height + gap;\n\t        }\n\t        else {\n\t            y += gap;\n\t        }\n\t        return [x, y];\n\t    }\n\t\n\t    function calcTooltipPosition(position, rect, dom) {\n\t        var domWidth = dom.clientWidth;\n\t        var domHeight = dom.clientHeight;\n\t        var gap = 5;\n\t        var x = 0;\n\t        var y = 0;\n\t        var rectWidth = rect.width;\n\t        var rectHeight = rect.height;\n\t        switch (position) {\n\t            case 'inside':\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\n\t                break;\n\t            case 'top':\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\n\t                y = rect.y - domHeight - gap;\n\t                break;\n\t            case 'bottom':\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\n\t                y = rect.y + rectHeight + gap;\n\t                break;\n\t            case 'left':\n\t                x = rect.x - domWidth - gap;\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\n\t                break;\n\t            case 'right':\n\t                x = rect.x + rectWidth + gap;\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\n\t        }\n\t        return [x, y];\n\t    }\n\t\n\t    /**\n\t     * @param  {string|Function|Array.<number>} positionExpr\n\t     * @param  {number} x Mouse x\n\t     * @param  {number} y Mouse y\n\t     * @param  {module:echarts/component/tooltip/TooltipContent} content\n\t     * @param  {Object|<Array.<Object>} params\n\t     * @param  {module:zrender/Element} el target element\n\t     * @param  {module:echarts/ExtensionAPI} api\n\t     * @return {Array.<number>}\n\t     */\n\t    function updatePosition(positionExpr, x, y, content, params, el, api) {\n\t        var viewWidth = api.getWidth();\n\t        var viewHeight = api.getHeight();\n\t\n\t        var rect = el && el.getBoundingRect().clone();\n\t        el && rect.applyTransform(el.transform);\n\t        if (typeof positionExpr === 'function') {\n\t            // Callback of position can be an array or a string specify the position\n\t            positionExpr = positionExpr([x, y], params, content.el, rect);\n\t        }\n\t\n\t        if (zrUtil.isArray(positionExpr)) {\n\t            x = parsePercent(positionExpr[0], viewWidth);\n\t            y = parsePercent(positionExpr[1], viewHeight);\n\t        }\n\t        // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n\t        else if (typeof positionExpr === 'string' && el) {\n\t            var pos = calcTooltipPosition(\n\t                positionExpr, rect, content.el\n\t            );\n\t            x = pos[0];\n\t            y = pos[1];\n\t        }\n\t        else {\n\t            var pos = refixTooltipPosition(\n\t                x, y, content.el, viewWidth, viewHeight\n\t            );\n\t            x = pos[0];\n\t            y = pos[1];\n\t        }\n\t\n\t        content.moveTo(x, y);\n\t    }\n\t\n\t    function ifSeriesSupportAxisTrigger(seriesModel) {\n\t        var coordSys = seriesModel.coordinateSystem;\n\t        var trigger = seriesModel.get('tooltip.trigger', true);\n\t        // Ignore series use item tooltip trigger and series coordinate system is not cartesian or\n\t        return !(!coordSys\n\t            || (coordSys.type !== 'cartesian2d' && coordSys.type !== 'polar' && coordSys.type !== 'singleAxis')\n\t            || trigger === 'item');\n\t    }\n\t\n\t    __webpack_require__(/*! ../../echarts */ 2).extendComponentView({\n\t\n\t        type: 'tooltip',\n\t\n\t        _axisPointers: {},\n\t\n\t        init: function (ecModel, api) {\n\t            if (env.node) {\n\t                return;\n\t            }\n\t            var tooltipContent = new TooltipContent(api.getDom(), api);\n\t            this._tooltipContent = tooltipContent;\n\t\n\t            api.on('showTip', this._manuallyShowTip, this);\n\t            api.on('hideTip', this._manuallyHideTip, this);\n\t        },\n\t\n\t        render: function (tooltipModel, ecModel, api) {\n\t            if (env.node) {\n\t                return;\n\t            }\n\t\n\t            // Reset\n\t            this.group.removeAll();\n\t\n\t            /**\n\t             * @type {Object}\n\t             * @private\n\t             */\n\t            this._axisPointers = {};\n\t\n\t            /**\n\t             * @private\n\t             * @type {module:echarts/component/tooltip/TooltipModel}\n\t             */\n\t            this._tooltipModel = tooltipModel;\n\t\n\t            /**\n\t             * @private\n\t             * @type {module:echarts/model/Global}\n\t             */\n\t            this._ecModel = ecModel;\n\t\n\t            /**\n\t             * @private\n\t             * @type {module:echarts/ExtensionAPI}\n\t             */\n\t            this._api = api;\n\t\n\t            /**\n\t             * @type {Object}\n\t             * @private\n\t             */\n\t            this._lastHover = {\n\t                // data\n\t                // payloadBatch\n\t            };\n\t\n\t            var tooltipContent = this._tooltipContent;\n\t            tooltipContent.update();\n\t            tooltipContent.enterable = tooltipModel.get('enterable');\n\t            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\t\n\t            /**\n\t             * @type {Object.<string, Array>}\n\t             */\n\t            this._seriesGroupByAxis = this._prepareAxisTriggerData(\n\t                tooltipModel, ecModel\n\t            );\n\t\n\t            var crossText = this._crossText;\n\t            if (crossText) {\n\t                this.group.add(crossText);\n\t            }\n\t\n\t            var triggerOn = tooltipModel.get('triggerOn');\n\t\n\t            // Try to keep the tooltip show when refreshing\n\t            if (this._lastX != null\n\t                && this._lastY != null\n\t                // When user is willing to control tooltip totally using API,\n\t                // self._manuallyShowTip({x, y}) might cause tooltip hide,\n\t                // which is not expected.\n\t                && triggerOn !== 'none'\n\t            ) {\n\t                var self = this;\n\t                clearTimeout(this._refreshUpdateTimeout);\n\t                this._refreshUpdateTimeout = setTimeout(function () {\n\t                    // Show tip next tick after other charts are rendered\n\t                    // In case highlight action has wrong result\n\t                    // FIXME\n\t                    self._manuallyShowTip({\n\t                        x: self._lastX,\n\t                        y: self._lastY\n\t                    });\n\t                });\n\t            }\n\t\n\t            var zr = this._api.getZr();\n\t            zr.off('click', this._tryShow);\n\t            zr.off('mousemove', this._mousemove);\n\t            zr.off('mouseout', this._hide);\n\t            zr.off('globalout', this._hide);\n\t\n\t            if (triggerOn === 'click') {\n\t                zr.on('click', this._tryShow, this);\n\t            }\n\t            else if (triggerOn === 'mousemove') {\n\t                zr.on('mousemove', this._mousemove, this);\n\t                zr.on('mouseout', this._hide, this);\n\t                zr.on('globalout', this._hide, this);\n\t            }\n\t            // else triggerOn is 'none', which enable user\n\t            // to control tooltip totally using API.\n\t        },\n\t\n\t        _mousemove: function (e) {\n\t            var showDelay = this._tooltipModel.get('showDelay');\n\t            var self = this;\n\t            clearTimeout(this._showTimeout);\n\t            if (showDelay > 0) {\n\t                this._showTimeout = setTimeout(function () {\n\t                    self._tryShow(e);\n\t                }, showDelay);\n\t            }\n\t            else {\n\t                this._tryShow(e);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tip manually by\n\t         * dispatchAction({\n\t         *     type: 'showTip',\n\t         *     x: 10,\n\t         *     y: 10\n\t         * });\n\t         * Or\n\t         * dispatchAction({\n\t         *      type: 'showTip',\n\t         *      seriesIndex: 0,\n\t         *      dataIndex or dataIndexInside or name\n\t         * });\n\t         *\n\t         *  TODO Batch\n\t         */\n\t        _manuallyShowTip: function (event) {\n\t            // From self\n\t            if (event.from === this.uid) {\n\t                return;\n\t            }\n\t\n\t            var ecModel = this._ecModel;\n\t            var seriesIndex = event.seriesIndex;\n\t            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\t            var api = this._api;\n\t\n\t            if (event.x == null || event.y == null) {\n\t                if (!seriesModel) {\n\t                    // Find the first series can use axis trigger\n\t                    ecModel.eachSeries(function (_series) {\n\t                        if (ifSeriesSupportAxisTrigger(_series) && !seriesModel) {\n\t                            seriesModel = _series;\n\t                        }\n\t                    });\n\t                }\n\t                if (seriesModel) {\n\t                    var data = seriesModel.getData();\n\t                    var dataIndex = modelUtil.queryDataIndex(data, event);\n\t\n\t                    if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n\t                        return;\n\t                    }\n\t\n\t                    var el = data.getItemGraphicEl(dataIndex);\n\t                    var cx;\n\t                    var cy;\n\t                    // Try to get the point in coordinate system\n\t                    var coordSys = seriesModel.coordinateSystem;\n\t                    if (seriesModel.getTooltipPosition) {\n\t                        var point = seriesModel.getTooltipPosition(dataIndex) || [];\n\t                        cx = point[0];\n\t                        cy = point[1];\n\t                    }\n\t                    else if (coordSys && coordSys.dataToPoint) {\n\t                        var point = coordSys.dataToPoint(\n\t                            data.getValues(\n\t                                zrUtil.map(coordSys.dimensions, function (dim) {\n\t                                    return seriesModel.coordDimToDataDim(dim)[0];\n\t                                }), dataIndex, true\n\t                            )\n\t                        );\n\t                        cx = point && point[0];\n\t                        cy = point && point[1];\n\t                    }\n\t                    else if (el) {\n\t                        // Use graphic bounding rect\n\t                        var rect = el.getBoundingRect().clone();\n\t                        rect.applyTransform(el.transform);\n\t                        cx = rect.x + rect.width / 2;\n\t                        cy = rect.y + rect.height / 2;\n\t                    }\n\t\n\t                    if (cx != null && cy != null) {\n\t                        this._tryShow({\n\t                            offsetX: cx,\n\t                            offsetY: cy,\n\t                            position: event.position,\n\t                            target: el,\n\t                            event: {}\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                var el = api.getZr().handler.findHover(event.x, event.y);\n\t                this._tryShow({\n\t                    offsetX: event.x,\n\t                    offsetY: event.y,\n\t                    position: event.position,\n\t                    target: el,\n\t                    event: {}\n\t                });\n\t            }\n\t        },\n\t\n\t        _manuallyHideTip: function (e) {\n\t            if (e.from === this.uid) {\n\t                return;\n\t            }\n\t\n\t            this._hide();\n\t        },\n\t\n\t        _prepareAxisTriggerData: function (tooltipModel, ecModel) {\n\t            // Prepare data for axis trigger\n\t            var seriesGroupByAxis = {};\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                if (ifSeriesSupportAxisTrigger(seriesModel)) {\n\t                    var coordSys = seriesModel.coordinateSystem;\n\t                    var baseAxis;\n\t                    var key;\n\t\n\t                    // Only cartesian2d, polar and single support axis trigger\n\t                    if (coordSys.type === 'cartesian2d') {\n\t                        // FIXME `axisPointer.axis` is not baseAxis\n\t                        baseAxis = coordSys.getBaseAxis();\n\t                        key = baseAxis.dim + baseAxis.index;\n\t                    }\n\t                    else if (coordSys.type === 'singleAxis') {\n\t                        baseAxis = coordSys.getAxis();\n\t                        key = baseAxis.dim + baseAxis.type;\n\t                    }\n\t                    else {\n\t                        baseAxis = coordSys.getBaseAxis();\n\t                        key = baseAxis.dim + coordSys.name;\n\t                    }\n\t\n\t                    seriesGroupByAxis[key] = seriesGroupByAxis[key] || {\n\t                        coordSys: [],\n\t                        series: []\n\t                    };\n\t                    seriesGroupByAxis[key].coordSys.push(coordSys);\n\t                    seriesGroupByAxis[key].series.push(seriesModel);\n\t                }\n\t            }, this);\n\t\n\t            return seriesGroupByAxis;\n\t        },\n\t\n\t        /**\n\t         * mousemove handler\n\t         * @param {Object} e\n\t         * @private\n\t         */\n\t        _tryShow: function (e) {\n\t            var el = e.target;\n\t            var tooltipModel = this._tooltipModel;\n\t            var globalTrigger = tooltipModel.get('trigger');\n\t            var ecModel = this._ecModel;\n\t            var api = this._api;\n\t\n\t            if (!tooltipModel) {\n\t                return;\n\t            }\n\t\n\t            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n\t            this._lastX = e.offsetX;\n\t            this._lastY = e.offsetY;\n\t\n\t            // Always show item tooltip if mouse is on the element with dataIndex\n\t            if (el && el.dataIndex != null) {\n\t                // Use dataModel in element if possible\n\t                // Used when mouseover on a element like markPoint or edge\n\t                // In which case, the data is not main data in series.\n\t                var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n\t                var dataIndex = el.dataIndex;\n\t                var itemModel = dataModel.getData().getItemModel(dataIndex);\n\t                // Series or single data may use item trigger when global is axis trigger\n\t                if ((itemModel.get('tooltip.trigger') || globalTrigger) === 'axis') {\n\t                    this._showAxisTooltip(tooltipModel, ecModel, e);\n\t                }\n\t                else {\n\t                    // Reset ticket\n\t                    this._ticket = '';\n\t                    // If either single data or series use item trigger\n\t                    this._hideAxisPointer();\n\t                    // Reset last hover and dispatch downplay action\n\t                    this._resetLastHover();\n\t\n\t                    this._showItemTooltipContent(dataModel, dataIndex, el.dataType, e);\n\t                }\n\t\n\t                api.dispatchAction({\n\t                    type: 'showTip',\n\t                    from: this.uid,\n\t                    dataIndexInside: el.dataIndex,\n\t                    seriesIndex: el.seriesIndex\n\t                });\n\t            }\n\t            // Tooltip provided directly. Like legend\n\t            else if (el && el.tooltip) {\n\t                var tooltipOpt = el.tooltip;\n\t                if (typeof tooltipOpt === 'string') {\n\t                    var content = tooltipOpt;\n\t                    tooltipOpt = {\n\t                        content: content,\n\t                        // Fixed formatter\n\t                        formatter: content\n\t                    };\n\t                }\n\t                var subTooltipModel = new Model(tooltipOpt, tooltipModel);\n\t                var defaultHtml = subTooltipModel.get('content');\n\t                var asyncTicket = Math.random();\n\t                this._showTooltipContent(\n\t                    // TODO params\n\t                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n\t                    asyncTicket, e.offsetX, e.offsetY, e.position, el, api\n\t                );\n\t            }\n\t            else {\n\t                if (globalTrigger === 'item') {\n\t                    this._hide();\n\t                }\n\t                else {\n\t                    // Try show axis tooltip\n\t                    this._showAxisTooltip(tooltipModel, ecModel, e);\n\t                }\n\t\n\t                // Action of cross pointer\n\t                // other pointer types will trigger action in _dispatchAndShowSeriesTooltipContent method\n\t                if (tooltipModel.get('axisPointer.type') === 'cross') {\n\t                    api.dispatchAction({\n\t                        type: 'showTip',\n\t                        from: this.uid,\n\t                        x: e.offsetX,\n\t                        y: e.offsetY\n\t                    });\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on axis\n\t         * @param {module:echarts/component/tooltip/TooltipModel} tooltipModel\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @param {Object} e\n\t         * @private\n\t         */\n\t        _showAxisTooltip: function (tooltipModel, ecModel, e) {\n\t            var axisPointerModel = tooltipModel.getModel('axisPointer');\n\t            var axisPointerType = axisPointerModel.get('type');\n\t\n\t            if (axisPointerType === 'cross') {\n\t                var el = e.target;\n\t                if (el && el.dataIndex != null) {\n\t                    var seriesModel = ecModel.getSeriesByIndex(el.seriesIndex);\n\t                    var dataIndex = el.dataIndex;\n\t                    this._showItemTooltipContent(seriesModel, dataIndex, el.dataType, e);\n\t                }\n\t            }\n\t\n\t            this._showAxisPointer();\n\t            var allNotShow = true;\n\t            zrUtil.each(this._seriesGroupByAxis, function (seriesCoordSysSameAxis) {\n\t                // Try show the axis pointer\n\t                var allCoordSys = seriesCoordSysSameAxis.coordSys;\n\t                var coordSys = allCoordSys[0];\n\t\n\t                // If mouse position is not in the grid or polar\n\t                var point = [e.offsetX, e.offsetY];\n\t\n\t                if (!coordSys.containPoint(point)) {\n\t                    // Hide axis pointer\n\t                    this._hideAxisPointer(coordSys.name);\n\t                    return;\n\t                }\n\t\n\t                allNotShow = false;\n\t                // Make sure point is discrete on cateogry axis\n\t                var dimensions = coordSys.dimensions;\n\t                var value = coordSys.pointToData(point, true);\n\t                point = coordSys.dataToPoint(value);\n\t                var baseAxis = coordSys.getBaseAxis();\n\t                var axisType = axisPointerModel.get('axis');\n\t                if (axisType === 'auto') {\n\t                    axisType = baseAxis.dim;\n\t                }\n\t\n\t                var contentNotChange = false;\n\t                var lastHover = this._lastHover;\n\t                if (axisPointerType === 'cross') {\n\t                    // If hover data not changed\n\t                    // Possible when two axes are all category\n\t                    if (dataEqual(lastHover.data, value)) {\n\t                        contentNotChange = true;\n\t                    }\n\t                    lastHover.data = value;\n\t                }\n\t                else {\n\t                    var valIndex = zrUtil.indexOf(dimensions, axisType);\n\t\n\t                    // If hover data not changed on the axis dimension\n\t                    if (lastHover.data === value[valIndex]) {\n\t                        contentNotChange = true;\n\t                    }\n\t                    lastHover.data = value[valIndex];\n\t                }\n\t\n\t                if (coordSys.type === 'cartesian2d' && !contentNotChange) {\n\t                    this._showCartesianPointer(\n\t                        axisPointerModel, coordSys, axisType, point\n\t                    );\n\t                }\n\t                else if (coordSys.type === 'polar' && !contentNotChange) {\n\t                    this._showPolarPointer(\n\t                        axisPointerModel, coordSys, axisType, point\n\t                    );\n\t                }\n\t                else if (coordSys.type === 'singleAxis' && !contentNotChange) {\n\t                    this._showSinglePointer(\n\t                        axisPointerModel, coordSys, axisType, point\n\t                    );\n\t                }\n\t\n\t                if (axisPointerType !== 'cross') {\n\t                    this._dispatchAndShowSeriesTooltipContent(\n\t                        coordSys, seriesCoordSysSameAxis.series, point, value, contentNotChange, e.position\n\t                    );\n\t                }\n\t            }, this);\n\t\n\t            if (!this._tooltipModel.get('show')) {\n\t                this._hideAxisPointer();\n\t            }\n\t\n\t            if (allNotShow) {\n\t                this._hide();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on axis of cartesian coordinate\n\t         * @param {module:echarts/model/Model} axisPointerModel\n\t         * @param {module:echarts/coord/cartesian/Cartesian2D} cartesians\n\t         * @param {string} axisType\n\t         * @param {Array.<number>} point\n\t         * @private\n\t         */\n\t        _showCartesianPointer: function (axisPointerModel, cartesian, axisType, point) {\n\t            var self = this;\n\t\n\t            var axisPointerType = axisPointerModel.get('type');\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var moveAnimation = axisPointerType !== 'cross'\n\t                && baseAxis.type === 'category'\n\t                && baseAxis.getBandWidth() > 20;\n\t\n\t            if (axisPointerType === 'cross') {\n\t                moveGridLine('x', point, cartesian.getAxis('y').getGlobalExtent());\n\t                moveGridLine('y', point, cartesian.getAxis('x').getGlobalExtent());\n\t\n\t                this._updateCrossText(cartesian, point, axisPointerModel);\n\t            }\n\t            else {\n\t                var otherAxis = cartesian.getAxis(axisType === 'x' ? 'y' : 'x');\n\t                var otherExtent = otherAxis.getGlobalExtent();\n\t\n\t                if (cartesian.type === 'cartesian2d') {\n\t                    (axisPointerType === 'line' ? moveGridLine : moveGridShadow)(\n\t                        axisType, point, otherExtent\n\t                    );\n\t                }\n\t            }\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function moveGridLine(axisType, point, otherExtent) {\n\t                var targetShape = axisType === 'x'\n\t                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n\t                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    cartesian, axisPointerModel, axisType, targetShape\n\t                );\n\t                graphic.subPixelOptimizeLine({\n\t                    shape: targetShape,\n\t                    style: pointerEl.style\n\t                });\n\t\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function moveGridShadow(axisType, point, otherExtent) {\n\t                var axis = cartesian.getAxis(axisType);\n\t                var bandWidth = axis.getBandWidth();\n\t                var span = otherExtent[1] - otherExtent[0];\n\t                var targetShape = axisType === 'x'\n\t                    ? makeRectShape(point[0] - bandWidth / 2, otherExtent[0], bandWidth, span)\n\t                    : makeRectShape(otherExtent[0], point[1] - bandWidth / 2, span, bandWidth);\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    cartesian, axisPointerModel, axisType, targetShape\n\t                );\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t        },\n\t\n\t        _showSinglePointer: function (axisPointerModel, single, axisType, point) {\n\t            var self = this;\n\t            var axisPointerType = axisPointerModel.get('type');\n\t            var moveAnimation = axisPointerType !== 'cross' && single.getBaseAxis().type === 'category';\n\t            var rect = single.getRect();\n\t            var otherExtent = [rect.y, rect.y + rect.height];\n\t\n\t            moveSingleLine(axisType, point, otherExtent);\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function moveSingleLine(axisType, point, otherExtent) {\n\t                var axis = single.getAxis();\n\t                var orient = axis.orient;\n\t\n\t                var targetShape = orient === 'horizontal'\n\t                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n\t                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    single, axisPointerModel, axisType, targetShape\n\t                );\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on axis of polar coordinate\n\t         * @param {module:echarts/model/Model} axisPointerModel\n\t         * @param {Array.<module:echarts/coord/polar/Polar>} polar\n\t         * @param {string} axisType\n\t         * @param {Array.<number>} point\n\t         */\n\t        _showPolarPointer: function (axisPointerModel, polar, axisType, point) {\n\t            var self = this;\n\t\n\t            var axisPointerType = axisPointerModel.get('type');\n\t\n\t            var angleAxis = polar.getAngleAxis();\n\t            var radiusAxis = polar.getRadiusAxis();\n\t\n\t            var moveAnimation = axisPointerType !== 'cross'\n\t                && polar.getBaseAxis().type === 'category';\n\t\n\t            if (axisPointerType === 'cross') {\n\t                movePolarLine('angle', point, radiusAxis.getExtent());\n\t                movePolarLine('radius', point, angleAxis.getExtent());\n\t\n\t                this._updateCrossText(polar, point, axisPointerModel);\n\t            }\n\t            else {\n\t                var otherAxis = polar.getAxis(axisType === 'radius' ? 'angle' : 'radius');\n\t                var otherExtent = otherAxis.getExtent();\n\t\n\t                (axisPointerType === 'line' ? movePolarLine : movePolarShadow)(\n\t                    axisType, point, otherExtent\n\t                );\n\t            }\n\t            /**\n\t             * @inner\n\t             */\n\t            function movePolarLine(axisType, point, otherExtent) {\n\t                var mouseCoord = polar.pointToCoord(point);\n\t\n\t                var targetShape;\n\t\n\t                if (axisType === 'angle') {\n\t                    var p1 = polar.coordToPoint([otherExtent[0], mouseCoord[1]]);\n\t                    var p2 = polar.coordToPoint([otherExtent[1], mouseCoord[1]]);\n\t                    targetShape = makeLineShape(p1[0], p1[1], p2[0], p2[1]);\n\t                }\n\t                else {\n\t                    targetShape = {\n\t                        cx: polar.cx,\n\t                        cy: polar.cy,\n\t                        r: mouseCoord[0]\n\t                    };\n\t                }\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    polar, axisPointerModel, axisType, targetShape\n\t                );\n\t\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function movePolarShadow(axisType, point, otherExtent) {\n\t                var axis = polar.getAxis(axisType);\n\t                var bandWidth = axis.getBandWidth();\n\t\n\t                var mouseCoord = polar.pointToCoord(point);\n\t\n\t                var targetShape;\n\t\n\t                var radian = Math.PI / 180;\n\t\n\t                if (axisType === 'angle') {\n\t                    targetShape = makeSectorShape(\n\t                        polar.cx, polar.cy,\n\t                        otherExtent[0], otherExtent[1],\n\t                        // In ECharts y is negative if angle is positive\n\t                        (-mouseCoord[1] - bandWidth / 2) * radian,\n\t                        (-mouseCoord[1] + bandWidth / 2) * radian\n\t                    );\n\t                }\n\t                else {\n\t                    targetShape = makeSectorShape(\n\t                        polar.cx, polar.cy,\n\t                        mouseCoord[0] - bandWidth / 2,\n\t                        mouseCoord[0] + bandWidth / 2,\n\t                        0, Math.PI * 2\n\t                    );\n\t                }\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    polar, axisPointerModel, axisType, targetShape\n\t                );\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t        },\n\t\n\t        _updateCrossText: function (coordSys, point, axisPointerModel) {\n\t            var crossStyleModel = axisPointerModel.getModel('crossStyle');\n\t            var textStyleModel = crossStyleModel.getModel('textStyle');\n\t\n\t            var tooltipModel = this._tooltipModel;\n\t\n\t            var text = this._crossText;\n\t            if (!text) {\n\t                text = this._crossText = new graphic.Text({\n\t                    style: {\n\t                        textAlign: 'left',\n\t                        textVerticalAlign: 'bottom'\n\t                    }\n\t                });\n\t                this.group.add(text);\n\t            }\n\t\n\t            var value = coordSys.pointToData(point);\n\t\n\t            var dims = coordSys.dimensions;\n\t            value = zrUtil.map(value, function (val, idx) {\n\t                var axis = coordSys.getAxis(dims[idx]);\n\t                if (axis.type === 'category' || axis.type === 'time') {\n\t                    val = axis.scale.getLabel(val);\n\t                }\n\t                else {\n\t                    val = formatUtil.addCommas(\n\t                        val.toFixed(axis.getPixelPrecision())\n\t                    );\n\t                }\n\t                return val;\n\t            });\n\t\n\t            text.setStyle({\n\t                fill: textStyleModel.getTextColor() || crossStyleModel.get('color'),\n\t                textFont: textStyleModel.getFont(),\n\t                text: value.join(', '),\n\t                x: point[0] + 5,\n\t                y: point[1] - 5\n\t            });\n\t            text.z = tooltipModel.get('z');\n\t            text.zlevel = tooltipModel.get('zlevel');\n\t        },\n\t\n\t        _getPointerElement: function (coordSys, pointerModel, axisType, initShape) {\n\t            var tooltipModel = this._tooltipModel;\n\t            var z = tooltipModel.get('z');\n\t            var zlevel = tooltipModel.get('zlevel');\n\t            var axisPointers = this._axisPointers;\n\t            var coordSysName = coordSys.name;\n\t            axisPointers[coordSysName] = axisPointers[coordSysName] || {};\n\t            if (axisPointers[coordSysName][axisType]) {\n\t                return axisPointers[coordSysName][axisType];\n\t            }\n\t\n\t            // Create if not exists\n\t            var pointerType = pointerModel.get('type');\n\t            var styleModel = pointerModel.getModel(pointerType + 'Style');\n\t            var isShadow = pointerType === 'shadow';\n\t            var style = styleModel[isShadow ? 'getAreaStyle' : 'getLineStyle']();\n\t\n\t            var elementType = coordSys.type === 'polar'\n\t                ? (isShadow ? 'Sector' : (axisType === 'radius' ? 'Circle' : 'Line'))\n\t                : (isShadow ? 'Rect' : 'Line');\n\t\n\t            isShadow ? (style.stroke = null) : (style.fill = null);\n\t\n\t            var el = axisPointers[coordSysName][axisType] = new graphic[elementType]({\n\t                style: style,\n\t                z: z,\n\t                zlevel: zlevel,\n\t                silent: true,\n\t                shape: initShape\n\t            });\n\t\n\t            this.group.add(el);\n\t            return el;\n\t        },\n\t\n\t        /**\n\t         * Dispatch actions and show tooltip on series\n\t         * @param {Array.<module:echarts/model/Series>} seriesList\n\t         * @param {Array.<number>} point\n\t         * @param {Array.<number>} value\n\t         * @param {boolean} contentNotChange\n\t         * @param {Array.<number>|string|Function} [positionExpr]\n\t         */\n\t        _dispatchAndShowSeriesTooltipContent: function (\n\t            coordSys, seriesList, point, value, contentNotChange, positionExpr\n\t        ) {\n\t\n\t            var rootTooltipModel = this._tooltipModel;\n\t\n\t            var baseAxis = coordSys.getBaseAxis();\n\t            var baseDimIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\t\n\t            var payloadBatch = zrUtil.map(seriesList, function (series) {\n\t                return {\n\t                    seriesIndex: series.seriesIndex,\n\t                    dataIndexInside: series.getAxisTooltipDataIndex\n\t                        ? series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim), value, baseAxis)\n\t                        : series.getData().indexOfNearest(\n\t                            series.coordDimToDataDim(baseAxis.dim)[0],\n\t                            value[baseDimIndex],\n\t                            // Add a threshold to avoid find the wrong dataIndex when data length is not same\n\t                            false, baseAxis.type === 'category' ? 0.5 : null\n\t                        )\n\t                };\n\t            });\n\t\n\t            var lastHover = this._lastHover;\n\t            var api = this._api;\n\t            // Dispatch downplay action\n\t            if (lastHover.payloadBatch && !contentNotChange) {\n\t                api.dispatchAction({\n\t                    type: 'downplay',\n\t                    batch: lastHover.payloadBatch\n\t                });\n\t            }\n\t            // Dispatch highlight action\n\t            if (!contentNotChange) {\n\t                api.dispatchAction({\n\t                    type: 'highlight',\n\t                    batch: payloadBatch\n\t                });\n\t                lastHover.payloadBatch = payloadBatch;\n\t            }\n\t            // Dispatch showTip action\n\t            api.dispatchAction({\n\t                type: 'showTip',\n\t                dataIndexInside: payloadBatch[0].dataIndexInside,\n\t                seriesIndex: payloadBatch[0].seriesIndex,\n\t                from: this.uid\n\t            });\n\t\n\t            if (baseAxis && rootTooltipModel.get('showContent') && rootTooltipModel.get('show')) {\n\t                var paramsList = zrUtil.map(seriesList, function (series, index) {\n\t                    return series.getDataParams(payloadBatch[index].dataIndexInside);\n\t                });\n\t\n\t                if (!contentNotChange) {\n\t                    // Update html content\n\t                    var firstDataIndex = payloadBatch[0].dataIndexInside;\n\t\n\t                    // Default tooltip content\n\t                    // FIXME\n\t                    // (1) shold be the first data which has name?\n\t                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n\t                    var firstLine = baseAxis.type === 'time'\n\t                        ? baseAxis.scale.getLabel(value[baseDimIndex])\n\t                        : seriesList[0].getData().getName(firstDataIndex);\n\t                    var defaultHtml = (firstLine ? firstLine + '<br />' : '')\n\t                        + zrUtil.map(seriesList, function (series, index) {\n\t                            return series.formatTooltip(payloadBatch[index].dataIndexInside, true);\n\t                        }).join('<br />');\n\t\n\t                    var asyncTicket = 'axis_' + coordSys.name + '_' + firstDataIndex;\n\t\n\t                    this._showTooltipContent(\n\t                        rootTooltipModel, defaultHtml, paramsList, asyncTicket,\n\t                        point[0], point[1], positionExpr, null, api\n\t                    );\n\t                }\n\t                else {\n\t                    updatePosition(\n\t                        positionExpr || rootTooltipModel.get('position'), point[0], point[1],\n\t                        this._tooltipContent, paramsList, null, api\n\t                    );\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on item\n\t         * @param {module:echarts/model/Series} seriesModel\n\t         * @param {number} dataIndex\n\t         * @param {string} dataType\n\t         * @param {Object} e\n\t         */\n\t        _showItemTooltipContent: function (seriesModel, dataIndex, dataType, e) {\n\t            // FIXME Graph data\n\t            var api = this._api;\n\t            var data = seriesModel.getData(dataType);\n\t            var itemModel = data.getItemModel(dataIndex);\n\t\n\t            var tooltipOpt = itemModel.get('tooltip', true);\n\t            if (typeof tooltipOpt === 'string') {\n\t                // In each data item tooltip can be simply write:\n\t                // {\n\t                //  value: 10,\n\t                //  tooltip: 'Something you need to know'\n\t                // }\n\t                var tooltipContent = tooltipOpt;\n\t                tooltipOpt = {\n\t                    formatter: tooltipContent\n\t                };\n\t            }\n\t            var rootTooltipModel = this._tooltipModel;\n\t            var seriesTooltipModel = seriesModel.getModel(\n\t                'tooltip', rootTooltipModel\n\t            );\n\t            var tooltipModel = new Model(tooltipOpt, seriesTooltipModel, seriesTooltipModel.ecModel);\n\t\n\t            var params = seriesModel.getDataParams(dataIndex, dataType);\n\t            var defaultHtml = seriesModel.formatTooltip(dataIndex, false, dataType);\n\t\n\t            var asyncTicket = 'item_' + seriesModel.name + '_' + dataIndex;\n\t\n\t            this._showTooltipContent(\n\t                tooltipModel, defaultHtml, params, asyncTicket,\n\t                e.offsetX, e.offsetY, e.position, e.target, api\n\t            );\n\t        },\n\t\n\t        _showTooltipContent: function (\n\t            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, target, api\n\t        ) {\n\t            // Reset ticket\n\t            this._ticket = '';\n\t\n\t            if (tooltipModel.get('showContent') && tooltipModel.get('show')) {\n\t                var tooltipContent = this._tooltipContent;\n\t\n\t                var formatter = tooltipModel.get('formatter');\n\t                positionExpr = positionExpr || tooltipModel.get('position');\n\t                var html = defaultHtml;\n\t\n\t                if (formatter) {\n\t                    if (typeof formatter === 'string') {\n\t                        html = formatUtil.formatTpl(formatter, params);\n\t                    }\n\t                    else if (typeof formatter === 'function') {\n\t                        var self = this;\n\t                        var ticket = asyncTicket;\n\t                        var callback = function (cbTicket, html) {\n\t                            if (cbTicket === self._ticket) {\n\t                                tooltipContent.setContent(html);\n\t\n\t                                updatePosition(\n\t                                    positionExpr, x, y,\n\t                                    tooltipContent, params, target, api\n\t                                );\n\t                            }\n\t                        };\n\t                        self._ticket = ticket;\n\t                        html = formatter(params, ticket, callback);\n\t                    }\n\t                }\n\t\n\t                tooltipContent.show(tooltipModel);\n\t                tooltipContent.setContent(html);\n\t\n\t                updatePosition(\n\t                    positionExpr, x, y,\n\t                    tooltipContent, params, target, api\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show axis pointer\n\t         * @param {string} [coordSysName]\n\t         */\n\t        _showAxisPointer: function (coordSysName) {\n\t            if (coordSysName) {\n\t                var axisPointers = this._axisPointers[coordSysName];\n\t                axisPointers && zrUtil.each(axisPointers, function (el) {\n\t                    el.show();\n\t                });\n\t            }\n\t            else {\n\t                this.group.eachChild(function (child) {\n\t                    child.show();\n\t                });\n\t                this.group.show();\n\t            }\n\t        },\n\t\n\t        _resetLastHover: function () {\n\t            var lastHover = this._lastHover;\n\t            if (lastHover.payloadBatch) {\n\t                this._api.dispatchAction({\n\t                    type: 'downplay',\n\t                    batch: lastHover.payloadBatch\n\t                });\n\t            }\n\t            // Reset lastHover\n\t            this._lastHover = {};\n\t        },\n\t        /**\n\t         * Hide axis pointer\n\t         * @param {string} [coordSysName]\n\t         */\n\t        _hideAxisPointer: function (coordSysName) {\n\t            if (coordSysName) {\n\t                var axisPointers = this._axisPointers[coordSysName];\n\t                axisPointers && zrUtil.each(axisPointers, function (el) {\n\t                    el.hide();\n\t                });\n\t            }\n\t            else {\n\t                if (this.group.children().length) {\n\t                    this.group.hide();\n\t                }\n\t            }\n\t        },\n\t\n\t        _hide: function () {\n\t            clearTimeout(this._showTimeout);\n\t\n\t            this._hideAxisPointer();\n\t            this._resetLastHover();\n\t            if (!this._alwaysShowContent) {\n\t                this._tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n\t            }\n\t\n\t            this._api.dispatchAction({\n\t                type: 'hideTip',\n\t                from: this.uid\n\t            });\n\t\n\t            this._lastX = this._lastY = null;\n\t        },\n\t\n\t        dispose: function (ecModel, api) {\n\t            if (env.node) {\n\t                return;\n\t            }\n\t            var zr = api.getZr();\n\t            this._tooltipContent.hide();\n\t\n\t            zr.off('click', this._tryShow);\n\t            zr.off('mousemove', this._mousemove);\n\t            zr.off('mouseout', this._hide);\n\t            zr.off('globalout', this._hide);\n\t\n\t            api.off('showTip', this._manuallyShowTip);\n\t            api.off('hideTip', this._manuallyHideTip);\n\t        }\n\t    });\n\n\n/***/ },\n/* 216 */,\n/* 217 */\n/*!******************************!*\\\n  !*** ./~/process/browser.js ***!\n  \\******************************/\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 218 */\n/*!**************************************!*\\\n  !*** ./~/zrender/lib/vml/Painter.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * VML Painter.\n\t *\n\t * @module zrender/vml/Painter\n\t */\n\t\n\t\n\t\n\t    var zrLog = __webpack_require__(/*! ../core/log */ 47);\n\t    var vmlCore = __webpack_require__(/*! ./core */ 170);\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/vml/Painter\n\t     */\n\t    function VMLPainter(root, storage) {\n\t\n\t        vmlCore.initVML();\n\t\n\t        this.root = root;\n\t\n\t        this.storage = storage;\n\t\n\t        var vmlViewport = document.createElement('div');\n\t\n\t        var vmlRoot = document.createElement('div');\n\t\n\t        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\t\n\t        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\t\n\t        root.appendChild(vmlViewport);\n\t\n\t        this._vmlRoot = vmlRoot;\n\t        this._vmlViewport = vmlViewport;\n\t\n\t        this.resize();\n\t\n\t        // Modify storage\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t\n\t            oldDelFromMap.call(storage, elId);\n\t\n\t            if (el) {\n\t                el.onRemove && el.onRemove(vmlRoot);\n\t            }\n\t        };\n\t\n\t        storage.addToMap = function (el) {\n\t            // Displayable already has a vml node\n\t            el.onAdd && el.onAdd(vmlRoot);\n\t\n\t            oldAddToMap.call(storage, el);\n\t        };\n\t\n\t        this._firstPaint = true;\n\t    }\n\t\n\t    VMLPainter.prototype = {\n\t\n\t        constructor: VMLPainter,\n\t\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._vmlViewport;\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        refresh: function () {\n\t\n\t            var list = this.storage.getDisplayList(true, true);\n\t\n\t            this._paintList(list);\n\t        },\n\t\n\t        _paintList: function (list) {\n\t            var vmlRoot = this._vmlRoot;\n\t            for (var i = 0; i < list.length; i++) {\n\t                var el = list[i];\n\t                if (el.invisible || el.ignore) {\n\t                    if (!el.__alreadyNotVisible) {\n\t                        el.onRemove(vmlRoot);\n\t                    }\n\t                    // Set as already invisible\n\t                    el.__alreadyNotVisible = true;\n\t                }\n\t                else {\n\t                    if (el.__alreadyNotVisible) {\n\t                        el.onAdd(vmlRoot);\n\t                    }\n\t                    el.__alreadyNotVisible = false;\n\t                    if (el.__dirty) {\n\t                        el.beforeBrush && el.beforeBrush();\n\t                        (el.brushVML || el.brush).call(el, vmlRoot);\n\t                        el.afterBrush && el.afterBrush();\n\t                    }\n\t                }\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (this._firstPaint) {\n\t                // Detached from document at first time\n\t                // to avoid page refreshing too many times\n\t\n\t                // FIXME  removeChild \n\t                this._vmlViewport.appendChild(vmlRoot);\n\t                this._firstPaint = false;\n\t            }\n\t        },\n\t\n\t        resize: function (width, height) {\n\t            var width = width == null ? this._getWidth() : width;\n\t            var height = height == null ? this._getHeight() : height;\n\t\n\t            if (this._width != width || this._height != height) {\n\t                this._width = width;\n\t                this._height = height;\n\t\n\t                var vmlViewportStyle = this._vmlViewport.style;\n\t                vmlViewportStyle.width = width + 'px';\n\t                vmlViewportStyle.height = height + 'px';\n\t            }\n\t        },\n\t\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this._vmlRoot =\n\t            this._vmlViewport =\n\t            this.storage = null;\n\t        },\n\t\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        clear: function () {\n\t            if (this._vmlViewport) {\n\t                this.root.removeChild(this._vmlViewport);\n\t            }\n\t        },\n\t\n\t        _getWidth: function () {\n\t            var root = this.root;\n\t            var stl = root.currentStyle;\n\t\n\t            return ((root.clientWidth || parseInt10(stl.width))\n\t                    - parseInt10(stl.paddingLeft)\n\t                    - parseInt10(stl.paddingRight)) | 0;\n\t        },\n\t\n\t        _getHeight: function () {\n\t            var root = this.root;\n\t            var stl = root.currentStyle;\n\t\n\t            return ((root.clientHeight || parseInt10(stl.height))\n\t                    - parseInt10(stl.paddingTop)\n\t                    - parseInt10(stl.paddingBottom)) | 0;\n\t        }\n\t    };\n\t\n\t    // Not supported methods\n\t    function createMethodNotSupport(method) {\n\t        return function () {\n\t            zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n\t        };\n\t    }\n\t\n\t    var notSupportedMethods = [\n\t        'getLayer', 'insertLayer', 'eachLayer', 'eachBuildinLayer', 'eachOtherLayer', 'getLayers',\n\t        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'\n\t    ];\n\t\n\t    for (var i = 0; i < notSupportedMethods.length; i++) {\n\t        var name = notSupportedMethods[i];\n\t        VMLPainter.prototype[name] = createMethodNotSupport(name);\n\t    }\n\t\n\t    module.exports = VMLPainter;\n\n\n/***/ },\n/* 219 */\n/*!**************************************!*\\\n  !*** ./~/zrender/lib/vml/graphic.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// http://www.w3.org/TR/NOTE-VML\n\t// TODO Use proxy like svg instead of overwrite brush methods\n\t\n\t\n\tif (!__webpack_require__(/*! ../core/env */ 11).canvasSupported) {\n\t    var vec2 = __webpack_require__(/*! ../core/vector */ 5);\n\t    var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ 8);\n\t    var CMD = __webpack_require__(/*! ../core/PathProxy */ 28).CMD;\n\t    var colorTool = __webpack_require__(/*! ../tool/color */ 18);\n\t    var textContain = __webpack_require__(/*! ../contain/text */ 16);\n\t    var RectText = __webpack_require__(/*! ../graphic/mixin/RectText */ 75);\n\t    var Displayable = __webpack_require__(/*! ../graphic/Displayable */ 37);\n\t    var ZImage = __webpack_require__(/*! ../graphic/Image */ 48);\n\t    var Text = __webpack_require__(/*! ../graphic/Text */ 74);\n\t    var Path = __webpack_require__(/*! ../graphic/Path */ 6);\n\t\n\t    var Gradient = __webpack_require__(/*! ../graphic/Gradient */ 29);\n\t\n\t    var vmlCore = __webpack_require__(/*! ./core */ 170);\n\t\n\t    var round = Math.round;\n\t    var sqrt = Math.sqrt;\n\t    var abs = Math.abs;\n\t    var cos = Math.cos;\n\t    var sin = Math.sin;\n\t    var mathMax = Math.max;\n\t\n\t    var applyTransform = vec2.applyTransform;\n\t\n\t    var comma = ',';\n\t    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\t\n\t    var Z = 21600;\n\t    var Z2 = Z / 2;\n\t\n\t    var ZLEVEL_BASE = 100000;\n\t    var Z_BASE = 1000;\n\t\n\t    var initRootElStyle = function (el) {\n\t        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n\t        el.coordsize = Z + ','  + Z;\n\t        el.coordorigin = '0,0';\n\t    };\n\t\n\t    var encodeHtmlAttribute = function (s) {\n\t        return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n\t    };\n\t\n\t    var rgb2Str = function (r, g, b) {\n\t        return 'rgb(' + [r, g, b].join(',') + ')';\n\t    };\n\t\n\t    var append = function (parent, child) {\n\t        if (child && parent && child.parentNode !== parent) {\n\t            parent.appendChild(child);\n\t        }\n\t    };\n\t\n\t    var remove = function (parent, child) {\n\t        if (child && parent && child.parentNode === parent) {\n\t            parent.removeChild(child);\n\t        }\n\t    };\n\t\n\t    var getZIndex = function (zlevel, z, z2) {\n\t        // z  [0, 1000]\n\t        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n\t    };\n\t\n\t    var parsePercent = function (value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    };\n\t\n\t    /***************************************************\n\t     * PATH\n\t     **************************************************/\n\t\n\t    var setColorAndOpacity = function (el, color, opacity) {\n\t        var colorArr = colorTool.parse(color);\n\t        opacity = +opacity;\n\t        if (isNaN(opacity)) {\n\t            opacity = 1;\n\t        }\n\t        if (colorArr) {\n\t            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n\t            el.opacity = opacity * colorArr[3];\n\t        }\n\t    };\n\t\n\t    var getColorAndAlpha = function (color) {\n\t        var colorArr = colorTool.parse(color);\n\t        return [\n\t            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),\n\t            colorArr[3]\n\t        ];\n\t    };\n\t\n\t    var updateFillNode = function (el, style, zrEl) {\n\t        // TODO pattern\n\t        var fill = style.fill;\n\t        if (fill != null) {\n\t            // Modified from excanvas\n\t            if (fill instanceof Gradient) {\n\t                var gradientType;\n\t                var angle = 0;\n\t                var focus = [0, 0];\n\t                // additional offset\n\t                var shift = 0;\n\t                // scale factor for offset\n\t                var expansion = 1;\n\t                var rect = zrEl.getBoundingRect();\n\t                var rectWidth = rect.width;\n\t                var rectHeight = rect.height;\n\t                if (fill.type === 'linear') {\n\t                    gradientType = 'gradient';\n\t                    var transform = zrEl.transform;\n\t                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\t                    if (transform) {\n\t                        applyTransform(p0, p0, transform);\n\t                        applyTransform(p1, p1, transform);\n\t                    }\n\t                    var dx = p1[0] - p0[0];\n\t                    var dy = p1[1] - p0[1];\n\t                    angle = Math.atan2(dx, dy) * 180 / Math.PI;\n\t                    // The angle should be a non-negative number.\n\t                    if (angle < 0) {\n\t                        angle += 360;\n\t                    }\n\t\n\t                    // Very small angles produce an unexpected result because they are\n\t                    // converted to a scientific notation string.\n\t                    if (angle < 1e-6) {\n\t                        angle = 0;\n\t                    }\n\t                }\n\t                else {\n\t                    gradientType = 'gradientradial';\n\t                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t                    var transform = zrEl.transform;\n\t                    var scale = zrEl.scale;\n\t                    var width = rectWidth;\n\t                    var height = rectHeight;\n\t                    focus = [\n\t                        // Percent in bounding rect\n\t                        (p0[0] - rect.x) / width,\n\t                        (p0[1] - rect.y) / height\n\t                    ];\n\t                    if (transform) {\n\t                        applyTransform(p0, p0, transform);\n\t                    }\n\t\n\t                    width /= scale[0] * Z;\n\t                    height /= scale[1] * Z;\n\t                    var dimension = mathMax(width, height);\n\t                    shift = 2 * 0 / dimension;\n\t                    expansion = 2 * fill.r / dimension - shift;\n\t                }\n\t\n\t                // We need to sort the color stops in ascending order by offset,\n\t                // otherwise IE won't interpret it correctly.\n\t                var stops = fill.colorStops.slice();\n\t                stops.sort(function(cs1, cs2) {\n\t                    return cs1.offset - cs2.offset;\n\t                });\n\t\n\t                var length = stops.length;\n\t                // Color and alpha list of first and last stop\n\t                var colorAndAlphaList = [];\n\t                var colors = [];\n\t                for (var i = 0; i < length; i++) {\n\t                    var stop = stops[i];\n\t                    var colorAndAlpha = getColorAndAlpha(stop.color);\n\t                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\t                    if (i === 0 || i === length - 1) {\n\t                        colorAndAlphaList.push(colorAndAlpha);\n\t                    }\n\t                }\n\t\n\t                if (length >= 2) {\n\t                    var color1 = colorAndAlphaList[0][0];\n\t                    var color2 = colorAndAlphaList[1][0];\n\t                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n\t                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\t\n\t                    el.type = gradientType;\n\t                    el.method = 'none';\n\t                    el.focus = '100%';\n\t                    el.angle = angle;\n\t                    el.color = color1;\n\t                    el.color2 = color2;\n\t                    el.colors = colors.join(',');\n\t                    // When colors attribute is used, the meanings of opacity and o:opacity2\n\t                    // are reversed.\n\t                    el.opacity = opacity2;\n\t                    // FIXME g_o_:opacity ?\n\t                    el.opacity2 = opacity1;\n\t                }\n\t                if (gradientType === 'radial') {\n\t                    el.focusposition = focus.join(',');\n\t                }\n\t            }\n\t            else {\n\t                // FIXME Change from Gradient fill to color fill\n\t                setColorAndOpacity(el, fill, style.opacity);\n\t            }\n\t        }\n\t    };\n\t\n\t    var updateStrokeNode = function (el, style) {\n\t        // if (style.lineJoin != null) {\n\t        //     el.joinstyle = style.lineJoin;\n\t        // }\n\t        // if (style.miterLimit != null) {\n\t        //     el.miterlimit = style.miterLimit * Z;\n\t        // }\n\t        // if (style.lineCap != null) {\n\t        //     el.endcap = style.lineCap;\n\t        // }\n\t        if (style.lineDash != null) {\n\t            el.dashstyle = style.lineDash.join(' ');\n\t        }\n\t        if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n\t            setColorAndOpacity(el, style.stroke, style.opacity);\n\t        }\n\t    };\n\t\n\t    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n\t        var isFill = type == 'fill';\n\t        var el = vmlEl.getElementsByTagName(type)[0];\n\t        // Stroke must have lineWidth\n\t        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {\n\t            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';\n\t            // FIXME Remove before updating, or set `colors` will throw error\n\t            if (style[type] instanceof Gradient) {\n\t                remove(vmlEl, el);\n\t            }\n\t            if (!el) {\n\t                el = vmlCore.createNode(type);\n\t            }\n\t\n\t            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n\t            append(vmlEl, el);\n\t        }\n\t        else {\n\t            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n\t            remove(vmlEl, el);\n\t        }\n\t    };\n\t\n\t    var points = [[], [], []];\n\t    var pathDataToString = function (data, m) {\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        var str = [];\n\t        var nPoint;\n\t        var cmdStr;\n\t        var cmd;\n\t        var i;\n\t        var xi;\n\t        var yi;\n\t        for (i = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            cmdStr = '';\n\t            nPoint = 0;\n\t            switch (cmd) {\n\t                case M:\n\t                    cmdStr = ' m ';\n\t                    nPoint = 1;\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    points[0][0] = xi;\n\t                    points[0][1] = yi;\n\t                    break;\n\t                case L:\n\t                    cmdStr = ' l ';\n\t                    nPoint = 1;\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    points[0][0] = xi;\n\t                    points[0][1] = yi;\n\t                    break;\n\t                case Q:\n\t                case C:\n\t                    cmdStr = ' c ';\n\t                    nPoint = 3;\n\t                    var x1 = data[i++];\n\t                    var y1 = data[i++];\n\t                    var x2 = data[i++];\n\t                    var y2 = data[i++];\n\t                    var x3;\n\t                    var y3;\n\t                    if (cmd === Q) {\n\t                        // Convert quadratic to cubic using degree elevation\n\t                        x3 = x2;\n\t                        y3 = y2;\n\t                        x2 = (x2 + 2 * x1) / 3;\n\t                        y2 = (y2 + 2 * y1) / 3;\n\t                        x1 = (xi + 2 * x1) / 3;\n\t                        y1 = (yi + 2 * y1) / 3;\n\t                    }\n\t                    else {\n\t                        x3 = data[i++];\n\t                        y3 = data[i++];\n\t                    }\n\t                    points[0][0] = x1;\n\t                    points[0][1] = y1;\n\t                    points[1][0] = x2;\n\t                    points[1][1] = y2;\n\t                    points[2][0] = x3;\n\t                    points[2][1] = y3;\n\t\n\t                    xi = x3;\n\t                    yi = y3;\n\t                    break;\n\t                case A:\n\t                    var x = 0;\n\t                    var y = 0;\n\t                    var sx = 1;\n\t                    var sy = 1;\n\t                    var angle = 0;\n\t                    if (m) {\n\t                        // Extract SRT from matrix\n\t                        x = m[4];\n\t                        y = m[5];\n\t                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t                        angle = Math.atan2(-m[1] / sy, m[0] / sx);\n\t                    }\n\t\n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var startAngle = data[i++] + angle;\n\t                    var endAngle = data[i++] + startAngle + angle;\n\t                    // FIXME\n\t                    // var psi = data[i++];\n\t                    i++;\n\t                    var clockwise = data[i++];\n\t\n\t                    var x0 = cx + cos(startAngle) * rx;\n\t                    var y0 = cy + sin(startAngle) * ry;\n\t\n\t                    var x1 = cx + cos(endAngle) * rx;\n\t                    var y1 = cy + sin(endAngle) * ry;\n\t\n\t                    var type = clockwise ? ' wa ' : ' at ';\n\t                    if (Math.abs(x0 - x1) < 1e-10) {\n\t                        // IE won't render arches drawn counter clockwise if x0 == x1.\n\t                        if (Math.abs(endAngle - startAngle) > 1e-2) {\n\t                            // Offset x0 by 1/80 of a pixel. Use something\n\t                            // that can be represented in binary\n\t                            if (clockwise) {\n\t                                x0 += 270 / Z;\n\t                            }\n\t                        }\n\t                        else {\n\t                            // Avoid case draw full circle\n\t                            if (Math.abs(y0 - cy) < 1e-10) {\n\t                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {\n\t                                    y1 -= 270 / Z;\n\t                                }\n\t                                else {\n\t                                    y1 += 270 / Z;\n\t                                }\n\t                            }\n\t                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {\n\t                                x1 += 270 / Z;\n\t                            }\n\t                            else {\n\t                                x1 -= 270 / Z;\n\t                            }\n\t                        }\n\t                    }\n\t                    str.push(\n\t                        type,\n\t                        round(((cx - rx) * sx + x) * Z - Z2), comma,\n\t                        round(((cy - ry) * sy + y) * Z - Z2), comma,\n\t                        round(((cx + rx) * sx + x) * Z - Z2), comma,\n\t                        round(((cy + ry) * sy + y) * Z - Z2), comma,\n\t                        round((x0 * sx + x) * Z - Z2), comma,\n\t                        round((y0 * sy + y) * Z - Z2), comma,\n\t                        round((x1 * sx + x) * Z - Z2), comma,\n\t                        round((y1 * sy + y) * Z - Z2)\n\t                    );\n\t\n\t                    xi = x1;\n\t                    yi = y1;\n\t                    break;\n\t                case CMD.R:\n\t                    var p0 = points[0];\n\t                    var p1 = points[1];\n\t                    // x0, y0\n\t                    p0[0] = data[i++];\n\t                    p0[1] = data[i++];\n\t                    // x1, y1\n\t                    p1[0] = p0[0] + data[i++];\n\t                    p1[1] = p0[1] + data[i++];\n\t\n\t                    if (m) {\n\t                        applyTransform(p0, p0, m);\n\t                        applyTransform(p1, p1, m);\n\t                    }\n\t\n\t                    p0[0] = round(p0[0] * Z - Z2);\n\t                    p1[0] = round(p1[0] * Z - Z2);\n\t                    p0[1] = round(p0[1] * Z - Z2);\n\t                    p1[1] = round(p1[1] * Z - Z2);\n\t                    str.push(\n\t                        // x0, y0\n\t                        ' m ', p0[0], comma, p0[1],\n\t                        // x1, y0\n\t                        ' l ', p1[0], comma, p0[1],\n\t                        // x1, y1\n\t                        ' l ', p1[0], comma, p1[1],\n\t                        // x0, y1\n\t                        ' l ', p0[0], comma, p1[1]\n\t                    );\n\t                    break;\n\t                case CMD.Z:\n\t                    // FIXME Update xi, yi\n\t                    str.push(' x ');\n\t            }\n\t\n\t            if (nPoint > 0) {\n\t                str.push(cmdStr);\n\t                for (var k = 0; k < nPoint; k++) {\n\t                    var p = points[k];\n\t\n\t                    m && applyTransform(p, p, m);\n\t                    //  round \n\t                    str.push(\n\t                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),\n\t                        k < nPoint - 1 ? comma : ''\n\t                    );\n\t                }\n\t            }\n\t        }\n\t\n\t        return str.join('');\n\t    };\n\t\n\t    // Rewrite the original path method\n\t    Path.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t\n\t        var vmlEl = this._vmlEl;\n\t        if (!vmlEl) {\n\t            vmlEl = vmlCore.createNode('shape');\n\t            initRootElStyle(vmlEl);\n\t\n\t            this._vmlEl = vmlEl;\n\t        }\n\t\n\t        updateFillAndStroke(vmlEl, 'fill', style, this);\n\t        updateFillAndStroke(vmlEl, 'stroke', style, this);\n\t\n\t        var m = this.transform;\n\t        var needTransform = m != null;\n\t        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\t        if (strokeEl) {\n\t            var lineWidth = style.lineWidth;\n\t            // Get the line scale.\n\t            // Determinant of this.m_ means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            if (needTransform && !style.strokeNoScale) {\n\t                var det = m[0] * m[3] - m[1] * m[2];\n\t                lineWidth *= sqrt(abs(det));\n\t            }\n\t            strokeEl.weight = lineWidth + 'px';\n\t        }\n\t\n\t        var path = this.path;\n\t        if (this.__dirtyPath) {\n\t            path.beginPath();\n\t            this.buildPath(path, this.shape);\n\t            path.toStatic();\n\t            this.__dirtyPath = false;\n\t        }\n\t\n\t        vmlEl.path = pathDataToString(path.data, this.transform);\n\t\n\t        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Append to root\n\t        append(vmlRoot, vmlEl);\n\t\n\t        // Text\n\t        if (style.text != null) {\n\t            this.drawRectText(vmlRoot, this.getBoundingRect());\n\t        }\n\t        else {\n\t            this.removeRectText(vmlRoot);\n\t        }\n\t    };\n\t\n\t    Path.prototype.onRemove = function (vmlRoot) {\n\t        remove(vmlRoot, this._vmlEl);\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    Path.prototype.onAdd = function (vmlRoot) {\n\t        append(vmlRoot, this._vmlEl);\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t\n\t    /***************************************************\n\t     * IMAGE\n\t     **************************************************/\n\t    var isImage = function (img) {\n\t        // FIXME img instanceof Image  img IE8 \n\t        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';\n\t        // return img instanceof Image;\n\t    };\n\t\n\t    // Rewrite the original path method\n\t    ZImage.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t        var image = style.image;\n\t\n\t        // Image original width, height\n\t        var ow;\n\t        var oh;\n\t\n\t        if (isImage(image)) {\n\t            var src = image.src;\n\t            if (src === this._imageSrc) {\n\t                ow = this._imageWidth;\n\t                oh = this._imageHeight;\n\t            }\n\t            else {\n\t                var imageRuntimeStyle = image.runtimeStyle;\n\t                var oldRuntimeWidth = imageRuntimeStyle.width;\n\t                var oldRuntimeHeight = imageRuntimeStyle.height;\n\t                imageRuntimeStyle.width = 'auto';\n\t                imageRuntimeStyle.height = 'auto';\n\t\n\t                // get the original size\n\t                ow = image.width;\n\t                oh = image.height;\n\t\n\t                // and remove overides\n\t                imageRuntimeStyle.width = oldRuntimeWidth;\n\t                imageRuntimeStyle.height = oldRuntimeHeight;\n\t\n\t                // Caching image original width, height and src\n\t                this._imageSrc = src;\n\t                this._imageWidth = ow;\n\t                this._imageHeight = oh;\n\t            }\n\t            image = src;\n\t        }\n\t        else {\n\t            if (image === this._imageSrc) {\n\t                ow = this._imageWidth;\n\t                oh = this._imageHeight;\n\t            }\n\t        }\n\t        if (!image) {\n\t            return;\n\t        }\n\t\n\t        var x = style.x || 0;\n\t        var y = style.y || 0;\n\t\n\t        var dw = style.width;\n\t        var dh = style.height;\n\t\n\t        var sw = style.sWidth;\n\t        var sh = style.sHeight;\n\t        var sx = style.sx || 0;\n\t        var sy = style.sy || 0;\n\t\n\t        var hasCrop = sw && sh;\n\t\n\t        var vmlEl = this._vmlEl;\n\t        if (!vmlEl) {\n\t            // FIXME  group  left, top  0 \n\t            // vmlEl = vmlCore.createNode('group');\n\t            vmlEl = vmlCore.doc.createElement('div');\n\t            initRootElStyle(vmlEl);\n\t\n\t            this._vmlEl = vmlEl;\n\t        }\n\t\n\t        var vmlElStyle = vmlEl.style;\n\t        var hasRotation = false;\n\t        var m;\n\t        var scaleX = 1;\n\t        var scaleY = 1;\n\t        if (this.transform) {\n\t            m = this.transform;\n\t            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t\n\t            hasRotation = m[1] || m[2];\n\t        }\n\t        if (hasRotation) {\n\t            // If filters are necessary (rotation exists), create them\n\t            // filters are bog-slow, so only create them if abbsolutely necessary\n\t            // The following check doesn't account for skews (which don't exist\n\t            // in the canvas spec (yet) anyway.\n\t            // From excanvas\n\t            var p0 = [x, y];\n\t            var p1 = [x + dw, y];\n\t            var p2 = [x, y + dh];\n\t            var p3 = [x + dw, y + dh];\n\t            applyTransform(p0, p0, m);\n\t            applyTransform(p1, p1, m);\n\t            applyTransform(p2, p2, m);\n\t            applyTransform(p3, p3, m);\n\t\n\t            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n\t            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\t\n\t            var transformFilter = [];\n\t            transformFilter.push('M11=', m[0] / scaleX, comma,\n\t                        'M12=', m[2] / scaleY, comma,\n\t                        'M21=', m[1] / scaleX, comma,\n\t                        'M22=', m[3] / scaleY, comma,\n\t                        'Dx=', round(x * scaleX + m[4]), comma,\n\t                        'Dy=', round(y * scaleY + m[5]));\n\t\n\t            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';\n\t            // FIXME DXImageTransform  IE11 \n\t            vmlElStyle.filter = imageTransformPrefix + '.Matrix('\n\t                + transformFilter.join('') + ', SizingMethod=clip)';\n\t\n\t        }\n\t        else {\n\t            if (m) {\n\t                x = x * scaleX + m[4];\n\t                y = y * scaleY + m[5];\n\t            }\n\t            vmlElStyle.filter = '';\n\t            vmlElStyle.left = round(x) + 'px';\n\t            vmlElStyle.top = round(y) + 'px';\n\t        }\n\t\n\t        var imageEl = this._imageEl;\n\t        var cropEl = this._cropEl;\n\t\n\t        if (!imageEl) {\n\t            imageEl = vmlCore.doc.createElement('div');\n\t            this._imageEl = imageEl;\n\t        }\n\t        var imageELStyle = imageEl.style;\n\t        if (hasCrop) {\n\t            // Needs know image original width and height\n\t            if (! (ow && oh)) {\n\t                var tmpImage = new Image();\n\t                var self = this;\n\t                tmpImage.onload = function () {\n\t                    tmpImage.onload = null;\n\t                    ow = tmpImage.width;\n\t                    oh = tmpImage.height;\n\t                    // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\t                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t\n\t                    // Caching image original width, height and src\n\t                    self._imageWidth = ow;\n\t                    self._imageHeight = oh;\n\t                    self._imageSrc = image;\n\t                };\n\t                tmpImage.src = image;\n\t            }\n\t            else {\n\t                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t            }\n\t\n\t            if (! cropEl) {\n\t                cropEl = vmlCore.doc.createElement('div');\n\t                cropEl.style.overflow = 'hidden';\n\t                this._cropEl = cropEl;\n\t            }\n\t            var cropElStyle = cropEl.style;\n\t            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n\t            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n\t            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='\n\t                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';\n\t\n\t            if (! cropEl.parentNode) {\n\t                vmlEl.appendChild(cropEl);\n\t            }\n\t            if (imageEl.parentNode != cropEl) {\n\t                cropEl.appendChild(imageEl);\n\t            }\n\t        }\n\t        else {\n\t            imageELStyle.width = round(scaleX * dw) + 'px';\n\t            imageELStyle.height = round(scaleY * dh) + 'px';\n\t\n\t            vmlEl.appendChild(imageEl);\n\t\n\t            if (cropEl && cropEl.parentNode) {\n\t                vmlEl.removeChild(cropEl);\n\t                this._cropEl = null;\n\t            }\n\t        }\n\t\n\t        var filterStr = '';\n\t        var alpha = style.opacity;\n\t        if (alpha < 1) {\n\t            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n\t        }\n\t        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\t\n\t        imageELStyle.filter = filterStr;\n\t\n\t        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Append to root\n\t        append(vmlRoot, vmlEl);\n\t\n\t        // Text\n\t        if (style.text != null) {\n\t            this.drawRectText(vmlRoot, this.getBoundingRect());\n\t        }\n\t    };\n\t\n\t    ZImage.prototype.onRemove = function (vmlRoot) {\n\t        remove(vmlRoot, this._vmlEl);\n\t\n\t        this._vmlEl = null;\n\t        this._cropEl = null;\n\t        this._imageEl = null;\n\t\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    ZImage.prototype.onAdd = function (vmlRoot) {\n\t        append(vmlRoot, this._vmlEl);\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t\n\t\n\t    /***************************************************\n\t     * TEXT\n\t     **************************************************/\n\t\n\t    var DEFAULT_STYLE_NORMAL = 'normal';\n\t\n\t    var fontStyleCache = {};\n\t    var fontStyleCacheCount = 0;\n\t    var MAX_FONT_CACHE_SIZE = 100;\n\t    var fontEl = document.createElement('div');\n\t\n\t    var getFontStyle = function (fontString) {\n\t        var fontStyle = fontStyleCache[fontString];\n\t        if (!fontStyle) {\n\t            // Clear cache\n\t            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n\t                fontStyleCacheCount = 0;\n\t                fontStyleCache = {};\n\t            }\n\t\n\t            var style = fontEl.style;\n\t            var fontFamily;\n\t            try {\n\t                style.font = fontString;\n\t                fontFamily = style.fontFamily.split(',')[0];\n\t            }\n\t            catch (e) {\n\t            }\n\t\n\t            fontStyle = {\n\t                style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n\t                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n\t                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n\t                size: parseFloat(style.fontSize || 12) | 0,\n\t                family: fontFamily || 'Microsoft YaHei'\n\t            };\n\t\n\t            fontStyleCache[fontString] = fontStyle;\n\t            fontStyleCacheCount++;\n\t        }\n\t        return fontStyle;\n\t    };\n\t\n\t    var textMeasureEl;\n\t    // Overwrite measure text method\n\t    textContain.measureText = function (text, textFont) {\n\t        var doc = vmlCore.doc;\n\t        if (!textMeasureEl) {\n\t            textMeasureEl = doc.createElement('div');\n\t            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'\n\t                + 'padding:0;margin:0;border:none;white-space:pre;';\n\t            vmlCore.doc.body.appendChild(textMeasureEl);\n\t        }\n\t\n\t        try {\n\t            textMeasureEl.style.font = textFont;\n\t        } catch (ex) {\n\t            // Ignore failures to set to invalid font.\n\t        }\n\t        textMeasureEl.innerHTML = '';\n\t        // Don't use innerHTML or innerText because they allow markup/whitespace.\n\t        textMeasureEl.appendChild(doc.createTextNode(text));\n\t        return {\n\t            width: textMeasureEl.offsetWidth\n\t        };\n\t    };\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\t\n\t        var style = this.style;\n\t        var text = style.text;\n\t        // Convert to string\n\t        text != null && (text += '');\n\t        if (!text) {\n\t            return;\n\t        }\n\t\n\t        var x;\n\t        var y;\n\t        var align = style.textAlign;\n\t        var fontStyle = getFontStyle(style.textFont);\n\t        // FIXME encodeHtmlAttribute ?\n\t        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '\n\t            + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\t\n\t        var baseline = style.textBaseline;\n\t        var verticalAlign = style.textVerticalAlign;\n\t\n\t        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t\n\t        // Transform rect to view space\n\t        var m = this.transform;\n\t        // Ignore transform for text in other element\n\t        if (m && !fromTextEl) {\n\t            tmpRect.copy(rect);\n\t            tmpRect.applyTransform(m);\n\t            rect = tmpRect;\n\t        }\n\t\n\t        if (!fromTextEl) {\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t        }\n\t        else {\n\t            x = rect.x;\n\t            y = rect.y;\n\t        }\n\t        if (verticalAlign) {\n\t            switch (verticalAlign) {\n\t                case 'middle':\n\t                    y -= textRect.height / 2;\n\t                    break;\n\t                case 'bottom':\n\t                    y -= textRect.height;\n\t                    break;\n\t                // 'top'\n\t            }\n\t            // Ignore baseline\n\t            baseline = 'top';\n\t        }\n\t\n\t        var fontSize = fontStyle.size;\n\t        // 1.75 is an arbitrary number, as there is no info about the text baseline\n\t        switch (baseline) {\n\t            case 'hanging':\n\t            case 'top':\n\t                y += fontSize / 1.75;\n\t                break;\n\t            case 'middle':\n\t                break;\n\t            default:\n\t            // case null:\n\t            // case 'alphabetic':\n\t            // case 'ideographic':\n\t            // case 'bottom':\n\t                y -= fontSize / 2.25;\n\t                break;\n\t        }\n\t        switch (align) {\n\t            case 'left':\n\t                break;\n\t            case 'center':\n\t                x -= textRect.width / 2;\n\t                break;\n\t            case 'right':\n\t                x -= textRect.width;\n\t                break;\n\t            // case 'end':\n\t                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n\t                // break;\n\t            // case 'start':\n\t                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n\t                // break;\n\t            // default:\n\t            //     align = 'left';\n\t        }\n\t\n\t        var createNode = vmlCore.createNode;\n\t\n\t        var textVmlEl = this._textVmlEl;\n\t        var pathEl;\n\t        var textPathEl;\n\t        var skewEl;\n\t        if (!textVmlEl) {\n\t            textVmlEl = createNode('line');\n\t            pathEl = createNode('path');\n\t            textPathEl = createNode('textpath');\n\t            skewEl = createNode('skew');\n\t\n\t            // FIXME Why here is not cammel case\n\t            // Align 'center' seems wrong\n\t            textPathEl.style['v-text-align'] = 'left';\n\t\n\t            initRootElStyle(textVmlEl);\n\t\n\t            pathEl.textpathok = true;\n\t            textPathEl.on = true;\n\t\n\t            textVmlEl.from = '0 0';\n\t            textVmlEl.to = '1000 0.05';\n\t\n\t            append(textVmlEl, skewEl);\n\t            append(textVmlEl, pathEl);\n\t            append(textVmlEl, textPathEl);\n\t\n\t            this._textVmlEl = textVmlEl;\n\t        }\n\t        else {\n\t            //  appendChild \n\t            skewEl = textVmlEl.firstChild;\n\t            pathEl = skewEl.nextSibling;\n\t            textPathEl = pathEl.nextSibling;\n\t        }\n\t\n\t        var coords = [x, y];\n\t        var textVmlElStyle = textVmlEl.style;\n\t        // Ignore transform for text in other element\n\t        if (m && fromTextEl) {\n\t            applyTransform(coords, coords, m);\n\t\n\t            skewEl.on = true;\n\t\n\t            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +\n\t            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';\n\t\n\t            // Text position\n\t            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);\n\t            // Left top point as origin\n\t            skewEl.origin = '0 0';\n\t\n\t            textVmlElStyle.left = '0px';\n\t            textVmlElStyle.top = '0px';\n\t        }\n\t        else {\n\t            skewEl.on = false;\n\t            textVmlElStyle.left = round(x) + 'px';\n\t            textVmlElStyle.top = round(y) + 'px';\n\t        }\n\t\n\t        textPathEl.string = encodeHtmlAttribute(text);\n\t        // TODO\n\t        try {\n\t            textPathEl.style.font = font;\n\t        }\n\t        // Error font format\n\t        catch (e) {}\n\t\n\t        updateFillAndStroke(textVmlEl, 'fill', {\n\t            fill: fromTextEl ? style.fill : style.textFill,\n\t            opacity: style.opacity\n\t        }, this);\n\t        updateFillAndStroke(textVmlEl, 'stroke', {\n\t            stroke: fromTextEl ? style.stroke : style.textStroke,\n\t            opacity: style.opacity,\n\t            lineDash: style.lineDash\n\t        }, this);\n\t\n\t        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Attached to root\n\t        append(vmlRoot, textVmlEl);\n\t    };\n\t\n\t    var removeRectText = function (vmlRoot) {\n\t        remove(vmlRoot, this._textVmlEl);\n\t        this._textVmlEl = null;\n\t    };\n\t\n\t    var appendRectText = function (vmlRoot) {\n\t        append(vmlRoot, this._textVmlEl);\n\t    };\n\t\n\t    var list = [RectText, Displayable, ZImage, Path, Text];\n\t\n\t    // In case Displayable has been mixed in RectText\n\t    for (var i = 0; i < list.length; i++) {\n\t        var proto = list[i].prototype;\n\t        proto.drawRectText = drawRectText;\n\t        proto.removeRectText = removeRectText;\n\t        proto.appendRectText = appendRectText;\n\t    }\n\t\n\t    Text.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t        if (style.text != null) {\n\t            this.drawRectText(vmlRoot, {\n\t                x: style.x || 0, y: style.y || 0,\n\t                width: 0, height: 0\n\t            }, this.getBoundingRect(), true);\n\t        }\n\t        else {\n\t            this.removeRectText(vmlRoot);\n\t        }\n\t    };\n\t\n\t    Text.prototype.onRemove = function (vmlRoot) {\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    Text.prototype.onAdd = function (vmlRoot) {\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t}\n\n\n/***/ },\n/* 220 */\n/*!**********************************!*\\\n  !*** ./~/zrender/lib/vml/vml.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    __webpack_require__(/*! ./graphic */ 219);\n\t    __webpack_require__(/*! ../zrender */ 76).registerPainter('vml', __webpack_require__(/*! ./Painter */ 218));\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// echarts.common.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e2f5d11b7ea9dedb1522","/**\n * Export echarts as CommonJS module\n */\nmodule.exports = require('./lib/echarts');\n\nrequire('./lib/chart/line');\nrequire('./lib/chart/bar');\nrequire('./lib/chart/pie');\nrequire('./lib/chart/scatter');\nrequire('./lib/component/tooltip');\nrequire('./lib/component/legend');\n\nrequire('./lib/component/grid');\nrequire('./lib/component/title');\n\nrequire('./lib/component/markPoint');\nrequire('./lib/component/markLine');\nrequire('./lib/component/markArea');\nrequire('./lib/component/dataZoom');\nrequire('./lib/component/toolbox');\n\nrequire('zrender/lib/vml/vml');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.common.js\n// module id = 0\n// module chunks = 1","/**\n * @module zrender/core/util\n */\n\n\n    // mergeDate\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuildInObject(sourceProp)\n                    && !isBuildInObject(targetProp)\n                ) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuildInObject: isBuildInObject,\n        isDom: isDom,\n        retrieve: retrieve,\n        assert: assert,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/util.js\n// module id = 1\n// module chunks = 0 1 2","// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = require('zrender/lib/core/env');\n\n    var GlobalModel = require('./model/Global');\n    var ExtensionAPI = require('./ExtensionAPI');\n    var CoordinateSystemManager = require('./CoordinateSystem');\n    var OptionManager = require('./model/OptionManager');\n\n    var ComponentModel = require('./model/Component');\n    var SeriesModel = require('./model/Series');\n\n    var ComponentView = require('./view/Component');\n    var ChartView = require('./view/Chart');\n    var graphic = require('./util/graphic');\n    var modelUtil = require('./util/model');\n\n    var zrender = require('zrender');\n    var zrUtil = require('zrender/lib/core/util');\n    var colorTool = require('zrender/lib/tool/color');\n    var Eventful = require('zrender/lib/mixin/Eventful');\n    var timsort = require('zrender/lib/core/timsort');\n\n    var each = zrUtil.each;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flag_in_main_process';\n    var HAS_GRADIENT_OR_PATTERN_BG = '_hasGradientOrPatternBg';\n\n\n    var OPTION_UPDATED = '_optionUpdated';\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts (dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = new ExtensionAPI(this);\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        this._zr.animation.on('frame', this._onframe, this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * @param {Object} option\n     * @param {boolean} notMerge\n     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = true;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            this._zr.refreshImmediately();\n            this[OPTION_UPDATED] = false;\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        this._flushPendingActions();\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.time && console.time('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            // console.time && console.timeEnd('update');\n        },\n\n        // PENDING\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        highlight: function (payload) {\n            toggleHighlight.call(this, 'highlight', payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        downplay: function (payload) {\n            toggleHighlight.call(this, 'downplay', payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            updateMethods.update.call(this, payload);\n        }\n    };\n\n    /**\n     * @param {Object} payload\n     * @private\n     */\n    function toggleHighlight(method, payload) {\n        var ecModel = this._model;\n\n        // dispatchAction before setOption\n        if (!ecModel) {\n            return;\n        }\n\n        ecModel.eachComponent(\n            {mainType: 'series', query: payload},\n            function (seriesModel, index) {\n                var chartView = this._chartsMap[seriesModel.__viewId];\n                if (chartView && chartView.__alive) {\n                    chartView[method](\n                        seriesModel, ecModel, this._api, payload\n                    );\n                }\n            },\n            this\n        );\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        this._flushPendingActions();\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {boolean} [silent=false] Whether trigger event.\n     */\n    echartsProto.dispatchAction = function (payload, silent) {\n        var actionWrap = actions[payload.type];\n        if (!actionWrap) {\n            return;\n        }\n\n        var actionInfo = actionWrap.actionInfo;\n        var updateMethod = actionInfo.update || 'update';\n\n        // if (__DEV__) {\n        //     zrUtil.assert(\n        //         !this[IN_MAIN_PROCESS],\n        //         '`dispatchAction` should not be called during main process.'\n        //         + 'unless updateMathod is \"none\".'\n        //     );\n        // }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';\n        for (var i = 0; i < payloads.length; i++) {\n            var batchItem = payloads[i];\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // Highlight and downplay are special.\n            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);\n        }\n\n        if (updateMethod !== 'none' && !isHighlightOrDownplay) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payload.type,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n\n        this._flushPendingActions();\n\n    };\n\n    echartsProto._flushPendingActions = function () {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            this.dispatchAction(payload);\n        }\n    };\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = ComponentModel.parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = viewId;\n            view.__alive = true;\n            view.__id = viewId;\n            view.__model = model;\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                if (previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var actions = [];\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.3.1',\n        dependencies: {\n            zrender: '3.2.1'\n        }\n    };\n\n    function enableConnect(chart) {\n\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n\n    }\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        dom.setAttribute &&\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (zrUtil.isDom(chart)) {\n            chart = echarts.getInstanceByDom(chart);\n        }\n        else if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        return instances[key];\n    };\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n\n    var parseClassType = ComponentModel.parseClassType;\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts, superClass) {\n        var Clazz = ComponentModel;\n        if (superClass) {\n            var classType = parseClassType(superClass);\n            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts, superClass) {\n        var Clazz = ComponentView;\n        if (superClass) {\n            var classType = parseClassType(superClass);\n            Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts, superClass) {\n        var Clazz = SeriesModel;\n        if (superClass) {\n            superClass = 'series.' + superClass.replace('series.', '');\n            var classType = parseClassType(superClass);\n            Clazz = SeriesModel.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts, superClass) {\n        var Clazz = ChartView;\n        if (superClass) {\n            superClass.replace('series.', '');\n            var classType = parseClassType(superClass);\n            Clazz = ChartView.getClass(classType.main, true);\n        }\n        return Clazz.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n    echarts.registerLoading('default', require('./loading/default'));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n\n    // --------\n    // Exports\n    // --------\n    //\n    echarts.List = require('./data/List');\n    echarts.Model = require('./model/Model');\n\n    echarts.graphic = require('./util/graphic');\n    echarts.number = require('./util/number');\n    echarts.format = require('./util/format');\n    echarts.matrix = require('zrender/lib/core/matrix');\n    echarts.vector = require('zrender/lib/core/vector');\n    echarts.color = require('zrender/lib/tool/color');\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits',\n            'reduce', 'filter', 'bind', 'curry', 'isArray',\n            'isString', 'isObject', 'isFunction', 'extend', 'defaults'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/echarts.js\n// module id = 2\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var pathTool = require('zrender/lib/tool/path');\n    var round = Math.round;\n    var Path = require('zrender/lib/graphic/Path');\n    var colorTool = require('zrender/lib/tool/color');\n    var matrix = require('zrender/lib/core/matrix');\n    var vector = require('zrender/lib/core/vector');\n    var Gradient = require('zrender/lib/graphic/Gradient');\n\n    var graphic = {};\n\n    graphic.Group = require('zrender/lib/container/Group');\n\n    graphic.Image = require('zrender/lib/graphic/Image');\n\n    graphic.Text = require('zrender/lib/graphic/Text');\n\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\n\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\n\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\n\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\n\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\n\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\n\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\n\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\n\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\n\n    graphic.CompoundPath = require('zrender/lib/graphic/CompoundPath');\n\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\n\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\n\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            this.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver() {\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut() {\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     */\n    graphic.setHoverStyle = function (el, hoverStyle) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n        // Remove previous bound handlers\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        var animationEnabled = animatableModel\n            && (\n                animatableModel.ifEnableAnimation\n                ? animatableModel.ifEnableAnimation()\n                // Directly use animation property\n                : animatableModel.getShallow('animation')\n            );\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel\n                && animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel\n                && animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel\n                && animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(dataIndex);\n            }\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n                : (el.attr(props), cb && cb());\n        }\n        else {\n            el.attr(props);\n            cb && cb();\n        }\n    }\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} vertex [x, y]\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (vertex, transform, invert) {\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], vertex, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    module.exports = graphic;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/graphic.js\n// module id = 3\n// module chunks = 0 1 2","/**\n * \n * @module echarts/util/number\n */\n\n\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * Fix rounding error of float numbers\n     * @param {number} x\n     * @return {number}\n     */\n    number.round = function (x, precision) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        return +(+x).toFixed(precision);\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n        var dotIndex = str.indexOf('.');\n        if (dotIndex < 0) {\n            return 0;\n        }\n        return str.length - 1 - dotIndex;\n    };\n\n    /**\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number}  precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        return Math.max(\n            -dataQuantity + sizeQuantity,\n            0\n        );\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    /**\n     * @param {string|Date|number} value\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Treat as ISO format. See issue #3623\n            var ret = new Date(value);\n            if (isNaN(+ret)) {\n                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n            }\n            return ret;\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n    };\n\n    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n    /**\n     * find a nice number approximately equal to x. Round the number if round = true, take ceiling if round = false\n     * The primary observation is that the nicest numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     * @param  {number} val\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exp10 = number.quantity(val);\n        var f = val / exp10; // between 1 and 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        return nf * exp10;\n    };\n\n    module.exports = number;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/number.js\n// module id = 4\n// module chunks = 0 1 2","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * \n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} \n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/vector.js\n// module id = 5\n// module chunks = 0 1 2","/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || (\n                lineDash && !ctxLineDash && hasStroke\n            )) {\n                path = this.path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Path.js\n// module id = 6\n// module chunks = 0 1 2","\n\n    var formatUtil = require('./format');\n    var nubmerUtil = require('./number');\n    var Model = require('../model/Model');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            zrUtil.each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n\n    modelUtil.LABEL_OPTIONS = ['position', 'show', 'textStyle', 'distance', 'formatter'];\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return zrUtil.isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && zrUtil.isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n\n            var seriesIndex = this.seriesIndex;\n            var seriesName = this.name;\n\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: seriesIndex,\n                seriesName: seriesName,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: data.getItemVisual(dataIndex, 'color'),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get(['label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (zrUtil.isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        zrUtil.each(newCptOptions, function (cptOption, index) {\n            if (!zrUtil.isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        zrUtil.each(newCptOptions, function (cptOption, index) {\n            if (!zrUtil.isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return zrUtil.isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, goeName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        zrUtil.each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = parsedKey[2];\n\n            if (!mainType || !queryType) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            queryParam[queryType.toLowerCase()] = value;\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/model.js\n// module id = 7\n// module chunks = 0 1 2","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // \n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/BoundingRect.js\n// module id = 8\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('./number');\n    var textContain = require('zrender/lib/contain/text');\n\n    var formatUtil = {};\n    /**\n     * ,\n     * @type {string|number} x\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str) {\n        return str.toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n    };\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        else if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    };\n\n    formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param  {string} tpl\n     * @param  {Array.<Object>|Object} paramsList\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            tpl = tpl.replace(wrapVar(alias),  wrapVar(alias, 0));\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    paramsList[seriesIdx][$vars[k]]\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var y = date.getFullYear();\n        var M = date.getMonth() + 1;\n        var d = date.getDate();\n        var h = date.getHours();\n        var m = date.getMinutes();\n        var s = date.getSeconds();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .toLowerCase()\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    module.exports = formatUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/format.js\n// module id = 9\n// module chunks = 0 1 2","/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazzUtil = require('../util/clazz');\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model \n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         *  Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (!path) {\n                return this.option;\n            }\n\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n\n            var obj = this.option;\n            var parentModel = this.parentModel;\n            for (var i = 0; i < path.length; i++) {\n                // Ignore empty\n                if (!path[i]) {\n                    continue;\n                }\n                // obj could be number/string/... (like 0)\n                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\n                if (obj == null) {\n                    break;\n                }\n            }\n            if (obj == null && parentModel && !ignoreParent) {\n                obj = parentModel.get(path);\n            }\n            return obj;\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = this.parentModel;\n            if (val == null && parentModel && !ignoreParent) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string} path\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = this.get(path, true);\n            var thisParentModel = this.parentModel;\n            var model = new Model(\n                obj, parentModel || (thisParentModel && thisParentModel.getModel(path)),\n                this.ecModel\n            );\n            return model;\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        }\n    };\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, require('./mixin/lineStyle'));\n    mixin(Model, require('./mixin/areaStyle'));\n    mixin(Model, require('./mixin/textStyle'));\n    mixin(Model, require('./mixin/itemStyle'));\n\n    module.exports = Model;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/Model.js\n// module id = 10\n// module chunks = 0 1 2","/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // canvas\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default,\n                // only MS browsers are reliable on pointer events currently.\n                && (browser.edge || (browser.ie && browser.version >= 10))\n        };\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/env.js\n// module id = 11\n// module chunks = 0 1 2","/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = require('./Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var arrayPush = Array.prototype.push;\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var layout = require('../util/layout');\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!this.hasOwnProperty('__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                this.__defaultOption = defaultOption;\n            }\n            return this.__defaultOption;\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n\n    module.exports = ComponentModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/Component.js\n// module id = 12\n// module chunks = 0 1 2","'use strict';\n// Layout helpers for each component positioning\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n    var numberUtil = require('./number');\n    var formatUtil = require('./format');\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n    /**\n     * Position group of component in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     */\n    layout.positionGroup = function (\n        group, positionInfo, containerRect, margin\n    ) {\n        var groupRect = group.getBoundingRect();\n\n        positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {\n            width: groupRect.width,\n            height: groupRect.height\n        });\n\n        positionInfo = layout.getLayoutRect(\n            positionInfo, containerRect, margin\n        );\n\n        group.attr('position', [\n            positionInfo.x - groupRect.x,\n            positionInfo.y - groupRect.y\n        ]);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n        var hNames = ['width', 'left', 'right']; // Order by priority.\n        var vNames = ['height', 'top', 'bottom']; // Order by priority.\n        var hResult = merge(hNames);\n        var vResult = merge(vNames);\n\n        copy(hNames, targetOption, hResult);\n        copy(vNames, targetOption, vResult);\n\n        function merge(names) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/layout.js\n// module id = 13\n// module chunks = 0 1 2","/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = require('../model/Model');\n    var DataDiffer = require('./DataDiffer');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    var transferProperties = function (a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string>} dimensions\n     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n            }\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var size = data.length;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var idList = [];\n        var nameRepeatCount = {};\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var idx = 0; idx < data.length; idx++) {\n            var dataItem = data[idx];\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n            }\n\n            indices.push(idx);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < data.length; i++) {\n            if (!nameList[i]) {\n                if (data[i] && data[i].name != null) {\n                    nameList[i] = data[i].name;\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = data[i] && data[i].id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null) {\n            return NaN;\n        }\n\n        var value = storage[dim] && storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getDataExtent = function (dim, stack) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                value < min && (min = value);\n                value > max && (max = value);\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {number}\n     */\n    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var nearestIdx = -1;\n        if (dimData) {\n            var minDist = Number.MAX_VALUE;\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var diff = value - this.get(dim, i, stack);\n                var dist = Math.abs(diff);\n                if (\n                    diff <= maxDistance\n                    && (dist < minDist\n                        // For the case of two data are same on xAxis, which has sequence data.\n                        // Show the nearest index\n                        // https://github.com/ecomfe/echarts/issues/2869\n                        || (dist === minDist && diff > 0)\n                    )\n                ) {\n                    minDist = dist;\n                    nearestIdx = i;\n                }\n            }\n        }\n        return nearestIdx;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData[this.getRawIndex(idx)];\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        return new DataDiffer(\n            otherList ? otherList.indices : [], this.indices, function (idx) {\n                return otherIdList[idx] || (idx + '');\n            }, function (idx) {\n                return idList[idx] || (idx + '');\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} ignoreParent\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/data/List.js\n// module id = 14\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../util/format');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var colorPaletteMixin = require('./mixin/colorPalette');\n    var env = require('zrender/lib/core/env');\n\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n\n            // If we reverse the order (make this._data firstly, and then make\n            // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause this._data.graph.data !== this._data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this._data = this._dataBeforeProcessed.cloneShallow();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                this._data = data;\n                this._dataBeforeProcessed = data.cloneShallow();\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            return dataType == null ? this._data : this._data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            this._data = data;\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return this._dataBeforeProcessed;\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return [coordDim];\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return dataDim;\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var result = [];\n\n                zrUtil.each(value, function (val, idx) {\n                    var dimInfo = data.getDimensionInfo(idx);\n                    var dimType = dimInfo && dimInfo.type;\n                    var valStr;\n\n                    if (dimType === 'ordinal') {\n                        valStr = val + '';\n                    }\n                    else if (dimType === 'time') {\n                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/mm/dd hh:mm:ss', val);\n                    }\n                    else {\n                        valStr = addCommas(val);\n                    }\n\n                    valStr && result.push(valStr);\n                });\n\n                return result.join(', ');\n            }\n\n            var data = this._data;\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? formatArrayValue(value) : addCommas(value);\n            var name = data.getName(dataIndex);\n            var color = data.getItemVisual(dataIndex, 'color');\n            var colorEl = '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            return !multipleSeries\n                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl\n                    + (name\n                        ? encodeHTML(name) + ' : ' + formattedValue\n                        : formattedValue)\n                  )\n                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);\n        },\n\n        /**\n         * @return {boolean}\n         */\n        ifEnableAnimation: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            this._data = this._dataBeforeProcessed.cloneShallow();\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Array.<number>} data indices.\n         */\n        getAxisTooltipDataIndex: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/Series.js\n// module id = 15\n// module chunks = 0 1 2","\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText  Canvas \n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME \n        var lineHeight = getTextWidth('', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var halfHeight = height / 2 - textHeight / 2;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/text.js\n// module id = 16\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/curve.js\n// module id = 17\n// module chunks = 0 1 2","/**\n * @module zrender/tool/color\n */\n\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();  // dup.\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                ];\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                ];\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return [\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    ];\n                case 'hsla':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    return hsla2rgba(params);\n                case 'hsl':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return hsla2rgba(params);\n                default:\n                    return;\n            }\n        }\n\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        var rgba = [\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n        ];\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n        out = out || [0, 0, 0, 0];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/color.js\n// module id = 18\n// module chunks = 0 1 2","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * \n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/matrix.js\n// module id = 19\n// module chunks = 0 1 2","/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * trigger\n         *\n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} [handler] \n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * \n         *\n         * @param {string} type \n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * context, context\n         * @param {string} type \n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Eventful.js\n// module id = 20\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    /**\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\n            var Clazz = storage[componentTypeMain];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/clazz.js\n// module id = 21\n// module chunks = 0 1 2","\n\n    var OrdinalScale = require('../scale/Ordinal');\n    var IntervalScale = require('../scale/Interval');\n    require('../scale/Time');\n    require('../scale/Log');\n    var Scale = require('../scale/Scale');\n\n    var numberUtil = require('../util/number');\n    var zrUtil = require('zrender/lib/core/util');\n    var textContain = require('zrender/lib/contain/text');\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     */\n    axisHelper.getScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var originalExtent = scale.getExtent();\n        var span = originalExtent[1] - originalExtent[0];\n        if (scale.type === 'ordinal') {\n            // If series has no data, scale extent may be wrong\n            if (!isFinite(span)) {\n                return [0, 0];\n            }\n            else {\n                return originalExtent;\n            }\n        }\n        var min = model.getMin ? model.getMin() : model.get('min');\n        var max = model.getMax ? model.getMax() : model.get('max');\n        var crossZero = model.getNeedCrossZero\n            ? model.getNeedCrossZero() : !model.get('scale');\n        var boundaryGap = model.get('boundaryGap');\n        if (!zrUtil.isArray(boundaryGap)) {\n            boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n        }\n        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n        var fixMin = true;\n        var fixMax = true;\n        // Add boundary gap\n        if (min == null) {\n            min = originalExtent[0] - boundaryGap[0] * span;\n            fixMin = false;\n        }\n        if (max == null) {\n            max = originalExtent[1] + boundaryGap[1] * span;\n            fixMax = false;\n        }\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n        // Evaluate if axis needs cross zero\n        if (crossZero) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var extent = axisHelper.getScaleExtent(axis, model);\n        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;\n        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent(splitNumber, fixMin, fixMax);\n\n        // Use minInterval to constraint the calculated interval.\n        // If calculated interval is less than minInterval. increase the interval quantity until\n        // it is larger than minInterval.\n        // For example:\n        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n        //  an integer axis.\n        var minInterval = model.get('minInterval');\n        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n            var interval = scale.getInterval();\n            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n            // while (interval < minInterval) {\n            //     var quantity = numberUtil.quantity(interval);\n            //     interval = quantity * 10;\n            //     scaleQuantity *= 10;\n            // }\n            extent = scale.getExtent();\n            var origin = (extent[1] + extent[0]) / 2;\n            scale.setExtent(\n                intervalScale * (extent[0] - origin) + origin,\n                intervalScale * (extent[1] - origin) + origin\n            );\n            scale.niceExtent(splitNumber);\n        }\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // axislabelhorizontalvertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val);\n                };\n            })(labelFormatter);\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axis.type === 'category' ? scale.getLabel(tick) : tick,\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    module.exports = axisHelper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/axisHelper.js\n// module id = 22\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * Interface of Coordinate System Class\n     *\n     * create:\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {module:echarts/ExtensionAPI} api\n     *     @return {Object} coordinate system instance\n     *\n     * update:\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {module:echarts/ExtensionAPI} api\n     *\n     * convertToPixel:\n     * convertFromPixel:\n     *     These two methods is also responsible for determine whether this\n     *     coodinate system is applicable to the given `finder`.\n     *     Each coordinate system will be tried, util one returns none\n     *     null/undefined value.\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {Object} finder\n     *     @param {Array|number} value\n     *     @return {Array|number} convert result.\n     *\n     * containPoint:\n     *     @param {Array.<number>} point In pixel coordinate system.\n     *     @return {boolean}\n     */\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/CoordinateSystem.js\n// module id = 23\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n    var env = require('./env');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * domtouch.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // \n        Dispatcher: Eventful\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/event.js\n// module id = 24\n// module chunks = 0 1 2","'use strict';\n\n\n    var features = {};\n\n    module.exports = {\n        register: function (name, ctor) {\n            features[name] = ctor;\n        },\n\n        get: function (name) {\n            return features[name];\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/toolbox/featureManager.js\n// module id = 25\n// module chunks = 0 1","'use strict';\n// Symbol factory\n\n\n    var graphic = require('./graphic');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME  onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/symbol.js\n// module id = 26\n// module chunks = 0 1 2","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/view/Chart.js\n// module id = 27\n// module chunks = 0 1 2","'use strict';\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n\n        this._len = 0;\n\n        this._ctx = null;\n\n        this._xi = 0;\n        this._yi = 0;\n\n        this._x0 = 0;\n        this._y0 = 0;\n\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            this._len = 0;\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._xi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context  rebuildPath  fill\n         * stroke \n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         *  Path \n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * \n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         *  Path \n         * \n         */\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         *  Float32Array \n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo  subpath, \n                        //  closePath \n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc \n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc \n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/PathProxy.js\n// module id = 28\n// module chunks = 0 1 2","\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Gradient.js\n// module id = 29\n// module chunks = 0 1 2","/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * Complete the dimensions array guessed from the data structure.\n     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n     * @return {Array.<string>}\n     */\n    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n        if (!data) {\n            return dimensions;\n        }\n\n        var value0 = retrieveValue(data[0]);\n        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\n        defaultNames = defaultNames || [];\n        extraPrefix = extraPrefix || 'extra';\n        for (var i = 0; i < dimSize; i++) {\n            if (!dimensions[i]) {\n                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));\n                dimensions[i] = guessOrdinal(data, i)\n                    ? {type: 'ordinal', name: name}\n                    : name;\n            }\n        }\n\n        return dimensions;\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (zrUtil.isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/data/helper/completeDimensions.js\n// module id = 30\n// module chunks = 0 1 2","// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/mixin/makeStyleMapper.js\n// module id = 31\n// module chunks = 0 1 2","/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = require('../util/clazz');\n\n    function Scale() {\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/scale/Scale.js\n// module id = 32\n// module chunks = 0 1 2","\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debugcatchBrushExceptiontrue\n         * 0 : debug\n         * 1 : \n         * 2 : \n         */\n        debugMode: 0,\n\n        // retina \n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/config.js\n// module id = 33\n// module chunks = 0 1 2","/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * \n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         *  index \n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * \n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         *  nextSibling \n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToMap(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromMap(child.id);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * \n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/container/Group.js\n// module id = 34\n// module chunks = 0 1 2","'use strict';\n\n\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var CoordinateSystem = require('../../CoordinateSystem');\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && registeredCoordSys.dimensions) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n        }\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            completeDimensions(dimensions, data, ['x', 'y', 'z']);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            completeDimensions(dimensions, data, ['radius', 'angle', 'value']);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel) {\n            // TODO Region\n            // \n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, ['lng', 'lat', 'value'])\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/helper/createListFromArray.js\n// module id = 35\n// module chunks = 0 1 2","'use strict';\n\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('../coord/cartesian/Grid');\n\n    require('./axis');\n\n    // Grid view\n    echarts.extendComponentView({\n\n        type: 'grid',\n\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({\n                        fill: gridModel.get('backgroundColor')\n                    }, gridModel.getItemStyle()),\n                    silent: true,\n                    z2: -1\n                }));\n            }\n        }\n\n    });\n\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/grid.js\n// module id = 36\n// module chunks = 0 1 2","/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable Painter \n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * true\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * zlevelcanvas\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * \n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * \n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         *  x, y \n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         *  x, y \n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * \n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * \n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO,  bind \n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Displayable.js\n// module id = 37\n// module chunks = 0 1 2","/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var Scale = require('./Scale');\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            var interval = this._interval;\n            var extent = this._extent;\n            var ticks = [];\n\n            // Consider this case: using dataZoom toolbox, zoom and zoom.\n            var safeLimit = 10000;\n\n            if (interval) {\n                var niceExtent = this._niceExtent;\n                var precision = getPrecisionSafe(interval) + 2;\n\n                if (extent[0] < niceExtent[0]) {\n                    ticks.push(extent[0]);\n                }\n                var tick = niceExtent[0];\n\n                while (tick <= niceExtent[1]) {\n                    ticks.push(tick);\n                    // Avoid rounding error\n                    tick = roundingErrorFix(tick + interval, precision);\n                    if (ticks.length > safeLimit) {\n                        return [];\n                    }\n                }\n                // Consider this case: the last item of ticks is smaller\n                // than niceExtent[1] and niceExtent[1] === extent[1].\n                if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceExtent[1])) {\n                    ticks.push(extent[1]);\n                }\n            }\n\n            return ticks;\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} n\n         * @return {number}\n         */\n        getLabel: function (data) {\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         */\n        niceTicks: function (splitNumber) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n            // var niceSpan = numberUtil.nice(span, false);\n            var step = roundingErrorFix(\n                numberUtil.nice(span / splitNumber, true),\n                Math.max(\n                    getPrecisionSafe(extent[0]),\n                    getPrecisionSafe(extent[1])\n                // extent may be [0, 1], and step should have 1 more digits.\n                // To make it safe we add 2 more digits\n                ) + 2\n            );\n\n            var precision = getPrecisionSafe(step) + 2;\n            // Niced extent inside original extent\n            var niceExtent = [\n                roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n                roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n            ];\n\n            this._interval = step;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [splitNumber = 5] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(splitNumber);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/scale/Interval.js\n// module id = 38\n// module chunks = 0 1 2","/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n\n    var graphic = require('../../util/graphic');\n    var Symbol = require('./Symbol');\n\n    /**\n     * @constructor\n     * @alias module:echarts/chart/helper/SymbolDraw\n     * @param {module:zrender/graphic/Group} [symbolCtor]\n     */\n    function SymbolDraw(symbolCtor) {\n        this.group = new graphic.Group();\n\n        this._symbolCtor = symbolCtor || Symbol;\n    }\n\n    var symbolDrawProto = SymbolDraw.prototype;\n\n    function symbolNeedsDraw(data, idx, isIgnore) {\n        var point = data.getItemLayout(idx);\n        // Is an object\n        // if (point && point.hasOwnProperty('point')) {\n        //     point = point.point;\n        // }\n        return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx))\n                    && data.getItemVisual(idx, 'symbol') !== 'none';\n    }\n    /**\n     * Update symbols draw by new data\n     * @param {module:echarts/data/List} data\n     * @param {Array.<boolean>} [isIgnore]\n     */\n    symbolDrawProto.updateData = function (data, isIgnore) {\n        var group = this.group;\n        var seriesModel = data.hostModel;\n        var oldData = this._data;\n\n        var SymbolCtor = this._symbolCtor;\n\n        var seriesScope = {\n            itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n            hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n            symbolRotate: seriesModel.get('symbolRotate'),\n            symbolOffset: seriesModel.get('symbolOffset'),\n            hoverAnimation: seriesModel.get('hoverAnimation'),\n\n            labelModel: seriesModel.getModel('label.normal'),\n            hoverLabelModel: seriesModel.getModel('label.emphasis')\n        };\n\n        data.diff(oldData)\n            .add(function (newIdx) {\n                var point = data.getItemLayout(newIdx);\n                if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n                    symbolEl.attr('position', point);\n                    data.setItemGraphicEl(newIdx, symbolEl);\n                    group.add(symbolEl);\n                }\n            })\n            .update(function (newIdx, oldIdx) {\n                var symbolEl = oldData.getItemGraphicEl(oldIdx);\n                var point = data.getItemLayout(newIdx);\n                if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    group.remove(symbolEl);\n                    return;\n                }\n                if (!symbolEl) {\n                    symbolEl = new SymbolCtor(data, newIdx);\n                    symbolEl.attr('position', point);\n                }\n                else {\n                    symbolEl.updateData(data, newIdx, seriesScope);\n                    graphic.updateProps(symbolEl, {\n                        position: point\n                    }, seriesModel);\n                }\n\n                // Add back\n                group.add(symbolEl);\n\n                data.setItemGraphicEl(newIdx, symbolEl);\n            })\n            .remove(function (oldIdx) {\n                var el = oldData.getItemGraphicEl(oldIdx);\n                el && el.fadeOut(function () {\n                    group.remove(el);\n                });\n            })\n            .execute();\n\n        this._data = data;\n    };\n\n    symbolDrawProto.updateLayout = function () {\n        var data = this._data;\n        if (data) {\n            // Not use animation\n            data.eachItemGraphicEl(function (el, idx) {\n                var point = data.getItemLayout(idx);\n                el.attr('position', point);\n            });\n        }\n    };\n\n    symbolDrawProto.remove = function (enableAnimation) {\n        var group = this.group;\n        var data = this._data;\n        if (data) {\n            if (enableAnimation) {\n                data.eachItemGraphicEl(function (el) {\n                    el.fadeOut(function () {\n                        group.remove(el);\n                    });\n                });\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    };\n\n    module.exports = SymbolDraw;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/helper/SymbolDraw.js\n// module id = 39\n// module chunks = 0 1 2","/**\n * @file Data zoom model\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var env = require('zrender/lib/core/env');\n    var echarts = require('../../echarts');\n    var modelUtil = require('../../util/model');\n    var helper = require('./helper');\n    var AxisProxy = require('./AxisProxy');\n    var each = zrUtil.each;\n    var eachAxisDim = helper.eachAxisDim;\n\n    var DataZoomModel = echarts.extendComponentModel({\n\n        type: 'dataZoom',\n\n        dependencies: [\n            'xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'series'\n        ],\n\n        /**\n         * @protected\n         */\n        defaultOption: {\n            zlevel: 0,\n            z: 4,                   // Higher than normal component (z: 2).\n            orient: null,           // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n            xAxisIndex: null,       // Default the first horizontal category axis.\n            yAxisIndex: null,       // Default the first vertical category axis.\n\n            filterMode: 'filter',   // Possible values: 'filter' or 'empty'.\n                                    // 'filter': data items which are out of window will be removed.\n                                    //           This option is applicable when filtering outliers.\n                                    // 'empty': data items which are out of window will be set to empty.\n                                    //          This option is applicable when user should not neglect\n                                    //          that there are some data items out of window.\n                                    // Taking line chart as an example, line will be broken in\n                                    // the filtered points when filterModel is set to 'empty', but\n                                    // be connected when set to 'filter'.\n\n            throttle: null,         // Dispatch action by the fixed rate, avoid frequency.\n                                    // default 100. Do not throttle when use null/undefined.\n                                    // If animation === true and animationDurationUpdate > 0,\n                                    // default value is 100, otherwise 20.\n            start: 0,               // Start percent. 0 ~ 100\n            end: 100,               // End percent. 0 ~ 100\n            startValue: null,       // Start value. If startValue specified, start is ignored.\n            endValue: null          // End value. If endValue specified, end is ignored.\n        },\n\n        /**\n         * @override\n         */\n        init: function (option, parentModel, ecModel) {\n\n            /**\n             * key like x_0, y_1\n             * @private\n             * @type {Object}\n             */\n            this._dataIntervalByAxis = {};\n\n            /**\n             * @private\n             */\n            this._dataInfo = {};\n\n            /**\n             * key like x_0, y_1\n             * @private\n             */\n            this._axisProxies = {};\n\n            /**\n             * @readOnly\n             */\n            this.textStyleModel;\n\n            /**\n             * @private\n             */\n            this._autoThrottle = true;\n\n            var rawOption = retrieveRaw(option);\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            this.doInit(rawOption);\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function (newOption) {\n            var rawOption = retrieveRaw(newOption);\n\n            //FIX #2591\n            zrUtil.merge(this.option, newOption, true);\n\n            this.doInit(rawOption);\n        },\n\n        /**\n         * @protected\n         */\n        doInit: function (rawOption) {\n            var thisOption = this.option;\n\n            // Disable realtime view update if canvas is not supported.\n            if (!env.canvasSupported) {\n                thisOption.realtime = false;\n            }\n\n            this._setDefaultThrottle(rawOption);\n\n            processRangeProp('start', 'startValue', rawOption, thisOption);\n            processRangeProp('end', 'endValue', rawOption, thisOption);\n\n            this.textStyleModel = this.getModel('textStyle');\n\n            this._resetTarget();\n\n            this._giveAxisProxies();\n        },\n\n        /**\n         * @private\n         */\n        _giveAxisProxies: function () {\n            var axisProxies = this._axisProxies;\n\n            this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n                var axisModel = this.dependentModels[dimNames.axis][axisIndex];\n\n                // If exists, share axisProxy with other dataZoomModels.\n                var axisProxy = axisModel.__dzAxisProxy || (\n                    // Use the first dataZoomModel as the main model of axisProxy.\n                    axisModel.__dzAxisProxy = new AxisProxy(\n                        dimNames.name, axisIndex, this, ecModel\n                    )\n                );\n                // FIXME\n                // dispose __dzAxisProxy\n\n                axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n            }, this);\n        },\n\n        /**\n         * @private\n         */\n        _resetTarget: function () {\n            var thisOption = this.option;\n\n            var autoMode = this._judgeAutoMode();\n\n            eachAxisDim(function (dimNames) {\n                var axisIndexName = dimNames.axisIndex;\n                thisOption[axisIndexName] = modelUtil.normalizeToArray(\n                    thisOption[axisIndexName]\n                );\n            }, this);\n\n            if (autoMode === 'axisIndex') {\n                this._autoSetAxisIndex();\n            }\n            else if (autoMode === 'orient') {\n                this._autoSetOrient();\n            }\n        },\n\n        /**\n         * @private\n         */\n        _judgeAutoMode: function () {\n            // Auto set only works for setOption at the first time.\n            // The following is user's reponsibility. So using merged\n            // option is OK.\n            var thisOption = this.option;\n\n            var hasIndexSpecified = false;\n            eachAxisDim(function (dimNames) {\n                // When user set axisIndex as a empty array, we think that user specify axisIndex\n                // but do not want use auto mode. Because empty array may be encountered when\n                // some error occured.\n                if (thisOption[dimNames.axisIndex] != null) {\n                    hasIndexSpecified = true;\n                }\n            }, this);\n\n            var orient = thisOption.orient;\n\n            if (orient == null && hasIndexSpecified) {\n                return 'orient';\n            }\n            else if (!hasIndexSpecified) {\n                if (orient == null) {\n                    thisOption.orient = 'horizontal';\n                }\n                return 'axisIndex';\n            }\n        },\n\n        /**\n         * @private\n         */\n        _autoSetAxisIndex: function () {\n            var autoAxisIndex = true;\n            var orient = this.get('orient', true);\n            var thisOption = this.option;\n\n            if (autoAxisIndex) {\n                // Find axis that parallel to dataZoom as default.\n                var dimNames = orient === 'vertical'\n                    ? {dim: 'y', axisIndex: 'yAxisIndex', axis: 'yAxis'}\n                    : {dim: 'x', axisIndex: 'xAxisIndex', axis: 'xAxis'};\n\n                if (this.dependentModels[dimNames.axis].length) {\n                    thisOption[dimNames.axisIndex] = [0];\n                    autoAxisIndex = false;\n                }\n            }\n\n            if (autoAxisIndex) {\n                // Find the first category axis as default. (consider polar)\n                eachAxisDim(function (dimNames) {\n                    if (!autoAxisIndex) {\n                        return;\n                    }\n                    var axisIndices = [];\n                    var axisModels = this.dependentModels[dimNames.axis];\n                    if (axisModels.length && !axisIndices.length) {\n                        for (var i = 0, len = axisModels.length; i < len; i++) {\n                            if (axisModels[i].get('type') === 'category') {\n                                axisIndices.push(i);\n                            }\n                        }\n                    }\n                    thisOption[dimNames.axisIndex] = axisIndices;\n                    if (axisIndices.length) {\n                        autoAxisIndex = false;\n                    }\n                }, this);\n            }\n\n            if (autoAxisIndex) {\n                // FIXME\n                // ec2xAxisIndexyAxisIndexscatterdataZoom\n                // Grid.js#getScaleByOptiontimelogaxis type\n\n                // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n                // dataZoom component auto adopts series that reference to\n                // both xAxis and yAxis which type is 'value'.\n                this.ecModel.eachSeries(function (seriesModel) {\n                    if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n                        eachAxisDim(function (dimNames) {\n                            var axisIndices = thisOption[dimNames.axisIndex];\n\n                            var axisIndex = seriesModel.get(dimNames.axisIndex);\n                            var axisId = seriesModel.get(dimNames.axisId);\n\n                            var axisModel = seriesModel.ecModel.queryComponents({\n                                mainType: dimNames.axis,\n                                index: axisIndex,\n                                id: axisId\n                            })[0];\n\n                            if (__DEV__) {\n                                if (!axisModel) {\n                                    throw new Error(\n                                        dimNames.axis + ' \"' + zrUtil.retrieve(\n                                            axisIndex,\n                                            axisId,\n                                            0\n                                        ) + '\" not found'\n                                    );\n                                }\n                            }\n                            axisIndex = axisModel.componentIndex;\n\n                            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n                                axisIndices.push(axisIndex);\n                            }\n                        });\n                    }\n                }, this);\n            }\n        },\n\n        /**\n         * @private\n         */\n        _autoSetOrient: function () {\n            var dim;\n\n            // Find the first axis\n            this.eachTargetAxis(function (dimNames) {\n                !dim && (dim = dimNames.name);\n            }, this);\n\n            this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n        },\n\n        /**\n         * @private\n         */\n        _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n            // FIXME\n            // seriesxAxisIndexyAxisIndex\n            // series.type === scatter\n\n            var is = true;\n            eachAxisDim(function (dimNames) {\n                var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n                var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n                if (!axisModel || axisModel.get('type') !== axisType) {\n                    is = false;\n                }\n            }, this);\n            return is;\n        },\n\n        /**\n         * @private\n         */\n        _setDefaultThrottle: function (rawOption) {\n            // When first time user set throttle, auto throttle ends.\n            if (rawOption.hasOwnProperty('throttle')) {\n                this._autoThrottle = false;\n            }\n            if (this._autoThrottle) {\n                var globalOption = this.ecModel.option;\n                this.option.throttle =\n                    (globalOption.animation && globalOption.animationDurationUpdate > 0)\n                    ? 100 : 20;\n            }\n        },\n\n        /**\n         * @public\n         */\n        getFirstTargetAxisModel: function () {\n            var firstAxisModel;\n            eachAxisDim(function (dimNames) {\n                if (firstAxisModel == null) {\n                    var indices = this.get(dimNames.axisIndex);\n                    if (indices.length) {\n                        firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n                    }\n                }\n            }, this);\n\n            return firstAxisModel;\n        },\n\n        /**\n         * @public\n         * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n         */\n        eachTargetAxis: function (callback, context) {\n            var ecModel = this.ecModel;\n            eachAxisDim(function (dimNames) {\n                each(\n                    this.get(dimNames.axisIndex),\n                    function (axisIndex) {\n                        callback.call(context, dimNames, axisIndex, this, ecModel);\n                    },\n                    this\n                );\n            }, this);\n        },\n\n        getAxisProxy: function (dimName, axisIndex) {\n            return this._axisProxies[dimName + '_' + axisIndex];\n        },\n\n        /**\n         * If not specified, set to undefined.\n         *\n         * @public\n         * @param {Object} opt\n         * @param {number} [opt.start]\n         * @param {number} [opt.end]\n         * @param {number} [opt.startValue]\n         * @param {number} [opt.endValue]\n         */\n        setRawRange: function (opt) {\n            each(['start', 'end', 'startValue', 'endValue'], function (name) {\n                // If any of those prop is null/undefined, we should alos set\n                // them, because only one pair between start/end and\n                // startValue/endValue can work.\n                this.option[name] = opt[name];\n            }, this);\n        },\n\n        /**\n         * @public\n         * @return {Array.<number>} [startPercent, endPercent]\n         */\n        getPercentRange: function () {\n            var axisProxy = this.findRepresentativeAxisProxy();\n            if (axisProxy) {\n                return axisProxy.getDataPercentWindow();\n            }\n        },\n\n        /**\n         * @public\n         * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n         *\n         * @param {string} [axisDimName]\n         * @param {number} [axisIndex]\n         * @return {Array.<number>} [startValue, endValue]\n         */\n        getValueRange: function (axisDimName, axisIndex) {\n            if (axisDimName == null && axisIndex == null) {\n                var axisProxy = this.findRepresentativeAxisProxy();\n                if (axisProxy) {\n                    return axisProxy.getDataValueWindow();\n                }\n            }\n            else {\n                return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n            }\n        },\n\n        /**\n         * @public\n         * @return {module:echarts/component/dataZoom/AxisProxy}\n         */\n        findRepresentativeAxisProxy: function () {\n            // Find the first hosted axisProxy\n            var axisProxies = this._axisProxies;\n            for (var key in axisProxies) {\n                if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n                    return axisProxies[key];\n                }\n            }\n\n            // If no hosted axis find not hosted axisProxy.\n            // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n            // and the option.start or option.end settings are different. The percentRange\n            // should follow axisProxy.\n            // (We encounter this problem in toolbox data zoom.)\n            for (var key in axisProxies) {\n                if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n                    return axisProxies[key];\n                }\n            }\n        }\n\n    });\n\n    function retrieveRaw(option) {\n        var ret = {};\n        each(\n            ['start', 'end', 'startValue', 'endValue', 'throttle'],\n            function (name) {\n                option.hasOwnProperty(name) && (ret[name] = option[name]);\n            }\n        );\n        return ret;\n    }\n\n    function processRangeProp(percentProp, valueProp, rawOption, thisOption) {\n        // start/end has higher priority over startValue/endValue,\n        // but we should make chart.setOption({endValue: 1000}) effective,\n        // rather than chart.setOption({endValue: 1000, end: null}).\n        if (rawOption[valueProp] != null && rawOption[percentProp] == null) {\n            thisOption[percentProp] = null;\n        }\n        // Otherwise do nothing and use the merge result.\n    }\n\n    module.exports = DataZoomModel;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/DataZoomModel.js\n// module id = 40\n// module chunks = 0 1","\n\n    var ComponentView = require('../../view/Component');\n\n    module.exports = ComponentView.extend({\n\n        type: 'dataZoom',\n\n        render: function (dataZoomModel, ecModel, api, payload) {\n            this.dataZoomModel = dataZoomModel;\n            this.ecModel = ecModel;\n            this.api = api;\n        },\n\n        /**\n         * Find the first target coordinate system.\n         *\n         * @protected\n         * @return {Object} {\n         *                   cartesians: [\n         *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n         *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n         *                       ...\n         *                   ],  // cartesians must not be null/undefined.\n         *                   polars: [\n         *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n         *                       ...\n         *                   ],  // polars must not be null/undefined.\n         *                   axisModels: [axis0, axis1, axis2, axis3, axis4]\n         *                       // axisModels must not be null/undefined.\n         *                  }\n         */\n        getTargetInfo: function () {\n            var dataZoomModel = this.dataZoomModel;\n            var ecModel = this.ecModel;\n            var cartesians = [];\n            var polars = [];\n            var axisModels = [];\n\n            dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n                var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n                if (axisModel) {\n                    axisModels.push(axisModel);\n                    var coordSysName;\n                    var axisName = dimNames.axis;\n\n                    if (axisName === 'xAxis' || axisName === 'yAxis') {\n                        coordSysName = 'grid';\n                    }\n                    else if (axisName === 'angleAxis' || axisName === 'radiusAxis') {\n                        coordSysName = 'polar';\n                    }\n\n                    var coordModel = coordSysName\n                        ? ecModel.queryComponents({\n                            mainType: coordSysName,\n                            index: axisModel.get(coordSysName + 'Index'),\n                            id: axisModel.get(coordSysName + 'Id')\n                        })[0]\n                        : null;\n\n                    if (coordModel != null) {\n                        save(\n                            coordModel,\n                            axisModel,\n                            coordSysName === 'grid' ? cartesians : polars,\n                            coordModel.componentIndex\n                        );\n                    }\n                }\n            }, this);\n\n            function save(coordModel, axisModel, store, coordIndex) {\n                var item;\n                for (var i = 0; i < store.length; i++) {\n                    if (store[i].model === coordModel) {\n                        item = store[i];\n                        break;\n                    }\n                }\n                if (!item) {\n                    store.push(item = {\n                        model: coordModel, axisModels: [], coordIndex: coordIndex\n                    });\n                }\n                item.axisModels.push(axisModel);\n            }\n\n            return {\n                cartesians: cartesians,\n                polars: polars,\n                axisModels: axisModels\n            };\n        }\n\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/DataZoomView.js\n// module id = 41\n// module chunks = 0 1","\n\n    var numberUtil = require('../util/number');\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = require('zrender/lib/core/util');\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            var ret = this._extent.slice();\n            return ret;\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        }\n    };\n\n    module.exports = Axis;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/Axis.js\n// module id = 42\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazz = require('./clazz');\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/component.js\n// module id = 43\n// module chunks = 0 1 2","// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/timsort.js\n// module id = 44\n// module chunks = 0 1 2","'use strict';\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            var key = keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/data/DataDiffer.js\n// module id = 45\n// module chunks = 0 1 2","\n\n    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\n        // Encoding visual for all series include which is filtered for legend drawing\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n\n            var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n            var symbolSize = seriesModel.get('symbolSize');\n\n            data.setVisual({\n                legendSymbol: legendSymbol || symbolType,\n                symbol: symbolType,\n                symbolSize: symbolSize\n            });\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof symbolSize === 'function') {\n                    data.each(function (idx) {\n                        var rawValue = seriesModel.getRawValue(idx);\n                        // FIXME\n                        var params = seriesModel.getDataParams(idx);\n                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n                    });\n                }\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var itemSymbolType = itemModel.getShallow('symbol', true);\n                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n                    // If has item symbol\n                    if (itemSymbolType != null) {\n                        data.setItemVisual(idx, 'symbol', itemSymbolType);\n                    }\n                    if (itemSymbolSize != null) {\n                        // PENDING Transform symbolSize ?\n                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n                    }\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/visual/symbol.js\n// module id = 46\n// module chunks = 0 1 2","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/log.js\n// module id = 47\n// module chunks = 0 1 2","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // \n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var width = style.width || image.width;\n                var height = style.height || image.height;\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // \n                if (!image.width || !image.height) {\n                    return;\n                }\n\n                // transform\n                this.setTransform(ctx);\n\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                // \n                if (style.width == null) {\n                    style.width = width;\n                }\n                if (style.height == null) {\n                    style.height = height;\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Image.js\n// module id = 48\n// module chunks = 0 1 2","/**\n * @module echarts/chart/helper/Symbol\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolUtil = require('../../util/symbol');\n    var graphic = require('../../util/graphic');\n    var numberUtil = require('../../util/number');\n\n    function normalizeSymbolSize(symbolSize) {\n        symbolSize = symbolSize instanceof Array\n            ? symbolSize.slice()\n            : [+symbolSize, +symbolSize];\n        symbolSize[0] /= 2;\n        symbolSize[1] /= 2;\n        return symbolSize;\n    }\n\n    /**\n     * @constructor\n     * @alias {module:echarts/chart/helper/Symbol}\n     * @param {module:echarts/data/List} data\n     * @param {number} idx\n     * @extends {module:zrender/graphic/Group}\n     */\n    function Symbol(data, idx, seriesScope) {\n        graphic.Group.call(this);\n\n        this.updateData(data, idx, seriesScope);\n    }\n\n    var symbolProto = Symbol.prototype;\n\n    function driftSymbol(dx, dy) {\n        this.parent.drift(dx, dy);\n    }\n\n    symbolProto._createSymbol = function (symbolType, data, idx) {\n        // Remove paths created before\n        this.removeAll();\n\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // var symbolPath = symbolUtil.createSymbol(\n        //     symbolType, -0.5, -0.5, 1, 1, color\n        // );\n        // If width/height are set too small (e.g., set to 1) on ios10\n        // and macOS Sierra, a circle stroke become a rect, no matter what\n        // the scale is set. So we set width/height as 2. See #4150.\n        var symbolPath = symbolUtil.createSymbol(\n            symbolType, -1, -1, 2, 2, color\n        );\n\n        symbolPath.attr({\n            z2: 100,\n            culling: true,\n            scale: [0, 0]\n        });\n        // Rewrite drift method\n        symbolPath.drift = driftSymbol;\n\n        var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\n        graphic.initProps(symbolPath, {\n            scale: size\n        }, seriesModel, idx);\n        this._symbolType = symbolType;\n\n        this.add(symbolPath);\n    };\n\n    /**\n     * Stop animation\n     * @param {boolean} toLastFrame\n     */\n    symbolProto.stopSymbolAnimation = function (toLastFrame) {\n        this.childAt(0).stopAnimation(toLastFrame);\n    };\n\n    /**\n     * Get symbol path element\n     */\n    symbolProto.getSymbolPath = function () {\n        return this.childAt(0);\n    };\n\n    /**\n     * Get scale(aka, current symbol size).\n     * Including the change caused by animation\n     */\n    symbolProto.getScale = function () {\n        return this.childAt(0).scale;\n    };\n\n    /**\n     * Highlight symbol\n     */\n    symbolProto.highlight = function () {\n        this.childAt(0).trigger('emphasis');\n    };\n\n    /**\n     * Downplay symbol\n     */\n    symbolProto.downplay = function () {\n        this.childAt(0).trigger('normal');\n    };\n\n    /**\n     * @param {number} zlevel\n     * @param {number} z\n     */\n    symbolProto.setZ = function (zlevel, z) {\n        var symbolPath = this.childAt(0);\n        symbolPath.zlevel = zlevel;\n        symbolPath.z = z;\n    };\n\n    symbolProto.setDraggable = function (draggable) {\n        var symbolPath = this.childAt(0);\n        symbolPath.draggable = draggable;\n        symbolPath.cursor = draggable ? 'move' : 'pointer';\n    };\n\n    /**\n     * Update symbol properties\n     * @param  {module:echarts/data/List} data\n     * @param  {number} idx\n     */\n    symbolProto.updateData = function (data, idx, seriesScope) {\n        this.silent = false;\n\n        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n        var seriesModel = data.hostModel;\n        var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n        if (symbolType !== this._symbolType) {\n            this._createSymbol(symbolType, data, idx);\n        }\n        else {\n            var symbolPath = this.childAt(0);\n            graphic.updateProps(symbolPath, {\n                scale: symbolSize\n            }, seriesModel, idx);\n        }\n        this._updateCommon(data, idx, symbolSize, seriesScope);\n        this._seriesModel = seriesModel;\n    };\n\n    // Update common properties\n    var normalStyleAccessPath = ['itemStyle', 'normal'];\n    var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\n    var normalLabelAccessPath = ['label', 'normal'];\n    var emphasisLabelAccessPath = ['label', 'emphasis'];\n\n    symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n        var symbolPath = this.childAt(0);\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // Reset style\n        if (symbolPath.type !== 'image') {\n            symbolPath.useStyle({\n                strokeNoScale: true\n            });\n        }\n\n        seriesScope = seriesScope || null;\n\n        var itemStyle = seriesScope && seriesScope.itemStyle;\n        var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n        var symbolRotate = seriesScope && seriesScope.symbolRotate;\n        var symbolOffset = seriesScope && seriesScope.symbolOffset;\n        var labelModel = seriesScope && seriesScope.labelModel;\n        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n        var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n\n        if (!seriesScope || data.hasItemOption) {\n            var itemModel = data.getItemModel(idx);\n\n            // Color must be excluded.\n            // Because symbol provide setColor individually to set fill and stroke\n            itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n            hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n\n            symbolRotate = itemModel.getShallow('symbolRotate');\n            symbolOffset = itemModel.getShallow('symbolOffset');\n\n            labelModel = itemModel.getModel(normalLabelAccessPath);\n            hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n            hoverAnimation = itemModel.getShallow('hoverAnimation');\n        }\n        else {\n            hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n        }\n\n        var elStyle = symbolPath.style;\n\n        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n        if (symbolOffset) {\n            symbolPath.attr('position', [\n                numberUtil.parsePercent(symbolOffset[0], symbolSize[0]),\n                numberUtil.parsePercent(symbolOffset[1], symbolSize[1])\n            ]);\n        }\n\n        // PENDING setColor before setStyle!!!\n        symbolPath.setColor(color);\n\n        symbolPath.setStyle(itemStyle);\n\n        var opacity = data.getItemVisual(idx, 'opacity');\n        if (opacity != null) {\n            elStyle.opacity = opacity;\n        }\n\n        // Get last value dim\n        var dimensions = data.dimensions.slice();\n        var valueDim;\n        var dataType;\n        while (dimensions.length && (\n            valueDim = dimensions.pop(),\n            dataType = data.getDimensionInfo(valueDim).type,\n            dataType === 'ordinal' || dataType === 'time'\n        )) {} // jshint ignore:line\n\n        if (valueDim != null && labelModel.getShallow('show')) {\n            graphic.setText(elStyle, labelModel, color);\n            elStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(idx, 'normal'),\n                data.get(valueDim, idx)\n            );\n        }\n        else {\n            elStyle.text = '';\n        }\n\n        if (valueDim != null && hoverLabelModel.getShallow('show')) {\n            graphic.setText(hoverItemStyle, hoverLabelModel, color);\n            hoverItemStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(idx, 'emphasis'),\n                data.get(valueDim, idx)\n            );\n        }\n        else {\n            hoverItemStyle.text = '';\n        }\n\n        var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\n        symbolPath.off('mouseover')\n            .off('mouseout')\n            .off('emphasis')\n            .off('normal');\n\n        symbolPath.hoverStyle = hoverItemStyle;\n\n        graphic.setHoverStyle(symbolPath);\n\n        if (hoverAnimation && seriesModel.ifEnableAnimation()) {\n            var onEmphasis = function() {\n                var ratio = size[1] / size[0];\n                this.animateTo({\n                    scale: [\n                        Math.max(size[0] * 1.1, size[0] + 3),\n                        Math.max(size[1] * 1.1, size[1] + 3 * ratio)\n                    ]\n                }, 400, 'elasticOut');\n            };\n            var onNormal = function() {\n                this.animateTo({\n                    scale: size\n                }, 400, 'elasticOut');\n            };\n            symbolPath.on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n    };\n\n    symbolProto.fadeOut = function (cb) {\n        var symbolPath = this.childAt(0);\n        // Avoid mistaken hover when fading out\n        this.silent = true;\n        // Not show text when animating\n        symbolPath.style.text = '';\n        graphic.updateProps(symbolPath, {\n            scale: [0, 0]\n        }, this._seriesModel, this.dataIndex, cb);\n    };\n\n    zrUtil.inherits(Symbol, graphic.Group);\n\n    module.exports = Symbol;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/helper/Symbol.js\n// module id = 49\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var numberUtil = require('../../util/number');\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = require('zrender/lib/core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTick: function () {\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisTick.show')) {\n                return;\n            }\n\n            var axis = axisModel.axis;\n            var tickModel = axisModel.getModel('axisTick');\n            var opt = this.opt;\n\n            var lineStyleModel = tickModel.getModel('lineStyle');\n            var tickLen = tickModel.get('length');\n\n            var tickInterval = getInterval(tickModel, opt.labelInterval);\n            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n            var ticks = axis.scale.getTicks();\n\n            var pt1 = [];\n            var pt2 = [];\n            var matrix = this._transform;\n\n            for (var i = 0; i < ticksCoords.length; i++) {\n                // Only ordinal scale support tick interval\n                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                     continue;\n                }\n\n                var tickCoord = ticksCoords[i];\n\n                pt1[0] = tickCoord;\n                pt1[1] = 0;\n                pt2[0] = tickCoord;\n                pt2[1] = opt.tickDirection * tickLen;\n\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                // Tick line, Not use group transform to have better line draw\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                    // Id for animation\n                    anid: 'tick_' + ticks[i],\n\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.defaults(\n                        lineStyleModel.getLineStyle(),\n                        {\n                            stroke: axisModel.get('axisLine.lineStyle.color')\n                        }\n                    ),\n                    z2: 2,\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @private\n         */\n        axisLabel: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n            if (!show) {\n                return;\n            }\n\n            var axis = axisModel.axis;\n            var labelModel = axisModel.getModel('axisLabel');\n            var textStyleModel = labelModel.getModel('textStyle');\n            var labelMargin = labelModel.get('margin');\n            var ticks = axis.scale.getTicks();\n            var labels = axisModel.getFormattedLabels();\n\n            // Special label rotate.\n            var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n            // To radian.\n            labelRotation = labelRotation * PI / 180;\n\n            var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n            var categoryData = axisModel.get('data');\n\n            var textEls = [];\n            var silent = isSilent(axisModel);\n            var triggerEvent = axisModel.get('triggerEvent');\n\n            for (var i = 0; i < ticks.length; i++) {\n                if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {\n                     continue;\n                }\n\n                var itemTextStyleModel = textStyleModel;\n                if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n                    itemTextStyleModel = new Model(\n                        categoryData[i].textStyle, textStyleModel, axisModel.ecModel\n                    );\n                }\n                var textColor = itemTextStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color');\n\n                var tickCoord = axis.dataToCoord(ticks[i]);\n                var pos = [\n                    tickCoord,\n                    opt.labelOffset + opt.labelDirection * labelMargin\n                ];\n                var labelBeforeFormat = axis.scale.getLabel(ticks[i]);\n\n                var textEl = new graphic.Text({\n\n                    // Id for animation\n                    anid: 'label_' + ticks[i],\n\n                    style: {\n                        text: labels[i],\n                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n                        textFont: itemTextStyleModel.getFont(),\n                        fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n                    },\n                    position: pos,\n                    rotation: labelLayout.rotation,\n                    silent: silent,\n                    z2: 10\n                });\n\n                // Pack data for mouse event\n                if (triggerEvent) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisLabel';\n                    textEl.eventData.value = labelBeforeFormat;\n                }\n\n\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n\n                textEls.push(textEl);\n                this.group.add(textEl);\n\n                textEl.decomposeTransform();\n            }\n\n            function isTwoLabelOverlapped(current, next) {\n                var firstRect = current && current.getBoundingRect().clone();\n                var nextRect = next && next.getBoundingRect().clone();\n                if (firstRect && nextRect) {\n                    firstRect.applyTransform(current.getLocalTransform());\n                    nextRect.applyTransform(next.getLocalTransform());\n                    return firstRect.intersect(nextRect);\n                }\n            }\n            if (axis.type !== 'category') {\n                // If min or max are user set, we need to check\n                // If the tick on min(max) are overlap on their neighbour tick\n                // If they are overlapped, we need to hide the min(max) tick label\n                if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {\n                    var firstLabel = textEls[0];\n                    var nextLabel = textEls[1];\n                    if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n                        firstLabel.ignore = true;\n                    }\n                }\n                if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {\n                    var lastLabel = textEls[textEls.length - 1];\n                    var prevLabel = textEls[textEls.length - 2];\n                    if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n                        lastLabel.ignore = true;\n                    }\n                }\n            }\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (nameLocation === 'middle') {\n                labelLayout = innerTextLayout(\n                    opt,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                style: {\n                    text: truncatedText,\n                    textFont: textFont,\n                    fill: textStyleModel.getTextColor()\n                        || axisModel.get('axisLine.lineStyle.color'),\n                    textAlign: labelLayout.textAlign,\n                    textVerticalAlign: labelLayout.verticalAlign\n                },\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @inner\n     */\n    function innerTextLayout(opt, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            verticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            verticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            verticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            verticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            verticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            verticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    module.exports = AxisBuilder;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/axis/AxisBuilder.js\n// module id = 50\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('./axisHelper');\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj;\n        }\n    }\n    /**\n     * Get categories\n     */\n    function getCategories() {\n        return this.get('type') === 'category'\n            && zrUtil.map(this.get('data'), getName);\n    }\n\n    /**\n     * Format labels\n     * @return {Array.<string>}\n     */\n    function getFormattedLabels() {\n        return axisHelper.getFormattedLabels(\n            this.axis,\n            this.get('axisLabel.formatter')\n        );\n    }\n\n    module.exports = {\n\n        getFormattedLabels: getFormattedLabels,\n\n        getCategories: getCategories\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/axisModelCommonMixin.js\n// module id = 51\n// module chunks = 0 1 2","\n\n    var axisDefault = require('./axisDefault');\n    var zrUtil = require('zrender/lib/core/util');\n    var ComponentModel = require('../model/Component');\n    var layout = require('../util/layout');\n\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n\n            BaseAxisModelClass.extend({\n\n                type: axisName + 'Axis.' + axisType,\n\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode\n                        ? layout.getLayoutParams(option) : {};\n\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n\n                    option.type = axisTypeDefaulter(axisName, option);\n\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n\n                defaultOption: zrUtil.mergeAll(\n                    [\n                        {},\n                        axisDefault[axisType + 'Axis'],\n                        extraDefaultOption\n                    ],\n                    true\n                )\n            });\n        });\n\n        ComponentModel.registerSubTypeDefaulter(\n            axisName + 'Axis',\n            zrUtil.curry(axisTypeDefaulter, axisName)\n        );\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/axisModelCreator.js\n// module id = 52\n// module chunks = 0 1 2","'use strict';\n\n\n    var ComponentModel = require('../../model/Component');\n    var zrUtil = require('zrender/lib/core/util');\n    var axisModelCreator = require('../axisModelCreator');\n\n    var AxisModel = ComponentModel.extend({\n\n        type: 'cartesian2dAxis',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Axis2D}\n         */\n        axis: null,\n\n        /**\n         * @override\n         */\n        init: function () {\n            AxisModel.superApply(this, 'init', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function () {\n            AxisModel.superApply(this, 'mergeOption', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        restoreData: function () {\n            AxisModel.superApply(this, 'restoreData', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        findGridModel: function () {\n            return this.ecModel.queryComponents({\n                mainType: 'grid',\n                index: this.get('gridIndex'),\n                id: this.get('gridId')\n            })[0];\n        }\n\n    });\n\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n\n    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n    zrUtil.merge(AxisModel.prototype, require('../axisModelZoomMixin'));\n\n    var extraOption = {\n        // gridIndex: 0,\n        // gridId: '',\n\n        // Offset is for multiple axis on the same position\n        offset: 0\n    };\n\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\n    module.exports = AxisModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/cartesian/AxisModel.js\n// module id = 53\n// module chunks = 0 1 2","/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nvar factory = exports;\n\n    var layout = require('../../util/layout');\n    var axisHelper = require('../../coord/axisHelper');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Cartesian2D = require('./Cartesian2D');\n    var Axis2D = require('./Axis2D');\n\n    var each = zrUtil.each;\n\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n\n    //  GridModel, AxisModel \n    require('./GridModel');\n\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.findGridModel() === gridModel;\n    }\n\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = axisModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : (rect = singleRect);\n            }\n        }\n        return rect;\n    }\n\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n\n        this._initCartesian(gridModel, ecModel, api);\n\n        this._model = gridModel;\n    }\n\n    var gridProto = Grid.prototype;\n\n    gridProto.type = 'grid';\n\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n\n    gridProto.update = function (ecModel, api) {\n\n        var axesMap = this._axesMap;\n\n        this._updateScale(ecModel, this._model);\n\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                if (axes.hasOwnProperty(idx)) {\n                    var axis = axes[idx];\n                    if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this._model, api);\n    };\n\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api) {\n\n        var gridRect = layout.getLayoutRect(\n            gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n\n        this._rect = gridRect;\n\n        var axesList = this._axesList;\n\n        adjustAxes();\n\n        // Minus label size\n        if (gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        }\n                        else if (axis.position === 'left')  {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n\n            adjustAxes();\n        }\n\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    if (axesMapOnDim.hasOwnProperty(name)) {\n                        return axesMapOnDim[name];\n                    }\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        }\n        else {\n            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n                if (coordList[i].getAxis('x').index === xAxisIndex\n                    || coordList[i].getAxis('y').index === yAxisIndex\n                ) {\n                    return coordList[i];\n                }\n            }\n        }\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertToPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.dataToPoint(value)\n            : target.axis\n            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n            : null;\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertFromPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.pointToData(value)\n            : target.axis\n            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n            : null;\n    };\n\n    /**\n     * @inner\n     */\n    gridProto._findConvertTarget = function (ecModel, finder) {\n        var seriesModel = finder.seriesModel;\n        var xAxisModel = finder.xAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n        var yAxisModel = finder.yAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n        var gridModel = finder.gridModel;\n        var coordsList = this._coordsList;\n        var cartesian;\n        var axis;\n\n        if (seriesModel) {\n            cartesian = seriesModel.coordinateSystem;\n            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n        }\n        else if (xAxisModel && yAxisModel) {\n            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        }\n        else if (xAxisModel) {\n            axis = this.getAxis('x', xAxisModel.componentIndex);\n        }\n        else if (yAxisModel) {\n            axis = this.getAxis('y', yAxisModel.componentIndex);\n        }\n        // Lowest priority.\n        else if (gridModel) {\n            var grid = gridModel.coordinateSystem;\n            if (grid === this) {\n                cartesian = this._coordsList[0];\n            }\n        }\n\n        return {cartesian: cartesian, axis: axis};\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.containPoint = function (point) {\n        var coord = this._coordsList[0];\n        if (coord) {\n            return coord.containPoint(point);\n        }\n    };\n\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n            left: false,\n            right: false,\n            top: false,\n            bottom: false\n        };\n\n        var axesMap = {\n            x: {},\n            y: {}\n        };\n        var axesCount = {\n            x: 0,\n            y: 0\n        };\n\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n\n        this._axesMap = axesMap;\n\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n\n                cartesian.grid = this;\n\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                }\n                else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n\n                var axis = new Axis2D(\n                    axisType, axisHelper.createScaleByModel(axisModel),\n                    [0, 0],\n                    axisModel.get('type'),\n                    axisPosition\n                );\n\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n\n                axis.onZero = axisModel.get('axisLine.onZero');\n\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n\n                // Inject axisModel into axis\n                axis.model = axisModel;\n\n                // Inject grid info axis\n                axis.grid = this;\n\n                // Index of axis, can be used as key\n                axis.index = idx;\n\n                this._axesList.push(axis);\n\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n                 ) {\n                    return;\n                }\n\n                var cartesian = this.getCartesian(\n                    xAxisModel.componentIndex, yAxisModel.componentIndex\n                );\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtent(data.getDataExtent(\n                    dim, axis.scale.type !== 'ordinal'\n                ));\n            });\n        }\n    };\n\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord + coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n        axis.toLocalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord - coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n    }\n\n    var axesTypes = ['xAxis', 'yAxis'];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\n            if (__DEV__) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n                        seriesModel.get(axisType + 'Index'),\n                        seriesModel.get(axisType + 'Id'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            grid.resize(gridModel, api);\n\n            gridModel.coordinateSystem = grid;\n\n            grids.push(grid);\n        });\n\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            var gridModel = xAxisModel.findGridModel();\n\n            if (__DEV__) {\n                if (!gridModel) {\n                    throw new Error(\n                        'Grid \"' + zrUtil.retrieve(\n                            xAxisModel.get('gridIndex'),\n                            xAxisModel.get('gridId'),\n                            0\n                        ) + '\" not found'\n                    );\n                }\n                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n\n            var grid = gridModel.coordinateSystem;\n\n            seriesModel.coordinateSystem = grid.getCartesian(\n                xAxisModel.componentIndex, yAxisModel.componentIndex\n            );\n        });\n\n        return grids;\n    };\n\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\n    require('../../CoordinateSystem').register('cartesian2d', Grid);\n\n    module.exports = Grid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/cartesian/Grid.js\n// module id = 54\n// module chunks = 0 1 2","\n\n    module.exports = function (seriesType, ecModel) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (coordSys) {\n                var dims = coordSys.dimensions;\n\n                if (coordSys.type === 'singleAxis') {\n                    data.each(dims[0], function (x, idx) {\n                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n                        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n                    });\n                }\n                else {\n                    data.each(dims, function (x, y, idx) {\n                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n                        data.setItemLayout(\n                            idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y])\n                        );\n                    }, true);\n                }\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/layout/points.js\n// module id = 55\n// module chunks = 0 1 2","\n    module.exports = {\n        clearColorPalette: function () {\n            this._colorIdx = 0;\n            this._colorNameMap = {};\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = scope._colorIdx || 0;\n            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});\n            if (colorNameMap[name]) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            scope._colorIdx = (colorIdx + 1) % colorPalette.length;\n\n            return color;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/mixin/colorPalette.js\n// module id = 56\n// module chunks = 0 1 2","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/view/Component.js\n// module id = 57\n// module chunks = 0 1 2","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * \n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * \n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender  element  zrender \n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * true\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * (shape) Group \n         * \n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Element.js\n// module id = 58\n// module chunks = 0 1 2","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = (\n                isValueArray\n                && isArrayLike(firstVal[0])\n            )\n            ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * \n         * @param  {number} time ms\n         * @param  {Object} props key-value\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * \n         * @param  {string|Function} easing\n         *         {@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * \n         * @param  {number} time ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animator.js\n// module id = 59\n// module chunks = 0 1 2","\n\n    module.exports = (typeof window !== 'undefined' &&\n                                    (window.requestAnimationFrame\n                                    || window.msRequestAnimationFrame\n                                    || window.mozRequestAnimationFrame\n                                    || window.webkitRequestAnimationFrame))\n                                || function (func) {\n                                    setTimeout(func, 16);\n                                };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/requestAnimationFrame.js\n// module id = 60\n// module chunks = 0 1 2","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/util.js\n// module id = 61\n// module chunks = 0 1 2","/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/guid.js\n// module id = 62\n// module chunks = 0 1 2","\n\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n\n        return this._canvasPattern\n            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n\n    module.exports = Pattern;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Pattern.js\n// module id = 63\n// module chunks = 0 1 2","/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Style.js\n// module id = 64\n// module chunks = 0 1 2","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/poly.js\n// module id = 65\n// module chunks = 0 1 2","/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n *\n * @module echarts/chart/helper/DataSelectable\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = {\n\n        updateSelectedMap: function (targetList) {\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap[target.name] = target;\n                return targetMap;\n            }, {});\n        },\n        /**\n         * @param {string} name\n         */\n        // PENGING If selectedMode is null ?\n        select: function (name) {\n            var targetMap = this._selectTargetMap;\n            var target = targetMap[name];\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                zrUtil.each(targetMap, function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            var target = this._selectTargetMap[name];\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name);\n                return target.selected;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            return target && target.selected;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/helper/selectableMixin.js\n// module id = 66\n// module chunks = 0 1 2","\n\n    var modelUtil = require('../../util/model');\n    var zrUtil = require('zrender/lib/core/util');\n    var env = require('zrender/lib/core/env');\n\n    var formatUtil = require('../../util/format');\n    var addCommas = formatUtil.addCommas;\n    var encodeHTML = formatUtil.encodeHTML;\n\n    function fillLabel(opt) {\n        modelUtil.defaultEmphasis(\n            opt.label,\n            modelUtil.LABEL_OPTIONS\n        );\n    }\n    var MarkerModel = require('../../echarts').extendComponentModel({\n\n        type: 'marker',\n\n        dependencies: ['series', 'grid', 'polar', 'geo'],\n        /**\n         * @overrite\n         */\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            if (__DEV__) {\n                if (this.type === 'marker') {\n                    throw new Error('Marker component is abstract component. Use markLine, markPoint, markArea instead.');\n                }\n            }\n            this.mergeDefaultAndTheme(option, ecModel);\n            this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);\n        },\n\n        /**\n         * @return {boolean}\n         */\n        ifEnableAnimation: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var hostSeries = this.__hostSeries;\n            return this.getShallow('animation') && hostSeries && hostSeries.ifEnableAnimation();\n        },\n\n        mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {\n            var MarkerModel = this.constructor;\n            var modelPropName = this.mainType + 'Model';\n            if (!createdBySelf) {\n                ecModel.eachSeries(function (seriesModel) {\n\n                    var markerOpt = seriesModel.get(this.mainType);\n\n                    var markerModel = seriesModel[modelPropName];\n                    if (!markerOpt || !markerOpt.data) {\n                        seriesModel[modelPropName] = null;\n                        return;\n                    }\n                    if (!markerModel) {\n                        if (isInit) {\n                            // Default label emphasis `position` and `show`\n                            fillLabel(markerOpt);\n                        }\n                        zrUtil.each(markerOpt.data, function (item) {\n                            // FIXME Overwrite fillLabel method ?\n                            if (item instanceof Array) {\n                                fillLabel(item[0]);\n                                fillLabel(item[1]);\n                            }\n                            else {\n                                fillLabel(item);\n                            }\n                        });\n\n                        markerModel = new MarkerModel(\n                            markerOpt, this, ecModel\n                        );\n\n                        zrUtil.extend(markerModel, {\n                            mainType: this.mainType,\n                            // Use the same series index and name\n                            seriesIndex: seriesModel.seriesIndex,\n                            name: seriesModel.name,\n                            createdBySelf: true\n                        });\n\n                        markerModel.__hostSeries = seriesModel;\n                    }\n                    else {\n                        markerModel.mergeOption(markerOpt, ecModel, true);\n                    }\n                    seriesModel[modelPropName] = markerModel;\n                }, this);\n            }\n        },\n\n        formatTooltip: function (dataIndex) {\n            var data = this.getData();\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);\n            var name = data.getName(dataIndex);\n            var html = this.name;\n            if (value != null || name) {\n                html += '<br />';\n            }\n            if (name) {\n                html += encodeHTML(name);\n                if (value != null) {\n                    html += ' : ';\n                }\n            }\n            if (value != null) {\n                html += formattedValue;\n            }\n            return html;\n        },\n\n        getData: function () {\n            return this._data;\n        },\n\n        setData: function (data) {\n            this._data = data;\n        }\n    });\n\n    zrUtil.mixin(MarkerModel, modelUtil.dataFormatMixin);\n\n    module.exports = MarkerModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/marker/MarkerModel.js\n// module id = 67\n// module chunks = 0 1","\n\n    module.exports = require('../../echarts').extendComponentView({\n\n        type: 'marker',\n\n        init: function () {\n            /**\n             * Markline grouped by series\n             * @private\n             * @type {Object}\n             */\n            this.markerGroupMap = {};\n        },\n\n        render: function (markerModel, ecModel, api) {\n            var markerGroupMap = this.markerGroupMap;\n            for (var name in markerGroupMap) {\n                if (markerGroupMap.hasOwnProperty(name)) {\n                    markerGroupMap[name].__keep = false;\n                }\n            }\n\n            var markerModelKey = this.type + 'Model';\n            ecModel.eachSeries(function (seriesModel) {\n                var markerModel = seriesModel[markerModelKey];\n                markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);\n            }, this);\n\n            for (var name in markerGroupMap) {\n                if (markerGroupMap.hasOwnProperty(name) && !markerGroupMap[name].__keep) {\n                    this.group.remove(markerGroupMap[name].group);\n                }\n            }\n        },\n\n        renderSeries: function () {}\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/marker/MarkerView.js\n// module id = 68\n// module chunks = 0 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../../util/number');\n    var indexOf = zrUtil.indexOf;\n\n    function hasXOrY(item) {\n        return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n    }\n\n    function hasXAndY(item) {\n        return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n    }\n\n    function getPrecision(data, valueAxisDim, dataIndex) {\n        var precision = -1;\n        do {\n            precision = Math.max(\n                numberUtil.getPrecision(data.get(\n                    valueAxisDim, dataIndex\n                )),\n                precision\n            );\n            data = data.stackedOn;\n        } while (data);\n\n        return precision;\n    }\n\n    function markerTypeCalculatorWithExtent(\n        mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex\n    ) {\n        var coordArr = [];\n        var value = numCalculate(data, targetDataDim, mlType);\n\n        var dataIndex = data.indexOfNearest(targetDataDim, value, true);\n        coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex, true);\n        coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex, true);\n\n        var precision = getPrecision(data, targetDataDim, dataIndex);\n        if (precision >= 0) {\n            coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n        }\n\n        return coordArr;\n    }\n\n    var curry = zrUtil.curry;\n    // TODO Specified percent\n    var markerTypeCalculator = {\n        /**\n         * @method\n         * @param {module:echarts/data/List} data\n         * @param {string} baseAxisDim\n         * @param {string} valueAxisDim\n         */\n        min: curry(markerTypeCalculatorWithExtent, 'min'),\n        /**\n         * @method\n         * @param {module:echarts/data/List} data\n         * @param {string} baseAxisDim\n         * @param {string} valueAxisDim\n         */\n        max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n        /**\n         * @method\n         * @param {module:echarts/data/List} data\n         * @param {string} baseAxisDim\n         * @param {string} valueAxisDim\n         */\n        average: curry(markerTypeCalculatorWithExtent, 'average')\n    };\n\n    /**\n     * Transform markPoint data item to format used in List by do the following\n     * 1. Calculate statistic like `max`, `min`, `average`\n     * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n     * @param  {module:echarts/model/Series} seriesModel\n     * @param  {module:echarts/coord/*} [coordSys]\n     * @param  {Object} item\n     * @return {Object}\n     */\n    var dataTransform = function (seriesModel, item) {\n        var data = seriesModel.getData();\n        var coordSys = seriesModel.coordinateSystem;\n\n        // 1. If not specify the position with pixel directly\n        // 2. If `coord` is not a data array. Which uses `xAxis`,\n        // `yAxis` to specify the coord on each dimension\n\n        // parseFloat first because item.x and item.y can be percent string like '20%'\n        if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n            var dims = coordSys.dimensions;\n            var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);\n\n            // Clone the option\n            // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n            item = zrUtil.clone(item);\n\n            if (item.type\n                && markerTypeCalculator[item.type]\n                && axisInfo.baseAxis && axisInfo.valueAxis\n            ) {\n                var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n                var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n\n                item.coord = markerTypeCalculator[item.type](\n                    data, axisInfo.baseDataDim, axisInfo.valueDataDim,\n                    otherCoordIndex, targetCoordIndex\n                );\n                // Force to use the value of calculated value.\n                item.value = item.coord[targetCoordIndex];\n            }\n            else {\n                // FIXME Only has one of xAxis and yAxis.\n                var coord = [\n                    item.xAxis != null ? item.xAxis : item.radiusAxis,\n                    item.yAxis != null ? item.yAxis : item.angleAxis\n                ];\n                // Each coord support max, min, average\n                for (var i = 0; i < 2; i++) {\n                    if (markerTypeCalculator[coord[i]]) {\n                        var dataDim = seriesModel.coordDimToDataDim(dims[i])[0];\n                        coord[i] = numCalculate(data, dataDim, coord[i]);\n                    }\n                }\n                item.coord = coord;\n            }\n        }\n        return item;\n    };\n\n    var getAxisInfo = function (item, data, coordSys, seriesModel) {\n        var ret = {};\n\n        if (item.valueIndex != null || item.valueDim != null) {\n            ret.valueDataDim = item.valueIndex != null\n                ? data.getDimension(item.valueIndex) : item.valueDim;\n            ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));\n            ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n            ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n        }\n        else {\n            ret.baseAxis = seriesModel.getBaseAxis();\n            ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n            ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n            ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];\n        }\n\n        return ret;\n    };\n\n    /**\n     * Filter data which is out of coordinateSystem range\n     * [dataFilter description]\n     * @param  {module:echarts/coord/*} [coordSys]\n     * @param  {Object} item\n     * @return {boolean}\n     */\n    var dataFilter = function (coordSys, item) {\n        // Alwalys return true if there is no coordSys\n        return (coordSys && coordSys.containData && item.coord && !hasXOrY(item))\n            ? coordSys.containData(item.coord) : true;\n    };\n\n    var dimValueGetter = function (item, dimName, dataIndex, dimIndex) {\n        // x, y, radius, angle\n        if (dimIndex < 2) {\n            return item.coord && item.coord[dimIndex];\n        }\n        return item.value;\n    };\n\n    var numCalculate = function (data, valueDataDim, type) {\n        if (type === 'average') {\n            var sum = 0;\n            var count = 0;\n            data.each(valueDataDim, function (val, idx) {\n                if (!isNaN(val)) {\n                    sum += val;\n                    count++;\n                }\n            }, true);\n            return sum / count;\n        }\n        else {\n            return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n        }\n    };\n\n    module.exports = {\n        dataTransform: dataTransform,\n        dataFilter: dataFilter,\n        dimValueGetter: dimValueGetter,\n        getAxisInfo: getAxisInfo,\n        numCalculate: numCalculate\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/marker/markerHelper.js\n// module id = 69\n// module chunks = 0 1","\n    module.exports = function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/processor/dataFilter.js\n// module id = 70\n// module chunks = 0 1 2","// Pick color from palette for each data item\n\n\n    module.exports = function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    // FIXME Performance\n                    var itemModel = dataAll.getItemModel(rawIdx);\n                    var filteredIdx = idxMap[rawIdx];\n\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null\n                        && data.getItemVisual(filteredIdx, 'color', true);\n\n                    if (!singleDataColor) {\n                        var color = itemModel.get('itemStyle.normal.color')\n                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    }\n                    else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/visual/dataColor.js\n// module id = 72\n// module chunks = 0 1 2","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/bbox.js\n// module id = 73\n// module chunks = 0 1 2","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            if (!this._rect) {\n                var style = this.style;\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                this._rect = rect;\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Text.js\n// module id = 74\n// module chunks = 0 1 2","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/mixin/RectText.js\n// module id = 75\n// module chunks = 0 1 2","/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var zrUtil = require('./core/util');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRendermap\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.2.2';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        //  storage.delFromMap, \n        // FIXME ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * \n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, width, height) {\n            var id = guid();\n            return this.painter.pathToImage(id, e, width, height);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/zrender.js\n// module id = 76\n// module chunks = 0 1 2","\n    var echarts = require('../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n    module.exports = function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent(\n                    {mainType: 'series', subType: seriesType, query: payload},\n                    function (seriesModel) {\n                        if (seriesModel[actionInfo.method]) {\n                            seriesModel[actionInfo.method](payload.name);\n                        }\n                        var data = seriesModel.getData();\n                        // Create selected map\n                        data.each(function (idx) {\n                            var name = data.getName(idx);\n                            selected[name] = seriesModel.isSelected(name) || false;\n                        });\n                    }\n                );\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/action/createDataSelectAction.js\n// module id = 77\n// module chunks = 0 1 2","/**\n * @module echarts/component/helper/RoamController\n */\n\n\n\n    var Eventful = require('zrender/lib/mixin/Eventful');\n    var zrUtil = require('zrender/lib/core/util');\n    var eventTool = require('zrender/lib/core/event');\n    var interactionMutex = require('./interactionMutex');\n\n    function mousedown(e) {\n        if (e.target && e.target.draggable) {\n            return;\n        }\n\n        var x = e.offsetX;\n        var y = e.offsetY;\n\n        if (this.containsPoint && this.containsPoint(x, y)) {\n            this._x = x;\n            this._y = y;\n            this._dragging = true;\n        }\n    }\n\n    function mousemove(e) {\n        if (!this._dragging) {\n            return;\n        }\n\n        eventTool.stop(e.event);\n\n        if (e.gestureEvent !== 'pinch') {\n\n            if (interactionMutex.isTaken(this._zr, 'globalPan')) {\n                return;\n            }\n\n            var x = e.offsetX;\n            var y = e.offsetY;\n\n            var oldX = this._x;\n            var oldY = this._y;\n\n            var dx = x - oldX;\n            var dy = y - oldY;\n\n            this._x = x;\n            this._y = y;\n\n            var target = this.target;\n\n            if (target) {\n                var pos = target.position;\n                pos[0] += dx;\n                pos[1] += dy;\n                target.dirty();\n            }\n\n            eventTool.stop(e.event);\n            this.trigger('pan', dx, dy, oldX, oldY, x, y);\n        }\n    }\n\n    function mouseup(e) {\n        this._dragging = false;\n    }\n\n    function mousewheel(e) {\n        // Convenience:\n        // Mac and VM Windows on Mac: scroll up: zoom out.\n        // Windows: scroll up: zoom in.\n        var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\n        zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);\n    }\n\n    function pinch(e) {\n        if (interactionMutex.isTaken(this._zr, 'globalPan')) {\n            return;\n        }\n        var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;\n        zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);\n    }\n\n    function zoom(e, zoomDelta, zoomX, zoomY) {\n        if (this.containsPoint && this.containsPoint(zoomX, zoomY)) {\n            // When mouse is out of roamController rect,\n            // default befavoius should be be disabled, otherwise\n            // page sliding is disabled, contrary to expectation.\n            eventTool.stop(e.event);\n\n            var target = this.target;\n            var zoomLimit = this.zoomLimit;\n\n            if (target) {\n                var pos = target.position;\n                var scale = target.scale;\n\n                var newZoom = this.zoom = this.zoom || 1;\n                newZoom *= zoomDelta;\n                if (zoomLimit) {\n                    var zoomMin = zoomLimit.min || 0;\n                    var zoomMax = zoomLimit.max || Infinity;\n                    newZoom = Math.max(\n                        Math.min(zoomMax, newZoom),\n                        zoomMin\n                    );\n                }\n                var zoomScale = newZoom / this.zoom;\n                this.zoom = newZoom;\n                // Keep the mouse center when scaling\n                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\n                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\n                scale[0] *= zoomScale;\n                scale[1] *= zoomScale;\n\n                target.dirty();\n            }\n\n            this.trigger('zoom', zoomDelta, zoomX, zoomY);\n        }\n    }\n\n    /**\n     * @alias module:echarts/component/helper/RoamController\n     * @constructor\n     * @mixin {module:zrender/mixin/Eventful}\n     *\n     * @param {module:zrender/zrender~ZRender} zr\n     * @param {module:zrender/Element} target\n     */\n    function RoamController(zr, target) {\n\n        /**\n         * @type {module:zrender/Element}\n         */\n        this.target = target;\n\n        /**\n         * @type {Function}\n         */\n        this.containsPoint;\n\n        /**\n         * { min: 1, max: 2 }\n         * @type {Object}\n         */\n        this.zoomLimit;\n\n        /**\n         * @type {number}\n         */\n        this.zoom;\n        /**\n         * @type {module:zrender}\n         */\n        this._zr = zr;\n\n        // Avoid two roamController bind the same handler\n        var bind = zrUtil.bind;\n        var mousedownHandler = bind(mousedown, this);\n        var mousemoveHandler = bind(mousemove, this);\n        var mouseupHandler = bind(mouseup, this);\n        var mousewheelHandler = bind(mousewheel, this);\n        var pinchHandler = bind(pinch, this);\n\n        Eventful.call(this);\n\n        /**\n         * @param {Function} containsPoint\n         *                   input: x, y\n         *                   output: boolean\n         */\n        this.setContainsPoint = function (containsPoint) {\n            this.containsPoint = containsPoint;\n        };\n\n        /**\n         * Notice: only enable needed types. For example, if 'zoom'\n         * is not needed, 'zoom' should not be enabled, otherwise\n         * default mousewheel behaviour (scroll page) will be disabled.\n         *\n         * @param  {boolean|string} [controlType=true] Specify the control type,\n         *                          which can be null/undefined or true/false\n         *                          or 'pan/move' or 'zoom'/'scale'\n         */\n        this.enable = function (controlType) {\n            // Disable previous first\n            this.disable();\n\n            if (controlType == null) {\n                controlType = true;\n            }\n\n            if (controlType === true || (controlType === 'move' || controlType === 'pan')) {\n                zr.on('mousedown', mousedownHandler);\n                zr.on('mousemove', mousemoveHandler);\n                zr.on('mouseup', mouseupHandler);\n            }\n            if (controlType === true || (controlType === 'scale' || controlType === 'zoom')) {\n                zr.on('mousewheel', mousewheelHandler);\n                zr.on('pinch', pinchHandler);\n            }\n        };\n\n        this.disable = function () {\n            zr.off('mousedown', mousedownHandler);\n            zr.off('mousemove', mousemoveHandler);\n            zr.off('mouseup', mouseupHandler);\n            zr.off('mousewheel', mousewheelHandler);\n            zr.off('pinch', pinchHandler);\n        };\n\n        this.dispose = this.disable;\n\n        this.isDragging = function () {\n            return this._dragging;\n        };\n\n        this.isPinching = function () {\n            return this._pinching;\n        };\n    }\n\n    zrUtil.mixin(RoamController, Eventful);\n\n    module.exports = RoamController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/helper/RoamController.js\n// module id = 79\n// module chunks = 0 1","\n\n    /**\n     * Calculate slider move result.\n     *\n     * @param {number} delta Move length.\n     * @param {Array.<number>} handleEnds handleEnds[0] and be bigger then handleEnds[1].\n     *                                    handleEnds will be modified in this method.\n     * @param {Array.<number>} extent handleEnds is restricted by extent.\n     *                                extent[0] should less or equals than extent[1].\n     * @param {string} mode 'rigid': Math.abs(handleEnds[0] - handleEnds[1]) remain unchanged,\n     *                      'cross' handleEnds[0] can be bigger then handleEnds[1],\n     *                      'push' handleEnds[0] can not be bigger then handleEnds[1],\n     *                              when they touch, one push other.\n     * @param {number} handleIndex If mode is 'rigid', handleIndex is not required.\n     * @param {Array.<number>} The input handleEnds.\n     */\n    module.exports = function (delta, handleEnds, extent, mode, handleIndex) {\n        if (!delta) {\n            return handleEnds;\n        }\n\n        if (mode === 'rigid') {\n            delta = getRealDelta(delta, handleEnds, extent);\n            handleEnds[0] += delta;\n            handleEnds[1] += delta;\n        }\n        else {\n            delta = getRealDelta(delta, handleEnds[handleIndex], extent);\n            handleEnds[handleIndex] += delta;\n\n            if (mode === 'push' && handleEnds[0] > handleEnds[1]) {\n                handleEnds[1 - handleIndex] = handleEnds[handleIndex];\n            }\n        }\n\n        return handleEnds;\n\n        function getRealDelta(delta, handleEnds, extent) {\n            var handleMinMax = !handleEnds.length\n                ? [handleEnds, handleEnds]\n                : handleEnds.slice();\n            handleEnds[0] > handleEnds[1] && handleMinMax.reverse();\n\n            if (delta < 0 && handleMinMax[0] + delta < extent[0]) {\n                delta = extent[0] - handleMinMax[0];\n            }\n            if (delta > 0 && handleMinMax[1] + delta > extent[1]) {\n                delta = extent[1] - handleMinMax[1];\n            }\n            return delta;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/helper/sliderMove.js\n// module id = 80\n// module chunks = 0 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var defaultOption = {\n        show: true,\n        zlevel: 0,                  // \n        z: 0,                       // \n        // \n        inverse: false,\n\n        // \n        name: '',\n        // 'start' | 'middle' | 'end'\n        nameLocation: 'end',\n        // degree\n        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n        nameTruncate: {\n            maxWidth: null,\n            ellipsis: '...',\n            placeholder: '.'\n        },\n        // \n        nameTextStyle: {},\n        // \n        nameGap: 15,\n\n        silent: false, // Default false to support tooltip.\n        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n        tooltip: {\n            show: false\n        },\n\n        // \n        axisLine: {\n            // show\n            show: true,\n            onZero: true,\n            // lineStyle\n            lineStyle: {\n                color: '#333',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        axisTick: {\n            // show\n            show: true,\n            // grid\n            inside: false,\n            // length\n            length: 5,\n            // lineStyle\n            lineStyle: {\n                width: 1\n            }\n        },\n        // axis.axisLabel\n        axisLabel: {\n            show: true,\n            // grid\n            inside: false,\n            rotate: 0,\n            margin: 8,\n            // formatter: null,\n            // TEXTSTYLE\n            textStyle: {\n                fontSize: 12\n            }\n        },\n        // \n        splitLine: {\n            // show\n            show: true,\n            // lineStylelineStyle\n            lineStyle: {\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        splitArea: {\n            // show\n            show: false,\n            // areaStyleareaStyle\n            areaStyle: {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    };\n\n    var categoryAxis = zrUtil.merge({\n        // \n        boundaryGap: true,\n        // splitArea: {\n            // show: false\n        // },\n        splitLine: {\n            show: false\n        },\n        // \n        axisTick: {\n            // If tick is align with label when boundaryGap is true\n            // Default with axisTick\n            alignWithLabel: false,\n            interval: 'auto'\n        },\n        // axis.axisLabel\n        axisLabel: {\n            interval: 'auto'\n        }\n    }, defaultOption);\n\n    var valueAxis = zrUtil.merge({\n        // \n        boundaryGap: [0, 0],\n        // ,  'dataMin' \n        // min: null,\n        //  'dataMax' \n        // max: null,\n        // Readonly prop, specifies start value of the range when using data zoom.\n        // rangeStart: null\n        // Readonly prop, specifies end value of the range when using data zoom.\n        // rangeEnd: null\n        // 0_min_max\n        // scale: false,\n        // 5\n        splitNumber: 5\n        // Minimum interval\n        // minInterval: null\n    }, defaultOption);\n\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n        scale: true,\n        min: 'dataMin',\n        max: 'dataMax'\n    }, valueAxis);\n    var logAxis = zrUtil.defaults({\n        logBase: 10\n    }, valueAxis);\n    logAxis.scale = true;\n\n    module.exports = {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/axisDefault.js\n// module id = 81\n// module chunks = 0 1 2","\n\n    module.exports = {\n\n        /**\n         * @public\n         * @return {Array.<number|string|Date>}\n         */\n        getMin: function () {\n            var option = this.option;\n            var min = option.rangeStart != null ? option.rangeStart : option.min;\n            // In case of axis.type === 'time', Date should be converted to timestamp.\n            // In other cases, min/max should be a number or null/undefined or 'dataMin/Max'.\n            if (min instanceof Date) {\n                min = +min;\n            }\n            return min;\n        },\n\n        /**\n         * @public\n         * @return {Array.<number|string|Date>}\n         */\n        getMax: function () {\n            var option = this.option;\n            var max = option.rangeEnd != null ? option.rangeEnd : option.max;\n            // In case of axis.type === 'time', Date should be converted to timestamp.\n            // In other cases, min/max should be a number or null/undefined or 'dataMin/Max'.\n            if (max instanceof Date) {\n                max = +max;\n            }\n            return max;\n        },\n\n        /**\n         * @public\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * @public\n         * @param {number} rangeStart\n         * @param {number} rangeEnd\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * @public\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/axisModelZoomMixin.js\n// module id = 82\n// module chunks = 0 1 2","\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            diff = currCall - (debounce ? lastCall : lastExec) - delay;\n\n            clearTimeout(timer);\n\n            if (debounce) {\n                timer = setTimeout(exec, delay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/throttle.js\n// module id = 83\n// module chunks = 0 1","\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/line.js\n// module id = 84\n// module chunks = 0 1 2","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/quadratic.js\n// module id = 85\n// module chunks = 0 1 2","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/windingLine.js\n// module id = 86\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/LinearGradient.js\n// module id = 87\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = this.origin;\n\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n    /**\n     * transformcontext\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n\n    var tmpTransform = [];\n\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Transformable.js\n// module id = 88\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\n    ];\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/ExtensionAPI.js\n// module id = 89\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    require('../coord/cartesian/Grid');\n\n    require('./bar/BarSeries');\n    require('./bar/BarView');\n\n    var barLayoutGrid = require('../layout/barGrid');\n    var echarts = require('../echarts');\n\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n\n    // In case developer forget to include grid component\n    require('../component/grid');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/bar.js\n// module id = 90\n// module chunks = 0 1 2","'use strict';\n\n\n    var SeriesModel = require('../../model/Series');\n    var createListFromArray = require('../helper/createListFromArray');\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.bar',\n\n        dependencies: ['grid', 'polar'],\n\n        getInitialData: function (option, ecModel) {\n            if (__DEV__) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'cartesian2d') {\n                    throw new Error('Bar only support cartesian2d coordinateSystem');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [NaN, NaN];\n        },\n\n        brushSelector: 'rect',\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            // stack: null\n\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // 0\n            barMinHeight: 0,\n\n            // barMaxWidth: null,\n            // \n            // barWidth: null,\n            // 30%\n            // barGap: '30%',\n            // 20%\n            // barCategoryGap: '20%',\n            // label: {\n            //     normal: {\n            //         show: false\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    // color: ''\n                },\n                emphasis: {}\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/bar/BarSeries.js\n// module id = 91\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n\n    zrUtil.extend(require('../../model/Model').prototype, require('./barItemStyle'));\n\n    function fixLayoutWithLineWidth(layout, lineWidth) {\n        var signX = layout.width > 0 ? 1 : -1;\n        var signY = layout.height > 0 ? 1 : -1;\n        // In case width or height are too small.\n        lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));\n        layout.x += signX * lineWidth / 2;\n        layout.y += signY * lineWidth / 2;\n        layout.width -= signX * lineWidth;\n        layout.height -= signY * lineWidth;\n    }\n\n    module.exports = require('../../echarts').extendChartView({\n\n        type: 'bar',\n\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n            if (coordinateSystemType === 'cartesian2d') {\n                this._renderOnCartesian(seriesModel, ecModel, api);\n            }\n\n            return this.group;\n        },\n\n        dispose: zrUtil.noop,\n\n        _renderOnCartesian: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var isHorizontal = baseAxis.isHorizontal();\n\n            var enableAnimation = seriesModel.get('animation');\n\n            var barBorderWidthQuery = ['itemStyle', 'normal', 'barBorderWidth'];\n\n            function createRect(dataIndex, isUpdate) {\n                var layout = data.getItemLayout(dataIndex);\n                var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;\n                fixLayoutWithLineWidth(layout, lineWidth);\n\n                var rect = new graphic.Rect({\n                    shape: zrUtil.extend({}, layout)\n                });\n                // Animation\n                if (enableAnimation) {\n                    var rectShape = rect.shape;\n                    var animateProperty = isHorizontal ? 'height' : 'width';\n                    var animateTarget = {};\n                    rectShape[animateProperty] = 0;\n                    animateTarget[animateProperty] = layout[animateProperty];\n                    graphic[isUpdate? 'updateProps' : 'initProps'](rect, {\n                        shape: animateTarget\n                    }, seriesModel, dataIndex);\n                }\n                return rect;\n            }\n            data.diff(oldData)\n                .add(function (dataIndex) {\n                    // \n                    if (!data.hasValue(dataIndex)) {\n                        return;\n                    }\n\n                    var rect = createRect(dataIndex);\n\n                    data.setItemGraphicEl(dataIndex, rect);\n\n                    group.add(rect);\n\n                })\n                .update(function (newIndex, oldIndex) {\n                    var rect = oldData.getItemGraphicEl(oldIndex);\n                    // \n                    if (!data.hasValue(newIndex)) {\n                        group.remove(rect);\n                        return;\n                    }\n                    if (!rect) {\n                        rect = createRect(newIndex, true);\n                    }\n\n                    var layout = data.getItemLayout(newIndex);\n                    var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;\n                    fixLayoutWithLineWidth(layout, lineWidth);\n\n                    graphic.updateProps(rect, {\n                        shape: layout\n                    }, seriesModel, newIndex);\n\n                    data.setItemGraphicEl(newIndex, rect);\n\n                    // Add back\n                    group.add(rect);\n                })\n                .remove(function (idx) {\n                    var rect = oldData.getItemGraphicEl(idx);\n                    if (rect) {\n                        // Not show text when animating\n                        rect.style.text = '';\n                        graphic.updateProps(rect, {\n                            shape: {\n                                width: 0\n                            }\n                        }, seriesModel, idx, function () {\n                            group.remove(rect);\n                        });\n                    }\n                })\n                .execute();\n\n            this._updateStyle(seriesModel, data, isHorizontal);\n\n            this._data = data;\n        },\n\n        _updateStyle: function (seriesModel, data, isHorizontal) {\n            function setLabel(style, model, color, labelText, labelPositionOutside) {\n                graphic.setText(style, model, color);\n                style.text = labelText;\n                if (style.textPosition === 'outside') {\n                    style.textPosition = labelPositionOutside;\n                }\n            }\n\n            data.eachItemGraphicEl(function (rect, idx) {\n                var itemModel = data.getItemModel(idx);\n                var color = data.getItemVisual(idx, 'color');\n                var opacity = data.getItemVisual(idx, 'opacity');\n                var layout = data.getItemLayout(idx);\n                var itemStyleModel = itemModel.getModel('itemStyle.normal');\n\n                var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n                rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n\n                rect.useStyle(zrUtil.defaults(\n                    {\n                        fill: color,\n                        opacity: opacity\n                    },\n                    itemStyleModel.getBarItemStyle()\n                ));\n\n                var labelPositionOutside = isHorizontal\n                    ? (layout.height > 0 ? 'bottom' : 'top')\n                    : (layout.width > 0 ? 'left' : 'right');\n\n                var labelModel = itemModel.getModel('label.normal');\n                var hoverLabelModel = itemModel.getModel('label.emphasis');\n                var rectStyle = rect.style;\n                if (labelModel.get('show')) {\n                    setLabel(\n                        rectStyle, labelModel, color,\n                        zrUtil.retrieve(\n                            seriesModel.getFormattedLabel(idx, 'normal'),\n                            seriesModel.getRawValue(idx)\n                        ),\n                        labelPositionOutside\n                    );\n                }\n                else {\n                    rectStyle.text = '';\n                }\n                if (hoverLabelModel.get('show')) {\n                    setLabel(\n                        hoverStyle, hoverLabelModel, color,\n                        zrUtil.retrieve(\n                            seriesModel.getFormattedLabel(idx, 'emphasis'),\n                            seriesModel.getRawValue(idx)\n                        ),\n                        labelPositionOutside\n                    );\n                }\n                else {\n                    hoverStyle.text = '';\n                }\n                graphic.setHoverStyle(rect, hoverStyle);\n            });\n        },\n\n        remove: function (ecModel, api) {\n            var group = this.group;\n            if (ecModel.get('animation')) {\n                if (this._data) {\n                    this._data.eachItemGraphicEl(function (el) {\n                        // Not show text when animating\n                        el.style.text = '';\n                        graphic.updateProps(el, {\n                            shape: {\n                                width: 0\n                            }\n                        }, ecModel, el.dataIndex, function () {\n                            group.remove(el);\n                        });\n                    });\n                }\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/bar/BarView.js\n// module id = 92\n// module chunks = 0 1 2","\n\n\n    var getBarItemStyle = require('../../model/mixin/makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            // Compatitable with 2\n            ['stroke', 'barBorderColor'],\n            ['lineWidth', 'barBorderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/bar/barItemStyle.js\n// module id = 93\n// module chunks = 0 1 2","/**\n * @module echarts/chart/helper/Line\n */\n\n\n    var symbolUtil = require('../../util/symbol');\n    var vector = require('zrender/lib/core/vector');\n    // var matrix = require('zrender/lib/core/matrix');\n    var LinePath = require('./LinePath');\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../../util/number');\n\n    var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];\n    function makeSymbolTypeKey(symbolCategory) {\n        return '_' + symbolCategory + 'Type';\n    }\n    /**\n     * @inner\n     */\n    function createSymbol(name, lineData, idx) {\n        var color = lineData.getItemVisual(idx, 'color');\n        var symbolType = lineData.getItemVisual(idx, name);\n        var symbolSize = lineData.getItemVisual(idx, name + 'Size');\n\n        if (!symbolType || symbolType === 'none') {\n            return;\n        }\n\n        if (!zrUtil.isArray(symbolSize)) {\n            symbolSize = [symbolSize, symbolSize];\n        }\n        var symbolPath = symbolUtil.createSymbol(\n            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\n            symbolSize[0], symbolSize[1], color\n        );\n\n        symbolPath.name = name;\n\n        return symbolPath;\n    }\n\n    function createLine(points) {\n        var line = new LinePath({\n            name: 'line'\n        });\n        setLinePoints(line.shape, points);\n        return line;\n    }\n\n    function setLinePoints(targetShape, points) {\n        var p1 = points[0];\n        var p2 = points[1];\n        var cp1 = points[2];\n        targetShape.x1 = p1[0];\n        targetShape.y1 = p1[1];\n        targetShape.x2 = p2[0];\n        targetShape.y2 = p2[1];\n        targetShape.percent = 1;\n\n        if (cp1) {\n            targetShape.cpx1 = cp1[0];\n            targetShape.cpy1 = cp1[1];\n        }\n        else {\n            targetShape.cpx1 = NaN;\n            targetShape.cpy1 = NaN;\n        }\n    }\n\n    function updateSymbolAndLabelBeforeLineUpdate () {\n        var lineGroup = this;\n        var symbolFrom = lineGroup.childOfName('fromSymbol');\n        var symbolTo = lineGroup.childOfName('toSymbol');\n        var label = lineGroup.childOfName('label');\n        // Quick reject\n        if (!symbolFrom && !symbolTo && label.ignore) {\n            return;\n        }\n\n        var invScale = 1;\n        var parentNode = this.parent;\n        while (parentNode) {\n            if (parentNode.scale) {\n                invScale /= parentNode.scale[0];\n            }\n            parentNode = parentNode.parent;\n        }\n\n        var line = lineGroup.childOfName('line');\n        // If line not changed\n        // FIXME Parent scale changed\n        if (!this.__dirty && !line.__dirty) {\n            return;\n        }\n\n        var percent = line.shape.percent;\n        var fromPos = line.pointAt(0);\n        var toPos = line.pointAt(percent);\n\n        var d = vector.sub([], toPos, fromPos);\n        vector.normalize(d, d);\n\n        if (symbolFrom) {\n            symbolFrom.attr('position', fromPos);\n            var tangent = line.tangentAt(0);\n            symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(\n                tangent[1], tangent[0]\n            ));\n            symbolFrom.attr('scale', [invScale * percent, invScale * percent]);\n        }\n        if (symbolTo) {\n            symbolTo.attr('position', toPos);\n            var tangent = line.tangentAt(1);\n            symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(\n                tangent[1], tangent[0]\n            ));\n            symbolTo.attr('scale', [invScale * percent, invScale * percent]);\n        }\n\n        if (!label.ignore) {\n            label.attr('position', toPos);\n\n            var textPosition;\n            var textAlign;\n            var textVerticalAlign;\n\n            var distance = 5 * invScale;\n            // End\n            if (label.__position === 'end') {\n                textPosition = [d[0] * distance + toPos[0], d[1] * distance + toPos[1]];\n                textAlign = d[0] > 0.8 ? 'left' : (d[0] < -0.8 ? 'right' : 'center');\n                textVerticalAlign = d[1] > 0.8 ? 'top' : (d[1] < -0.8 ? 'bottom' : 'middle');\n            }\n            // Middle\n            else if (label.__position === 'middle') {\n                var halfPercent = percent / 2;\n                var tangent = line.tangentAt(halfPercent);\n                var n = [tangent[1], -tangent[0]];\n                var cp = line.pointAt(halfPercent);\n                if (n[1] > 0) {\n                    n[0] = -n[0];\n                    n[1] = -n[1];\n                }\n                textPosition = [cp[0] + n[0] * distance, cp[1] + n[1] * distance];\n                textAlign = 'center';\n                textVerticalAlign = 'bottom';\n                var rotation = -Math.atan2(tangent[1], tangent[0]);\n                if (toPos[0] < fromPos[0]) {\n                    rotation = Math.PI + rotation;\n                }\n                label.attr('rotation', rotation);\n            }\n            // Start\n            else {\n                textPosition = [-d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1]];\n                textAlign = d[0] > 0.8 ? 'right' : (d[0] < -0.8 ? 'left' : 'center');\n                textVerticalAlign = d[1] > 0.8 ? 'bottom' : (d[1] < -0.8 ? 'top' : 'middle');\n            }\n            label.attr({\n                style: {\n                    // Use the user specified text align and baseline first\n                    textVerticalAlign: label.__verticalAlign || textVerticalAlign,\n                    textAlign: label.__textAlign || textAlign\n                },\n                position: textPosition,\n                scale: [invScale, invScale]\n            });\n        }\n    }\n\n    /**\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     * @alias {module:echarts/chart/helper/Line}\n     */\n    function Line(lineData, idx, seriesScope) {\n        graphic.Group.call(this);\n\n        this._createLine(lineData, idx, seriesScope);\n    }\n\n    var lineProto = Line.prototype;\n\n    // Update symbol position and rotation\n    lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;\n\n    lineProto._createLine = function (lineData, idx, seriesScope) {\n        var seriesModel = lineData.hostModel;\n        var linePoints = lineData.getItemLayout(idx);\n\n        var line = createLine(linePoints);\n        line.shape.percent = 0;\n        graphic.initProps(line, {\n            shape: {\n                percent: 1\n            }\n        }, seriesModel, idx);\n\n        this.add(line);\n\n        var label = new graphic.Text({\n            name: 'label'\n        });\n        this.add(label);\n\n        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n            var symbol = createSymbol(symbolCategory, lineData, idx);\n            // symbols must added after line to make sure\n            // it will be updated after line#update.\n            // Or symbol position and rotation update in line#beforeUpdate will be one frame slow\n            this.add(symbol);\n            this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);\n        }, this);\n\n        this._updateCommonStl(lineData, idx, seriesScope);\n    };\n\n    lineProto.updateData = function (lineData, idx, seriesScope) {\n        var seriesModel = lineData.hostModel;\n\n        var line = this.childOfName('line');\n        var linePoints = lineData.getItemLayout(idx);\n        var target = {\n            shape: {}\n        };\n        setLinePoints(target.shape, linePoints);\n        graphic.updateProps(line, target, seriesModel, idx);\n\n        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n            var symbolType = lineData.getItemVisual(idx, symbolCategory);\n            var key = makeSymbolTypeKey(symbolCategory);\n            // Symbol changed\n            if (this[key] !== symbolType) {\n                this.remove(this.childOfName(symbolCategory));\n                var symbol = createSymbol(symbolCategory, lineData, idx);\n                this.add(symbol);\n            }\n            this[key] = symbolType;\n        }, this);\n\n        this._updateCommonStl(lineData, idx, seriesScope);\n    };\n\n    lineProto._updateCommonStl = function (lineData, idx, seriesScope) {\n        var seriesModel = lineData.hostModel;\n\n        var line = this.childOfName('line');\n\n        var lineStyle = seriesScope && seriesScope.lineStyle;\n        var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;\n        var labelModel = seriesScope && seriesScope.labelModel;\n        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n\n        // Optimization for large dataset\n        if (!seriesScope || lineData.hasItemOption) {\n            var itemModel = lineData.getItemModel(idx);\n\n            lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle();\n            hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n\n            labelModel = itemModel.getModel('label.normal');\n            hoverLabelModel = itemModel.getModel('label.emphasis');\n        }\n\n        var visualColor = lineData.getItemVisual(idx, 'color');\n        var visualOpacity = zrUtil.retrieve(\n            lineData.getItemVisual(idx, 'opacity'),\n            lineStyle.opacity,\n            1\n        );\n\n        line.useStyle(zrUtil.defaults(\n            {\n                strokeNoScale: true,\n                fill: 'none',\n                stroke: visualColor,\n                opacity: visualOpacity\n            },\n            lineStyle\n        ));\n        line.hoverStyle = hoverLineStyle;\n\n        // Update symbol\n        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {\n            var symbol = this.childOfName(symbolCategory);\n            if (symbol) {\n                symbol.setColor(visualColor);\n                symbol.setStyle({\n                    opacity: visualOpacity\n                });\n            }\n        }, this);\n\n        var showLabel = labelModel.getShallow('show');\n        var hoverShowLabel = hoverLabelModel.getShallow('show');\n\n        var label = this.childOfName('label');\n        var defaultLabelColor;\n        var defaultText;\n\n        if (showLabel || hoverShowLabel) {\n            var rawVal = seriesModel.getRawValue(idx);\n            defaultText = rawVal == null\n                ? defaultText = lineData.getName(idx)\n                : isFinite(rawVal)\n                ? numberUtil.round(rawVal)\n                : rawVal;\n            defaultLabelColor = visualColor || '#000';\n        }\n\n        // label.afterUpdate = lineAfterUpdate;\n        if (showLabel) {\n            var textStyleModel = labelModel.getModel('textStyle');\n            label.setStyle({\n                text: zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType),\n                    defaultText\n                ),\n                textFont: textStyleModel.getFont(),\n                fill: textStyleModel.getTextColor() || defaultLabelColor\n            });\n\n            label.__textAlign = textStyleModel.get('align');\n            label.__verticalAlign = textStyleModel.get('baseline');\n            label.__position = labelModel.get('position');\n        }\n        else {\n            label.setStyle('text', '');\n        }\n        if (hoverShowLabel) {\n            var textStyleHoverModel = hoverLabelModel.getModel('textStyle');\n\n            label.hoverStyle = {\n                text: zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType),\n                    defaultText\n                ),\n                textFont: textStyleHoverModel.getFont(),\n                fill: textStyleHoverModel.getTextColor() || defaultLabelColor\n            };\n        }\n        else {\n            label.hoverStyle = {\n                text: ''\n            };\n        }\n\n        label.ignore = !showLabel && !hoverShowLabel;\n\n        graphic.setHoverStyle(this);\n    };\n\n    lineProto.updateLayout = function (lineData, idx) {\n        this.setLinePoints(lineData.getItemLayout(idx));\n    };\n\n    lineProto.setLinePoints = function (points) {\n        var linePath = this.childOfName('line');\n        setLinePoints(linePath.shape, points);\n        linePath.dirty();\n    };\n\n    zrUtil.inherits(Line, graphic.Group);\n\n    module.exports = Line;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/helper/Line.js\n// module id = 94\n// module chunks = 0 1","/**\n * @module echarts/chart/helper/LineDraw\n */\n\n\n    var graphic = require('../../util/graphic');\n    var LineGroup = require('./Line');\n\n\n    function isPointNaN(pt) {\n        return isNaN(pt[0]) || isNaN(pt[1]);\n    }\n    function lineNeedsDraw(pts) {\n        return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);\n    }\n    /**\n     * @alias module:echarts/component/marker/LineDraw\n     * @constructor\n     */\n    function LineDraw(ctor) {\n        this._ctor = ctor || LineGroup;\n        this.group = new graphic.Group();\n    }\n\n    var lineDrawProto = LineDraw.prototype;\n\n    /**\n     * @param {module:echarts/data/List} lineData\n     */\n    lineDrawProto.updateData = function (lineData) {\n\n        var oldLineData = this._lineData;\n        var group = this.group;\n        var LineCtor = this._ctor;\n\n        var hostModel = lineData.hostModel;\n\n        var seriesScope = {\n            lineStyle: hostModel.getModel('lineStyle.normal').getLineStyle(),\n            hoverLineStyle: hostModel.getModel('lineStyle.emphasis').getLineStyle(),\n            labelModel: hostModel.getModel('label.normal'),\n            hoverLabelModel: hostModel.getModel('label.emphasis')\n        };\n\n        lineData.diff(oldLineData)\n            .add(function (idx) {\n                if (!lineNeedsDraw(lineData.getItemLayout(idx))) {\n                    return;\n                }\n                var lineGroup = new LineCtor(lineData, idx, seriesScope);\n\n                lineData.setItemGraphicEl(idx, lineGroup);\n\n                group.add(lineGroup);\n            })\n            .update(function (newIdx, oldIdx) {\n                var lineGroup = oldLineData.getItemGraphicEl(oldIdx);\n                if (!lineNeedsDraw(lineData.getItemLayout(newIdx))) {\n                    group.remove(lineGroup);\n                    return;\n                }\n\n                if (!lineGroup) {\n                    lineGroup = new LineCtor(lineData, newIdx, seriesScope);\n                }\n                else {\n                    lineGroup.updateData(lineData, newIdx, seriesScope);\n                }\n\n                lineData.setItemGraphicEl(newIdx, lineGroup);\n\n                group.add(lineGroup);\n            })\n            .remove(function (idx) {\n                group.remove(oldLineData.getItemGraphicEl(idx));\n            })\n            .execute();\n\n        this._lineData = lineData;\n    };\n\n    lineDrawProto.updateLayout = function () {\n        var lineData = this._lineData;\n        lineData.eachItemGraphicEl(function (el, idx) {\n            el.updateLayout(lineData, idx);\n        }, this);\n    };\n\n    lineDrawProto.remove = function () {\n        this.group.removeAll();\n    };\n\n    module.exports = LineDraw;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/helper/LineDraw.js\n// module id = 95\n// module chunks = 0 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n    var PRIORITY = echarts.PRIORITY;\n\n    require('./line/LineSeries');\n    require('./line/LineView');\n\n    echarts.registerVisual(zrUtil.curry(\n        require('../visual/symbol'), 'line', 'circle', 'line'\n    ));\n    echarts.registerLayout(zrUtil.curry(\n        require('../layout/points'), 'line'\n    ));\n\n    // Down sample after filter\n    echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(\n        require('../processor/dataSample'), 'line'\n    ));\n\n    // In case developer forget to include grid component\n    require('../component/grid');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/line.js\n// module id = 96\n// module chunks = 0 1 2","'use strict';\n\n\n    var createListFromArray = require('../helper/createListFromArray');\n    var SeriesModel = require('../../model/Series');\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.line',\n\n        dependencies: ['grid', 'polar'],\n\n        getInitialData: function (option, ecModel) {\n            if (__DEV__) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {\n                    throw new Error('Line not support coordinateSystem besides cartesian and polar');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // stack: null\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // polarIndex: 0,\n\n            // If clip the overflow value\n            clipOverflow: true,\n\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // itemStyle: {\n            //     normal: {},\n            //     emphasis: {}\n            // },\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            // areaStyle: {},\n            // false, 'start', 'end', 'middle'\n            step: false,\n\n            // Disabled if step is true\n            smooth: false,\n            smoothMonotone: null,\n            // \n            symbol: 'emptyCircle',\n            // \n            symbolSize: 4,\n            // \n            symbolRotate: null,\n\n            //  symbol,  tooltip hover \n            showSymbol: true,\n            // \n            showAllSymbol: false,\n\n            // \n            connectNulls: false,\n\n            // 'average', 'max', 'min', 'sum'\n            sampling: 'none',\n\n            animationEasing: 'linear',\n\n            // Disable progressive\n            progressive: 0,\n            hoverLayerThreshold: Infinity\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/line/LineSeries.js\n// module id = 97\n// module chunks = 0 1 2","'use strict';\n// FIXME step not support polar\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var SymbolDraw = require('../helper/SymbolDraw');\n    var Symbol = require('../helper/Symbol');\n    var lineAnimationDiff = require('./lineAnimationDiff');\n    var graphic = require('../../util/graphic');\n    var modelUtil = require('../../util/model');\n\n    var polyHelper = require('./poly');\n\n    var ChartView = require('../../view/Chart');\n\n    function isPointsSame(points1, points2) {\n        if (points1.length !== points2.length) {\n            return;\n        }\n        for (var i = 0; i < points1.length; i++) {\n            var p1 = points1[i];\n            var p2 = points2[i];\n            if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n                return;\n            }\n        }\n        return true;\n    }\n\n    function getSmooth(smooth) {\n        return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);\n    }\n\n    function getAxisExtentWithGap(axis) {\n        var extent = axis.getGlobalExtent();\n        if (axis.onBand) {\n            // Remove extra 1px to avoid line miter in clipped edge\n            var halfBandWidth = axis.getBandWidth() / 2 - 1;\n            var dir = extent[1] > extent[0] ? 1 : -1;\n            extent[0] += dir * halfBandWidth;\n            extent[1] -= dir * halfBandWidth;\n        }\n        return extent;\n    }\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n    /**\n     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n     * @param {module:echarts/data/List} data\n     * @param {Array.<Array.<number>>} points\n     * @private\n     */\n    function getStackedOnPoints(coordSys, data) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        return data.mapArray([valueDim], function (val, idx) {\n            var stackedOnSameSign;\n            var stackedOn = data.stackedOn;\n            // Find first stacked value with same sign\n            while (stackedOn &&\n                sign(stackedOn.get(valueDim, idx)) === sign(val)\n            ) {\n                stackedOnSameSign = stackedOn;\n                break;\n            }\n            var stackedData = [];\n            stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n            stackedData[1 - baseDataOffset] = stackedOnSameSign\n                ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n            return coordSys.dataToPoint(stackedData);\n        }, true);\n    }\n\n    function createGridClipShape(cartesian, hasAnimation, seriesModel) {\n        var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n        var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n        var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n\n        var x = Math.min(xExtent[0], xExtent[1]);\n        var y = Math.min(yExtent[0], yExtent[1]);\n        var width = Math.max(xExtent[0], xExtent[1]) - x;\n        var height = Math.max(yExtent[0], yExtent[1]) - y;\n        var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;\n        // Expand clip shape to avoid clipping when line value exceeds axis\n        var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n        if (isHorizontal) {\n            y -= expandSize;\n            height += expandSize * 2;\n        }\n        else {\n            x -= expandSize;\n            width += expandSize * 2;\n        }\n\n        var clipPath = new graphic.Rect({\n            shape: {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n            graphic.initProps(clipPath, {\n                shape: {\n                    width: width,\n                    height: height\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createPolarClipShape(polar, hasAnimation, seriesModel) {\n        var angleAxis = polar.getAngleAxis();\n        var radiusAxis = polar.getRadiusAxis();\n\n        var radiusExtent = radiusAxis.getExtent();\n        var angleExtent = angleAxis.getExtent();\n\n        var RADIAN = Math.PI / 180;\n\n        var clipPath = new graphic.Sector({\n            shape: {\n                cx: polar.cx,\n                cy: polar.cy,\n                r0: radiusExtent[0],\n                r: radiusExtent[1],\n                startAngle: -angleExtent[0] * RADIAN,\n                endAngle: -angleExtent[1] * RADIAN,\n                clockwise: angleAxis.inverse\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: -angleExtent[1] * RADIAN\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createClipShape(coordSys, hasAnimation, seriesModel) {\n        return coordSys.type === 'polar'\n            ? createPolarClipShape(coordSys, hasAnimation, seriesModel)\n            : createGridClipShape(coordSys, hasAnimation, seriesModel);\n    }\n\n    function turnPointsIntoStep(points, coordSys, stepTurnAt) {\n        var baseAxis = coordSys.getBaseAxis();\n        var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\n        var stepPoints = [];\n        for (var i = 0; i < points.length - 1; i++) {\n            var nextPt = points[i + 1];\n            var pt = points[i];\n            stepPoints.push(pt);\n\n            var stepPt = [];\n            switch (stepTurnAt) {\n                case 'end':\n                    stepPt[baseIndex] = nextPt[baseIndex];\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n                    break;\n                case 'middle':\n                    // default is start\n                    var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n                    var stepPt2 = [];\n                    stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n                    stepPoints.push(stepPt);\n                    stepPoints.push(stepPt2);\n                    break;\n                default:\n                    stepPt[baseIndex] = pt[baseIndex];\n                    stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n            }\n        }\n        // Last points\n        points[i] && stepPoints.push(points[i]);\n        return stepPoints;\n    }\n\n    function clamp(number, extent) {\n        return Math.max(Math.min(number, extent[1]), extent[0]);\n    }\n\n    function getVisualGradient(data, coordSys) {\n        var visualMetaList = data.getVisual('visualMeta');\n        if (!visualMetaList || !visualMetaList.length || !data.count()) {\n            // When data.count() is 0, gradient range can not be calculated.\n            return;\n        }\n\n        var visualMeta;\n        for (var i = visualMetaList.length - 1; i >= 0; i--) {\n            // Can only be x or y\n            if (visualMetaList[i].dimension < 2) {\n                visualMeta = visualMetaList[i];\n                break;\n            }\n        }\n        if (!visualMeta || coordSys.type !== 'cartesian2d') {\n            if (__DEV__) {\n                console.warn('Visual map on line style only support x or y dimension.');\n            }\n            return;\n        }\n\n        var dimension = visualMeta.dimension;\n        var dimName = data.dimensions[dimension];\n        var dataExtent = data.getDataExtent(dimName);\n\n        var stops = visualMeta.stops;\n\n        var colorStops = [];\n        if (stops[0].interval) {\n            stops.sort(function (a, b) {\n                return a.interval[0] - b.interval[0];\n            });\n        }\n\n        var firstStop = stops[0];\n        var lastStop = stops[stops.length - 1];\n        // Interval can be infinity in piecewise case\n        var min = firstStop.interval ? clamp(firstStop.interval[0], dataExtent) : firstStop.value;\n        var max = lastStop.interval ? clamp(lastStop.interval[1], dataExtent) : lastStop.value;\n        var stopsSpan = max - min;\n\n        // In the piecewise case data out of visual range\n        // ----dataMin----dataMax-----visualMin----visualMax\n        if (stopsSpan === 0) {\n            return data.getItemVisual(0, 'color');\n        }\n        for (var i = 0; i < stops.length; i++) {\n            // Piecewise\n            if (stops[i].interval) {\n                if (stops[i].interval[1] === stops[i].interval[0]) {\n                    continue;\n                }\n                colorStops.push({\n                    // Make sure offset is between 0 and 1\n                    offset: (clamp(stops[i].interval[0], dataExtent) - min) / stopsSpan,\n                    color: stops[i].color\n                }, {\n                    offset: (clamp(stops[i].interval[1], dataExtent) - min) / stopsSpan,\n                    color: stops[i].color\n                });\n            }\n            // Continous\n            else {\n                // if (i > 0 && stops[i].value === stops[i - 1].value) {\n                //     continue;\n                // }\n                colorStops.push({\n                    offset: (stops[i].value - min) / stopsSpan,\n                    color: stops[i].color\n                });\n            }\n        }\n\n        var gradient = new graphic.LinearGradient(\n            0, 0, 0, 0, colorStops, true\n        );\n        var axis = coordSys.getAxis(dimName);\n\n        var start = axis.toGlobalCoord(axis.dataToCoord(min));\n        var end = axis.toGlobalCoord(axis.dataToCoord(max));\n        // zrUtil.each(colorStops, function (colorStop) {\n        //     // Make sure each offset has rounded px to avoid not sharp edge\n        //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n        // });\n\n        gradient[dimName] = start;\n        gradient[dimName + '2'] = end;\n\n        return gradient;\n    }\n\n    module.exports = ChartView.extend({\n\n        type: 'line',\n\n        init: function () {\n            var lineGroup = new graphic.Group();\n\n            var symbolDraw = new SymbolDraw();\n            this.group.add(symbolDraw.group);\n\n            this._symbolDraw = symbolDraw;\n            this._lineGroup = lineGroup;\n        },\n\n        render: function (seriesModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var group = this.group;\n            var data = seriesModel.getData();\n            var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n            var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n\n            var points = data.mapArray(data.getItemLayout, true);\n\n            var isCoordSysPolar = coordSys.type === 'polar';\n            var prevCoordSys = this._coordSys;\n\n            var symbolDraw = this._symbolDraw;\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n\n            var lineGroup = this._lineGroup;\n\n            var hasAnimation = seriesModel.get('animation');\n\n            var isAreaChart = !areaStyleModel.isEmpty();\n            var stackedOnPoints = getStackedOnPoints(coordSys, data);\n\n            var showSymbol = seriesModel.get('showSymbol');\n\n            var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol')\n                && this._getSymbolIgnoreFunc(data, coordSys);\n\n            // Remove temporary symbols\n            var oldData = this._data;\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            // Remove previous created symbols if showSymbol changed to false\n            if (!showSymbol) {\n                symbolDraw.remove();\n            }\n\n            group.add(lineGroup);\n\n            // FIXME step not support polar\n            var step = !isCoordSysPolar && seriesModel.get('step');\n            // Initialization animation or coordinate system changed\n            if (\n                !(polyline && prevCoordSys.type === coordSys.type && step === this._step)\n            ) {\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                if (step) {\n                    // TODO If stacked series is not step\n                    points = turnPointsIntoStep(points, coordSys, step);\n                    stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                }\n\n                polyline = this._newPolyline(points, coordSys, hasAnimation);\n                if (isAreaChart) {\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n            }\n            else {\n                if (isAreaChart && !polygon) {\n                    // If areaStyle is added\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                else if (polygon && !isAreaChart) {\n                    // If areaStyle is removed\n                    lineGroup.remove(polygon);\n                    polygon = this._polygon = null;\n                }\n\n                // Update clipPath\n                lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));\n\n                // Always update, or it is wrong in the case turning on legend\n                // because points are not changed\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                // Stop symbol animation and sync with line points\n                // FIXME performance?\n                data.eachItemGraphicEl(function (el) {\n                    el.stopAnimation(true);\n                });\n\n                // In the case data zoom triggerred refreshing frequently\n                // Data may not change if line has a category axis. So it should animate nothing\n                if (!isPointsSame(this._stackedOnPoints, stackedOnPoints)\n                    || !isPointsSame(this._points, points)\n                ) {\n                    if (hasAnimation) {\n                        this._updateAnimation(\n                            data, stackedOnPoints, coordSys, api, step\n                        );\n                    }\n                    else {\n                        // Not do it in update with animation\n                        if (step) {\n                            // TODO If stacked series is not step\n                            points = turnPointsIntoStep(points, coordSys, step);\n                            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                        }\n\n                        polyline.setShape({\n                            points: points\n                        });\n                        polygon && polygon.setShape({\n                            points: points,\n                            stackedOnPoints: stackedOnPoints\n                        });\n                    }\n                }\n            }\n\n            var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n\n            polyline.useStyle(zrUtil.defaults(\n                // Use color in lineStyle first\n                lineStyleModel.getLineStyle(),\n                {\n                    fill: 'none',\n                    stroke: visualColor,\n                    lineJoin: 'bevel'\n                }\n            ));\n\n            var smooth = seriesModel.get('smooth');\n            smooth = getSmooth(seriesModel.get('smooth'));\n            polyline.setShape({\n                smooth: smooth,\n                smoothMonotone: seriesModel.get('smoothMonotone'),\n                connectNulls: seriesModel.get('connectNulls')\n            });\n\n            if (polygon) {\n                var stackedOn = data.stackedOn;\n                var stackedOnSmooth = 0;\n\n                polygon.useStyle(zrUtil.defaults(\n                    areaStyleModel.getAreaStyle(),\n                    {\n                        fill: visualColor,\n                        opacity: 0.7,\n                        lineJoin: 'bevel'\n                    }\n                ));\n\n                if (stackedOn) {\n                    var stackedOnSeries = stackedOn.hostModel;\n                    stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n                }\n\n                polygon.setShape({\n                    smooth: smooth,\n                    stackedOnSmooth: stackedOnSmooth,\n                    smoothMonotone: seriesModel.get('smoothMonotone'),\n                    connectNulls: seriesModel.get('connectNulls')\n                });\n            }\n\n            this._data = data;\n            // Save the coordinate system for transition animation when data changed\n            this._coordSys = coordSys;\n            this._stackedOnPoints = stackedOnPoints;\n            this._points = points;\n            this._step = step;\n        },\n\n        dispose: function () {},\n\n        highlight: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n            if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (!symbol) {\n                    // Create a temporary symbol if it is not exists\n                    var pt = data.getItemLayout(dataIndex);\n                    symbol = new Symbol(data, dataIndex);\n                    symbol.position = pt;\n                    symbol.setZ(\n                        seriesModel.get('zlevel'),\n                        seriesModel.get('z')\n                    );\n                    symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n                    symbol.__temp = true;\n                    data.setItemGraphicEl(dataIndex, symbol);\n\n                    // Stop scale animation\n                    symbol.stopSymbolAnimation(true);\n\n                    this.group.add(symbol);\n                }\n                symbol.highlight();\n            }\n            else {\n                // Highlight whole series\n                ChartView.prototype.highlight.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        downplay: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n            if (dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (symbol) {\n                    if (symbol.__temp) {\n                        data.setItemGraphicEl(dataIndex, null);\n                        this.group.remove(symbol);\n                    }\n                    else {\n                        symbol.downplay();\n                    }\n                }\n            }\n            else {\n                // Downplay whole series\n                ChartView.prototype.downplay.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolyline: function (points) {\n            var polyline = this._polyline;\n            // Remove previous created polyline\n            if (polyline) {\n                this._lineGroup.remove(polyline);\n            }\n\n            polyline = new polyHelper.Polyline({\n                shape: {\n                    points: points\n                },\n                silent: true,\n                z2: 10\n            });\n\n            this._lineGroup.add(polyline);\n\n            this._polyline = polyline;\n\n            return polyline;\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} stackedOnPoints\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolygon: function (points, stackedOnPoints) {\n            var polygon = this._polygon;\n            // Remove previous created polygon\n            if (polygon) {\n                this._lineGroup.remove(polygon);\n            }\n\n            polygon = new polyHelper.Polygon({\n                shape: {\n                    points: points,\n                    stackedOnPoints: stackedOnPoints\n                },\n                silent: true\n            });\n\n            this._lineGroup.add(polygon);\n\n            this._polygon = polygon;\n            return polygon;\n        },\n        /**\n         * @private\n         */\n        _getSymbolIgnoreFunc: function (data, coordSys) {\n            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n            // `getLabelInterval` is provided by echarts/component/axis\n            if (categoryAxis && categoryAxis.isLabelIgnored) {\n                return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n            }\n        },\n\n        /**\n         * @private\n         */\n        // FIXME Two value axis\n        _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n            var seriesModel = data.hostModel;\n\n            var diff = lineAnimationDiff(\n                this._data, data,\n                this._stackedOnPoints, stackedOnPoints,\n                this._coordSys, coordSys\n            );\n\n            var current = diff.current;\n            var stackedOnCurrent = diff.stackedOnCurrent;\n            var next = diff.next;\n            var stackedOnNext = diff.stackedOnNext;\n            if (step) {\n                // TODO If stacked series is not step\n                current = turnPointsIntoStep(diff.current, coordSys, step);\n                stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n                next = turnPointsIntoStep(diff.next, coordSys, step);\n                stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n            }\n            // `diff.current` is subset of `current` (which should be ensured by\n            // turnPointsIntoStep), so points in `__points` can be updated when\n            // points in `current` are update during animation.\n            polyline.shape.__points = diff.current;\n            polyline.shape.points = current;\n\n            graphic.updateProps(polyline, {\n                shape: {\n                    points: next\n                }\n            }, seriesModel);\n\n            if (polygon) {\n                polygon.setShape({\n                    points: current,\n                    stackedOnPoints: stackedOnCurrent\n                });\n                graphic.updateProps(polygon, {\n                    shape: {\n                        points: next,\n                        stackedOnPoints: stackedOnNext\n                    }\n                }, seriesModel);\n            }\n\n            var updatedDataInfo = [];\n            var diffStatus = diff.status;\n\n            for (var i = 0; i < diffStatus.length; i++) {\n                var cmd = diffStatus[i].cmd;\n                if (cmd === '=') {\n                    var el = data.getItemGraphicEl(diffStatus[i].idx1);\n                    if (el) {\n                        updatedDataInfo.push({\n                            el: el,\n                            ptIdx: i    // Index of points\n                        });\n                    }\n                }\n            }\n\n            if (polyline.animators && polyline.animators.length) {\n                polyline.animators[0].during(function () {\n                    for (var i = 0; i < updatedDataInfo.length; i++) {\n                        var el = updatedDataInfo[i].el;\n                        el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n                    }\n                });\n            }\n        },\n\n        remove: function (ecModel) {\n            var group = this.group;\n            var oldData = this._data;\n            this._lineGroup.removeAll();\n            this._symbolDraw.remove(true);\n            // Remove temporary created elements when highlighting\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            this._polyline =\n            this._polygon =\n            this._coordSys =\n            this._points =\n            this._stackedOnPoints =\n            this._data = null;\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/line/LineView.js\n// module id = 98\n// module chunks = 0 1 2","\n\n    // var arrayDiff = require('zrender/lib/core/arrayDiff');\n    // 'zrender/core/arrayDiff' has been used before, but it did\n    // not do well in performance when roam with fixed dataZoom window.\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n\n    function getStackedOnPoint(coordSys, data, idx) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        var stackedOnSameSign;\n        var stackedOn = data.stackedOn;\n        var val = data.get(valueDim, idx);\n        // Find first stacked value with same sign\n        while (stackedOn &&\n            sign(stackedOn.get(valueDim, idx)) === sign(val)\n        ) {\n            stackedOnSameSign = stackedOn;\n            break;\n        }\n        var stackedData = [];\n        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n        stackedData[1 - baseDataOffset] = stackedOnSameSign\n            ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n        return coordSys.dataToPoint(stackedData);\n    }\n\n    // function convertToIntId(newIdList, oldIdList) {\n    //     // Generate int id instead of string id.\n    //     // Compare string maybe slow in score function of arrDiff\n\n    //     // Assume id in idList are all unique\n    //     var idIndicesMap = {};\n    //     var idx = 0;\n    //     for (var i = 0; i < newIdList.length; i++) {\n    //         idIndicesMap[newIdList[i]] = idx;\n    //         newIdList[i] = idx++;\n    //     }\n    //     for (var i = 0; i < oldIdList.length; i++) {\n    //         var oldId = oldIdList[i];\n    //         // Same with newIdList\n    //         if (idIndicesMap[oldId]) {\n    //             oldIdList[i] = idIndicesMap[oldId];\n    //         }\n    //         else {\n    //             oldIdList[i] = idx++;\n    //         }\n    //     }\n    // }\n\n    function diffData(oldData, newData) {\n        var diffResult = [];\n\n        newData.diff(oldData)\n            .add(function (idx) {\n                diffResult.push({cmd: '+', idx: idx});\n            })\n            .update(function (newIdx, oldIdx) {\n                diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx});\n            })\n            .remove(function (idx) {\n                diffResult.push({cmd: '-', idx: idx});\n            })\n            .execute();\n\n        return diffResult;\n    }\n\n    module.exports = function (\n        oldData, newData,\n        oldStackedOnPoints, newStackedOnPoints,\n        oldCoordSys, newCoordSys\n    ) {\n        var diff = diffData(oldData, newData);\n\n        // var newIdList = newData.mapArray(newData.getId);\n        // var oldIdList = oldData.mapArray(oldData.getId);\n\n        // convertToIntId(newIdList, oldIdList);\n\n        // // FIXME One data ?\n        // diff = arrayDiff(oldIdList, newIdList);\n\n        var currPoints = [];\n        var nextPoints = [];\n        // Points for stacking base line\n        var currStackedPoints = [];\n        var nextStackedPoints = [];\n\n        var status = [];\n        var sortedIndices = [];\n        var rawIndices = [];\n        var dims = newCoordSys.dimensions;\n        for (var i = 0; i < diff.length; i++) {\n            var diffItem = diff[i];\n            var pointAdded = true;\n\n            // FIXME, animation is not so perfect when dataZoom window moves fast\n            // Which is in case remvoing or add more than one data in the tail or head\n            switch (diffItem.cmd) {\n                case '=':\n                    var currentPt = oldData.getItemLayout(diffItem.idx);\n                    var nextPt = newData.getItemLayout(diffItem.idx1);\n                    // If previous data is NaN, use next point directly\n                    if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n                        currentPt = nextPt.slice();\n                    }\n                    currPoints.push(currentPt);\n                    nextPoints.push(nextPt);\n\n                    currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n                    nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n\n                    rawIndices.push(newData.getRawIndex(diffItem.idx1));\n                    break;\n                case '+':\n                    var idx = diffItem.idx;\n                    currPoints.push(\n                        oldCoordSys.dataToPoint([\n                            newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)\n                        ])\n                    );\n\n                    nextPoints.push(newData.getItemLayout(idx).slice());\n\n                    currStackedPoints.push(\n                        getStackedOnPoint(oldCoordSys, newData, idx)\n                    );\n                    nextStackedPoints.push(newStackedOnPoints[idx]);\n\n                    rawIndices.push(newData.getRawIndex(idx));\n                    break;\n                case '-':\n                    var idx = diffItem.idx;\n                    var rawIndex = oldData.getRawIndex(idx);\n                    // Data is replaced. In the case of dynamic data queue\n                    // FIXME FIXME FIXME\n                    if (rawIndex !== idx) {\n                        currPoints.push(oldData.getItemLayout(idx));\n                        nextPoints.push(newCoordSys.dataToPoint([\n                            oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)\n                        ]));\n\n                        currStackedPoints.push(oldStackedOnPoints[idx]);\n                        nextStackedPoints.push(\n                            getStackedOnPoint(\n                                newCoordSys, oldData, idx\n                            )\n                        );\n\n                        rawIndices.push(rawIndex);\n                    }\n                    else {\n                        pointAdded = false;\n                    }\n            }\n\n            // Original indices\n            if (pointAdded) {\n                status.push(diffItem);\n                sortedIndices.push(sortedIndices.length);\n            }\n        }\n\n        // Diff result may be crossed if all items are changed\n        // Sort by data index\n        sortedIndices.sort(function (a, b) {\n            return rawIndices[a] - rawIndices[b];\n        });\n\n        var sortedCurrPoints = [];\n        var sortedNextPoints = [];\n\n        var sortedCurrStackedPoints = [];\n        var sortedNextStackedPoints = [];\n\n        var sortedStatus = [];\n        for (var i = 0; i < sortedIndices.length; i++) {\n            var idx = sortedIndices[i];\n            sortedCurrPoints[i] = currPoints[idx];\n            sortedNextPoints[i] = nextPoints[idx];\n\n            sortedCurrStackedPoints[i] = currStackedPoints[idx];\n            sortedNextStackedPoints[i] = nextStackedPoints[idx];\n\n            sortedStatus[i] = status[idx];\n        }\n\n        return {\n            current: sortedCurrPoints,\n            next: sortedNextPoints,\n\n            stackedOnCurrent: sortedCurrStackedPoints,\n            stackedOnNext: sortedNextStackedPoints,\n\n            status: sortedStatus\n        };\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/line/lineAnimationDiff.js\n// module id = 99\n// module chunks = 0 1 2","// Poly path support NaN point\n\n\n    var Path = require('zrender/lib/graphic/Path');\n    var vec2 = require('zrender/lib/core/vector');\n\n    var vec2Min = vec2.min;\n    var vec2Max = vec2.max;\n\n    var scaleAndAdd = vec2.scaleAndAdd;\n    var v2Copy = vec2.copy;\n\n    // Temporary variable\n    var v = [];\n    var cp0 = [];\n    var cp1 = [];\n\n    function isPointNull(p) {\n        return isNaN(p[0]) || isNaN(p[1]);\n    }\n\n    function drawSegment(\n        ctx, points, start, segLen, allLen,\n        dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls\n    ) {\n        var prevIdx = 0;\n        var idx = start;\n        for (var k = 0; k < segLen; k++) {\n            var p = points[idx];\n            if (idx >= allLen || idx < 0) {\n                break;\n            }\n            if (isPointNull(p)) {\n                if (connectNulls) {\n                    idx += dir;\n                    continue;\n                }\n                break;\n            }\n\n            if (idx === start) {\n                ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n                v2Copy(cp0, p);\n            }\n            else {\n                if (smooth > 0) {\n                    var nextIdx = idx + dir;\n                    var nextP = points[nextIdx];\n                    if (connectNulls) {\n                        // Find next point not null\n                        while (nextP && isPointNull(points[nextIdx])) {\n                            nextIdx += dir;\n                            nextP = points[nextIdx];\n                        }\n                    }\n\n                    var ratioNextSeg = 0.5;\n                    var prevP = points[prevIdx];\n                    var nextP = points[nextIdx];\n                    // Last point\n                    if (!nextP || isPointNull(nextP)) {\n                        v2Copy(cp1, p);\n                    }\n                    else {\n                        // If next data is null in not connect case\n                        if (isPointNull(nextP) && !connectNulls) {\n                            nextP = p;\n                        }\n\n                        vec2.sub(v, nextP, prevP);\n\n                        var lenPrevSeg;\n                        var lenNextSeg;\n                        if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n                            var dim = smoothMonotone === 'x' ? 0 : 1;\n                            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n                            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n                        }\n                        else {\n                            lenPrevSeg = vec2.dist(p, prevP);\n                            lenNextSeg = vec2.dist(p, nextP);\n                        }\n\n                        // Use ratio of seg length\n                        ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n\n                        scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n                    }\n                    // Smooth constraint\n                    vec2Min(cp0, cp0, smoothMax);\n                    vec2Max(cp0, cp0, smoothMin);\n                    vec2Min(cp1, cp1, smoothMax);\n                    vec2Max(cp1, cp1, smoothMin);\n\n                    ctx.bezierCurveTo(\n                        cp0[0], cp0[1],\n                        cp1[0], cp1[1],\n                        p[0], p[1]\n                    );\n                    // cp0 of next segment\n                    scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n                }\n                else {\n                    ctx.lineTo(p[0], p[1]);\n                }\n            }\n\n            prevIdx = idx;\n            idx += dir;\n        }\n\n        return k;\n    }\n\n    function getBoundingBox(points, smoothConstraint) {\n        var ptMin = [Infinity, Infinity];\n        var ptMax = [-Infinity, -Infinity];\n        if (smoothConstraint) {\n            for (var i = 0; i < points.length; i++) {\n                var pt = points[i];\n                if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; }\n                if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; }\n                if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; }\n                if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; }\n            }\n        }\n        return {\n            min: smoothConstraint ? ptMin : ptMax,\n            max: smoothConstraint ? ptMax : ptMin\n        };\n    }\n\n    module.exports = {\n\n        Polyline: Path.extend({\n\n            type: 'ec-polyline',\n\n            shape: {\n                points: [],\n\n                smooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            style: {\n                fill: null,\n\n                stroke: '#000'\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n\n                var i = 0;\n                var len = points.length;\n\n                var result = getBoundingBox(points, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    i += drawSegment(\n                        ctx, points, i, len, len,\n                        1, result.min, result.max, shape.smooth,\n                        shape.smoothMonotone, shape.connectNulls\n                    ) + 1;\n                }\n            }\n        }),\n\n        Polygon: Path.extend({\n\n            type: 'ec-polygon',\n\n            shape: {\n                points: [],\n\n                // Offset between stacked base points and points\n                stackedOnPoints: [],\n\n                smooth: 0,\n\n                stackedOnSmooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n                var stackedOnPoints = shape.stackedOnPoints;\n\n                var i = 0;\n                var len = points.length;\n                var smoothMonotone = shape.smoothMonotone;\n                var bbox = getBoundingBox(points, shape.smoothConstraint);\n                var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    var k = drawSegment(\n                        ctx, points, i, len, len,\n                        1, bbox.min, bbox.max, shape.smooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    drawSegment(\n                        ctx, stackedOnPoints, i + k - 1, k, len,\n                        -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    i += k + 1;\n\n                    ctx.closePath();\n                }\n            }\n        })\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/line/poly.js\n// module id = 100\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('./pie/PieSeries');\n    require('./pie/PieView');\n\n    require('../action/createDataSelectAction')('pie', [{\n        type: 'pieToggleSelect',\n        event: 'pieselectchanged',\n        method: 'toggleSelected'\n    }, {\n        type: 'pieSelect',\n        event: 'pieselected',\n        method: 'select'\n    }, {\n        type: 'pieUnSelect',\n        event: 'pieunselected',\n        method: 'unSelect'\n    }]);\n\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n\n    echarts.registerLayout(zrUtil.curry(\n        require('./pie/pieLayout'), 'pie'\n    ));\n\n    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/pie.js\n// module id = 101\n// module chunks = 0 1 2","'use strict';\n\n\n    var List = require('../../data/List');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n\n    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n\n    var PieSeries = require('../../echarts').extendSeriesModel({\n\n        type: 'series.pie',\n\n        // Overwrite\n        init: function (option) {\n            PieSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this._dataBeforeProcessed;\n            };\n\n            this.updateSelectedMap(option.data);\n\n            this._defaultLabelLine(option);\n        },\n\n        // Overwrite\n        mergeOption: function (newOption) {\n            PieSeries.superCall(this, 'mergeOption', newOption);\n            this.updateSelectedMap(this.option.data);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        // Overwrite\n        getDataParams: function (dataIndex) {\n            var data = this._data;\n            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n            var sum = data.getSum('value');\n            // FIXME toFixed?\n            //\n            // Percent is 0 if sum is 0\n            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\n            params.$vars.push('percent');\n            return params;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // \n            center: ['50%', '50%'],\n            radius: [0, '75%'],\n            // \n            clockwise: true,\n            startAngle: 90,\n            // 0\n            minAngle: 0,\n            // \n            selectedOffset: 10,\n\n            // If use strategy to avoid label overlapping\n            avoidLabelOverlap: true,\n            // singlemultiple\n            // selectedMode: false,\n            // 'radius' | 'area'\n            // roseType: null,\n\n            label: {\n                normal: {\n                    // If rotate around circle\n                    rotate: false,\n                    show: true,\n                    // 'outer', 'inside', 'center'\n                    position: 'outer'\n                    // formatter: Tooltip.formatter\n                    // textStyle: null      // TEXTSTYLE\n                    // distance: positioninnerlabel()\n                },\n                emphasis: {}\n            },\n            // Enabled when label.normal.position is 'outer'\n            labelLine: {\n                normal: {\n                    show: true,\n                    // \n                    length: 15,\n                    // \n                    length2: 15,\n                    smooth: false,\n                    lineStyle: {\n                        // color: ,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 1\n                },\n                emphasis: {}\n            },\n\n            animationEasing: 'cubicOut',\n\n            data: []\n        }\n    });\n\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\n    module.exports = PieSeries;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/pie/PieSeries.js\n// module id = 102\n// module chunks = 0 1 2","\n\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n\n        data.each(function (idx) {\n            toggleItemSelected(\n                data.getItemGraphicEl(idx),\n                data.getItemLayout(idx),\n                seriesModel.isSelected(data.getName(idx)),\n                selectedOffset,\n                hasAnimation\n            );\n        });\n    }\n\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [dx * offset, dy * offset];\n\n        hasAnimation\n            // animateTo will stop revious animation like update transition\n            ? el.animate()\n                .when(200, {\n                    position: position\n                })\n                .start('bounceOut')\n            : el.attr('position', position);\n    }\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var sector = new graphic.Sector({\n            z2: 2\n        });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var piePieceProto = PiePiece.prototype;\n\n    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        return {\n            fill: textStyleModel.getTextColor()\n                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            opacity: data.getItemVisual(idx, 'opacity'),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(\n                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n            )\n        };\n    }\n\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n\n        var sector = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n            sector.shape.endAngle = layout.startAngle;\n            graphic.updateProps(sector, {\n                shape: {\n                    endAngle: layout.endAngle\n                }\n            }, seriesModel, idx);\n        }\n        else {\n            graphic.updateProps(sector, {\n                shape: sectorShape\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        sector.useStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'bevel',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle()\n            )\n        );\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        // Toggle selected\n        toggleItemSelected(\n            this,\n            data.getItemLayout(idx),\n            itemModel.get('selected'),\n            seriesModel.get('selectedOffset'),\n            seriesModel.get('animation')\n        );\n\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r + 10\n                }\n            }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r\n                }\n            }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n            sector\n                .on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    piePieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n                ]\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textVerticalAlign: labelLayout.verticalAlign,\n                textAlign: labelLayout.textAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({\n            smooth: smooth\n        });\n    };\n\n    zrUtil.inherits(PiePiece, graphic.Group);\n\n\n    // Pie view\n    var Pie = require('../../view/Chart').extend({\n\n        type: 'pie',\n\n        init: function () {\n            var sectorGroup = new graphic.Group();\n            this._sectorGroup = sectorGroup;\n        },\n\n        render: function (seriesModel, ecModel, api, payload) {\n            if (payload && (payload.from === this.uid)) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var group = this.group;\n\n            var hasAnimation = ecModel.get('animation');\n            var isFirstRender = !oldData;\n\n            var onSectorClick = zrUtil.curry(\n                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n            );\n\n            var selectedMode = seriesModel.get('selectedMode');\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    if (isFirstRender) {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n\n                    selectedMode && piePiece.on('click', onSectorClick);\n\n                    data.setItemGraphicEl(idx, piePiece);\n\n                    group.add(piePiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            if (hasAnimation && isFirstRender && data.count() > 0) {\n                var shape = data.getItemLayout(0);\n                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\n                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                group.setClipPath(this._createClipPath(\n                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n                ));\n            }\n\n            this._data = data;\n        },\n\n        dispose: function () {},\n\n        _createClipPath: function (\n            cx, cy, r, startAngle, clockwise, cb, seriesModel\n        ) {\n            var clipPath = new graphic.Sector({\n                shape: {\n                    cx: cx,\n                    cy: cy,\n                    r0: 0,\n                    r: r,\n                    startAngle: startAngle,\n                    endAngle: startAngle,\n                    clockwise: clockwise\n                }\n            });\n\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n                }\n            }, seriesModel, cb);\n\n            return clipPath;\n        },\n\n        /**\n         * @implement\n         */\n        containPoint: function (point, seriesModel) {\n            var data = seriesModel.getData();\n            var itemLayout = data.getItemLayout(0);\n            if (itemLayout) {\n                var dx = point[0] - itemLayout.cx;\n                var dy = point[1] - itemLayout.cy;\n                var radius = Math.sqrt(dx * dx + dy * dy);\n                return radius <= itemLayout.r && radius >= itemLayout.r0;\n            }\n        }\n\n    });\n\n    module.exports = Pie;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/pie/PieView.js\n// module id = 103\n// module chunks = 0 1 2","'use strict';\n// FIXME emphasis label position is not same with normal label position\n\n\n    var textContain = require('zrender/lib/contain/text');\n\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n\n        // \n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start\n                    && j + 1 < end\n                    && list[j + 1].y > list[j].y + list[j].height\n                ) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n\n            shiftUp(end - 1, delta / 2);\n        }\n\n        // \n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0\n                    && list[j].y > list[j - 1].y + list[j - 1].height\n                ) {\n                    break;\n                }\n            }\n        }\n\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0\n                ? isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0                     // \n                : isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0;                    // \n\n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = (deltaY < r + length)\n                    ? Math.sqrt(\n                          (r + length + length2) * (r + length + length2)\n                          - deltaY * deltaY\n                      )\n                    : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX + 10;\n                }\n\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            }\n            else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            }\n            else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                }\n                else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n\n    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n\n            cx = layout.cx;\n            cy = layout.cy;\n\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            }\n            else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n                    var y3 = y2;\n\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n                }\n\n                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n            }\n            var font = labelModel.getModel('textStyle').getFont();\n\n            var labelRotate = labelModel.get('rotate')\n                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal')\n                        || data.getName(idx);\n            var textRect = textContain.getBoundingRect(\n                text, font, textAlign, 'top'\n            );\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                font: font,\n                rotation: labelRotate\n            };\n\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/pie/labelLayout.js\n// module id = 104\n// module chunks = 0 1 2","// TODO minAngle\n\n\n\n    var numberUtil = require('../../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = require('./labelLayout');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n\n    module.exports = function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n\n            if (!zrUtil.isArray(radius)) {\n                radius = [0, radius];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [center, center];\n            }\n\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n\n            var data = seriesModel.getData();\n\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\n            var clockwise = seriesModel.get('clockwise');\n\n            var roseType = seriesModel.get('roseType');\n\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n\n            var currentAngle = startAngle;\n\n            var dir = clockwise ? 1 : -1;\n            data.each('value', function (value, idx) {\n                var angle;\n                // FIXME  2.0  roseType  area \n                if (roseType !== 'area') {\n                    angle = sum === 0 ? unitRadian : (value * unitRadian);\n                }\n                else {\n                    angle = PI2 / (data.count() || 1);\n                }\n\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                }\n                else {\n                    valueSumLargerThanMinAngle += value;\n                }\n\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType\n                        ? numberUtil.linearMap(value, extent, [r0, r])\n                        : r\n                });\n\n                currentAngle = endAngle;\n            }, true);\n\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 1e-3) {\n                    var angle = PI2 / data.count();\n                    data.each(function (idx) {\n                        var layout = data.getItemLayout(idx);\n                        layout.startAngle = startAngle + dir * idx * angle;\n                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                    });\n                }\n                else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        var layout = data.getItemLayout(idx);\n                        var angle = layout.angle === minAngle\n                            ? minAngle : value * unitRadian;\n                        layout.startAngle = currentAngle;\n                        layout.endAngle = currentAngle + dir * angle;\n                        currentAngle += angle;\n                    });\n                }\n            }\n\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/pie/pieLayout.js\n// module id = 105\n// module chunks = 0 1 2","'use strict';\n// TODO boundaryGap\n\n\n    require('../coord/cartesian/AxisModel');\n\n    require('./axis/AxisView');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/axis.js\n// module id = 106\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var AxisBuilder = require('./AxisBuilder');\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n    var selfBuilderAttrs = [\n        'splitArea', 'splitLine'\n    ];\n\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n\n    var AxisView = require('../../echarts').extendComponentView({\n\n        type: 'axis',\n\n        render: function (axisModel, ecModel) {\n\n            this.group.removeAll();\n\n            var oldAxisGroup = this._axisGroup;\n            this._axisGroup = new graphic.Group();\n\n            this.group.add(this._axisGroup);\n\n            if (!axisModel.get('show')) {\n                return;\n            }\n\n            var gridModel = axisModel.findGridModel();\n\n            var layout = layoutAxis(gridModel, axisModel);\n\n            var axisBuilder = new AxisBuilder(axisModel, layout);\n\n            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n            this._axisGroup.add(axisBuilder.getGroup());\n\n            zrUtil.each(selfBuilderAttrs, function (name) {\n                if (axisModel.get(name + '.show')) {\n                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n                }\n            }, this);\n\n            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitLine: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            var splitLineModel = axisModel.getModel('splitLine');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var lineColors = lineStyleModel.get('color');\n\n            var lineInterval = getInterval(splitLineModel, labelInterval);\n\n            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n            var isHorizontal = axis.isHorizontal();\n\n            var lineCount = 0;\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitLineModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var p1 = [];\n            var p2 = [];\n            // Simple optimization\n            // Batching the lines if color are the same\n            var lineStyle = lineStyleModel.getLineStyle();\n            for (var i = 0; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                if (isHorizontal) {\n                    p1[0] = tickCoord;\n                    p1[1] = gridRect.y;\n                    p2[0] = tickCoord;\n                    p2[1] = gridRect.y + gridRect.height;\n                }\n                else {\n                    p1[0] = gridRect.x;\n                    p1[1] = tickCoord;\n                    p2[0] = gridRect.x + gridRect.width;\n                    p2[1] = tickCoord;\n                }\n\n                var colorIndex = (lineCount++) % lineColors.length;\n                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line_' + ticks[i],\n\n                    shape: {\n                        x1: p1[0],\n                        y1: p1[1],\n                        x2: p2[0],\n                        y2: p2[1]\n                    },\n                    style: zrUtil.defaults({\n                        stroke: lineColors[colorIndex]\n                    }, lineStyle),\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitArea: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            var splitAreaModel = axisModel.getModel('splitArea');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n            var areaColors = areaStyleModel.get('color');\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitAreaModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\n            var count = 0;\n\n            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\n            var areaStyle = areaStyleModel.getAreaStyle();\n            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n            for (var i = 1; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                var x;\n                var y;\n                var width;\n                var height;\n                if (axis.isHorizontal()) {\n                    x = prevX;\n                    y = gridRect.y;\n                    width = tickCoord - x;\n                    height = gridRect.height;\n                }\n                else {\n                    x = gridRect.x;\n                    y = prevY;\n                    width = gridRect.width;\n                    height = tickCoord - y;\n                }\n\n                var colorIndex = (count++) % areaColors.length;\n                this._axisGroup.add(new graphic.Rect({\n                    anid: 'area_' + ticks[i],\n\n                    shape: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    style: zrUtil.defaults({\n                        fill: areaColors[colorIndex]\n                    }, areaStyle),\n                    silent: true\n                }));\n\n                prevX = x + width;\n                prevY = y + height;\n            }\n        }\n    });\n\n    AxisView.extend({\n        type: 'xAxis'\n    });\n    AxisView.extend({\n        type: 'yAxis'\n    });\n\n    /**\n     * @inner\n     */\n    function layoutAxis(gridModel, axisModel) {\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\n        var axisOffset = axisModel.get('offset') || 0;\n\n        var posMap = {\n            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n        };\n\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n        // Tick and label direction, x y is axisDim\n        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        if (axis.onZero) {\n            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n        }\n\n        if (axisModel.getModel('axisTick').get('inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (axisModel.getModel('axisLabel').get('inside')) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n\n        // Special label rotation\n        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n\n        return layout;\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/axis/AxisView.js\n// module id = 107\n// module chunks = 0 1 2","/**\n * @file Data zoom action\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var helper = require('./helper');\n    var echarts = require('../../echarts');\n\n\n    echarts.registerAction('dataZoom', function (payload, ecModel) {\n\n        var linkedNodesFinder = helper.createLinkedNodesFinder(\n            zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'),\n            helper.eachAxisDim,\n            function (model, dimNames) {\n                return model.get(dimNames.axisIndex);\n            }\n        );\n\n        var effectedModels = [];\n\n        ecModel.eachComponent(\n            {mainType: 'dataZoom', query: payload},\n            function (model, index) {\n                effectedModels.push.apply(\n                    effectedModels, linkedNodesFinder(model).nodes\n                );\n            }\n        );\n\n        zrUtil.each(effectedModels, function (dataZoomModel, index) {\n            dataZoomModel.setRawRange({\n                start: payload.start,\n                end: payload.end,\n                startValue: payload.startValue,\n                endValue: payload.endValue\n            });\n        });\n\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/dataZoomAction.js\n// module id = 108\n// module chunks = 0 1","/**\n * @file Data zoom processor\n */\n\n\n    var echarts = require('../../echarts');\n\n    echarts.registerProcessor(function (ecModel, api) {\n\n        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n            // We calculate window and reset axis here but not in model\n            // init stage and not after action dispatch handler, because\n            // reset should be called after seriesData.restoreData.\n            dataZoomModel.eachTargetAxis(resetSingleAxis);\n\n            // Caution: data zoom filtering is order sensitive when using\n            // percent range and no min/max/scale set on axis.\n            // For example, we have dataZoom definition:\n            // [\n            //      {xAxisIndex: 0, start: 30, end: 70},\n            //      {yAxisIndex: 0, start: 20, end: 80}\n            // ]\n            // In this case, [20, 80] of y-dataZoom should be based on data\n            // that have filtered by x-dataZoom using range of [30, 70],\n            // but should not be based on full raw data. Thus sliding\n            // x-dataZoom will change both ranges of xAxis and yAxis,\n            // while sliding y-dataZoom will only change the range of yAxis.\n            // So we should filter x-axis after reset x-axis immediately,\n            // and then reset y-axis and filter y-axis.\n            dataZoomModel.eachTargetAxis(filterSingleAxis);\n        });\n\n        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n            // Fullfill all of the range props so that user\n            // is able to get them from chart.getOption().\n            var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n            var percentRange = axisProxy.getDataPercentWindow();\n            var valueRange = axisProxy.getDataValueWindow();\n\n            dataZoomModel.setRawRange({\n                start: percentRange[0],\n                end: percentRange[1],\n                startValue: valueRange[0],\n                endValue: valueRange[1]\n            });\n        });\n    });\n\n    function resetSingleAxis(dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);\n    }\n\n    function filterSingleAxis(dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);\n    }\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/dataZoomProcessor.js\n// module id = 109\n// module chunks = 0 1","\n    var formatUtil = require('../../util/format');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var helper = {};\n\n    var AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle'];\n\n    /**\n     * Create \"each\" method to iterate names.\n     *\n     * @pubilc\n     * @param  {Array.<string>} names\n     * @param  {Array.<string>=} attrs\n     * @return {Function}\n     */\n    helper.createNameEach = function (names, attrs) {\n        names = names.slice();\n        var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n        attrs = (attrs || []).slice();\n        var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n\n        return function (callback, context) {\n            zrUtil.each(names, function (name, index) {\n                var nameObj = {name: name, capital: capitalNames[index]};\n\n                for (var j = 0; j < attrs.length; j++) {\n                    nameObj[attrs[j]] = name + capitalAttrs[j];\n                }\n\n                callback.call(context, nameObj);\n            });\n        };\n    };\n\n    /**\n     * Iterate each dimension name.\n     *\n     * @public\n     * @param {Function} callback The parameter is like:\n     *                            {\n     *                                name: 'angle',\n     *                                capital: 'Angle',\n     *                                axis: 'angleAxis',\n     *                                axisIndex: 'angleAixs',\n     *                                index: 'angleIndex'\n     *                            }\n     * @param {Object} context\n     */\n    helper.eachAxisDim = helper.createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n\n    /**\n     * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n     * dataZoomModels and 'links' make up one or more graphics.\n     * This function finds the graphic where the source dataZoomModel is in.\n     *\n     * @public\n     * @param {Function} forEachNode Node iterator.\n     * @param {Function} forEachEdgeType edgeType iterator\n     * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n     * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n     */\n    helper.createLinkedNodesFinder = function (forEachNode, forEachEdgeType, edgeIdGetter) {\n\n        return function (sourceNode) {\n            var result = {\n                nodes: [],\n                records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n            };\n\n            forEachEdgeType(function (edgeType) {\n                result.records[edgeType.name] = {};\n            });\n\n            if (!sourceNode) {\n                return result;\n            }\n\n            absorb(sourceNode, result);\n\n            var existsLink;\n            do {\n                existsLink = false;\n                forEachNode(processSingleNode);\n            }\n            while (existsLink);\n\n            function processSingleNode(node) {\n                if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n                    absorb(node, result);\n                    existsLink = true;\n                }\n            }\n\n            return result;\n        };\n\n        function isNodeAbsorded(node, result) {\n            return zrUtil.indexOf(result.nodes, node) >= 0;\n        }\n\n        function isLinked(node, result) {\n            var hasLink = false;\n            forEachEdgeType(function (edgeType) {\n                zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n                    result.records[edgeType.name][edgeId] && (hasLink = true);\n                });\n            });\n            return hasLink;\n        }\n\n        function absorb(node, result) {\n            result.nodes.push(node);\n            forEachEdgeType(function (edgeType) {\n                zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n                    result.records[edgeType.name][edgeId] = true;\n                });\n            });\n        }\n    };\n\n    module.exports = helper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/helper.js\n// module id = 110\n// module chunks = 0 1","/**\n * @file History manager.\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var each = zrUtil.each;\n\n    var ATTR = '\\0_ec_hist_store';\n\n    var history = {\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}\n         */\n        push: function (ecModel, newSnapshot) {\n            var store = giveStore(ecModel);\n\n            // If previous dataZoom can not be found,\n            // complete an range with current range.\n            each(newSnapshot, function (batchItem, dataZoomId) {\n                var i = store.length - 1;\n                for (; i >= 0; i--) {\n                    var snapshot = store[i];\n                    if (snapshot[dataZoomId]) {\n                        break;\n                    }\n                }\n                if (i < 0) {\n                    // No origin range set, create one by current range.\n                    var dataZoomModel = ecModel.queryComponents(\n                        {mainType: 'dataZoom', subType: 'select', id: dataZoomId}\n                    )[0];\n                    if (dataZoomModel) {\n                        var percentRange = dataZoomModel.getPercentRange();\n                        store[0][dataZoomId] = {\n                            dataZoomId: dataZoomId,\n                            start: percentRange[0],\n                            end: percentRange[1]\n                        };\n                    }\n                }\n            });\n\n            store.push(newSnapshot);\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object} snapshot\n         */\n        pop: function (ecModel) {\n            var store = giveStore(ecModel);\n            var head = store[store.length - 1];\n            store.length > 1 && store.pop();\n\n            // Find top for all dataZoom.\n            var snapshot = {};\n            each(head, function (batchItem, dataZoomId) {\n                for (var i = store.length - 1; i >= 0; i--) {\n                    var batchItem = store[i][dataZoomId];\n                    if (batchItem) {\n                        snapshot[dataZoomId] = batchItem;\n                        break;\n                    }\n                }\n            });\n\n            return snapshot;\n        },\n\n        /**\n         * @public\n         */\n        clear: function (ecModel) {\n            ecModel[ATTR] = null;\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @return {number} records. always >= 1.\n         */\n        count: function (ecModel) {\n            return giveStore(ecModel).length;\n        }\n\n    };\n\n    /**\n     * [{key: dataZoomId, value: {dataZoomId, range}}, ...]\n     * History length of each dataZoom may be different.\n     * this._history[0] is used to store origin range.\n     * @type {Array.<Object>}\n     */\n    function giveStore(ecModel) {\n        var store = ecModel[ATTR];\n        if (!store) {\n            store = ecModel[ATTR] = [{}];\n        }\n        return store;\n    }\n\n    module.exports = history;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/history.js\n// module id = 111\n// module chunks = 0 1","\n\n    require('../../model/Component').registerSubTypeDefaulter('dataZoom', function (option) {\n        // Default 'slider' when no type specified.\n        return 'slider';\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/typeDefaulter.js\n// module id = 112\n// module chunks = 0 1","/**\n * Box selection tool.\n *\n * @module echarts/component/helper/BrushController\n */\n\n\n\n    var Eventful = require('zrender/lib/mixin/Eventful');\n    var zrUtil = require('zrender/lib/core/util');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n    var graphic = require('../../util/graphic');\n    var interactionMutex = require('./interactionMutex');\n    var DataDiffer = require('../../data/DataDiffer');\n\n    var curry = zrUtil.curry;\n    var each = zrUtil.each;\n    var map = zrUtil.map;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathPow = Math.pow;\n\n    var COVER_Z = 10000;\n    var UNSELECT_THRESHOLD = 6;\n    var MIN_RESIZE_LINE_WIDTH = 6;\n    var MUTEX_RESOURCE_KEY = 'globalPan';\n\n    var DIRECTION_MAP = {\n        w: [0, 0],\n        e: [0, 1],\n        n: [1, 0],\n        s: [1, 1]\n    };\n    var CURSOR_MAP = {\n        w: 'ew',\n        e: 'ew',\n        n: 'ns',\n        s: 'ns',\n        ne: 'nesw',\n        sw: 'nesw',\n        nw: 'nwse',\n        se: 'nwse'\n    };\n    var DEFAULT_BRUSH_OPT = {\n        brushStyle: {\n            lineWidth: 2,\n            stroke: 'rgba(0,0,0,0.3)',\n            fill: 'rgba(0,0,0,0.1)'\n        },\n        transformable: true,\n        brushMode: 'single',\n        removeOnClick: false\n    };\n\n    var baseUID = 0;\n\n    /**\n     * @alias module:echarts/component/helper/BrushController\n     * @constructor\n     * @mixin {module:zrender/mixin/Eventful}\n     * @event module:echarts/component/helper/BrushController#brush\n     *        params:\n     *            areas: Array.<Array>, coord relates to container group,\n     *                                    If no container specified, to global.\n     *            opt {\n     *                isEnd: boolean,\n     *                removeOnClick: boolean\n     *            }\n     *\n     * @param {module:zrender/zrender~ZRender} zr\n     */\n    function BrushController(zr) {\n\n        if (__DEV__) {\n            zrUtil.assert(zr);\n        }\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:zrender/zrender~ZRender}\n         * @private\n         */\n        this._zr = zr;\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        /**\n         * Only for drawing (after enabledBrush).\n         * @private\n         * @type {string}\n         */\n        this._brushType;\n\n        /**\n         * Only for drawing (after enabledBrush).\n         * @private\n         * @type {Object}\n         */\n        this._brushOption;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._panels;\n\n        /**\n         * @private\n         * @type {Array.<nubmer>}\n         */\n        this._track = [];\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._dragging;\n\n        /**\n         * @private\n         * @type {Array}\n         */\n        this._covers = [];\n\n        /**\n         * @private\n         * @type {moudule:zrender/container/Group}\n         */\n        this._creatingCover;\n\n        /**\n         * true means global panel\n         * @private\n         * @type {module:zrender/container/Group|boolean}\n         */\n        this._creatingPanel;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._enableGlobalPan;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        if (__DEV__) {\n            this._mounted;\n        }\n\n        /**\n         * @private\n         * @type {string}\n         */\n        this._uid = 'brushController_' + baseUID++;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._handlers = {};\n        each(mouseHandlers, function (handler, eventName) {\n            this._handlers[eventName] = zrUtil.bind(handler, this);\n        }, this);\n    }\n\n    BrushController.prototype = {\n\n        constructor: BrushController,\n\n        /**\n         * If set to null/undefined/false, select disabled.\n         * @param {Object} brushOption\n         * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n         *                          If pass false/null/undefined, disable brush.\n         * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n         * @param {boolean} [brushOption.transformable=true]\n         * @param {boolean} [brushOption.removeOnClick=false]\n         * @param {Object} [brushOption.brushStyle]\n         * @param {number} [brushOption.brushStyle.width]\n         * @param {number} [brushOption.brushStyle.lineWidth]\n         * @param {string} [brushOption.brushStyle.stroke]\n         * @param {string} [brushOption.brushStyle.fill]\n         */\n        enableBrush: function (brushOption) {\n            if (__DEV__) {\n                zrUtil.assert(this._mounted);\n            }\n\n            this._brushType && doDisableBrush(this);\n            brushOption.brushType && doEnableBrush(this, brushOption);\n\n            return this;\n        },\n\n        /**\n         * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n         *        Each items: {panelId, rect}\n         */\n        setPanels: function (panelOpts) {\n            var oldPanels = this._panels || {};\n            var newPanels = this._panels = panelOpts && panelOpts.length && {};\n            var thisGroup = this.group;\n\n            newPanels && each(panelOpts, function (panelOpt) {\n                var panelId = panelOpt.panelId;\n                var panel = oldPanels[panelId];\n                if (!panel) {\n                    panel = new graphic.Rect({\n                        silent: true,\n                        invisible: true\n                    });\n                    thisGroup.add(panel);\n                }\n\n                var rect = panelOpt.rect;\n                // Using BoundingRect to normalize negative width/height.\n                if (!(rect instanceof BoundingRect)) {\n                    rect = BoundingRect.create(rect);\n                }\n\n                panel.attr('shape', rect.plain());\n                panel.__brushPanelId = panelId;\n                newPanels[panelId] = panel;\n                oldPanels[panelId] = null;\n            });\n\n            each(oldPanels, function (panel) {\n                panel && thisGroup.remove(panel);\n            });\n\n            return this;\n        },\n\n        /**\n         * @param {Object} [opt]\n         * @return {boolean} [opt.enableGlobalPan=false]\n         * @return {boolean} [opt.position=[0, 0]]\n         * @return {boolean} [opt.rotation=0]\n         * @return {boolean} [opt.scale=[1, 1]]\n         */\n        mount: function (opt) {\n            opt = opt || {};\n\n            if (__DEV__) {\n                this._mounted = true; // should be at first.\n            }\n\n            this._enableGlobalPan = opt.enableGlobalPan;\n\n            var thisGroup = this.group;\n            this._zr.add(thisGroup);\n\n            thisGroup.attr({\n                position: opt.position || [0, 0],\n                rotation: opt.rotation || 0,\n                scale: opt.scale || [1, 1]\n            });\n\n            return this;\n        },\n\n        eachCover: function (cb, context) {\n            each(this._covers, cb, context);\n        },\n\n        /**\n         * Update covers.\n         * @param {Array.<Object>} brushOptionList Like:\n         *        [\n         *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n         *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n         *            ...\n         *        ]\n         *        `brushType` is required in each cover info.\n         *        `id` is not mandatory.\n         *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n         *        If brushOptionList is null/undefined, all covers removed.\n         */\n        updateCovers: function (brushOptionList) {\n            if (__DEV__) {\n                zrUtil.assert(this._mounted);\n            }\n\n            brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n                return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n            });\n\n            var tmpIdPrefix = '\\0-brush-index-';\n            var oldCovers = this._covers;\n            var newCovers = this._covers = [];\n            var controller = this;\n            var creatingCover = this._creatingCover;\n\n            (new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey))\n                .add(addOrUpdate)\n                .update(addOrUpdate)\n                .remove(remove)\n                .execute();\n\n            return this;\n\n            function getKey(brushOption, index) {\n                return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index)\n                    + '-' + brushOption.brushType;\n            }\n\n            function oldGetKey(cover, index) {\n                return getKey(cover.__brushOption, index);\n            }\n\n            function addOrUpdate(newIndex, oldIndex) {\n                var newBrushOption = brushOptionList[newIndex];\n                // Consider setOption in event listener of brushSelect,\n                // where updating cover when creating should be forbiden.\n                if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n                    newCovers[newIndex] = oldCovers[oldIndex];\n                }\n                else {\n                    var cover = newCovers[newIndex] = oldIndex != null\n                        ? (\n                            oldCovers[oldIndex].__brushOption = newBrushOption,\n                            oldCovers[oldIndex]\n                        )\n                        : endCreating(controller, createCover(controller, newBrushOption));\n                    updateCoverAfterCreation(controller, cover);\n                }\n            }\n\n            function remove(oldIndex) {\n                if (oldCovers[oldIndex] !== creatingCover) {\n                    controller.group.remove(oldCovers[oldIndex]);\n                }\n            }\n        },\n\n        unmount: function () {\n            this.enableBrush(false);\n\n            // container may 'removeAll' outside.\n            clearCovers(this);\n            this._zr.remove(this.group);\n\n            if (__DEV__) {\n                this._mounted = false; // should be at last.\n            }\n\n            return this;\n        },\n\n        dispose: function () {\n            this.unmount();\n            this.off();\n        }\n    };\n\n    zrUtil.mixin(BrushController, Eventful);\n\n\n    function doEnableBrush(controller, brushOption) {\n        var zr = controller._zr;\n\n        // Consider roam, which takes globalPan too.\n        if (!controller._enableGlobalPan) {\n            interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n        }\n\n        each(controller._handlers, function (handler, eventName) {\n            zr.on(eventName, handler);\n        });\n\n        controller._brushType = brushOption.brushType;\n        controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    }\n\n    function doDisableBrush(controller) {\n        var zr = controller._zr;\n\n        interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n\n        each(controller._handlers, function (handler, eventName) {\n            zr.off(eventName, handler);\n        });\n\n        controller._brushType = controller._brushOption = null;\n    }\n\n    function createCover(controller, brushOption) {\n        var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n        updateZ(cover);\n        cover.__brushOption = brushOption;\n        controller.group.add(cover);\n        return cover;\n    }\n\n    function endCreating(controller, creatingCover) {\n        var coverRenderer = getCoverRenderer(creatingCover);\n        if (coverRenderer.endCreating) {\n            coverRenderer.endCreating(controller, creatingCover);\n            updateZ(creatingCover);\n        }\n        return creatingCover;\n    }\n\n    function updateCoverShape(controller, cover) {\n        var brushOption = cover.__brushOption;\n        getCoverRenderer(cover).updateCoverShape(\n            controller, cover, brushOption.range, brushOption\n        );\n    }\n\n    function updateZ(group) {\n        group.traverse(function (el) {\n            el.z = COVER_Z;\n            el.z2 = COVER_Z; // Consider in given container.\n        });\n    }\n\n    function updateCoverAfterCreation(controller, cover) {\n        getCoverRenderer(cover).updateCommon(controller, cover);\n        updateCoverShape(controller, cover);\n    }\n\n    function getCoverRenderer(cover) {\n        return coverRenderers[cover.__brushOption.brushType];\n    }\n\n    function getPanelByPoint(controller, x, y) {\n        var panels = controller._panels;\n        if (!panels) {\n            return true; // Global panel\n        }\n        var panel;\n        each(panels, function (pn) {\n            pn.contain(x, y) && (panel = pn);\n        });\n        return panel;\n    }\n\n    function getPanelByCover(controller, cover) {\n        var panels = controller._panels;\n        if (!panels) {\n            return true; // Global panel\n        }\n        var panelId = cover.__brushOption.panelId;\n        // User may give cover without coord sys info,\n        // which is then treated as global panel.\n        return panelId != null ? panels[panelId] : true;\n    }\n\n    function clearCovers(controller) {\n        var covers = controller._covers;\n        var originalLength = covers.length;\n        each(covers, function (cover) {\n            controller.group.remove(cover);\n        }, controller);\n        covers.length = 0;\n\n        return !!originalLength;\n    }\n\n    function trigger(controller, opt) {\n        var areas = map(controller._covers, function (cover) {\n            var brushOption = cover.__brushOption;\n            var range = zrUtil.clone(brushOption.range);\n\n            return {\n                brushType: brushOption.brushType,\n                panelId: brushOption.panelId,\n                range: range\n            };\n        });\n\n        controller.trigger('brush', areas, {\n            isEnd: !!opt.isEnd,\n            removeOnClick: !!opt.removeOnClick\n        });\n    }\n\n    function shouldShowCover(controller) {\n        var track = controller._track;\n\n        if (!track.length) {\n            return false;\n        }\n\n        var p2 = track[track.length - 1];\n        var p1 = track[0];\n        var dx = p2[0] - p1[0];\n        var dy = p2[1] - p1[1];\n        var dist = mathPow(dx * dx + dy * dy, 0.5);\n\n        return dist > UNSELECT_THRESHOLD;\n    }\n\n    function getTrackEnds(track) {\n        var tail = track.length - 1;\n        tail < 0 && (tail = 0);\n        return [track[0], track[tail]];\n    }\n\n    function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n        var cover = new graphic.Group();\n\n        cover.add(new graphic.Rect({\n            name: 'main',\n            style: makeStyle(brushOption),\n            silent: true,\n            draggable: true,\n            cursor: 'move',\n            drift: curry(doDrift, controller, cover, 'nswe'),\n            ondragend: curry(trigger, controller, {isEnd: true})\n        }));\n\n        each(\n            edgeNames,\n            function (name) {\n                cover.add(new graphic.Rect({\n                    name: name,\n                    style: {opacity: 0},\n                    draggable: true,\n                    silent: true,\n                    invisible: true,\n                    drift: curry(doDrift, controller, cover, name),\n                    ondragend: curry(trigger, controller, {isEnd: true})\n                }));\n            }\n        );\n\n        return cover;\n    }\n\n    function updateBaseRect(controller, cover, localRange, brushOption) {\n        var lineWidth = brushOption.brushStyle.lineWidth || 0;\n        var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n        var x = localRange[0][0];\n        var y = localRange[1][0];\n        var xa = x - lineWidth / 2;\n        var ya = y - lineWidth / 2;\n        var x2 = localRange[0][1];\n        var y2 = localRange[1][1];\n        var x2a = x2 - handleSize + lineWidth / 2;\n        var y2a = y2 - handleSize + lineWidth / 2;\n        var width = x2 - x;\n        var height = y2 - y;\n        var widtha = width + lineWidth;\n        var heighta = height + lineWidth;\n\n        updateRectShape(controller, cover, 'main', x, y, width, height);\n\n        if (brushOption.transformable) {\n            updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n            updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n            updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n            updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n\n            updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n            updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n            updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n            updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n        }\n    }\n\n    function updateCommon(controller, cover) {\n        var brushOption = cover.__brushOption;\n        var transformable = brushOption.transformable;\n\n        var mainEl = cover.childAt(0);\n        mainEl.useStyle(makeStyle(brushOption));\n        mainEl.attr({\n            silent: !transformable,\n            cursor: transformable ? 'move' : 'default'\n        });\n\n        each(\n            ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'],\n            function (name) {\n                var el = cover.childOfName(name);\n                var globalDir = getGlobalDirection(controller, name);\n\n                el && el.attr({\n                    silent: !transformable,\n                    invisible: !transformable,\n                    cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n                });\n            }\n        );\n    }\n\n    function updateRectShape(controller, cover, name, x, y, w, h) {\n        var el = cover.childOfName(name);\n        el && el.setShape(pointsToRect(\n            clipByPanel(controller, cover, [[x, y], [x + w, y + h]])\n        ));\n    }\n\n    function makeStyle(brushOption) {\n        return zrUtil.defaults({strokeNoScale: true}, brushOption.brushStyle);\n    }\n\n    function formatRectRange(x, y, x2, y2) {\n        var min = [mathMin(x, x2), mathMin(y, y2)];\n        var max = [mathMax(x, x2), mathMax(y, y2)];\n\n        return [\n            [min[0], max[0]], // x range\n            [min[1], max[1]] // y range\n        ];\n    }\n\n    function getTransform(controller) {\n        return graphic.getTransform(controller.group);\n    }\n\n    function getGlobalDirection(controller, localDirection) {\n        if (localDirection.length > 1) {\n            localDirection = localDirection.split('');\n            var globalDir = [\n                getGlobalDirection(controller, localDirection[0]),\n                getGlobalDirection(controller, localDirection[1])\n            ];\n            (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n            return globalDir.join('');\n        }\n        else {\n            var map = {w: 'left', e: 'right', n: 'top', s: 'bottom'};\n            var inverseMap = {left: 'w', right: 'e', top: 'n', bottom: 's'};\n            var globalDir = graphic.transformDirection(\n                map[localDirection], getTransform(controller)\n            );\n            return inverseMap[globalDir];\n        }\n    }\n\n    function driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n        var brushOption = cover.__brushOption;\n        var rectRange = toRectRange(brushOption.range);\n        var localDelta = toLocalDelta(controller, dx, dy);\n\n        each(name.split(''), function (namePart) {\n            var ind = DIRECTION_MAP[namePart];\n            rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n        });\n\n        brushOption.range = fromRectRange(formatRectRange(\n            rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]\n        ));\n\n        updateCoverAfterCreation(controller, cover);\n        trigger(controller, {isEnd: false});\n    }\n\n    function driftPolygon(controller, cover, dx, dy, e) {\n        var range = cover.__brushOption.range;\n        var localDelta = toLocalDelta(controller, dx, dy);\n\n        each(range, function (point) {\n            point[0] += localDelta[0];\n            point[1] += localDelta[1];\n        });\n\n        updateCoverAfterCreation(controller, cover);\n        trigger(controller, {isEnd: false});\n    }\n\n    function toLocalDelta(controller, dx, dy) {\n        var thisGroup = controller.group;\n        var localD = thisGroup.transformCoordToLocal(dx, dy);\n        var localZero = thisGroup.transformCoordToLocal(0, 0);\n\n        return [localD[0] - localZero[0], localD[1] - localZero[1]];\n    }\n\n    function clipByPanel(controller, cover, data) {\n        var panel = getPanelByCover(controller, cover);\n        if (panel === true) { // Global panel\n            return zrUtil.clone(data);\n        }\n\n        var panelRect = panel.getBoundingRect();\n\n        return zrUtil.map(data, function (point) {\n            var x = point[0];\n            x = mathMax(x, panelRect.x);\n            x = mathMin(x, panelRect.x + panelRect.width);\n            var y = point[1];\n            y = mathMax(y, panelRect.y);\n            y = mathMin(y, panelRect.y + panelRect.height);\n            return [x, y];\n        });\n    }\n\n    function pointsToRect(points) {\n        var xmin = mathMin(points[0][0], points[1][0]);\n        var ymin = mathMin(points[0][1], points[1][1]);\n        var xmax = mathMax(points[0][0], points[1][0]);\n        var ymax = mathMax(points[0][1], points[1][1]);\n\n        return {\n            x: xmin,\n            y: ymin,\n            width: xmax - xmin,\n            height: ymax - ymin\n        };\n    }\n\n    function resetCursor(controller, e) {\n        var x = e.offsetX;\n        var y = e.offsetY;\n        var zr = controller._zr;\n\n        if (controller._brushType) { // If active\n            var panels = controller._panels;\n            var covers = controller._covers;\n            var inCover;\n\n            for (var i = 0; i < covers.length; i++) {\n                if (coverRenderers[covers[i].__brushOption.brushType].contain(covers[i], x, y)) {\n                    inCover = true;\n                    break;\n                }\n            }\n\n            if (!inCover) {\n                if (panels) { // Brush on panels\n                    each(panels, function (panel) {\n                        panel.contain(x, y) && zr.setCursorStyle('crosshair');\n                    });\n                }\n                else { // Global brush\n                    zr.setCursorStyle('crosshair');\n                }\n            }\n        }\n    }\n\n    function preventDefault(e) {\n        var rawE = e.event;\n        rawE.preventDefault && rawE.preventDefault();\n    }\n\n    function mainShapeContain(cover, x, y) {\n        return cover.childOfName('main').contain(x, y);\n    }\n\n    function updateCoverByMouse(controller, e, isEnd) {\n        var x = e.offsetX;\n        var y = e.offsetY;\n        var creatingCover = controller._creatingCover;\n        var panel = controller._creatingPanel;\n        var thisBrushOption = controller._brushOption;\n        var eventParams;\n\n        controller._track.push(controller.group.transformCoordToLocal(x, y));\n\n        if (shouldShowCover(controller) || creatingCover) {\n\n            if (panel && !creatingCover) {\n                thisBrushOption.brushMode === 'single' && clearCovers(controller);\n                var brushOption = zrUtil.clone(thisBrushOption);\n                brushOption.panelId = panel === true ? null : panel.__brushPanelId;\n                creatingCover = controller._creatingCover = createCover(controller, brushOption);\n                controller._covers.push(creatingCover);\n            }\n\n            if (creatingCover) {\n                var coverRenderer = coverRenderers[controller._brushType];\n                var coverBrushOption = creatingCover.__brushOption;\n\n                coverBrushOption.range = coverRenderer.getCreatingRange(\n                    clipByPanel(controller, creatingCover, controller._track)\n                );\n\n                if (isEnd) {\n                    endCreating(controller, creatingCover);\n                    coverRenderer.updateCommon(controller, creatingCover);\n                }\n\n                updateCoverShape(controller, creatingCover);\n\n                eventParams = {isEnd: isEnd};\n            }\n        }\n        else if (\n            isEnd\n            && thisBrushOption.brushMode === 'single'\n            && thisBrushOption.removeOnClick\n        ) {\n            // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n            // But a single click do not clear covers, because user may have casual\n            // clicks (for example, click on other component and do not expect covers\n            // disappear).\n            // Only some cover removed, trigger action, but not every click trigger action.\n            if (getPanelByPoint(controller, x, y) && clearCovers(controller)) {\n                eventParams = {isEnd: isEnd, removeOnClick: true};\n            }\n        }\n\n        return eventParams;\n    }\n\n    var mouseHandlers = {\n\n        mousedown: function (e) {\n            if (this._dragging) {\n                // In case some browser do not support globalOut,\n                // and release mose out side the browser.\n                handleDragEnd.call(this, e);\n            }\n            else if (!e.target || !e.target.draggable) {\n\n                preventDefault(e);\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                this._creatingCover = null;\n                var panel = this._creatingPanel = getPanelByPoint(this, x, y);\n\n                if (panel) {\n                    this._dragging = true;\n                    this._track = [this.group.transformCoordToLocal(x, y)];\n                }\n            }\n        },\n\n        mousemove: function (e) {\n            // set Cursor\n            resetCursor(this, e);\n\n            if (this._dragging) {\n\n                preventDefault(e);\n\n                var eventParams = updateCoverByMouse(this, e, false);\n\n                eventParams && trigger(this, eventParams);\n            }\n        },\n\n        mouseup: handleDragEnd //,\n\n        // FIXME\n        // in tooltip, globalout should not be triggered.\n        // globalout: handleDragEnd\n    };\n\n    function handleDragEnd(e) {\n        if (this._dragging) {\n\n            preventDefault(e);\n\n            var eventParams = updateCoverByMouse(this, e, true);\n\n            this._dragging = false;\n            this._track = [];\n            this._creatingCover = null;\n\n            // trigger event shoule be at final, after procedure will be nested.\n            eventParams && trigger(this, eventParams);\n        }\n    }\n\n    /**\n     * key: brushType\n     * @type {Object}\n     */\n    var coverRenderers = {\n\n        lineX: getLineRenderer(0),\n\n        lineY: getLineRenderer(1),\n\n        rect: {\n            createCover: function (controller, brushOption) {\n                return createBaseRectCover(\n                    curry(\n                        driftRect,\n                        function (range) {\n                            return range;\n                        },\n                        function (range) {\n                            return range;\n                        }\n                    ),\n                    controller,\n                    brushOption,\n                    ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']\n                );\n            },\n            getCreatingRange: function (localTrack) {\n                var ends = getTrackEnds(localTrack);\n                return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                updateBaseRect(controller, cover, localRange, brushOption);\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        },\n\n        polygon: {\n            createCover: function (controller, brushOption) {\n                var cover = new graphic.Group();\n\n                // Do not use graphic.Polygon because graphic.Polyline do not close the\n                // border of the shape when drawing, which is a better experience for user.\n                cover.add(new graphic.Polyline({\n                    name: 'main',\n                    style: makeStyle(brushOption),\n                    silent: true\n                }));\n\n                return cover;\n            },\n            getCreatingRange: function (localTrack) {\n                return localTrack;\n            },\n            endCreating: function (controller, cover) {\n                cover.remove(cover.childAt(0));\n                // Use graphic.Polygon close the shape.\n                cover.add(new graphic.Polygon({\n                    name: 'main',\n                    draggable: true,\n                    drift: curry(driftPolygon, controller, cover),\n                    ondragend: curry(trigger, controller, {isEnd: true})\n                }));\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                cover.childAt(0).setShape({\n                    points: clipByPanel(controller, cover, localRange)\n                });\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        }\n    };\n\n    function getLineRenderer(xyIndex) {\n        return {\n            createCover: function (controller, brushOption) {\n                return createBaseRectCover(\n                    curry(\n                        driftRect,\n                        function (range) {\n                            var rectRange = [range, [0, 100]];\n                            xyIndex && rectRange.reverse();\n                            return rectRange;\n                        },\n                        function (rectRange) {\n                            return rectRange[xyIndex];\n                        }\n                    ),\n                    controller,\n                    brushOption,\n                    [['w', 'e'], ['n', 's']][xyIndex]\n                );\n            },\n            getCreatingRange: function (localTrack) {\n                var ends = getTrackEnds(localTrack);\n                var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n                var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n\n                return [min, max];\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                var brushWidth = brushOption.brushStyle.width;\n                var otherExtent;\n                // If brushWidth not specified, fit the panel.\n                if (brushWidth == null) {\n                    var panel = getPanelByCover(controller, cover);\n                    var base = 0;\n                    if (panel !== true) {\n                        var rect = panel.getBoundingRect();\n                        brushWidth = xyIndex ? rect.width : rect.height;\n                        base = xyIndex ? rect.x : rect.y;\n                    }\n                    // FIXME\n                    // do not support global panel yet.\n                    otherExtent = [base, base + (brushWidth || 0)];\n                }\n                else {\n                    otherExtent = [-brushWidth / 2, brushWidth / 2];\n                }\n                var rectRange = [localRange, otherExtent];\n                xyIndex && rectRange.reverse();\n\n                updateBaseRect(controller, cover, rectRange, brushOption);\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        };\n    }\n\n    module.exports = BrushController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/helper/BrushController.js\n// module id = 113\n// module chunks = 0 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n\n    var each = zrUtil.each;\n\n    var helper = {};\n\n    var COMPONENT_NAMES = ['geo', 'xAxis', 'yAxis'];\n    var PANEL_ID_SPLIT = '--';\n    var COORD_CONVERTS = ['dataToPoint', 'pointToData'];\n\n    helper.parseOutputRanges = function (areas, coordInfoList, ecModel, rangesCoordInfo) {\n        each(areas, function (area, index) {\n            var panelId = area.panelId;\n\n            if (panelId) {\n                panelId = panelId.split(PANEL_ID_SPLIT);\n\n                area[panelId[0] + 'Index'] = +panelId[1];\n\n                var coordInfo = findCoordInfo(area, coordInfoList);\n                area.coordRange = coordConvert[area.brushType](\n                    1, coordInfo, area.range\n                );\n                rangesCoordInfo && (rangesCoordInfo[index] = coordInfo);\n            }\n        });\n    };\n\n    helper.parseInputRanges = function (brushModel, ecModel) {\n        each(brushModel.areas, function (area) {\n            var coordInfo = findCoordInfo(area, brushModel.coordInfoList);\n\n            if (__DEV__) {\n                zrUtil.assert(\n                    !coordInfo || coordInfo === true || area.coordRange,\n                    'coordRange must be specified when coord index specified.'\n                );\n                zrUtil.assert(\n                    !coordInfo || coordInfo !== true || area.range,\n                    'range must be specified.'\n                );\n            }\n\n            area.range = area.range || [];\n\n            // convert coordRange to global range and set panelId.\n            if (coordInfo && coordInfo !== true) {\n                area.range = coordConvert[area.brushType](\n                    0, coordInfo, area.coordRange\n                );\n                area.panelId = coordInfo.panelId;\n            }\n        });\n    };\n\n    helper.makePanelOpts = function (coordInfoList) {\n        var panelOpts = [];\n\n        each(coordInfoList, function (coordInfo) {\n            var coordSys = coordInfo.coordSys;\n            var rect;\n\n            if (coordInfo.geoIndex >= 0) {\n                rect = coordSys.getBoundingRect().clone();\n                // geo roam and zoom transform\n                rect.applyTransform(graphic.getTransform(coordSys));\n            }\n            else { // xAxis or yAxis\n                // grid is not Transformable.\n                rect = coordSys.grid.getRect().clone();\n            }\n\n            panelOpts.push({panelId: coordInfo.panelId, rect: rect});\n        });\n\n        return panelOpts;\n    };\n\n    /**\n     * @param {Object} option {xAxisIndex, yAxisIndex, geoIndex}\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Array.<Obejct>} coordInfoList\n     */\n    helper.makeCoordInfoList = function (option, ecModel) {\n        var coordInfoList = [];\n\n        each(COMPONENT_NAMES, function (componentName) {\n            var componentIndices = option[componentName + 'Index'];\n            if (componentIndices == null || componentIndices === 'none') {\n                return;\n            }\n            if (componentIndices !== 'all' && !zrUtil.isArray(componentIndices)) {\n                componentIndices = [componentIndices];\n            }\n\n            ecModel.eachComponent({mainType: componentName}, function (componentModel, index) {\n                if (componentIndices !== 'all' && zrUtil.indexOf(componentIndices, index) < 0) {\n                    return;\n                }\n\n                var grid;\n                var coordSys;\n\n                (componentName === 'xAxis' || componentName === 'yAxis')\n                    ? (grid = componentModel.axis.grid)\n                    : (coordSys = componentModel.coordinateSystem); // geo\n\n                var coordInfo;\n\n                // Check duplicate and find cartesian when tranval to yAxis.\n                for (var i = 0, len = coordInfoList.length; i < len; i++) {\n                    var cInfo = coordInfoList[i];\n                    if (__DEV__) {\n                        zrUtil.assert(\n                            cInfo[componentName + 'Index'] != index,\n                            'Coord should not be defined duplicately: ' + componentName + index\n                        );\n                    }\n                    // CoordSys is always required for `rect brush` or `polygon brush`.\n                    // If both xAxisIndex and yAxisIndex specified, fetch cartesian by them.\n                    if (componentName === 'yAxis' && !cInfo.yAxis && cInfo.xAxis) {\n                        var aCoordSys = grid.getCartesian(cInfo.xAxisIndex, index);\n                        if (aCoordSys) { // The yAxis and xAxis are in the same cartesian.\n                            coordSys = aCoordSys;\n                            coordInfo = cInfo;\n                            break;\n                        }\n                    }\n                }\n\n                !coordInfo && coordInfoList.push(coordInfo = {});\n\n                coordInfo[componentName] = componentModel;\n                coordInfo[componentName + 'Index'] = index;\n                // If both xAxisIndex and yAxisIndex specified, panelId only use yAxisIndex,\n                // which is enough to index panel.\n                coordInfo.panelId = componentName + PANEL_ID_SPLIT + index;\n                coordInfo.coordSys = coordSys\n                    // If only xAxisIndex or only yAxisIndex specified, find its first cartesian.\n                    || grid.getCartesian(coordInfo.xAxisIndex, coordInfo.yAxisIndex);\n\n                coordInfo.coordSys\n                    ? (coordInfoList[componentName + 'Has'] = true)\n                    : coordInfoList.pop(); // If a coordInfo exists originally, existance of coordSys is ensured.\n            });\n        });\n\n        return coordInfoList;\n    };\n\n    helper.controlSeries = function (area, brushModel, seriesModel) {\n        // Check whether area is bound in coord, and series do not belong to that coord.\n        // If do not do this check, some brush (like lineX) will controll all axes.\n        var coordInfo = findCoordInfo(area, brushModel.coordInfoList);\n        return coordInfo === true || (coordInfo && coordInfo.coordSys === seriesModel.coordinateSystem);\n    };\n\n    function formatMinMax(minMax) {\n        minMax[0] > minMax[1] && minMax.reverse();\n        return minMax;\n    }\n\n    /**\n     * If return Object, a coord found.\n     * If reutrn true, global found.\n     * Otherwise nothing found.\n     *\n     * @param {Object} area {<componentName>Index}\n     * @param {Array} coordInfoList\n     * @return {Obejct|boolean}\n     */\n    function findCoordInfo(area, coordInfoList) {\n        var isGlobal = true;\n        for (var j = 0; j < COMPONENT_NAMES.length; j++) {\n            var indexAttr = COMPONENT_NAMES[j] + 'Index';\n            if (area[indexAttr] >= 0) {\n                isGlobal = false;\n                for (var i = 0; i < coordInfoList.length; i++) {\n                    if (coordInfoList[i][indexAttr] === area[indexAttr]) {\n                        return coordInfoList[i];\n                    }\n                }\n            }\n        }\n        return isGlobal;\n    }\n\n    function axisConvert(axisName, to, coordInfo, coordRange) {\n        var axis = coordInfo.coordSys.getAxis(axisName);\n\n        if (__DEV__) {\n            zrUtil.assert(axis, 'line brush is only available in cartesian (grid).');\n        }\n\n        return formatMinMax(zrUtil.map([0, 1], function (i) {\n            return to\n                ? axis.coordToData(axis.toLocalCoord(coordRange[i]))\n                : axis.toGlobalCoord(axis.dataToCoord(coordRange[i]));\n        }));\n    }\n\n    var coordConvert = {\n\n        lineX: zrUtil.curry(axisConvert, 'x'),\n\n        lineY: zrUtil.curry(axisConvert, 'y'),\n\n        rect: function (to, coordInfo, coordRange) {\n            var coordSys = coordInfo.coordSys;\n            var xminymin = coordSys[COORD_CONVERTS[to]]([coordRange[0][0], coordRange[1][0]]);\n            var xmaxymax = coordSys[COORD_CONVERTS[to]]([coordRange[0][1], coordRange[1][1]]);\n            return [\n                formatMinMax([xminymin[0], xmaxymax[0]]),\n                formatMinMax([xminymin[1], xmaxymax[1]])\n            ];\n        },\n\n        polygon: function (to, coordInfo, coordRange) {\n            var coordSys = coordInfo.coordSys;\n            return zrUtil.map(coordRange, coordSys[COORD_CONVERTS[to]], coordSys);\n        }\n    };\n\n    module.exports = helper;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/helper/brushHelper.js\n// module id = 114\n// module chunks = 0 1","\n\n    var ATTR = '\\0_ec_interaction_mutex';\n\n    var interactionMutex = {\n\n        take: function (zr, resourceKey, userKey) {\n            var store = getStore(zr);\n            store[resourceKey] = userKey;\n        },\n\n        release: function (zr, resourceKey, userKey) {\n            var store = getStore(zr);\n            var uKey = store[resourceKey];\n\n            if (uKey === userKey) {\n                store[resourceKey] = null;\n            }\n        },\n\n        isTaken: function (zr, resourceKey) {\n            return !!getStore(zr)[resourceKey];\n        }\n    };\n\n    function getStore(zr) {\n        return zr[ATTR] || (zr[ATTR] = {});\n    }\n\n    /**\n     * payload: {\n     *     type: 'takeGlobalCursor',\n     *     key: 'dataZoomSelect', or 'brush', or ...,\n     *         If no userKey, release global cursor.\n     * }\n     */\n    require('../../echarts').registerAction(\n        {type: 'takeGlobalCursor', event: 'globalCursorTaken', update: 'update'},\n        function () {}\n    );\n\n    module.exports = interactionMutex;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/helper/interactionMutex.js\n// module id = 115\n// module chunks = 0 1","\n    // List layout\n    var layout = require('../../util/layout');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n\n    function positionGroup(group, model, api) {\n        layout.positionGroup(\n            group, model.getBoxLayoutParams(),\n            {\n                width: api.getWidth(),\n                height: api.getHeight()\n            },\n            model.get('padding')\n        );\n    }\n\n    module.exports = {\n        /**\n         * Layout list like component.\n         * It will box layout each items in group of component and then position the whole group in the viewport\n         * @param {module:zrender/group/Group} group\n         * @param {module:echarts/model/Component} componentModel\n         * @param {module:echarts/ExtensionAPI}\n         */\n        layout: function (group, componentModel, api) {\n            var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }, componentModel.get('padding'));\n            layout.box(\n                componentModel.get('orient'),\n                group,\n                componentModel.get('itemGap'),\n                rect.width,\n                rect.height\n            );\n\n            positionGroup(group, componentModel, api);\n        },\n\n        addBackground: function (group, componentModel) {\n            var padding = formatUtil.normalizeCssArray(\n                componentModel.get('padding')\n            );\n            var boundingRect = group.getBoundingRect();\n            var style = componentModel.getItemStyle(['color', 'opacity']);\n            style.fill = componentModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: boundingRect.x - padding[3],\n                    y: boundingRect.y - padding[0],\n                    width: boundingRect.width + padding[1] + padding[3],\n                    height: boundingRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true,\n                z2: -1\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/helper/listComponent.js\n// module id = 116\n// module chunks = 0 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Axis = require('../Axis');\n    var axisLabelInterval = require('./axisLabelInterval');\n\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n\n    Axis2D.prototype = {\n\n        constructor: Axis2D,\n\n        /**\n         * Index of axis, can be used as key\n         */\n        index: 0,\n        /**\n         * If axis is on the zero position of the other axis\n         * @type {boolean}\n         */\n        onZero: false,\n\n        /**\n         * Axis model\n         * @param {module:echarts/coord/cartesian/AxisModel}\n         */\n        model: null,\n\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n\n        getGlobalExtent: function () {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            return ret;\n        },\n\n        /**\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                labelInterval = this._labelInterval = axisLabelInterval(this);\n            }\n            return labelInterval;\n        },\n\n        /**\n         * If label is ignored.\n         * Automatically used when axis is category and label can not be all shown\n         * @param  {number}  idx\n         * @return {boolean}\n         */\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return ((typeof labelInterval === 'function')\n                    && !labelInterval(idx, this.scale.getLabel(idx)))\n                    || idx % (labelInterval + 1);\n            }\n        },\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var localCoord = axis.toLocalCoord(80);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toLocalCoord: null,\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var globalCoord = axis.toLocalCoord(40);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toGlobalCoord: null\n\n    };\n    zrUtil.inherits(Axis2D, Axis);\n\n    module.exports = Axis2D;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/cartesian/Axis2D.js\n// module id = 117\n// module chunks = 0 1 2","'use strict';\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n\n        this._dimList = [];\n\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n\n    Cartesian.prototype = {\n\n        constructor: Cartesian,\n\n        type: 'cartesian',\n\n        /**\n         * Get axis\n         * @param  {number|string} dim\n         * @return {module:echarts/coord/Cartesian~Axis}\n         */\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n\n        /**\n         * Get axes list\n         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n         */\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n\n        /**\n         * Get axes list by given scale type\n         */\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(\n                this.getAxes(),\n                function (axis) {\n                    return axis.scale.type === scaleType;\n                }\n            );\n        },\n\n        /**\n         * Add axis\n         * @param {module:echarts/coord/Cartesian.Axis}\n         */\n        addAxis: function (axis) {\n            var dim = axis.dim;\n\n            this._axes[dim] = axis;\n\n            this._dimList.push(dim);\n        },\n\n        /**\n         * Convert data to coord in nd space\n         * @param {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n\n        /**\n         * Convert coord in nd space to data\n         * @param  {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n\n            var output = input instanceof Array ? [] : {};\n\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n\n                output[dim] = axis[method](input[dim]);\n            }\n\n            return output;\n        }\n    };\n\n    module.exports = Cartesian;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/cartesian/Cartesian.js\n// module id = 118\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Cartesian = require('./Cartesian');\n\n    function Cartesian2D(name) {\n\n        Cartesian.call(this, name);\n    }\n\n    Cartesian2D.prototype = {\n\n        constructor: Cartesian2D,\n\n        type: 'cartesian2d',\n\n        /**\n         * @type {Array.<string>}\n         * @readOnly\n         */\n        dimensions: ['x', 'y'],\n\n        /**\n         * Base axis will be used on stacking.\n         *\n         * @return {module:echarts/coord/cartesian/Axis2D}\n         */\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0]\n                || this.getAxesByScale('time')[0]\n                || this.getAxis('x');\n        },\n\n        /**\n         * If contain point\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0]))\n                && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n\n        /**\n         * If contain data\n         * @param {Array.<number>} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0])\n                && this.getAxis('y').containData(data[1]);\n        },\n\n        /**\n         * Convert series data to an array of points\n         * @param {module:echarts/data/List} data\n         * @param {boolean} stack\n         * @return {Array}\n         *  Return array of points. For example:\n         *  `[[10, 10], [20, 20], [30, 30]]`\n         */\n        dataToPoints: function (data, stack) {\n            return data.mapArray(['x', 'y'], function (x, y) {\n                return this.dataToPoint([x, y]);\n            }, stack, this);\n        },\n\n        /**\n         * @param {Array.<number>} data\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n\n        /**\n         * @param {Array.<number>} point\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n\n        /**\n         * Get other axis\n         * @param {module:echarts/coord/cartesian/Axis2D} axis\n         */\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n    };\n\n    zrUtil.inherits(Cartesian2D, Cartesian);\n\n    module.exports = Cartesian2D;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/cartesian/Cartesian2D.js\n// module id = 119\n// module chunks = 0 1 2","'use strict';\n// Grid \n//  Cartesian2D \n\n\n    require('./AxisModel');\n    var ComponentModel = require('../../model/Component');\n\n    module.exports = ComponentModel.extend({\n\n        type: 'grid',\n\n        dependencies: ['xAxis', 'yAxis'],\n\n        layoutMode: 'box',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Grid}\n         */\n        coordinateSystem: null,\n\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            // If grid size contain label\n            containLabel: false,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/cartesian/GridModel.js\n// module id = 120\n// module chunks = 0 1 2","'use strict';\n/**\n * Helper function for axisLabelInterval calculation\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('../axisHelper');\n\n    module.exports = function (axis) {\n        var axisModel = axis.model;\n        var labelModel = axisModel.getModel('axisLabel');\n        var labelInterval = labelModel.get('interval');\n        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n            return labelInterval === 'auto' ? 0 : labelInterval;\n        }\n\n        return axisHelper.getAxisLabelInterval(\n            zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis),\n            axisModel.getFormattedLabels(),\n            labelModel.getModel('textStyle').getFont(),\n            axis.isHorizontal()\n        );\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/cartesian/axisLabelInterval.js\n// module id = 121\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var parsePercent = numberUtil.parsePercent;\n\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n    }\n\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n\n    function calBarWidthAndOffset(barSeries, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n\n        zrUtil.each(barSeries, function (seriesModel, idx) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category'\n                ? baseAxis.getBandWidth()\n                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\n            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n                bandWidth: bandWidth,\n                remainedWidth: bandWidth,\n                autoWidthCount: 0,\n                categoryGap: '20%',\n                gap: '30%',\n                stacks: {}\n            };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n\n            var stackId = getSeriesStackId(seriesModel);\n\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n\n            var barWidth = parsePercent(\n                seriesModel.get('barWidth'), bandWidth\n            );\n            var barMaxWidth = parsePercent(\n                seriesModel.get('barMaxWidth'), bandWidth\n            );\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n            // TODO\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            (barGap != null) && (columnsOnAxis.gap = barGap);\n            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n\n        var result = {};\n\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\n            result[coordSysName] = {};\n\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (!column.width && maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n\n        var barWidthAndOffset = calBarWidthAndOffset(\n            zrUtil.filter(\n                ecModel.getSeriesByType(seriesType),\n                function (seriesModel) {\n                    return !ecModel.isSeriesFiltered(seriesModel)\n                        && seriesModel.coordinateSystem\n                        && seriesModel.coordinateSystem.type === 'cartesian2d';\n                }\n            )\n        );\n\n        var lastStackCoords = {};\n        var lastStackCoordsOrigin = {};\n\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\n            var valueAxisStart = baseAxis.onZero\n                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n                : valueAxis.getGlobalExtent()[0];\n\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n\n            data.each(valueAxis.dim, function (value, idx) {\n                // \n                if (isNaN(value)) {\n                    return;\n                }\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                    lastStackCoordsOrigin[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n                var x;\n                var y;\n                var width;\n                var height;\n\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoordOrigin;\n                    height = columnWidth;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += width;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                }\n                else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoordOrigin;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += height;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n\n        }, this);\n    }\n\n    module.exports = barLayoutGrid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/layout/barGrid.js\n// module id = 122\n// module chunks = 0 1 2","\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/loading/default.js\n// module id = 123\n// module chunks = 0 1 2","/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var Model = require('./Model');\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = require('./Component');\n\n    var globalDefault = require('./globalDefault');\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption();\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            //  component model  merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION \n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap[mainType], newCptOptionList\n                );\n\n                makeKeyInfo(mainType, mapResult);\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap[mainType] = [];\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap[mainType][index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.series);\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap[mainType];\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap[mainType];\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts;\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap[mainType];\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q.hasOwnProperty(indexAttr)\n                        || q.hasOwnProperty(idAttr)\n                        || q.hasOwnProperty(nameAttr)\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                each(componentsMap, function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap[mainType], cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.series[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.series.slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.series, cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.series, cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.series);\n\n            var componentTypes = [];\n            each(componentsMap, function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap[componentType], function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            //  component model  merge  model \n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap[type] || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function makeKeyInfo(mainType, mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = {};\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && (idMap[existCpt.id] = item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && (idMap[opt.id] = item);\n\n            // Complete subType\n            if (isObject(opt)) {\n                var subType = determineSubType(mainType, opt, item.exist);\n                item.keyInfo = {mainType: mainType, subType: subType};\n            }\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-';\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap[keyInfo.id]);\n            }\n\n            idMap[keyInfo.id] = item;\n        });\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Series has not been initialized yet.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n\n    module.exports = GlobalModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/Global.js\n// module id = 124\n// module chunks = 0 1 2","/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            //  timeline options  media baseOption\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // resetclone\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // proformed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // mediaDefault\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/OptionManager.js\n// module id = 125\n// module chunks = 0 1 2","\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // \n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // \n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // \n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        //  Grid \n        // grid: {},\n        // \n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: true,\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        hoverLayerThreshold: 3000\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/globalDefault.js\n// module id = 126\n// module chunks = 0 1 2","\n    module.exports = {\n        getAreaStyle: require('./makeStyleMapper')(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/mixin/areaStyle.js\n// module id = 127\n// module chunks = 0 1 2","\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/mixin/boxLayout.js\n// module id = 128\n// module chunks = 0 1 2","\n    var getItemStyle = require('./makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes) {\n            var style = getItemStyle.call(this, excludes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/mixin/itemStyle.js\n// module id = 129\n// module chunks = 0 1 2","\n    var getLineStyle = require('./makeStyleMapper')(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/mixin/lineStyle.js\n// module id = 130\n// module chunks = 0 1 2","\n\n    var textContain = require('zrender/lib/contain/text');\n\n    function getShallow(model, path) {\n        return model && model.getShallow(path);\n    }\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @return {string}\n         */\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (ecModel && ecModel.get('textStyle.color'));\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            var ecModel = this.ecModel;\n            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n            return [\n                // FIXME in node-canvas fontWeight is before fontStyle\n                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n            ].join(' ');\n        },\n\n        getTextRect: function (text) {\n            var textStyle = this.get('textStyle') || {};\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                textStyle.align,\n                textStyle.baseline\n            );\n        },\n\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(\n                text, containerWidth, this.getFont(), ellipsis, options\n            );\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/mixin/textStyle.js\n// module id = 131\n// module chunks = 0 1 2","// Compatitable with 2.0\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var compatStyle = require('./helper/compatStyle');\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            compatStyle(seriesOpt);\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/preprocessor/backwardCompat.js\n// module id = 132\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n\n    module.exports = function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    }\n                    else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/preprocessor/helper/compatStyle.js\n// module id = 133\n// module chunks = 0 1 2","\n    var samplers = {\n        average: function (frame) {\n            var sum = 0;\n            var count = 0;\n            for (var i = 0; i < frame.length; i++) {\n                if (!isNaN(frame[i])) {\n                    sum += frame[i];\n                    count++;\n                }\n            }\n            // Return NaN if count is 0\n            return count === 0 ? NaN : sum / count;\n        },\n        sum: function (frame) {\n            var sum = 0;\n            for (var i = 0; i < frame.length; i++) {\n                // Ignore NaN\n                sum += frame[i] || 0;\n            }\n            return sum;\n        },\n        max: function (frame) {\n            var max = -Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] > max && (max = frame[i]);\n            }\n            return max;\n        },\n        min: function (frame) {\n            var min = Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] < min && (min = frame[i]);\n            }\n            return min;\n        },\n        // TODO\n        // Median\n        nearest: function (frame) {\n            return frame[0];\n        }\n    };\n\n    var indexSampler = function (frame, value) {\n        return Math.round(frame.length / 2);\n    };\n    module.exports = function (seriesType, ecModel, api) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var sampling = seriesModel.get('sampling');\n            var coordSys = seriesModel.coordinateSystem;\n            // Only cartesian2d support down sampling\n            if (coordSys.type === 'cartesian2d' && sampling) {\n                var baseAxis = coordSys.getBaseAxis();\n                var valueAxis = coordSys.getOtherAxis(baseAxis);\n                var extent = baseAxis.getExtent();\n                // Coordinste system has been resized\n                var size = extent[1] - extent[0];\n                var rate = Math.round(data.count() / size);\n                if (rate > 1) {\n                    var sampler;\n                    if (typeof sampling === 'string') {\n                        sampler = samplers[sampling];\n                    }\n                    else if (typeof sampling === 'function') {\n                        sampler = sampling;\n                    }\n                    if (sampler) {\n                        data = data.downSample(\n                            valueAxis.dim, 1 / rate, sampler, indexSampler\n                        );\n                        seriesModel.setData(data);\n                    }\n                }\n            }\n        }, this);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/processor/dataSample.js\n// module id = 134\n// module chunks = 0 1 2","/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n    var numberUtil = require('../util/number');\n\n    // Use some method of IntervalScale\n    var IntervalScale = require('./Interval');\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [approxTickNum = 10] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            intervalScaleProto.niceExtent.call(this, splitNumber, fixMin, fixMax);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = fixMin;\n            originalScale.__fixMax = fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/scale/Log.js\n// module id = 135\n// module chunks = 0 1 2","/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/scale/Ordinal.js\n// module id = 136\n// module chunks = 0 1 2","/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n\n    var IntervalScale = require('./Interval');\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME \n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        // Overwrite\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date);\n        },\n\n        // Overwrite\n        niceExtent: function (approxTickNum, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(approxTickNum);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        // Overwrite\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var niceExtent = [\n                mathCeil(extent[0] / interval) * interval,\n                mathFloor(extent[1] / interval) * interval\n            ];\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function () {\n        return new TimeScale();\n    };\n\n    module.exports = TimeScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/scale/Time.js\n// module id = 137\n// module chunks = 0 1 2","\n    var Gradient = require('zrender/lib/graphic/Gradient');\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/visual/seriesColor.js\n// module id = 138\n// module chunks = 0 1 2","'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n\n            this._hovered = hovered;\n\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = null;\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * cursor style\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * \n         *\n         * @private\n         * @param {Object} targetEl \n         * @param {string} eventName \n         * @param {Object} event \n         */\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\n            var el = targetEl;\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                if (!list[i].silent\n                 && list[i] !== exclude\n                 // getDisplayList may include ignored item in VML mode\n                 && !list[i].ignore\n                 && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hovered;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Handler.js\n// module id = 139\n// module chunks = 0 1 2","/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Layer.js\n// module id = 140\n// module chunks = 0 1 2","'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n\n    var Layer = require('./Layer');\n\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.isBuildin) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // \n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n        }\n\n        this.pathToImage = this._createPathToImage();\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n        },\n\n        /**\n         * \n         * @param {boolean} [paintAll=false] displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.isBuildin && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuildinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuildinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.isBuildin) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         *  zlevel \n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.isBuildin = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(\n                        layer.dom,\n                        prevDom.nextSibling\n                    );\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n\n            layersMap[zlevel] = layer;\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuildinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (! layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuildinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // \n            this.eachBuildinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * hover\n         */\n        clear: function () {\n            this.eachBuildinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * zlevel\n         *\n         * @param {string} zlevel\n         * @param {Object} config \n         * @param {string} [config.clearColor=0] \n         * @param {string} [config.motionBlur=false] \n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 alpha\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {number} zlevel zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * \n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * \n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            return imageLayer.dom;\n        },\n        /**\n         * \n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * \n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        _pathToImage: function (id, path, width, height, dpr) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [0, 0, 0];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                id: id,\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        },\n\n        _createPathToImage: function () {\n            var me = this;\n\n            return function (id, e, width, height) {\n                return me._pathToImage(\n                    id, e, width, height, me.dpr\n                );\n            };\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Painter.js\n// module id = 141\n// module chunks = 0 1 2","'use strict';\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n    var env = require('./core/env');\n\n    var Group = require('./container/Group');\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // idmap\n        this._elements = {};\n\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [update=false] \n         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n         *\n         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * \n         * GroupShapeShape\n         * zlevel > z > \n         * @param {boolean} [includeIgnore=false]  ignore \n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var clipPath = el.clipPath;\n            if (clipPath) {\n                // clipPath  group \n                clipPath.parent = el;\n                clipPath.updateTransform();\n\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                    clipPaths.push(clipPath);\n                }\n                else {\n                    clipPaths = [clipPath];\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {string|Array.<string>} [elId] Storage\n         */\n        delRoot: function (elId) {\n            if (elId == null) {\n                // elId\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n\n            var el;\n            if (typeof(elId) == 'string') {\n                el = this._elements[elId];\n            }\n            else {\n                el = elId;\n            }\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n\n            this._elements[el.id] = el;\n\n            return this;\n        },\n\n        get: function (elId) {\n            return this._elements[elId];\n        },\n\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Storage\n         */\n        dispose: function () {\n            this._elements =\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Storage.js\n// module id = 142\n// module chunks = 0 1 2","'use strict';\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = require('./requestAnimationFrame');\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         *  clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         *  animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * \n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * \n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * \n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * \n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * \n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * animator\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] \n         * @param  {Function} [options.getter=null]\n         *         gettergetter\n         * @param  {Function} [options.setter=null]\n         *         settersetter\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animation.js\n// module id = 143\n// module chunks = 0 1 2","/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n\n        // \n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            var percent = (globalTime - this._startTime) / this._life;\n\n            // \n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n\n            this._needsRemove = false;\n        },\n\n        fire: function(eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Clip.js\n// module id = 144\n// module chunks = 0 1 2","/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // t^3\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // t^4\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // t^5\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // sin(t)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 2^t\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // sqrt(1-t^2)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/easing.js\n// module id = 145\n// module chunks = 0 1 2","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/arc.js\n// module id = 146\n// module chunks = 0 1 2","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/cubic.js\n// module id = 147\n// module chunks = 0 1 2","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // \n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc \n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                //  subpath \n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE  L, C, Q  NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    //  arc \n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // \n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr scale, x\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        //  subpath \n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/path.js\n// module id = 148\n// module chunks = 0 1 2","'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = require('./event');\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/GestureMgr.js\n// module id = 149\n// module chunks = 0 1 2","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function() {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function(val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function(entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function(entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function() {\n        return this._len;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function(val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function(maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     */\n    LRUProto.put = function(key, value) {\n        var list = this._list;\n        var map = this._map;\n        if (map[key] == null) {\n            var len = list.len();\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n            }\n\n            var entry = list.insert(value);\n            entry.key = key;\n            map[key] = entry;\n        }\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function(key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function() {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/LRU.js\n// module id = 150\n// module chunks = 0 1 2","\n\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null),\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        if (gestureInfo) {\n            // eventTool.stop(event);\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n    function useTouchEvent() {\n        return env.touchEventsSupported;\n    }\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // rootdommouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        }\n    };\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        for (var i = 0; i < touchHandlerNames.length; i++) {\n            var name = touchHandlerNames[i];\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        }\n\n        for (var i = 0; i < mouseHandlerNames.length; i++) {\n            var name = mouseHandlerNames[i];\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        }\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (useTouchEvent()) {\n            mountHandlers(touchHandlerNames, this);\n\n            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n            // addEventListener(root, 'mouseout', this._mouseoutHandler);\n        }\n\n        // Considering some devices that both enable touch and mouse event (like MS Surface\n        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n        // mouse event can not be handle in those devices.\n        mountHandlers(mouseHandlerNames, this);\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/dom/HandlerProxy.js\n// module id = 151\n// module chunks = 0 1 2","// CompoundPath to improve performance\n\n\n    var Path = require('./Path');\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/CompoundPath.js\n// module id = 152\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/RadialGradient.js\n// module id = 153\n// module chunks = 0 1 2","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/roundRect.js\n// module id = 154\n// module chunks = 0 1 2","/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothBezier.js\n// module id = 155\n// module chunks = 0 1 2","/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothSpline.js\n// module id = 156\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Arc.js\n// module id = 157\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/BezierCurve.js\n// module id = 158\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Circle.js\n// module id = 159\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Line.js\n// module id = 160\n// module chunks = 0 1 2","/**\n * \n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polygon.js\n// module id = 161\n// module chunks = 0 1 2","/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polyline.js\n// module id = 162\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // r1r2r3r4\n            // r1          [1, 1, 1, 1]\n            // r[1]        [1, 1, 1, 1]\n            // r[1, 2]     [1, 2, 1, 2]\n            // r[1, 2, 3]  [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Rect.js\n// module id = 163\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Ring.js\n// module id = 164\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Sector.js\n// module id = 165\n// module chunks = 0 1 2","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * \n         *\n         * @param {string} path a.b.c\n         * @param {boolean} [loop] \n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Animatable.js\n// module id = 166\n// module chunks = 0 1 2","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    module.exports = Draggable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Draggable.js\n// module id = 167\n// module chunks = 0 1 2","\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/path.js\n// module id = 168\n// module chunks = 0 1 2","\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i++] += x;\n                    // cy\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/transformPath.js\n// module id = 169\n// module chunks = 0 1 2","\n\nif (!require('../core/env').canvasSupported) {\n    var urn = 'urn:schemas-microsoft-com:vml';\n\n    var createNode;\n    var win = window;\n    var doc = win.document;\n\n    var vmlInited = false;\n\n    try {\n        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n        createNode = function (tagName) {\n            return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n        };\n    }\n    catch (e) {\n        createNode = function (tagName) {\n            return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n        };\n    }\n\n    // From raphael\n    var initVML = function () {\n        if (vmlInited) {\n            return;\n        }\n        vmlInited = true;\n\n        var styleSheets = doc.styleSheets;\n        if (styleSheets.length < 31) {\n            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n        }\n        else {\n            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n        }\n    };\n\n    // Not useing return to avoid error when converting to CommonJS module\n    module.exports = {\n        doc: doc,\n        initVML: initVML,\n        createNode: createNode\n    };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/core.js\n// module id = 170\n// module chunks = 0 1","// TODO Batch by color\n\n\n\n    var graphic = require('../../util/graphic');\n    var symbolUtil = require('../../util/symbol');\n\n    var LargeSymbolPath = graphic.extendShape({\n\n        shape: {\n            points: null,\n            sizes: null\n        },\n\n        symbolProxy: null,\n\n        buildPath: function (path, shape) {\n            var points = shape.points;\n            var sizes = shape.sizes;\n\n            var symbolProxy = this.symbolProxy;\n            var symbolProxyShape = symbolProxy.shape;\n            for (var i = 0; i < points.length; i++) {\n                var pt = points[i];\n                var size = sizes[i];\n                if (size[0] < 4) {\n                    // Optimize for small symbol\n                    path.rect(\n                        pt[0] - size[0] / 2, pt[1] - size[1] / 2,\n                        size[0], size[1]\n                    );\n                }\n                else {\n                    symbolProxyShape.x = pt[0] - size[0] / 2;\n                    symbolProxyShape.y = pt[1] - size[1] / 2;\n                    symbolProxyShape.width = size[0];\n                    symbolProxyShape.height = size[1];\n\n                    symbolProxy.buildPath(path, symbolProxyShape, true);\n                }\n            }\n        },\n\n        findDataIndex: function (x, y) {\n            var shape = this.shape;\n            var points = shape.points;\n            var sizes = shape.sizes;\n\n            // Not consider transform\n            // Treat each element as a rect\n            // top down traverse\n            for (var i = points.length - 1; i >= 0; i--) {\n                var pt = points[i];\n                var size = sizes[i];\n                var x0 = pt[0] - size[0] / 2;\n                var y0 = pt[1] - size[1] / 2;\n                if (x >= x0 && y >= y0 && x <= x0 + size[0] && y <= y0 + size[1]) {\n                    // i is dataIndex\n                    return i;\n                }\n            }\n\n            return -1;\n        }\n    });\n\n    function LargeSymbolDraw() {\n        this.group = new graphic.Group();\n\n        this._symbolEl = new LargeSymbolPath({\n            // rectHover: true,\n            // cursor: 'default'\n        });\n    }\n\n    var largeSymbolProto = LargeSymbolDraw.prototype;\n\n    /**\n     * Update symbols draw by new data\n     * @param {module:echarts/data/List} data\n     */\n    largeSymbolProto.updateData = function (data) {\n        this.group.removeAll();\n\n        var symbolEl = this._symbolEl;\n\n        var seriesModel = data.hostModel;\n\n        symbolEl.setShape({\n            points: data.mapArray(data.getItemLayout),\n            sizes: data.mapArray(\n                function (idx) {\n                    var size = data.getItemVisual(idx, 'symbolSize');\n                    if (!(size instanceof Array)) {\n                        size = [size, size];\n                    }\n                    return size;\n                }\n            )\n        });\n\n        // Create symbolProxy to build path for each data\n        symbolEl.symbolProxy = symbolUtil.createSymbol(\n            data.getVisual('symbol'), 0, 0, 0, 0\n        );\n        // Use symbolProxy setColor method\n        symbolEl.setColor = symbolEl.symbolProxy.setColor;\n\n        symbolEl.useStyle(\n            seriesModel.getModel('itemStyle.normal').getItemStyle(['color'])\n        );\n\n        var visualColor = data.getVisual('color');\n        if (visualColor) {\n            symbolEl.setColor(visualColor);\n        }\n\n        // Enable tooltip\n        // PENDING May have performance issue when path is extremely large\n        symbolEl.seriesIndex = seriesModel.seriesIndex;\n        symbolEl.on('mousemove', function (e) {\n            symbolEl.dataIndex = null;\n            var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);\n            if (dataIndex > 0) {\n                // Provide dataIndex for tooltip\n                symbolEl.dataIndex = dataIndex;\n            }\n        });\n\n        // Add back\n        this.group.add(symbolEl);\n    };\n\n    largeSymbolProto.updateLayout = function (seriesModel) {\n        var data = seriesModel.getData();\n        this._symbolEl.setShape({\n            points: data.mapArray(data.getItemLayout)\n        });\n    };\n\n    largeSymbolProto.remove = function () {\n        this.group.removeAll();\n    };\n\n    module.exports = LargeSymbolDraw;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/helper/LargeSymbolDraw.js\n// module id = 174\n// module chunks = 0 1","/**\n * Line path for bezier and straight line draw\n */\n\n    var graphic = require('../../util/graphic');\n    var vec2 = require('zrender/lib/core/vector');\n\n    var straightLineProto = graphic.Line.prototype;\n    var bezierCurveProto = graphic.BezierCurve.prototype;\n\n    function isLine(shape) {\n        return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);\n    }\n\n    module.exports = graphic.extendShape({\n\n        type: 'ec-line',\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            percent: 1,\n            cpx1: null,\n            cpy1: null\n        },\n\n        buildPath: function (ctx, shape) {\n            (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);\n        },\n\n        pointAt: function (t) {\n            return isLine(this.shape)\n                ? straightLineProto.pointAt.call(this, t)\n                : bezierCurveProto.pointAt.call(this, t);\n        },\n\n        tangentAt: function (t) {\n            var shape = this.shape;\n            var p = isLine(shape)\n                ? [shape.x2 - shape.x1, shape.y2 - shape.y1]\n                : bezierCurveProto.tangentAt.call(this, t);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/helper/LinePath.js\n// module id = 175\n// module chunks = 0 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('./scatter/ScatterSeries');\n    require('./scatter/ScatterView');\n\n    echarts.registerVisual(zrUtil.curry(\n        require('../visual/symbol'), 'scatter', 'circle', null\n    ));\n    echarts.registerLayout(zrUtil.curry(\n        require('../layout/points'), 'scatter'\n    ));\n\n    // In case developer forget to include grid component\n    require('../component/grid');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/scatter.js\n// module id = 176\n// module chunks = 0 1","'use strict';\n\n\n    var createListFromArray = require('../helper/createListFromArray');\n    var SeriesModel = require('../../model/Series');\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.scatter',\n\n        dependencies: ['grid', 'polar'],\n\n        getInitialData: function (option, ecModel) {\n            var list = createListFromArray(option.data, this, ecModel);\n            return list;\n        },\n\n        brushSelector: 'point',\n\n        defaultOption: {\n            coordinateSystem: 'cartesian2d',\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // Polar coordinate system\n            // polarIndex: 0,\n\n            // Geo coordinate system\n            // geoIndex: 0,\n\n            // symbol: null,        // \n            symbolSize: 10,          // symbolSize * 2\n            // symbolRotate: null,  // \n\n            large: false,\n            // Available when large is true\n            largeThreshold: 2000,\n\n            // label: {\n                // normal: {\n                    // show: false\n                    // distance: 5,\n                    // formatter: Tooltip.formatter\n                    // position: 'top''right'\n                    //           'inside'|'left'|'right'|'top'|'bottom'\n                    // textStyle: null      // TEXTSTYLE\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    opacity: 0.8\n                    // color: \n                }\n            }\n        }\n\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/scatter/ScatterSeries.js\n// module id = 177\n// module chunks = 0 1","\n\n    var SymbolDraw = require('../helper/SymbolDraw');\n    var LargeSymbolDraw = require('../helper/LargeSymbolDraw');\n\n    require('../../echarts').extendChartView({\n\n        type: 'scatter',\n\n        init: function () {\n            this._normalSymbolDraw = new SymbolDraw();\n            this._largeSymbolDraw = new LargeSymbolDraw();\n        },\n\n        render: function (seriesModel, ecModel, api) {\n            var data = seriesModel.getData();\n            var largeSymbolDraw = this._largeSymbolDraw;\n            var normalSymbolDraw = this._normalSymbolDraw;\n            var group = this.group;\n\n            var symbolDraw = seriesModel.get('large') && data.count() > seriesModel.get('largeThreshold')\n                ? largeSymbolDraw : normalSymbolDraw;\n\n            this._symbolDraw = symbolDraw;\n            symbolDraw.updateData(data);\n            group.add(symbolDraw.group);\n\n            group.remove(\n                symbolDraw === largeSymbolDraw\n                ? normalSymbolDraw.group : largeSymbolDraw.group\n            );\n        },\n\n        updateLayout: function (seriesModel) {\n            this._symbolDraw.updateLayout(seriesModel);\n        },\n\n        remove: function (ecModel, api) {\n            this._symbolDraw && this._symbolDraw.remove(api, true);\n        },\n\n        dispose: function () {}\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/scatter/ScatterView.js\n// module id = 178\n// module chunks = 0 1","/**\n * DataZoom component entry\n */\n\n\n    require('./dataZoom/typeDefaulter');\n\n    require('./dataZoom/DataZoomModel');\n    require('./dataZoom/DataZoomView');\n\n    require('./dataZoom/SliderZoomModel');\n    require('./dataZoom/SliderZoomView');\n\n    require('./dataZoom/InsideZoomModel');\n    require('./dataZoom/InsideZoomView');\n\n    require('./dataZoom/dataZoomProcessor');\n    require('./dataZoom/dataZoomAction');\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom.js\n// module id = 179\n// module chunks = 0 1","/**\n * @file Axis operator\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../../util/number');\n    var each = zrUtil.each;\n    var asc = numberUtil.asc;\n\n    /**\n     * Operate single axis.\n     * One axis can only operated by one axis operator.\n     * Different dataZoomModels may be defined to operate the same axis.\n     * (i.e. 'inside' data zoom and 'slider' data zoom components)\n     * So dataZoomModels share one axisProxy in that case.\n     *\n     * @class\n     */\n    var AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n\n        /**\n         * @private\n         * @type {string}\n         */\n        this._dimName = dimName;\n\n        /**\n         * @private\n         */\n        this._axisIndex = axisIndex;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._valueWindow;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._percentWindow;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._dataExtent;\n\n        /**\n         * @readOnly\n         * @type {module: echarts/model/Global}\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @private\n         * @type {module: echarts/component/dataZoom/DataZoomModel}\n         */\n        this._dataZoomModel = dataZoomModel;\n    };\n\n    AxisProxy.prototype = {\n\n        constructor: AxisProxy,\n\n        /**\n         * Whether the axisProxy is hosted by dataZoomModel.\n         *\n         * @public\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         * @return {boolean}\n         */\n        hostedBy: function (dataZoomModel) {\n            return this._dataZoomModel === dataZoomModel;\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getDataExtent: function () {\n            return this._dataExtent.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getDataValueWindow: function () {\n            return this._valueWindow.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getDataPercentWindow: function () {\n            return this._percentWindow.slice();\n        },\n\n        /**\n         * @public\n         * @param {number} axisIndex\n         * @return {Array} seriesModels\n         */\n        getTargetSeriesModels: function () {\n            var seriesModels = [];\n            var ecModel = this.ecModel;\n\n            ecModel.eachSeries(function (seriesModel) {\n                var coordSysName = seriesModel.get('coordinateSystem');\n                if (coordSysName === 'cartesian2d' || coordSysName === 'polar') {\n                    var dimName = this._dimName;\n                    var axisModel = ecModel.queryComponents({\n                        mainType: dimName + 'Axis',\n                        index: seriesModel.get(dimName + 'AxisIndex'),\n                        id: seriesModel.get(dimName + 'AxisId')\n                    })[0];\n                    if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n                        seriesModels.push(seriesModel);\n                    }\n                }\n            }, this);\n\n            return seriesModels;\n        },\n\n        getAxisModel: function () {\n            return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n        },\n\n        getOtherAxisModel: function () {\n            var axisDim = this._dimName;\n            var ecModel = this.ecModel;\n            var axisModel = this.getAxisModel();\n            var isCartesian = axisDim === 'x' || axisDim === 'y';\n            var otherAxisDim;\n            var coordSysIndexName;\n            if (isCartesian) {\n                coordSysIndexName = 'gridIndex';\n                otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n            }\n            else {\n                coordSysIndexName = 'polarIndex';\n                otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n            }\n            var foundOtherAxisModel;\n            ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n                if ((otherAxisModel.get(coordSysIndexName) || 0)\n                    === (axisModel.get(coordSysIndexName) || 0)\n                ) {\n                    foundOtherAxisModel = otherAxisModel;\n                }\n            });\n            return foundOtherAxisModel;\n        },\n\n        /**\n         * Notice: reset should not be called before series.restoreData() called,\n         * so it is recommanded to be called in \"process stage\" but not \"model init\n         * stage\".\n         *\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        reset: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            // Culculate data window and data extent, and record them.\n            var dataExtent = this._dataExtent = calculateDataExtent(\n                this._dimName, this.getTargetSeriesModels()\n            );\n            var dataWindow = calculateDataWindow(\n                dataZoomModel.option, dataExtent, this\n            );\n            this._valueWindow = dataWindow.valueWindow;\n            this._percentWindow = dataWindow.percentWindow;\n\n            // Update axis setting then.\n            setAxisModel(this);\n        },\n\n        /**\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        restore: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            this._valueWindow = this._percentWindow = null;\n            setAxisModel(this, true);\n        },\n\n        /**\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        filterData: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            var axisDim = this._dimName;\n            var seriesModels = this.getTargetSeriesModels();\n            var filterMode = dataZoomModel.get('filterMode');\n            var valueWindow = this._valueWindow;\n\n            // FIXME\n            // Toolbox may has dataZoom injected. And if there are stacked bar chart\n            // with NaN data, NaN will be filtered and stack will be wrong.\n            // So we need to force the mode to be set empty.\n            // In fect, it is not a big deal that do not support filterMode-'filter'\n            // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n            // selection\" some day, which might need \"adapt to data extent on the\n            // otherAxis\", which is disabled by filterMode-'empty'.\n            var otherAxisModel = this.getOtherAxisModel();\n            if (dataZoomModel.get('$fromToolbox')\n                && otherAxisModel\n                && otherAxisModel.get('type') === 'category'\n            ) {\n                filterMode = 'empty';\n            }\n\n            // Process series data\n            each(seriesModels, function (seriesModel) {\n                var seriesData = seriesModel.getData();\n\n                seriesData && each(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n                    if (filterMode === 'empty') {\n                        seriesModel.setData(\n                            seriesData.map(dim, function (value) {\n                                return !isInWindow(value) ? NaN : value;\n                            })\n                        );\n                    }\n                    else {\n                        seriesData.filterSelf(dim, isInWindow);\n                    }\n                });\n            });\n\n            function isInWindow(value) {\n                return value >= valueWindow[0] && value <= valueWindow[1];\n            }\n        }\n    };\n\n    function calculateDataExtent(axisDim, seriesModels) {\n        var dataExtent = [Infinity, -Infinity];\n\n        each(seriesModels, function (seriesModel) {\n            var seriesData = seriesModel.getData();\n            if (seriesData) {\n                each(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n                    var seriesExtent = seriesData.getDataExtent(dim);\n                    seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n                    seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n                });\n            }\n        }, this);\n\n        return dataExtent;\n    }\n\n    function calculateDataWindow(opt, dataExtent, axisProxy) {\n        var axisModel = axisProxy.getAxisModel();\n        var scale = axisModel.axis.scale;\n        var percentExtent = [0, 100];\n        var percentWindow = [\n            opt.start,\n            opt.end\n        ];\n        var valueWindow = [];\n\n        // In percent range is used and axis min/max/scale is set,\n        // window should be based on min/max/0, but should not be\n        // based on the extent of filtered data.\n        dataExtent = dataExtent.slice();\n        fixExtendByAxis(dataExtent, axisModel, scale);\n\n        each(['startValue', 'endValue'], function (prop) {\n            valueWindow.push(\n                opt[prop] != null\n                    ? scale.parse(opt[prop])\n                    : null\n            );\n        });\n\n        // Normalize bound.\n        each([0, 1], function (idx) {\n            var boundValue = valueWindow[idx];\n            var boundPercent = percentWindow[idx];\n\n            // start/end has higher priority over startValue/endValue,\n            // because start/end can be consistent among different type\n            // of axis but startValue/endValue not.\n\n            if (boundPercent != null || boundValue == null) {\n                if (boundPercent == null) {\n                    boundPercent = percentExtent[idx];\n                }\n                // Use scale.parse to math round for category or time axis.\n                boundValue = scale.parse(numberUtil.linearMap(\n                    boundPercent, percentExtent, dataExtent, true\n                ));\n            }\n            else { // boundPercent == null && boundValue != null\n                boundPercent = numberUtil.linearMap(\n                    boundValue, dataExtent, percentExtent, true\n                );\n            }\n            // valueWindow[idx] = round(boundValue);\n            // percentWindow[idx] = round(boundPercent);\n            valueWindow[idx] = boundValue;\n            percentWindow[idx] = boundPercent;\n        });\n\n        return {\n            valueWindow: asc(valueWindow),\n            percentWindow: asc(percentWindow)\n        };\n    }\n\n    function fixExtendByAxis(dataExtent, axisModel, scale) {\n        each(['min', 'max'], function (minMax, index) {\n            var axisMax = axisModel.get(minMax, true);\n            // Consider 'dataMin', 'dataMax'\n            if (axisMax != null && (axisMax + '').toLowerCase() !== 'data' + minMax) {\n                dataExtent[index] = scale.parse(axisMax);\n            }\n        });\n\n        if (!axisModel.get('scale', true)) {\n            dataExtent[0] > 0 && (dataExtent[0] = 0);\n            dataExtent[1] < 0 && (dataExtent[1] = 0);\n        }\n\n        return dataExtent;\n    }\n\n    function setAxisModel(axisProxy, isRestore) {\n        var axisModel = axisProxy.getAxisModel();\n\n        var percentWindow = axisProxy._percentWindow;\n        var valueWindow = axisProxy._valueWindow;\n\n        if (!percentWindow) {\n            return;\n        }\n\n        var isFull = isRestore || (percentWindow[0] === 0 && percentWindow[1] === 100);\n        // [0, 500]: arbitrary value, guess axis extent.\n        var precision = !isRestore && numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n        // toFixed() digits argument must be between 0 and 20\n        var invalidPrecision = !isRestore && !(precision < 20 && precision >= 0);\n\n        var useOrigin = isRestore || isFull || invalidPrecision;\n\n        axisModel.setRange && axisModel.setRange(\n            useOrigin ? null : +valueWindow[0].toFixed(precision),\n            useOrigin ? null : +valueWindow[1].toFixed(precision)\n        );\n    }\n\n    module.exports = AxisProxy;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/AxisProxy.js\n// module id = 180\n// module chunks = 0 1","/**\n * @file Data zoom model\n */\n\n\n    module.exports = require('./DataZoomModel').extend({\n\n        type: 'dataZoom.inside',\n\n        /**\n         * @protected\n         */\n        defaultOption: {\n            silent: false,   // Whether disable this inside zoom.\n            zoomLock: false  // Whether disable zoom but only pan.\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/InsideZoomModel.js\n// module id = 181\n// module chunks = 0 1","\n\n    var DataZoomView = require('./DataZoomView');\n    var zrUtil = require('zrender/lib/core/util');\n    var sliderMove = require('../helper/sliderMove');\n    var roams = require('./roams');\n    var bind = zrUtil.bind;\n\n    var InsideZoomView = DataZoomView.extend({\n\n        type: 'dataZoom.inside',\n\n        /**\n         * @override\n         */\n        init: function (ecModel, api) {\n            /**\n             * 'throttle' is used in this.dispatchAction, so we save range\n             * to avoid missing some 'pan' info.\n             * @private\n             * @type {Array.<number>}\n             */\n            this._range;\n        },\n\n        /**\n         * @override\n         */\n        render: function (dataZoomModel, ecModel, api, payload) {\n            InsideZoomView.superApply(this, 'render', arguments);\n\n            // Notice: origin this._range should be maintained, and should not be re-fetched\n            // from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'\n            // info will be missed because of 'throttle' of this.dispatchAction.\n            if (roams.shouldRecordRange(payload, dataZoomModel.id)) {\n                this._range = dataZoomModel.getPercentRange();\n            }\n\n            var targetInfo = this.getTargetInfo();\n\n            // Reset controllers.\n            zrUtil.each(['cartesians', 'polars'], function (coordSysName) {\n\n                var coordInfoList = targetInfo[coordSysName];\n                var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {\n                    return roams.generateCoordId(coordInfo.model);\n                });\n\n                zrUtil.each(coordInfoList, function (coordInfo) {\n                    var coordModel = coordInfo.model;\n                    var coordinateSystem = coordModel.coordinateSystem;\n\n                    roams.register(\n                        api,\n                        {\n                            coordId: roams.generateCoordId(coordModel),\n                            allCoordIds: allCoordIds,\n                            coordinateSystem: coordinateSystem,\n                            containsPoint: bind(operations[coordSysName].containsPoint, this, coordinateSystem),\n                            dataZoomId: dataZoomModel.id,\n                            throttleRate: dataZoomModel.get('throttle', true),\n                            panGetRange: bind(this._onPan, this, coordInfo, coordSysName),\n                            zoomGetRange: bind(this._onZoom, this, coordInfo, coordSysName)\n                        }\n                    );\n                }, this);\n\n            }, this);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function () {\n            roams.unregister(this.api, this.dataZoomModel.id);\n            InsideZoomView.superApply(this, 'dispose', arguments);\n            this._range = null;\n        },\n\n        /**\n         * @private\n         */\n        _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) {\n            if (this.dataZoomModel.option.silent) {\n                return this._range;\n            }\n\n            var range = this._range.slice();\n\n            // Calculate transform by the first axis.\n            var axisModel = coordInfo.axisModels[0];\n            if (!axisModel) {\n                return;\n            }\n\n            var directionInfo = operations[coordSysName].getDirectionInfo(\n                [oldX, oldY], [newX, newY], axisModel, controller, coordInfo\n            );\n\n            var percentDelta = directionInfo.signal\n                * (range[1] - range[0])\n                * directionInfo.pixel / directionInfo.pixelLength;\n\n            sliderMove(percentDelta, range, [0, 100], 'rigid');\n\n            return (this._range = range);\n        },\n\n        /**\n         * @private\n         */\n        _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) {\n            var option = this.dataZoomModel.option;\n\n            if (option.silent || option.zoomLock) {\n                return this._range;\n            }\n\n            var range = this._range.slice();\n\n            // Calculate transform by the first axis.\n            var axisModel = coordInfo.axisModels[0];\n            if (!axisModel) {\n                return;\n            }\n\n            var directionInfo = operations[coordSysName].getDirectionInfo(\n                null, [mouseX, mouseY], axisModel, controller, coordInfo\n            );\n\n            var percentPoint = (directionInfo.pixel - directionInfo.pixelStart) /\n                directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n\n            scale = Math.max(1 / scale, 0);\n            range[0] = (range[0] - percentPoint) * scale + percentPoint;\n            range[1] = (range[1] - percentPoint) * scale + percentPoint;\n            return (this._range = fixRange(range));\n        }\n\n    });\n\n    var operations = {\n\n        cartesians: {\n\n            getDirectionInfo: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n                var axis = axisModel.axis;\n                var ret = {};\n                var rect = coordInfo.model.coordinateSystem.getRect();\n                oldPoint = oldPoint || [0, 0];\n\n                if (axis.dim === 'x') {\n                    ret.pixel = newPoint[0] - oldPoint[0];\n                    ret.pixelLength = rect.width;\n                    ret.pixelStart = rect.x;\n                    ret.signal = axis.inverse ? 1 : -1;\n                }\n                else { // axis.dim === 'y'\n                    ret.pixel = newPoint[1] - oldPoint[1];\n                    ret.pixelLength = rect.height;\n                    ret.pixelStart = rect.y;\n                    ret.signal = axis.inverse ? -1 : 1;\n                }\n\n                return ret;\n            },\n\n            containsPoint: function (coordinateSystem, x, y) {\n                return coordinateSystem.getRect().contain(x, y);\n            }\n        },\n\n        polars: {\n\n            getDirectionInfo: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n                var axis = axisModel.axis;\n                var ret = {};\n                var polar = coordInfo.model.coordinateSystem;\n                var radiusExtent = polar.getRadiusAxis().getExtent();\n                var angleExtent = polar.getAngleAxis().getExtent();\n\n                oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n                newPoint = polar.pointToCoord(newPoint);\n\n                if (axisModel.mainType === 'radiusAxis') {\n                    ret.pixel = newPoint[0] - oldPoint[0];\n                    // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);\n                    // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);\n                    ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n                    ret.pixelStart = radiusExtent[0];\n                    ret.signal = axis.inverse ? 1 : -1;\n                }\n                else { // 'angleAxis'\n                    ret.pixel = newPoint[1] - oldPoint[1];\n                    // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);\n                    // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);\n                    ret.pixelLength = angleExtent[1] - angleExtent[0];\n                    ret.pixelStart = angleExtent[0];\n                    ret.signal = axis.inverse ? -1 : 1;\n                }\n\n                return ret;\n            },\n\n            containsPoint: function (coordinateSystem, x, y) {\n                var radius = coordinateSystem.getRadiusAxis().getExtent()[1];\n                var cx = coordinateSystem.cx;\n                var cy = coordinateSystem.cy;\n\n                return Math.pow(x - cx, 2) + Math.pow(y - cy, 2) <= Math.pow(radius, 2);\n            }\n        }\n    };\n\n    function fixRange(range) {\n        // Clamp, using !(<= or >=) to handle NaN.\n        // jshint ignore:start\n        var bound = [0, 100];\n        !(range[0] <= bound[1]) && (range[0] = bound[1]);\n        !(range[1] <= bound[1]) && (range[1] = bound[1]);\n        !(range[0] >= bound[0]) && (range[0] = bound[0]);\n        !(range[1] >= bound[0]) && (range[1] = bound[0]);\n        // jshint ignore:end\n\n        return range;\n    }\n\n    module.exports = InsideZoomView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/InsideZoomView.js\n// module id = 182\n// module chunks = 0 1","/**\n * @file Data zoom model\n */\n\n\n    var DataZoomModel = require('./DataZoomModel');\n\n    module.exports = DataZoomModel.extend({\n\n        type: 'dataZoom.select'\n\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/SelectZoomModel.js\n// module id = 183\n// module chunks = 0 1","\n\n    module.exports = require('./DataZoomView').extend({\n\n        type: 'dataZoom.select'\n\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/SelectZoomView.js\n// module id = 184\n// module chunks = 0 1","/**\n * @file Data zoom model\n */\n\n\n    var DataZoomModel = require('./DataZoomModel');\n\n    var SliderZoomModel = DataZoomModel.extend({\n\n        type: 'dataZoom.slider',\n\n        layoutMode: 'box',\n\n        /**\n         * @protected\n         */\n        defaultOption: {\n            show: true,\n\n            // ph => placeholder. Using placehoder here because\n            // deault value can only be drived in view stage.\n            right: 'ph',  // Default align to grid rect.\n            top: 'ph',    // Default align to grid rect.\n            width: 'ph',  // Default align to grid rect.\n            height: 'ph', // Default align to grid rect.\n            left: null,   // Default align to grid rect.\n            bottom: null, // Default align to grid rect.\n\n            backgroundColor: 'rgba(47,69,84,0)',    // Background of slider zoom component.\n            // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,\n                                                    // highest priority, remain for compatibility of\n                                                    // previous version, but not recommended any more.\n            dataBackground: {\n                lineStyle: {\n                    color: '#2f4554',\n                    width: 0.5,\n                    opacity: 0.3\n                },\n                areaStyle: {\n                    color: 'rgba(47,69,84,0.3)',\n                    opacity: 0.3\n                }\n            },\n            borderColor: '#ddd',                    // border color of the box. For compatibility,\n                                                    // if dataBackgroundColor is set, borderColor\n                                                    // is ignored.\n\n            fillerColor: 'rgba(167,183,204,0.4)',     // Color of selected area.\n            // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.\n            // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',\n            handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',\n            // Percent of the slider height\n            handleSize: '100%',\n\n            handleStyle: {\n                color: '#a7b7cc'\n            },\n\n            labelPrecision: null,\n            labelFormatter: null,\n            showDetail: true,\n            showDataShadow: 'auto',                 // Default auto decision.\n            realtime: true,\n            zoomLock: false,                        // Whether disable zoom.\n            textStyle: {\n                color: '#333'\n            }\n        }\n\n    });\n\n    module.exports = SliderZoomModel;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/SliderZoomModel.js\n// module id = 185\n// module chunks = 0 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var throttle = require('../../util/throttle');\n    var DataZoomView = require('./DataZoomView');\n    var Rect = graphic.Rect;\n    var numberUtil = require('../../util/number');\n    var linearMap = numberUtil.linearMap;\n    var layout = require('../../util/layout');\n    var sliderMove = require('../helper/sliderMove');\n    var asc = numberUtil.asc;\n    var bind = zrUtil.bind;\n    // var mathMax = Math.max;\n    var each = zrUtil.each;\n\n    // Constants\n    var DEFAULT_LOCATION_EDGE_GAP = 7;\n    var DEFAULT_FRAME_BORDER_WIDTH = 1;\n    var DEFAULT_FILLER_SIZE = 30;\n    var HORIZONTAL = 'horizontal';\n    var VERTICAL = 'vertical';\n    var LABEL_GAP = 5;\n    var SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];\n\n    var SliderZoomView = DataZoomView.extend({\n\n        type: 'dataZoom.slider',\n\n        init: function (ecModel, api) {\n\n            /**\n             * @private\n             * @type {Object}\n             */\n            this._displayables = {};\n\n            /**\n             * @private\n             * @type {string}\n             */\n            this._orient;\n\n            /**\n             * [0, 100]\n             * @private\n             */\n            this._range;\n\n            /**\n             * [coord of the first handle, coord of the second handle]\n             * @private\n             */\n            this._handleEnds;\n\n            /**\n             * [length, thick]\n             * @private\n             * @type {Array.<number>}\n             */\n            this._size;\n\n            /**\n             * @private\n             * @type {number}\n             */\n            this._handleWidth;\n\n            /**\n             * @private\n             * @type {number}\n             */\n            this._handleHeight;\n\n            /**\n             * @private\n             */\n            this._location;\n\n            /**\n             * @private\n             */\n            this._dragging;\n\n            /**\n             * @private\n             */\n            this._dataShadowInfo;\n\n            this.api = api;\n        },\n\n        /**\n         * @override\n         */\n        render: function (dataZoomModel, ecModel, api, payload) {\n            SliderZoomView.superApply(this, 'render', arguments);\n\n            throttle.createOrUpdate(\n                this,\n                '_dispatchZoomAction',\n                this.dataZoomModel.get('throttle'),\n                'fixRate'\n            );\n\n            this._orient = dataZoomModel.get('orient');\n\n            if (this.dataZoomModel.get('show') === false) {\n                this.group.removeAll();\n                return;\n            }\n\n            // Notice: this._resetInterval() should not be executed when payload.type\n            // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'\n            // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,\n            if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {\n                this._buildView();\n            }\n\n            this._updateView();\n        },\n\n        /**\n         * @override\n         */\n        remove: function () {\n            SliderZoomView.superApply(this, 'remove', arguments);\n            throttle.clear(this, '_dispatchZoomAction');\n        },\n\n        /**\n         * @override\n         */\n        dispose: function () {\n            SliderZoomView.superApply(this, 'dispose', arguments);\n            throttle.clear(this, '_dispatchZoomAction');\n        },\n\n        _buildView: function () {\n            var thisGroup = this.group;\n\n            thisGroup.removeAll();\n\n            this._resetLocation();\n            this._resetInterval();\n\n            var barGroup = this._displayables.barGroup = new graphic.Group();\n\n            this._renderBackground();\n\n            this._renderHandle();\n\n            this._renderDataShadow();\n\n            thisGroup.add(barGroup);\n\n            this._positionGroup();\n        },\n\n        /**\n         * @private\n         */\n        _resetLocation: function () {\n            var dataZoomModel = this.dataZoomModel;\n            var api = this.api;\n\n            // If some of x/y/width/height are not specified,\n            // auto-adapt according to target grid.\n            var coordRect = this._findCoordRect();\n            var ecSize = {width: api.getWidth(), height: api.getHeight()};\n            // Default align by coordinate system rect.\n            var positionInfo = this._orient === HORIZONTAL\n                ? {\n                    // Why using 'right', because right should be used in vertical,\n                    // and it is better to be consistent for dealing with position param merge.\n                    right: ecSize.width - coordRect.x - coordRect.width,\n                    top: (ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP),\n                    width: coordRect.width,\n                    height: DEFAULT_FILLER_SIZE\n                }\n                : { // vertical\n                    right: DEFAULT_LOCATION_EDGE_GAP,\n                    top: coordRect.y,\n                    width: DEFAULT_FILLER_SIZE,\n                    height: coordRect.height\n                };\n\n            // Do not write back to option and replace value 'ph', because\n            // the 'ph' value should be recalculated when resize.\n            var layoutParams = layout.getLayoutParams(dataZoomModel.option);\n\n            // Replace the placeholder value.\n            zrUtil.each(['right', 'top', 'width', 'height'], function (name) {\n                if (layoutParams[name] === 'ph') {\n                    layoutParams[name] = positionInfo[name];\n                }\n            });\n\n            var layoutRect = layout.getLayoutRect(\n                layoutParams,\n                ecSize,\n                dataZoomModel.padding\n            );\n\n            this._location = {x: layoutRect.x, y: layoutRect.y};\n            this._size = [layoutRect.width, layoutRect.height];\n            this._orient === VERTICAL && this._size.reverse();\n        },\n\n        /**\n         * @private\n         */\n        _positionGroup: function () {\n            var thisGroup = this.group;\n            var location = this._location;\n            var orient = this._orient;\n\n            // Just use the first axis to determine mapping.\n            var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();\n            var inverse = targetAxisModel && targetAxisModel.get('inverse');\n\n            var barGroup = this._displayables.barGroup;\n            var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;\n\n            // Transform barGroup.\n            barGroup.attr(\n                (orient === HORIZONTAL && !inverse)\n                ? {scale: otherAxisInverse ? [1, 1] : [1, -1]}\n                : (orient === HORIZONTAL && inverse)\n                ? {scale: otherAxisInverse ? [-1, 1] : [-1, -1]}\n                : (orient === VERTICAL && !inverse)\n                ? {scale: otherAxisInverse ? [1, -1] : [1, 1], rotation: Math.PI / 2}\n                // Dont use Math.PI, considering shadow direction.\n                : {scale: otherAxisInverse ? [-1, -1] : [-1, 1], rotation: Math.PI / 2}\n            );\n\n            // Position barGroup\n            var rect = thisGroup.getBoundingRect([barGroup]);\n            thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);\n        },\n\n        /**\n         * @private\n         */\n        _getViewExtent: function () {\n            return [0, this._size[0]];\n        },\n\n        _renderBackground : function () {\n            var dataZoomModel = this.dataZoomModel;\n            var size = this._size;\n\n            this._displayables.barGroup.add(new Rect({\n                silent: true,\n                shape: {\n                    x: 0, y: 0, width: size[0], height: size[1]\n                },\n                style: {\n                    fill: dataZoomModel.get('backgroundColor')\n                },\n                z2: -40\n            }));\n        },\n\n        _renderDataShadow: function () {\n            var info = this._dataShadowInfo = this._prepareDataShadowInfo();\n\n            if (!info) {\n                return;\n            }\n\n            var size = this._size;\n            var seriesModel = info.series;\n            var data = seriesModel.getRawData();\n            var otherDim = seriesModel.getShadowDim\n                ? seriesModel.getShadowDim() // @see candlestick\n                : info.otherDim;\n\n            var otherDataExtent = data.getDataExtent(otherDim);\n            // Nice extent.\n            var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;\n            otherDataExtent = [\n                otherDataExtent[0] - otherOffset,\n                otherDataExtent[1] + otherOffset\n            ];\n            var otherShadowExtent = [0, size[1]];\n\n            var thisShadowExtent = [0, size[0]];\n\n            var areaPoints = [[size[0], 0], [0, 0]];\n            var linePoints = [];\n            var step = thisShadowExtent[1] / (data.count() - 1);\n            var thisCoord = 0;\n\n            // Optimize for large data shadow\n            var stride = Math.round(data.count() / size[0]);\n            var lastIsEmpty;\n            data.each([otherDim], function (value, index) {\n                if (stride > 0 && (index % stride)) {\n                    thisCoord += step;\n                    return;\n                }\n\n                // FIXME\n                // Should consider axis.min/axis.max when drawing dataShadow.\n\n                // FIXME\n                // list\n                var isEmpty = value == null || isNaN(value) || value === '';\n                // See #4235.\n                var otherCoord = isEmpty\n                    ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true);\n\n                // Attempt to draw data shadow precisely when there are empty value.\n                if (isEmpty && !lastIsEmpty && index) {\n                    areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);\n                    linePoints.push([linePoints[linePoints.length - 1][0], 0]);\n                }\n                else if (!isEmpty && lastIsEmpty) {\n                    areaPoints.push([thisCoord, 0]);\n                    linePoints.push([thisCoord, 0]);\n                }\n\n                areaPoints.push([thisCoord, otherCoord]);\n                linePoints.push([thisCoord, otherCoord]);\n\n                thisCoord += step;\n                lastIsEmpty = isEmpty;\n            });\n\n            var dataZoomModel = this.dataZoomModel;\n            // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');\n            this._displayables.barGroup.add(new graphic.Polygon({\n                shape: {points: areaPoints},\n                style: zrUtil.defaults(\n                    {fill: dataZoomModel.get('dataBackgroundColor')},\n                    dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()\n                ),\n                silent: true,\n                z2: -20\n            }));\n            this._displayables.barGroup.add(new graphic.Polyline({\n                shape: {points: linePoints},\n                style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),\n                silent: true,\n                z2: -19\n            }));\n        },\n\n        _prepareDataShadowInfo: function () {\n            var dataZoomModel = this.dataZoomModel;\n            var showDataShadow = dataZoomModel.get('showDataShadow');\n\n            if (showDataShadow === false) {\n                return;\n            }\n\n            // Find a representative series.\n            var result;\n            var ecModel = this.ecModel;\n\n            dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n                var seriesModels = dataZoomModel\n                    .getAxisProxy(dimNames.name, axisIndex)\n                    .getTargetSeriesModels();\n\n                zrUtil.each(seriesModels, function (seriesModel) {\n                    if (result) {\n                        return;\n                    }\n\n                    if (showDataShadow !== true && zrUtil.indexOf(\n                            SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')\n                        ) < 0\n                    ) {\n                        return;\n                    }\n\n                    var otherDim = getOtherDim(dimNames.name);\n\n                    var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;\n\n                    result = {\n                        thisAxis: thisAxis,\n                        series: seriesModel,\n                        thisDim: dimNames.name,\n                        otherDim: otherDim,\n                        otherAxisInverse: seriesModel\n                            .coordinateSystem.getOtherAxis(thisAxis).inverse\n                    };\n\n                }, this);\n\n            }, this);\n\n            return result;\n        },\n\n        _renderHandle: function () {\n            var displaybles = this._displayables;\n            var handles = displaybles.handles = [];\n            var handleLabels = displaybles.handleLabels = [];\n            var barGroup = this._displayables.barGroup;\n            var size = this._size;\n            var dataZoomModel = this.dataZoomModel;\n\n            barGroup.add(displaybles.filler = new Rect({\n                draggable: true,\n                cursor: 'move',\n                drift: bind(this._onDragMove, this, 'all'),\n                ondragstart: bind(this._showDataInfo, this, true),\n                ondragend: bind(this._onDragEnd, this),\n                onmouseover: bind(this._showDataInfo, this, true),\n                onmouseout: bind(this._showDataInfo, this, false),\n                style: {\n                    fill: dataZoomModel.get('fillerColor'),\n                    textPosition : 'inside'\n                }\n            }));\n\n            // Frame border.\n            barGroup.add(new Rect(graphic.subPixelOptimizeRect({\n                silent: true,\n                shape: {\n                    x: 0,\n                    y: 0,\n                    width: size[0],\n                    height: size[1]\n                },\n                style: {\n                    stroke: dataZoomModel.get('dataBackgroundColor')\n                        || dataZoomModel.get('borderColor'),\n                    lineWidth: DEFAULT_FRAME_BORDER_WIDTH,\n                    fill: 'rgba(0,0,0,0)'\n                }\n            })));\n\n            var iconStr = dataZoomModel.get('handleIcon');\n            each([0, 1], function (handleIndex) {\n                var path = graphic.makePath(iconStr, {\n                    style: {\n                        strokeNoScale: true\n                    },\n                    rectHover: true,\n                    cursor: this._orient === 'vertical' ? 'ns-resize' : 'ew-resize',\n                    draggable: true,\n                    drift: bind(this._onDragMove, this, handleIndex),\n                    ondragend: bind(this._onDragEnd, this),\n                    onmouseover: bind(this._showDataInfo, this, true),\n                    onmouseout: bind(this._showDataInfo, this, false)\n                }, {\n                    x: -0.5,\n                    y: 0,\n                    width: 1,\n                    height: 1\n                }, 'center');\n\n                var bRect = path.getBoundingRect();\n                this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);\n                this._handleWidth = bRect.width / bRect.height * this._handleHeight;\n\n                path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());\n                var handleColor = dataZoomModel.get('handleColor');\n                // Compatitable with previous version\n                if (handleColor != null) {\n                    path.style.fill = handleColor;\n                }\n\n                barGroup.add(handles[handleIndex] = path);\n\n                var textStyleModel = dataZoomModel.textStyleModel;\n\n                this.group.add(\n                    handleLabels[handleIndex] = new graphic.Text({\n                    silent: true,\n                    invisible: true,\n                    style: {\n                        x: 0, y: 0, text: '',\n                        textVerticalAlign: 'middle',\n                        textAlign: 'center',\n                        fill: textStyleModel.getTextColor(),\n                        textFont: textStyleModel.getFont()\n                    },\n                    z2: 10\n                }));\n\n            }, this);\n        },\n\n        /**\n         * @private\n         */\n        _resetInterval: function () {\n            var range = this._range = this.dataZoomModel.getPercentRange();\n            var viewExtent = this._getViewExtent();\n\n            this._handleEnds = [\n                linearMap(range[0], [0, 100], viewExtent, true),\n                linearMap(range[1], [0, 100], viewExtent, true)\n            ];\n        },\n\n        /**\n         * @private\n         * @param {(number|string)} handleIndex 0 or 1 or 'all'\n         * @param {number} dx\n         * @param {number} dy\n         */\n        _updateInterval: function (handleIndex, delta) {\n            var handleEnds = this._handleEnds;\n            var viewExtend = this._getViewExtent();\n\n            sliderMove(\n                delta,\n                handleEnds,\n                viewExtend,\n                (handleIndex === 'all' || this.dataZoomModel.get('zoomLock'))\n                    ? 'rigid' : 'cross',\n                handleIndex\n            );\n\n            this._range = asc([\n                linearMap(handleEnds[0], viewExtend, [0, 100], true),\n                linearMap(handleEnds[1], viewExtend, [0, 100], true)\n            ]);\n        },\n\n        /**\n         * @private\n         */\n        _updateView: function () {\n            var displaybles = this._displayables;\n            var handleEnds = this._handleEnds;\n            var handleInterval = asc(handleEnds.slice());\n            var size = this._size;\n\n            each([0, 1], function (handleIndex) {\n                // Handles\n                var handle = displaybles.handles[handleIndex];\n                var handleHeight = this._handleHeight;\n                handle.attr({\n                    scale: [handleHeight, handleHeight],\n                    position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]\n                });\n            }, this);\n\n            // Filler\n            displaybles.filler.setShape({\n                x: handleInterval[0],\n                y: 0,\n                width: handleInterval[1] - handleInterval[0],\n                height: size[1]\n            });\n\n            this._updateDataInfo();\n        },\n\n        /**\n         * @private\n         */\n        _updateDataInfo: function () {\n            var dataZoomModel = this.dataZoomModel;\n            var displaybles = this._displayables;\n            var handleLabels = displaybles.handleLabels;\n            var orient = this._orient;\n            var labelTexts = ['', ''];\n\n            // FIXME\n            // dateformatterautoformatterec2 date.getAutoFormatter\n            if (dataZoomModel.get('showDetail')) {\n                var dataInterval;\n                var axis;\n                dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n                    // Using dataInterval of the first axis.\n                    if (!dataInterval) {\n                        dataInterval = dataZoomModel\n                            .getAxisProxy(dimNames.name, axisIndex)\n                            .getDataValueWindow();\n                        axis = this.ecModel.getComponent(dimNames.axis, axisIndex).axis;\n                    }\n                }, this);\n\n                if (dataInterval) {\n                    labelTexts = [\n                        this._formatLabel(dataInterval[0], axis),\n                        this._formatLabel(dataInterval[1], axis)\n                    ];\n                }\n            }\n\n            var orderedHandleEnds = asc(this._handleEnds.slice());\n\n            setLabel.call(this, 0);\n            setLabel.call(this, 1);\n\n            function setLabel(handleIndex) {\n                // Label\n                // Text should not transform by barGroup.\n                // Ignore handlers transform\n                var barTransform = graphic.getTransform(\n                    displaybles.handles[handleIndex].parent, this.group\n                );\n                var direction = graphic.transformDirection(\n                    handleIndex === 0 ? 'right' : 'left', barTransform\n                );\n                var offset = this._handleWidth / 2 + LABEL_GAP;\n                var textPoint = graphic.applyTransform(\n                    [\n                        orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset),\n                        this._size[1] / 2\n                    ],\n                    barTransform\n                );\n                handleLabels[handleIndex].setStyle({\n                    x: textPoint[0],\n                    y: textPoint[1],\n                    textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,\n                    textAlign: orient === HORIZONTAL ? direction : 'center',\n                    text: labelTexts[handleIndex]\n                });\n            }\n        },\n\n        /**\n         * @private\n         */\n        _formatLabel: function (value, axis) {\n            var dataZoomModel = this.dataZoomModel;\n            var labelFormatter = dataZoomModel.get('labelFormatter');\n\n            var labelPrecision = dataZoomModel.get('labelPrecision');\n            if (labelPrecision == null || labelPrecision === 'auto') {\n                labelPrecision = axis.getPixelPrecision();\n            }\n\n            var valueStr = (value == null && isNaN(value))\n                ? ''\n                // FIXME Glue code\n                : (axis.type === 'category' || axis.type === 'time')\n                    ? axis.scale.getLabel(Math.round(value))\n                    // param of toFixed should less then 20.\n                    : value.toFixed(Math.min(labelPrecision, 20));\n\n            return zrUtil.isFunction(labelFormatter)\n                ? labelFormatter(value, valueStr)\n                : zrUtil.isString(labelFormatter)\n                ? labelFormatter.replace('{value}', valueStr)\n                : valueStr;\n        },\n\n        /**\n         * @private\n         * @param {boolean} showOrHide true: show, false: hide\n         */\n        _showDataInfo: function (showOrHide) {\n            // Always show when drgging.\n            showOrHide = this._dragging || showOrHide;\n\n            var handleLabels = this._displayables.handleLabels;\n            handleLabels[0].attr('invisible', !showOrHide);\n            handleLabels[1].attr('invisible', !showOrHide);\n        },\n\n        _onDragMove: function (handleIndex, dx, dy) {\n            this._dragging = true;\n\n            // Transform dx, dy to bar coordination.\n            var vertex = this._applyBarTransform([dx, dy], true);\n\n            this._updateInterval(handleIndex, vertex[0]);\n            this._updateView();\n\n            if (this.dataZoomModel.get('realtime')) {\n                this._dispatchZoomAction();\n            }\n        },\n\n        _onDragEnd: function () {\n            this._dragging = false;\n            this._showDataInfo(false);\n            this._dispatchZoomAction();\n        },\n\n        /**\n         * This action will be throttled.\n         * @private\n         */\n        _dispatchZoomAction: function () {\n            var range = this._range;\n\n            this.api.dispatchAction({\n                type: 'dataZoom',\n                from: this.uid,\n                dataZoomId: this.dataZoomModel.id,\n                start: range[0],\n                end: range[1]\n            });\n        },\n\n        /**\n         * @private\n         */\n        _applyBarTransform: function (vertex, inverse) {\n            var barTransform = this._displayables.barGroup.getLocalTransform();\n            return graphic.applyTransform(vertex, barTransform, inverse);\n        },\n\n        /**\n         * @private\n         */\n        _findCoordRect: function () {\n            // Find the grid coresponding to the first axis referred by dataZoom.\n            var targetInfo = this.getTargetInfo();\n\n            // FIXME\n            // catesianpolar\n            var rect;\n            if (targetInfo.cartesians.length) {\n                rect = targetInfo.cartesians[0].model.coordinateSystem.getRect();\n            }\n            else { // Polar\n                // FIXME\n                // \n                var width = this.api.getWidth();\n                var height = this.api.getHeight();\n                rect = {\n                    x: width * 0.2,\n                    y: height * 0.2,\n                    width: width * 0.6,\n                    height: height * 0.6\n                };\n            }\n\n            return rect;\n        }\n\n    });\n\n    function getOtherDim(thisDim) {\n        // FIXME\n        // getOtherAxis\n        return thisDim === 'x' ? 'y' : 'x';\n    }\n\n    module.exports = SliderZoomView;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/SliderZoomView.js\n// module id = 186\n// module chunks = 0 1","/**\n * @file Roam controller manager.\n */\n\n\n    // Only create one roam controller for each coordinate system.\n    // one roam controller might be refered by two inside data zoom\n    // components (for example, one for x and one for y). When user\n    // pan or zoom, only dispatch one action for those data zoom\n    // components.\n\n    var zrUtil = require('zrender/lib/core/util');\n    var RoamController = require('../../component/helper/RoamController');\n    var throttle = require('../../util/throttle');\n    var curry = zrUtil.curry;\n\n    var ATTR = '\\0_ec_dataZoom_roams';\n\n    var roams = {\n\n        /**\n         * @public\n         * @param {module:echarts/ExtensionAPI} api\n         * @param {Object} dataZoomInfo\n         * @param {string} dataZoomInfo.coordId\n         * @param {Function} dataZoomInfo.containsPoint\n         * @param {Array.<string>} dataZoomInfo.allCoordIds\n         * @param {string} dataZoomInfo.dataZoomId\n         * @param {number} dataZoomInfo.throttleRate\n         * @param {Function} dataZoomInfo.panGetRange\n         * @param {Function} dataZoomInfo.zoomGetRange\n         */\n        register: function (api, dataZoomInfo) {\n            var store = giveStore(api);\n            var theDataZoomId = dataZoomInfo.dataZoomId;\n            var theCoordId = dataZoomInfo.coordId;\n\n            // Do clean when a dataZoom changes its target coordnate system.\n            // Avoid memory leak, dispose all not-used-registered.\n            zrUtil.each(store, function (record, coordId) {\n                var dataZoomInfos = record.dataZoomInfos;\n                if (dataZoomInfos[theDataZoomId]\n                    && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0\n                ) {\n                    delete dataZoomInfos[theDataZoomId];\n                    record.count--;\n                }\n            });\n\n            cleanStore(store);\n\n            var record = store[theCoordId];\n            // Create if needed.\n            if (!record) {\n                record = store[theCoordId] = {\n                    coordId: theCoordId,\n                    dataZoomInfos: {},\n                    count: 0\n                };\n                record.controller = createController(api, dataZoomInfo, record);\n                record.dispatchAction = zrUtil.curry(dispatchAction, api);\n            }\n\n            // Consider resize, area should be always updated.\n            record.controller.setContainsPoint(dataZoomInfo.containsPoint);\n\n            // Update throttle.\n            throttle.createOrUpdate(\n                record,\n                'dispatchAction',\n                dataZoomInfo.throttleRate,\n                'fixRate'\n            );\n\n            // Update reference of dataZoom.\n            !(record.dataZoomInfos[theDataZoomId]) && record.count++;\n            record.dataZoomInfos[theDataZoomId] = dataZoomInfo;\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/ExtensionAPI} api\n         * @param {string} dataZoomId\n         */\n        unregister: function (api, dataZoomId) {\n            var store = giveStore(api);\n\n            zrUtil.each(store, function (record) {\n                record.controller.dispose();\n                var dataZoomInfos = record.dataZoomInfos;\n                if (dataZoomInfos[dataZoomId]) {\n                    delete dataZoomInfos[dataZoomId];\n                    record.count--;\n                }\n            });\n\n            cleanStore(store);\n        },\n\n        /**\n         * @public\n         */\n        shouldRecordRange: function (payload, dataZoomId) {\n            if (payload && payload.type === 'dataZoom' && payload.batch) {\n                for (var i = 0, len = payload.batch.length; i < len; i++) {\n                    if (payload.batch[i].dataZoomId === dataZoomId) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        },\n\n        /**\n         * @public\n         */\n        generateCoordId: function (coordModel) {\n            return coordModel.type + '\\0_' + coordModel.id;\n        }\n    };\n\n    /**\n     * Key: coordId, value: {dataZoomInfos: [], count, controller}\n     * @type {Array.<Object>}\n     */\n    function giveStore(api) {\n        // Mount store on zrender instance, so that we do not\n        // need to worry about dispose.\n        var zr = api.getZr();\n        return zr[ATTR] || (zr[ATTR] = {});\n    }\n\n    function createController(api, dataZoomInfo, newRecord) {\n        var controller = new RoamController(api.getZr());\n        controller.enable();\n        controller.on('pan', curry(onPan, newRecord));\n        controller.on('zoom', curry(onZoom, newRecord));\n\n        return controller;\n    }\n\n    function cleanStore(store) {\n        zrUtil.each(store, function (record, coordId) {\n            if (!record.count) {\n                record.controller.dispose();\n                delete store[coordId];\n            }\n        });\n    }\n\n    function onPan(record, dx, dy, oldX, oldY, newX, newY) {\n        wrapAndDispatch(record, function (info) {\n            return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY);\n        });\n    }\n\n    function onZoom(record, scale, mouseX, mouseY) {\n        wrapAndDispatch(record, function (info) {\n            return info.zoomGetRange(record.controller, scale, mouseX, mouseY);\n        });\n    }\n\n    function wrapAndDispatch(record, getRange) {\n        var batch = [];\n\n        zrUtil.each(record.dataZoomInfos, function (info) {\n            var range = getRange(info);\n            range && batch.push({\n                dataZoomId: info.dataZoomId,\n                start: range[0],\n                end: range[1]\n            });\n        });\n\n        record.dispatchAction(batch);\n    }\n\n    /**\n     * This action will be throttled.\n     */\n    function dispatchAction(api, batch) {\n        api.dispatchAction({\n            type: 'dataZoom',\n            batch: batch\n        });\n    }\n\n    module.exports = roams;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoom/roams.js\n// module id = 187\n// module chunks = 0 1","/**\n * DataZoom component entry\n */\n\n\n    require('./dataZoom/typeDefaulter');\n\n    require('./dataZoom/DataZoomModel');\n    require('./dataZoom/DataZoomView');\n\n    require('./dataZoom/SelectZoomModel');\n    require('./dataZoom/SelectZoomView');\n\n    require('./dataZoom/dataZoomProcessor');\n    require('./dataZoom/dataZoomAction');\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/dataZoomSelect.js\n// module id = 188\n// module chunks = 0 1","/**\n * Legend component entry file8\n */\n\n\n    require('./legend/LegendModel');\n    require('./legend/legendAction');\n    require('./legend/LegendView');\n\n    var echarts = require('../echarts');\n    // Series Filter\n    echarts.registerProcessor(require('./legend/legendFilter'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/legend.js\n// module id = 189\n// module chunks = 0 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Model = require('../../model/Model');\n\n    var LegendModel = require('../../echarts').extendComponentModel({\n\n        type: 'legend',\n\n        dependencies: ['series'],\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        init: function (option, parentModel, ecModel) {\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            option.selected = option.selected || {};\n        },\n\n        mergeOption: function (option) {\n            LegendModel.superCall(this, 'mergeOption', option);\n        },\n\n        optionUpdated: function () {\n            this._updateData(this.ecModel);\n\n            var legendData = this._data;\n\n            // If selectedMode is single, try to select one\n            if (legendData[0] && this.get('selectedMode') === 'single') {\n                var hasSelected = false;\n                // If has any selected in option.selected\n                for (var i = 0; i < legendData.length; i++) {\n                    var name = legendData[i].get('name');\n                    if (this.isSelected(name)) {\n                        // Force to unselect others\n                        this.select(name);\n                        hasSelected = true;\n                        break;\n                    }\n                }\n                // Try select the first if selectedMode is single\n                !hasSelected && this.select(legendData[0].get('name'));\n            }\n        },\n\n        _updateData: function (ecModel) {\n            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n                // Can be string or number\n                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n                    dataItem = {\n                        name: dataItem\n                    };\n                }\n                return new Model(dataItem, this, this.ecModel);\n            }, this);\n            this._data = legendData;\n\n            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n                return series.name;\n            });\n            ecModel.eachSeries(function (seriesModel) {\n                if (seriesModel.legendDataProvider) {\n                    var data = seriesModel.legendDataProvider();\n                    availableNames = availableNames.concat(data.mapArray(data.getName));\n                }\n            });\n            /**\n             * @type {Array.<string>}\n             * @private\n             */\n            this._availableNames = availableNames;\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Model>}\n         */\n        getData: function () {\n            return this._data;\n        },\n\n        /**\n         * @param {string} name\n         */\n        select: function (name) {\n            var selected = this.option.selected;\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                var data = this._data;\n                zrUtil.each(data, function (dataItem) {\n                    selected[dataItem.get('name')] = false;\n                });\n            }\n            selected[name] = true;\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            if (this.get('selectedMode') !== 'single') {\n                this.option.selected[name] = false;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var selected = this.option.selected;\n            // Default is true\n            if (!selected.hasOwnProperty(name)) {\n                selected[name] = true;\n            }\n            this[selected[name] ? 'unSelect' : 'select'](name);\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var selected = this.option.selected;\n            return !(selected.hasOwnProperty(name) && !selected[name])\n                && zrUtil.indexOf(this._availableNames, name) >= 0;\n        },\n\n        defaultOption: {\n            // \n            zlevel: 0,\n            // \n            z: 4,\n            show: true,\n\n            // \n            // 'horizontal' | 'vertical'\n            orient: 'horizontal',\n\n            left: 'center',\n            // right: 'center',\n\n            top: 'top',\n            // bottom: 'top',\n\n            // \n            // 'auto' | 'left' | 'right'\n            //  'auto',  x \n            align: 'auto',\n\n            backgroundColor: 'rgba(0,0,0,0)',\n            // \n            borderColor: '#ccc',\n            // px0\n            borderWidth: 0,\n            // px5\n            // css\n            padding: 5,\n            // itempx10\n            // \n            itemGap: 10,\n            // \n            itemWidth: 25,\n            // \n            itemHeight: 14,\n\n            // \n            inactiveColor: '#ccc',\n\n            textStyle: {\n                // \n                color: '#333'\n            },\n            // formatter: '',\n            // \n            selectedMode: true,\n            // LEGEND.SELECTED\n            // selected: null,\n            // legend.dataitem\n            // data: [],\n\n            // Tooltip \n            tooltip: {\n                show: false\n            }\n        }\n    });\n\n    module.exports = LegendModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/legend/LegendModel.js\n// module id = 190\n// module chunks = 0 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolCreator = require('../../util/symbol');\n    var graphic = require('../../util/graphic');\n    var listComponentHelper = require('../helper/listComponent');\n\n    var curry = zrUtil.curry;\n\n    function dispatchSelectAction(name, api) {\n        api.dispatchAction({\n            type: 'legendToggleSelect',\n            name: name\n        });\n    }\n\n    function dispatchHighlightAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'highlight',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    function dispatchDownplayAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'downplay',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    module.exports = require('../../echarts').extendComponentView({\n\n        type: 'legend',\n\n        init: function () {\n            this._symbolTypeStore = {};\n        },\n\n        render: function (legendModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!legendModel.get('show')) {\n                return;\n            }\n\n            var selectMode = legendModel.get('selectedMode');\n            var itemAlign = legendModel.get('align');\n\n            if (itemAlign === 'auto') {\n                itemAlign = (legendModel.get('left') === 'right'\n                    && legendModel.get('orient') === 'vertical')\n                    ? 'right' : 'left';\n            }\n\n            var legendDrawedMap = {};\n\n            zrUtil.each(legendModel.getData(), function (itemModel) {\n                var name = itemModel.get('name');\n\n                // Use empty string or \\n as a newline string\n                if (name === '' || name === '\\n') {\n                    group.add(new graphic.Group({\n                        newline: true\n                    }));\n                    return;\n                }\n\n                var seriesModel = ecModel.getSeriesByName(name)[0];\n\n                if (legendDrawedMap[name]) {\n                    // Have been drawed\n                    return;\n                }\n\n                // Series legend\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var color = data.getVisual('color');\n\n                    // If color is a callback function\n                    if (typeof color === 'function') {\n                        // Use the first data\n                        color = color(seriesModel.getDataParams(0));\n                    }\n\n                    // Using rect symbol defaultly\n                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n                    var symbolType = data.getVisual('symbol');\n\n                    var itemGroup = this._createItem(\n                        name, itemModel, legendModel,\n                        legendSymbolType, symbolType,\n                        itemAlign, color,\n                        selectMode\n                    );\n\n                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\n                    legendDrawedMap[name] = true;\n                }\n                else {\n                    // Data legend of pie, funnel\n                    ecModel.eachRawSeries(function (seriesModel) {\n                        // In case multiple series has same data name\n                        if (legendDrawedMap[name]) {\n                            return;\n                        }\n                        if (seriesModel.legendDataProvider) {\n                            var data = seriesModel.legendDataProvider();\n                            var idx = data.indexOfName(name);\n                            if (idx < 0) {\n                                return;\n                            }\n\n                            var color = data.getItemVisual(idx, 'color');\n\n                            var legendSymbolType = 'roundRect';\n\n                            var itemGroup = this._createItem(\n                                name, itemModel, legendModel,\n                                legendSymbolType, null,\n                                itemAlign, color,\n                                selectMode\n                            );\n\n                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                                // FIXME Should not specify the series name\n                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\n                            legendDrawedMap[name] = true;\n                        }\n                    }, this);\n                }\n\n                if (__DEV__) {\n                    if (!legendDrawedMap[name]) {\n                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n                    }\n                }\n            }, this);\n\n            listComponentHelper.layout(group, legendModel, api);\n            // Render background after group is layout\n            // FIXME\n            listComponentHelper.addBackground(group, legendModel);\n        },\n\n        _createItem: function (\n            name, itemModel, legendModel,\n            legendSymbolType, symbolType,\n            itemAlign, color, selectMode\n        ) {\n            var itemWidth = legendModel.get('itemWidth');\n            var itemHeight = legendModel.get('itemHeight');\n            var inactiveColor = legendModel.get('inactiveColor');\n\n            var isSelected = legendModel.isSelected(name);\n            var itemGroup = new graphic.Group();\n\n            var textStyleModel = itemModel.getModel('textStyle');\n\n            var itemIcon = itemModel.get('icon');\n\n            var tooltipModel = itemModel.getModel('tooltip');\n            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\n            // Use user given icon first\n            legendSymbolType = itemIcon || legendSymbolType;\n            itemGroup.add(symbolCreator.createSymbol(\n                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n            ));\n\n            // Compose symbols\n            // PENDING\n            if (!itemIcon && symbolType\n                // At least show one symbol, can't be all none\n                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n            ) {\n                var size = itemHeight * 0.8;\n                if (symbolType === 'none') {\n                    symbolType = 'circle';\n                }\n                // Put symbol in the center\n                itemGroup.add(symbolCreator.createSymbol(\n                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n                    isSelected ? color : inactiveColor\n                ));\n            }\n\n            // Text\n            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n            var textAlign = itemAlign;\n\n            var formatter = legendModel.get('formatter');\n            var content = name;\n            if (typeof formatter === 'string' && formatter) {\n                content = formatter.replace('{name}', name);\n            }\n            else if (typeof formatter === 'function') {\n                content = formatter(name);\n            }\n\n            var text = new graphic.Text({\n                style: {\n                    text: content,\n                    x: textX,\n                    y: itemHeight / 2,\n                    fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n                    textFont: textStyleModel.getFont(),\n                    textAlign: textAlign,\n                    textVerticalAlign: 'middle'\n                }\n            });\n            itemGroup.add(text);\n\n            // Add a invisible rect to increase the area of mouse hover\n            var hitRect = new graphic.Rect({\n                shape: itemGroup.getBoundingRect(),\n                invisible: true,\n                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n                    content: name,\n                    // Defaul formatter\n                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n                        return name;\n                    },\n                    formatterParams: {\n                        componentType: 'legend',\n                        legendIndex: legendModel.componentIndex,\n                        name: name,\n                        $vars: ['name']\n                    }\n                }, tooltipModel.option) : null\n            });\n            itemGroup.add(hitRect);\n\n            itemGroup.eachChild(function (child) {\n                child.silent = true;\n            });\n\n            hitRect.silent = !selectMode;\n\n\n\n            this.group.add(itemGroup);\n\n            graphic.setHoverStyle(itemGroup);\n\n            return itemGroup;\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/legend/LegendView.js\n// module id = 191\n// module chunks = 0 1","/**\n * @file Legend action\n */\n\n\n    var echarts = require('../../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function legendSelectActionHandler(methodName, payload, ecModel) {\n        var selectedMap = {};\n        var isToggleSelect = methodName === 'toggleSelected';\n        var isSelected;\n        // Update all legend components\n        ecModel.eachComponent('legend', function (legendModel) {\n            if (isToggleSelect && isSelected != null) {\n                // Force other legend has same selected status\n                // Or the first is toggled to true and other are toggled to false\n                // In the case one legend has some item unSelected in option. And if other legend\n                // doesn't has the item, they will assume it is selected.\n                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n            }\n            else {\n                legendModel[methodName](payload.name);\n                isSelected = legendModel.isSelected(payload.name);\n            }\n            var legendData = legendModel.getData();\n            zrUtil.each(legendData, function (model) {\n                var name = model.get('name');\n                // Wrap element\n                if (name === '\\n' || name === '') {\n                    return;\n                }\n                var isItemSelected = legendModel.isSelected(name);\n                if (name in selectedMap) {\n                    // Unselected if any legend is unselected\n                    selectedMap[name] = selectedMap[name] && isItemSelected;\n                }\n                else {\n                    selectedMap[name] = isItemSelected;\n                }\n            });\n        });\n        // Return the event explicitly\n        return {\n            name: payload.name,\n            selected: selectedMap\n        };\n    }\n    /**\n     * @event legendToggleSelect\n     * @type {Object}\n     * @property {string} type 'legendToggleSelect'\n     * @property {string} [from]\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendToggleSelect', 'legendselectchanged',\n        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n    );\n\n    /**\n     * @event legendSelect\n     * @type {Object}\n     * @property {string} type 'legendSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendSelect', 'legendselected',\n        zrUtil.curry(legendSelectActionHandler, 'select')\n    );\n\n    /**\n     * @event legendUnSelect\n     * @type {Object}\n     * @property {string} type 'legendUnSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendUnSelect', 'legendunselected',\n        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n    );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/legend/legendAction.js\n// module id = 192\n// module chunks = 0 1","\n   module.exports = function (ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (legendModels && legendModels.length) {\n            ecModel.filterSeries(function (series) {\n                // If in any legend component the status is not selected.\n                // Because in legend series is assumed selected when it is not in the legend data.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(series.name)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/legend/legendFilter.js\n// module id = 193\n// module chunks = 0 1","\n\n    require('./marker/MarkAreaModel');\n    require('./marker/MarkAreaView');\n\n    require('../echarts').registerPreprocessor(function (opt) {\n        // Make sure markArea component is enabled\n        opt.markArea = opt.markArea || {};\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/markArea.js\n// module id = 194\n// module chunks = 0 1","\n\n    require('./marker/MarkLineModel');\n    require('./marker/MarkLineView');\n\n    require('../echarts').registerPreprocessor(function (opt) {\n        // Make sure markLine component is enabled\n        opt.markLine = opt.markLine || {};\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/markLine.js\n// module id = 195\n// module chunks = 0 1","// HINT Markpoint can't be used too much\n\n\n    require('./marker/MarkPointModel');\n    require('./marker/MarkPointView');\n\n    require('../echarts').registerPreprocessor(function (opt) {\n        // Make sure markPoint component is enabled\n        opt.markPoint = opt.markPoint || {};\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/markPoint.js\n// module id = 196\n// module chunks = 0 1","\n\n    module.exports = require('./MarkerModel').extend({\n\n        type: 'markArea',\n\n        defaultOption: {\n            zlevel: 0,\n            // PENDING\n            z: 1,\n            tooltip: {\n                trigger: 'item'\n            },\n            // markArea should fixed on the coordinate system\n            animation: false,\n            label: {\n                normal: {\n                    show: true,\n                    position: 'top'\n                },\n                emphasis: {\n                    show: true,\n                    position: 'top'\n                }\n            },\n            itemStyle: {\n                normal: {\n                    // color and borderColor default to use color from series\n                    // color: 'auto'\n                    // borderColor: 'auto'\n                    borderWidth: 0\n                }\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/marker/MarkAreaModel.js\n// module id = 197\n// module chunks = 0 1","// TODO Better on polar\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var List = require('../../data/List');\n    var numberUtil = require('../../util/number');\n    var graphic = require('../../util/graphic');\n    var colorUtil = require('zrender/lib/tool/color');\n\n    var markerHelper = require('./markerHelper');\n\n    var markAreaTransform = function (seriesModel, coordSys, maModel, item) {\n        var lt = markerHelper.dataTransform(seriesModel, item[0]);\n        var rb = markerHelper.dataTransform(seriesModel, item[1]);\n        var retrieve = zrUtil.retrieve;\n\n        // FIXME make sure lt is less than rb\n        var ltCoord = lt.coord;\n        var rbCoord = rb.coord;\n        ltCoord[0] = retrieve(ltCoord[0], -Infinity);\n        ltCoord[1] = retrieve(ltCoord[1], -Infinity);\n\n        rbCoord[0] = retrieve(rbCoord[0], Infinity);\n        rbCoord[1] = retrieve(rbCoord[1], Infinity);\n\n        // Merge option into one\n        var result = zrUtil.mergeAll([{}, lt, rb]);\n\n        result.coord = [\n            lt.coord, rb.coord\n        ];\n        result.x0 = lt.x;\n        result.y0 = lt.y;\n        result.x1 = rb.x;\n        result.y1 = rb.y;\n        return result;\n    };\n\n    function isInifinity(val) {\n        return !isNaN(val) && !isFinite(val);\n    }\n\n    // If a markArea has one dim\n    function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n        var otherDimIndex = 1 - dimIndex;\n        return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);\n    }\n\n    function markAreaFilter(coordSys, item) {\n        var fromCoord = item.coord[0];\n        var toCoord = item.coord[1];\n        if (coordSys.type === 'cartesian2d') {\n            // In case\n            // {\n            //  markArea: {\n            //    data: [{ yAxis: 2 }]\n            //  }\n            // }\n            if (\n                fromCoord && toCoord &&\n                (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys)\n                || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))\n            ) {\n                return true;\n            }\n        }\n        return markerHelper.dataFilter(coordSys, {\n                coord: fromCoord,\n                x: item.x0,\n                y: item.y0\n            })\n            || markerHelper.dataFilter(coordSys, {\n                coord: toCoord,\n                x: item.x1,\n                y: item.y1\n            });\n    }\n\n    // dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']\n    function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {\n        var coordSys = seriesModel.coordinateSystem;\n        var itemModel = data.getItemModel(idx);\n\n        var point;\n        var xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth());\n        var yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight());\n        if (!isNaN(xPx) && !isNaN(yPx)) {\n            point = [xPx, yPx];\n        }\n        else {\n            // Chart like bar may have there own marker positioning logic\n            if (seriesModel.getMarkerPosition) {\n                // Use the getMarkerPoisition\n                point = seriesModel.getMarkerPosition(\n                    data.getValues(dims, idx)\n                );\n            }\n            else {\n                var x = data.get(dims[0], idx);\n                var y = data.get(dims[1], idx);\n                point = coordSys.dataToPoint([x, y], true);\n            }\n            if (coordSys.type === 'cartesian2d') {\n                var xAxis = coordSys.getAxis('x');\n                var yAxis = coordSys.getAxis('y');\n                var x = data.get(dims[0], idx);\n                var y = data.get(dims[1], idx);\n                if (isInifinity(x)) {\n                    point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);\n                }\n                else if (isInifinity(y)) {\n                    point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);\n                }\n            }\n\n            // Use x, y if has any\n            if (!isNaN(xPx)) {\n                point[0] = xPx;\n            }\n            if (!isNaN(yPx)) {\n                point[1] = yPx;\n            }\n        }\n\n        return point;\n    }\n\n    var dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];\n\n    require('./MarkerView').extend({\n\n        type: 'markArea',\n\n        updateLayout: function (markAreaModel, ecModel, api) {\n            ecModel.eachSeries(function (seriesModel) {\n                var maModel = seriesModel.markAreaModel;\n                if (maModel) {\n                    var areaData = maModel.getData();\n                    areaData.each(function (idx) {\n                        var points = zrUtil.map(dimPermutations, function (dim) {\n                            return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n                        });\n                        // Layout\n                        areaData.setItemLayout(idx, points);\n                        var el = areaData.getItemGraphicEl(idx);\n                        el.setShape('points', points);\n                    });\n                }\n            }, this);\n        },\n\n        renderSeries: function (seriesModel, maModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesName = seriesModel.name;\n            var seriesData = seriesModel.getData();\n\n            var areaGroupMap = this.markerGroupMap;\n            var polygonGroup = areaGroupMap[seriesName];\n            if (!polygonGroup) {\n                polygonGroup = areaGroupMap[seriesName] = {\n                    group: new graphic.Group()\n                };\n            }\n            this.group.add(polygonGroup.group);\n            polygonGroup.__keep = true;\n\n            var areaData = createList(coordSys, seriesModel, maModel);\n\n            // Line data for tooltip and formatter\n            maModel.setData(areaData);\n\n            // Update visual and layout of line\n            areaData.each(function (idx) {\n                // Layout\n                areaData.setItemLayout(idx, zrUtil.map(dimPermutations, function (dim) {\n                    return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n                }));\n\n                // Visual\n                areaData.setItemVisual(idx, {\n                    color: seriesData.getVisual('color')\n                });\n            });\n\n\n            areaData.diff(polygonGroup.__data)\n                .add(function (idx) {\n                    var polygon = new graphic.Polygon({\n                        shape: {\n                            points: areaData.getItemLayout(idx)\n                        }\n                    });\n                    areaData.setItemGraphicEl(idx, polygon);\n                    polygonGroup.group.add(polygon);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var polygon = polygonGroup.__data.getItemGraphicEl(oldIdx);\n                    graphic.updateProps(polygon, {\n                        shape: {\n                            points: areaData.getItemLayout(newIdx)\n                        }\n                    }, maModel, newIdx);\n                    polygonGroup.group.add(polygon);\n                    areaData.setItemGraphicEl(newIdx, polygon);\n                })\n                .remove(function (idx) {\n                    var polygon = polygonGroup.__data.getItemGraphicEl(idx);\n                    polygonGroup.group.remove(polygon);\n                })\n                .execute();\n\n            areaData.eachItemGraphicEl(function (polygon, idx) {\n                var itemModel = areaData.getItemModel(idx);\n                var labelModel = itemModel.getModel('label.normal');\n                var labelHoverModel = itemModel.getModel('label.emphasis');\n                var color = areaData.getItemVisual(idx, 'color');\n                polygon.useStyle(\n                    zrUtil.defaults(\n                        itemModel.getModel('itemStyle.normal').getItemStyle(),\n                        {\n                            fill: colorUtil.modifyAlpha(color, 0.4),\n                            stroke: color\n                        }\n                    )\n                );\n\n                polygon.hoverStyle = itemModel.getModel('itemStyle.normal').getItemStyle();\n\n                var defaultValue = areaData.getName(idx) || '';\n                var textColor = color || polygon.style.fill;\n                graphic.setText(polygon.style, labelModel, textColor);\n                polygon.style.text = zrUtil.retrieve(\n                    maModel.getFormattedLabel(idx, 'normal'),\n                    defaultValue\n                );\n\n                graphic.setText(polygon.hoverStyle, labelHoverModel, textColor);\n                polygon.hoverStyle.text = zrUtil.retrieve(\n                    maModel.getFormattedLabel(idx, 'emphasis'),\n                    defaultValue\n                );\n\n                graphic.setHoverStyle(polygon, {});\n\n                polygon.dataModel = maModel;\n            });\n\n            polygonGroup.__data = areaData;\n\n            polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');\n        }\n    });\n\n    /**\n     * @inner\n     * @param {module:echarts/coord/*} coordSys\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {module:echarts/model/Model} mpModel\n     */\n    function createList(coordSys, seriesModel, maModel) {\n\n        var coordDimsInfos;\n        var areaData;\n        var dims = ['x0', 'y0', 'x1', 'y1'];\n        if (coordSys) {\n            coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n                var info = seriesModel.getData().getDimensionInfo(\n                    seriesModel.coordDimToDataDim(coordDim)[0]\n                ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n                info.name = coordDim;\n                return info;\n            });\n            areaData = new List(zrUtil.map(dims, function (dim, idx) {\n                return {\n                    name: dim,\n                    type: coordDimsInfos[idx % 2].type\n                };\n            }), maModel);\n        }\n        else {\n            coordDimsInfos =[{\n                name: 'value',\n                type: 'float'\n            }];\n            areaData = new List(coordDimsInfos, maModel);\n        }\n\n        var optData = zrUtil.map(maModel.get('data'), zrUtil.curry(\n            markAreaTransform, seriesModel, coordSys, maModel\n        ));\n        if (coordSys) {\n            optData = zrUtil.filter(\n                optData, zrUtil.curry(markAreaFilter, coordSys)\n            );\n        }\n\n        var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {\n            return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];\n        } : function (item) {\n            return item.value;\n        };\n        areaData.initData(optData, null, dimValueGetter);\n        areaData.hasItemOption = true;\n        return areaData;\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/marker/MarkAreaView.js\n// module id = 198\n// module chunks = 0 1","\n\n    module.exports = require('./MarkerModel').extend({\n\n        type: 'markLine',\n\n        defaultOption: {\n            zlevel: 0,\n            z: 5,\n\n            symbol: ['circle', 'arrow'],\n            symbolSize: [8, 16],\n\n            //symbolRotate: 0,\n\n            precision: 2,\n            tooltip: {\n                trigger: 'item'\n            },\n            label: {\n                normal: {\n                    show: true,\n                    position: 'end'\n                },\n                emphasis: {\n                    show: true\n                }\n            },\n            lineStyle: {\n                normal: {\n                    type: 'dashed'\n                },\n                emphasis: {\n                    width: 3\n                }\n            },\n            animationEasing: 'linear'\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/marker/MarkLineModel.js\n// module id = 199\n// module chunks = 0 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var List = require('../../data/List');\n    var numberUtil = require('../../util/number');\n\n    var markerHelper = require('./markerHelper');\n\n    var LineDraw = require('../../chart/helper/LineDraw');\n\n    var markLineTransform = function (seriesModel, coordSys, mlModel, item) {\n        var data = seriesModel.getData();\n        // Special type markLine like 'min', 'max', 'average'\n        var mlType = item.type;\n\n        if (!zrUtil.isArray(item)\n            && (\n                mlType === 'min' || mlType === 'max' || mlType === 'average'\n                // In case\n                // data: [{\n                //   yAxis: 10\n                // }]\n                || (item.xAxis != null || item.yAxis != null)\n            )\n        ) {\n            var valueAxis;\n            var valueDataDim;\n            var value;\n\n            if (item.yAxis != null || item.xAxis != null) {\n                valueDataDim = item.yAxis != null ? 'y' : 'x';\n                valueAxis = coordSys.getAxis(valueDataDim);\n\n                value = zrUtil.retrieve(item.yAxis, item.xAxis);\n            }\n            else {\n                var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);\n                valueDataDim = axisInfo.valueDataDim;\n                valueAxis = axisInfo.valueAxis;\n                value = markerHelper.numCalculate(data, valueDataDim, mlType);\n            }\n            var valueIndex = valueDataDim === 'x' ? 0 : 1;\n            var baseIndex = 1 - valueIndex;\n\n            var mlFrom = zrUtil.clone(item);\n            var mlTo = {};\n\n            mlFrom.type = null;\n\n            mlFrom.coord = [];\n            mlTo.coord = [];\n            mlFrom.coord[baseIndex] = -Infinity;\n            mlTo.coord[baseIndex] = Infinity;\n\n            var precision = mlModel.get('precision');\n            if (precision >= 0 && typeof value === 'number') {\n                value = +value.toFixed(precision);\n            }\n\n            mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;\n\n            item = [mlFrom, mlTo, { // Extra option for tooltip and label\n                type: mlType,\n                valueIndex: item.valueIndex,\n                // Force to use the value of calculated value.\n                value: value\n            }];\n        }\n\n        item = [\n            markerHelper.dataTransform(seriesModel, item[0]),\n            markerHelper.dataTransform(seriesModel, item[1]),\n            zrUtil.extend({}, item[2])\n        ];\n\n        // Avoid line data type is extended by from(to) data type\n        item[2].type = item[2].type || '';\n\n        // Merge from option and to option into line option\n        zrUtil.merge(item[2], item[0]);\n        zrUtil.merge(item[2], item[1]);\n\n        return item;\n    };\n\n    function isInifinity(val) {\n        return !isNaN(val) && !isFinite(val);\n    }\n\n    // If a markLine has one dim\n    function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n        var otherDimIndex = 1 - dimIndex;\n        var dimName = coordSys.dimensions[dimIndex];\n        return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex])\n            && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);\n    }\n\n    function markLineFilter(coordSys, item) {\n        if (coordSys.type === 'cartesian2d') {\n            var fromCoord = item[0].coord;\n            var toCoord = item[1].coord;\n            // In case\n            // {\n            //  markLine: {\n            //    data: [{ yAxis: 2 }]\n            //  }\n            // }\n            if (\n                fromCoord && toCoord &&\n                (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys)\n                || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))\n            ) {\n                return true;\n            }\n        }\n        return markerHelper.dataFilter(coordSys, item[0])\n            && markerHelper.dataFilter(coordSys, item[1]);\n    }\n\n    function updateSingleMarkerEndLayout(\n        data, idx, isFrom, seriesModel, api\n    ) {\n        var coordSys = seriesModel.coordinateSystem;\n        var itemModel = data.getItemModel(idx);\n\n        var point;\n        var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n        var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n        if (!isNaN(xPx) && !isNaN(yPx)) {\n            point = [xPx, yPx];\n        }\n        else {\n            // Chart like bar may have there own marker positioning logic\n            if (seriesModel.getMarkerPosition) {\n                // Use the getMarkerPoisition\n                point = seriesModel.getMarkerPosition(\n                    data.getValues(data.dimensions, idx)\n                );\n            }\n            else {\n                var dims = coordSys.dimensions;\n                var x = data.get(dims[0], idx);\n                var y = data.get(dims[1], idx);\n                point = coordSys.dataToPoint([x, y]);\n            }\n            // Expand line to the edge of grid if value on one axis is Inifnity\n            // In case\n            //  markLine: {\n            //    data: [{\n            //      yAxis: 2\n            //      // or\n            //      type: 'average'\n            //    }]\n            //  }\n            if (coordSys.type === 'cartesian2d') {\n                var xAxis = coordSys.getAxis('x');\n                var yAxis = coordSys.getAxis('y');\n                var dims = coordSys.dimensions;\n                if (isInifinity(data.get(dims[0], idx))) {\n                    point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);\n                }\n                else if (isInifinity(data.get(dims[1], idx))) {\n                    point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);\n                }\n            }\n\n            // Use x, y if has any\n            if (!isNaN(xPx)) {\n                point[0] = xPx;\n            }\n            if (!isNaN(yPx)) {\n                point[1] = yPx;\n            }\n        }\n\n        data.setItemLayout(idx, point);\n    }\n\n    require('./MarkerView').extend({\n\n        type: 'markLine',\n\n        updateLayout: function (markLineModel, ecModel, api) {\n            ecModel.eachSeries(function (seriesModel) {\n                var mlModel = seriesModel.markLineModel;\n                if (mlModel) {\n                    var mlData = mlModel.getData();\n                    var fromData = mlModel.__from;\n                    var toData = mlModel.__to;\n                    // Update visual and layout of from symbol and to symbol\n                    fromData.each(function (idx) {\n                        updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);\n                        updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);\n                    });\n                    // Update layout of line\n                    mlData.each(function (idx) {\n                        mlData.setItemLayout(idx, [\n                            fromData.getItemLayout(idx),\n                            toData.getItemLayout(idx)\n                        ]);\n                    });\n\n                    this.markerGroupMap[seriesModel.name].updateLayout();\n\n                }\n            }, this);\n        },\n\n        renderSeries: function (seriesModel, mlModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesName = seriesModel.name;\n            var seriesData = seriesModel.getData();\n\n            var lineDrawMap = this.markerGroupMap;\n            var lineDraw = lineDrawMap[seriesName];\n            if (!lineDraw) {\n                lineDraw = lineDrawMap[seriesName] = new LineDraw();\n            }\n            this.group.add(lineDraw.group);\n\n            var mlData = createList(coordSys, seriesModel, mlModel);\n\n            var fromData = mlData.from;\n            var toData = mlData.to;\n            var lineData = mlData.line;\n\n            mlModel.__from = fromData;\n            mlModel.__to = toData;\n            // Line data for tooltip and formatter\n            mlModel.setData(lineData);\n\n            var symbolType = mlModel.get('symbol');\n            var symbolSize = mlModel.get('symbolSize');\n            if (!zrUtil.isArray(symbolType)) {\n                symbolType = [symbolType, symbolType];\n            }\n            if (typeof symbolSize === 'number') {\n                symbolSize = [symbolSize, symbolSize];\n            }\n\n            // Update visual and layout of from symbol and to symbol\n            mlData.from.each(function (idx) {\n                updateDataVisualAndLayout(fromData, idx, true);\n                updateDataVisualAndLayout(toData, idx, false);\n            });\n\n            // Update visual and layout of line\n            lineData.each(function (idx) {\n                var lineColor = lineData.getItemModel(idx).get('lineStyle.normal.color');\n                lineData.setItemVisual(idx, {\n                    color: lineColor || fromData.getItemVisual(idx, 'color')\n                });\n                lineData.setItemLayout(idx, [\n                    fromData.getItemLayout(idx),\n                    toData.getItemLayout(idx)\n                ]);\n\n                lineData.setItemVisual(idx, {\n                    'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),\n                    'fromSymbol': fromData.getItemVisual(idx, 'symbol'),\n                    'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),\n                    'toSymbol': toData.getItemVisual(idx, 'symbol')\n                });\n            });\n\n            lineDraw.updateData(lineData);\n\n            // Set host model for tooltip\n            // FIXME\n            mlData.line.eachItemGraphicEl(function (el, idx) {\n                el.traverse(function (child) {\n                    child.dataModel = mlModel;\n                });\n            });\n\n            function updateDataVisualAndLayout(data, idx, isFrom) {\n                var itemModel = data.getItemModel(idx);\n\n                updateSingleMarkerEndLayout(\n                    data, idx, isFrom, seriesModel, api\n                );\n\n                data.setItemVisual(idx, {\n                    symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],\n                    symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],\n                    color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color')\n                });\n            }\n\n            lineDraw.__keep = true;\n\n            lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');\n        }\n    });\n\n    /**\n     * @inner\n     * @param {module:echarts/coord/*} coordSys\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {module:echarts/model/Model} mpModel\n     */\n    function createList(coordSys, seriesModel, mlModel) {\n\n        var coordDimsInfos;\n        if (coordSys) {\n            coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n                var info = seriesModel.getData().getDimensionInfo(\n                    seriesModel.coordDimToDataDim(coordDim)[0]\n                ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n                info.name = coordDim;\n                return info;\n            });\n        }\n        else {\n            coordDimsInfos =[{\n                name: 'value',\n                type: 'float'\n            }];\n        }\n\n        var fromData = new List(coordDimsInfos, mlModel);\n        var toData = new List(coordDimsInfos, mlModel);\n        // No dimensions\n        var lineData = new List([], mlModel);\n\n        var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry(\n            markLineTransform, seriesModel, coordSys, mlModel\n        ));\n        if (coordSys) {\n            optData = zrUtil.filter(\n                optData, zrUtil.curry(markLineFilter, coordSys)\n            );\n        }\n        var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {\n            return item.value;\n        };\n        fromData.initData(\n            zrUtil.map(optData, function (item) { return item[0]; }),\n            null, dimValueGetter\n        );\n        toData.initData(\n            zrUtil.map(optData, function (item) { return item[1]; }),\n            null, dimValueGetter\n        );\n        lineData.initData(\n            zrUtil.map(optData, function (item) { return item[2]; })\n        );\n        lineData.hasItemOption = true;\n        return {\n            from: fromData,\n            to: toData,\n            line: lineData\n        };\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/marker/MarkLineView.js\n// module id = 200\n// module chunks = 0 1","\n\n    module.exports = require('./MarkerModel').extend({\n\n        type: 'markPoint',\n\n        defaultOption: {\n            zlevel: 0,\n            z: 5,\n            symbol: 'pin',\n            symbolSize: 50,\n            //symbolRotate: 0,\n            //symbolOffset: [0, 0]\n            tooltip: {\n                trigger: 'item'\n            },\n            label: {\n                normal: {\n                    show: true,\n                    position: 'inside'\n                },\n                emphasis: {\n                    show: true\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 2\n                }\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/marker/MarkPointModel.js\n// module id = 201\n// module chunks = 0 1","\n\n    var SymbolDraw = require('../../chart/helper/SymbolDraw');\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../../util/number');\n\n    var List = require('../../data/List');\n\n    var markerHelper = require('./markerHelper');\n\n    function updateMarkerLayout(mpData, seriesModel, api) {\n        var coordSys = seriesModel.coordinateSystem;\n        mpData.each(function (idx) {\n            var itemModel = mpData.getItemModel(idx);\n            var point;\n            var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n            var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n            if (!isNaN(xPx) && !isNaN(yPx)) {\n                point = [xPx, yPx];\n            }\n            // Chart like bar may have there own marker positioning logic\n            else if (seriesModel.getMarkerPosition) {\n                // Use the getMarkerPoisition\n                point = seriesModel.getMarkerPosition(\n                    mpData.getValues(mpData.dimensions, idx)\n                );\n            }\n            else if (coordSys) {\n                var x = mpData.get(coordSys.dimensions[0], idx);\n                var y = mpData.get(coordSys.dimensions[1], idx);\n                point = coordSys.dataToPoint([x, y]);\n\n            }\n\n            // Use x, y if has any\n            if (!isNaN(xPx)) {\n                point[0] = xPx;\n            }\n            if (!isNaN(yPx)) {\n                point[1] = yPx;\n            }\n\n            mpData.setItemLayout(idx, point);\n        });\n    }\n\n    require('./MarkerView').extend({\n\n        type: 'markPoint',\n\n        updateLayout: function (markPointModel, ecModel, api) {\n            ecModel.eachSeries(function (seriesModel) {\n                var mpModel = seriesModel.markPointModel;\n                if (mpModel) {\n                    updateMarkerLayout(mpModel.getData(), seriesModel, api);\n                    this.markerGroupMap[seriesModel.name].updateLayout(mpModel);\n                }\n            }, this);\n        },\n\n        renderSeries: function (seriesModel, mpModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesName = seriesModel.name;\n            var seriesData = seriesModel.getData();\n\n            var symbolDrawMap = this.markerGroupMap;\n            var symbolDraw = symbolDrawMap[seriesName];\n            if (!symbolDraw) {\n                symbolDraw = symbolDrawMap[seriesName] = new SymbolDraw();\n            }\n\n            var mpData = createList(coordSys, seriesModel, mpModel);\n\n            // FIXME\n            mpModel.setData(mpData);\n\n            updateMarkerLayout(mpModel.getData(), seriesModel, api);\n\n            mpData.each(function (idx) {\n                var itemModel = mpData.getItemModel(idx);\n                var symbolSize = itemModel.getShallow('symbolSize');\n                if (typeof symbolSize === 'function') {\n                    // FIXME  ECharts 2.x2.x \n                    symbolSize = symbolSize(\n                        mpModel.getRawValue(idx), mpModel.getDataParams(idx)\n                    );\n                }\n                mpData.setItemVisual(idx, {\n                    symbolSize: symbolSize,\n                    color: itemModel.get('itemStyle.normal.color')\n                        || seriesData.getVisual('color'),\n                    symbol: itemModel.getShallow('symbol')\n                });\n            });\n\n            // TODO Text are wrong\n            symbolDraw.updateData(mpData);\n            this.group.add(symbolDraw.group);\n\n            // Set host model for tooltip\n            // FIXME\n            mpData.eachItemGraphicEl(function (el) {\n                el.traverse(function (child) {\n                    child.dataModel = mpModel;\n                });\n            });\n\n            symbolDraw.__keep = true;\n\n            symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');\n        }\n    });\n\n    /**\n     * @inner\n     * @param {module:echarts/coord/*} [coordSys]\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {module:echarts/model/Model} mpModel\n     */\n    function createList(coordSys, seriesModel, mpModel) {\n        var coordDimsInfos;\n        if (coordSys) {\n            coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n                var info = seriesModel.getData().getDimensionInfo(\n                    seriesModel.coordDimToDataDim(coordDim)[0]\n                ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n                info.name = coordDim;\n                return info;\n            });\n        }\n        else {\n            coordDimsInfos =[{\n                name: 'value',\n                type: 'float'\n            }];\n        }\n\n        var mpData = new List(coordDimsInfos, mpModel);\n        var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(\n                markerHelper.dataTransform, seriesModel\n            ));\n        if (coordSys) {\n            dataOpt = zrUtil.filter(\n                dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys)\n            );\n        }\n\n        mpData.initData(dataOpt, null,\n            coordSys ? markerHelper.dimValueGetter : function (item) {\n                return item.value;\n            }\n        );\n        return mpData;\n    }\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/marker/MarkPointView.js\n// module id = 202\n// module chunks = 0 1","'use strict';\n\n\n    var echarts = require('../echarts');\n    var graphic = require('../util/graphic');\n    var layout = require('../util/layout');\n\n    // Model\n    echarts.extendComponentModel({\n\n        type: 'title',\n\n        layoutMode: {type: 'box', ignoreSize: true},\n\n        defaultOption: {\n            // \n            zlevel: 0,\n            // \n            z: 6,\n            show: true,\n\n            text: '',\n            // \n            // link: null,\n            // self | blank\n            target: 'blank',\n            subtext: '',\n\n            // \n            // sublink: null,\n            // self | blank\n            subtarget: 'blank',\n\n            // 'center'  'left'  'right'\n            //  {number}xpx\n            left: 0,\n            // 'top'  'bottom'  'center'\n            //  {number}ypx\n            top: 0,\n\n            // \n            // 'auto' | 'left' | 'right' | 'center'\n            //  left \n            // textAlign: null\n            //\n            // \n            // 'auto' | 'top' | 'bottom' | 'middle'\n            //  top \n            // textBaseline: null\n\n            backgroundColor: 'rgba(0,0,0,0)',\n\n            // \n            borderColor: '#ccc',\n\n            // px0\n            borderWidth: 0,\n\n            // px5\n            // css\n            padding: 5,\n\n            // px10\n            itemGap: 10,\n            textStyle: {\n                fontSize: 18,\n                fontWeight: 'bolder',\n                color: '#333'\n            },\n            subtextStyle: {\n                color: '#aaa'\n            }\n        }\n    });\n\n    // View\n    echarts.extendComponentView({\n\n        type: 'title',\n\n        render: function (titleModel, ecModel, api) {\n            this.group.removeAll();\n\n            if (!titleModel.get('show')) {\n                return;\n            }\n\n            var group = this.group;\n\n            var textStyleModel = titleModel.getModel('textStyle');\n            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\n            var textAlign = titleModel.get('textAlign');\n            var textBaseline = titleModel.get('textBaseline');\n\n            var textEl = new graphic.Text({\n                style: {\n                    text: titleModel.get('text'),\n                    textFont: textStyleModel.getFont(),\n                    fill: textStyleModel.getTextColor()\n                },\n                z2: 10\n            });\n\n            var textRect = textEl.getBoundingRect();\n\n            var subText = titleModel.get('subtext');\n            var subTextEl = new graphic.Text({\n                style: {\n                    text: subText,\n                    textFont: subtextStyleModel.getFont(),\n                    fill: subtextStyleModel.getTextColor(),\n                    y: textRect.height + titleModel.get('itemGap'),\n                    textBaseline: 'top'\n                },\n                z2: 10\n            });\n\n            var link = titleModel.get('link');\n            var sublink = titleModel.get('sublink');\n\n            textEl.silent = !link;\n            subTextEl.silent = !sublink;\n\n            if (link) {\n                textEl.on('click', function () {\n                    window.open(link, '_' + titleModel.get('target'));\n                });\n            }\n            if (sublink) {\n                subTextEl.on('click', function () {\n                    window.open(sublink, '_' + titleModel.get('subtarget'));\n                });\n            }\n\n            group.add(textEl);\n            subText && group.add(subTextEl);\n            // If no subText, but add subTextEl, there will be an empty line.\n\n            var groupRect = group.getBoundingRect();\n            var layoutOption = titleModel.getBoxLayoutParams();\n            layoutOption.width = groupRect.width;\n            layoutOption.height = groupRect.height;\n            var layoutRect = layout.getLayoutRect(\n                layoutOption, {\n                    width: api.getWidth(),\n                    height: api.getHeight()\n                }, titleModel.get('padding')\n            );\n            // Adjust text align based on position\n            if (!textAlign) {\n                // Align left if title is on the left. center and right is same\n                textAlign = titleModel.get('left') || titleModel.get('right');\n                if (textAlign === 'middle') {\n                    textAlign = 'center';\n                }\n                // Adjust layout by text align\n                if (textAlign === 'right') {\n                    layoutRect.x += layoutRect.width;\n                }\n                else if (textAlign === 'center') {\n                    layoutRect.x += layoutRect.width / 2;\n                }\n            }\n            if (!textBaseline) {\n                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n                if (textBaseline === 'center') {\n                    textBaseline = 'middle';\n                }\n                if (textBaseline === 'bottom') {\n                    layoutRect.y += layoutRect.height;\n                }\n                else if (textBaseline === 'middle') {\n                    layoutRect.y += layoutRect.height / 2;\n                }\n\n                textBaseline = textBaseline || 'top';\n            }\n\n            group.attr('position', [layoutRect.x, layoutRect.y]);\n            var alignStyle = {\n                textAlign: textAlign,\n                textVerticalAlign: textBaseline\n            };\n            textEl.setStyle(alignStyle);\n            subTextEl.setStyle(alignStyle);\n\n            // Render background\n            // Get groupRect again because textAlign has been changed\n            groupRect = group.getBoundingRect();\n            var padding = layoutRect.margin;\n            var style = titleModel.getItemStyle(['color', 'opacity']);\n            style.fill = titleModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: groupRect.x - padding[3],\n                    y: groupRect.y - padding[0],\n                    width: groupRect.width + padding[1] + padding[3],\n                    height: groupRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/title.js\n// module id = 203\n// module chunks = 0 1","\n\n    require('./toolbox/ToolboxModel');\n    require('./toolbox/ToolboxView');\n\n    require('./toolbox/feature/SaveAsImage');\n    require('./toolbox/feature/MagicType');\n    require('./toolbox/feature/DataView');\n    require('./toolbox/feature/DataZoom');\n    require('./toolbox/feature/Restore');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/toolbox.js\n// module id = 204\n// module chunks = 0 1","\n\n    var featureManager = require('./featureManager');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var ToolboxModel = require('../../echarts').extendComponentModel({\n\n        type: 'toolbox',\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        mergeDefaultAndTheme: function (option) {\n            ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);\n\n            zrUtil.each(this.option.feature, function (featureOpt, featureName) {\n                var Feature = featureManager.get(featureName);\n                Feature && zrUtil.merge(featureOpt, Feature.defaultOption);\n            });\n        },\n\n        defaultOption: {\n\n            show: true,\n\n            z: 6,\n\n            zlevel: 0,\n\n            orient: 'horizontal',\n\n            left: 'right',\n\n            top: 'top',\n\n            // right\n            // bottom\n\n            backgroundColor: 'transparent',\n\n            borderColor: '#ccc',\n\n            borderWidth: 0,\n\n            padding: 5,\n\n            itemSize: 15,\n\n            itemGap: 8,\n\n            showTitle: true,\n\n            iconStyle: {\n                normal: {\n                    borderColor: '#666',\n                    color: 'none'\n                },\n                emphasis: {\n                    borderColor: '#3E98C5'\n                }\n            }\n            // textStyle: {},\n\n            // feature\n        }\n    });\n\n    module.exports = ToolboxModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/toolbox/ToolboxModel.js\n// module id = 205\n// module chunks = 0 1","\n\n    var featureManager = require('./featureManager');\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var DataDiffer = require('../../data/DataDiffer');\n    var listComponentHelper = require('../helper/listComponent');\n    var textContain = require('zrender/lib/contain/text');\n\n    module.exports = require('../../echarts').extendComponentView({\n\n        type: 'toolbox',\n\n        render: function (toolboxModel, ecModel, api, payload) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!toolboxModel.get('show')) {\n                return;\n            }\n\n            var itemSize = +toolboxModel.get('itemSize');\n            var featureOpts = toolboxModel.get('feature') || {};\n            var features = this._features || (this._features = {});\n\n            var featureNames = [];\n            zrUtil.each(featureOpts, function (opt, name) {\n                featureNames.push(name);\n            });\n\n            (new DataDiffer(this._featureNames || [], featureNames))\n                .add(process)\n                .update(process)\n                .remove(zrUtil.curry(process, null))\n                .execute();\n\n            // Keep for diff.\n            this._featureNames = featureNames;\n\n            function process(newIndex, oldIndex) {\n                var featureName = featureNames[newIndex];\n                var oldName = featureNames[oldIndex];\n                var featureOpt = featureOpts[featureName];\n                var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);\n                var feature;\n\n                if (featureName && !oldName) { // Create\n                    if (isUserFeatureName(featureName)) {\n                        feature = {\n                            model: featureModel,\n                            onclick: featureModel.option.onclick,\n                            featureName: featureName\n                        };\n                    }\n                    else {\n                        var Feature = featureManager.get(featureName);\n                        if (!Feature) {\n                            return;\n                        }\n                        feature = new Feature(featureModel, ecModel, api);\n                    }\n                    features[featureName] = feature;\n                }\n                else {\n                    feature = features[oldName];\n                    // If feature does not exsit.\n                    if (!feature) {\n                        return;\n                    }\n                    feature.model = featureModel;\n                    feature.ecModel = ecModel;\n                    feature.api = api;\n                }\n\n                if (!featureName && oldName) {\n                    feature.dispose && feature.dispose(ecModel, api);\n                    return;\n                }\n\n                if (!featureModel.get('show') || feature.unusable) {\n                    feature.remove && feature.remove(ecModel, api);\n                    return;\n                }\n\n                createIconPaths(featureModel, feature, featureName);\n\n                featureModel.setIconStatus = function (iconName, status) {\n                    var option = this.option;\n                    var iconPaths = this.iconPaths;\n                    option.iconStatus = option.iconStatus || {};\n                    option.iconStatus[iconName] = status;\n                    // FIXME\n                    iconPaths[iconName] && iconPaths[iconName].trigger(status);\n                };\n\n                if (feature.render) {\n                    feature.render(featureModel, ecModel, api, payload);\n                }\n            }\n\n            function createIconPaths(featureModel, feature, featureName) {\n                var iconStyleModel = featureModel.getModel('iconStyle');\n\n                // If one feature has mutiple icon. they are orginaized as\n                // {\n                //     icon: {\n                //         foo: '',\n                //         bar: ''\n                //     },\n                //     title: {\n                //         foo: '',\n                //         bar: ''\n                //     }\n                // }\n                var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n                var titles = featureModel.get('title') || {};\n                if (typeof icons === 'string') {\n                    var icon = icons;\n                    var title = titles;\n                    icons = {};\n                    titles = {};\n                    icons[featureName] = icon;\n                    titles[featureName] = title;\n                }\n                var iconPaths = featureModel.iconPaths = {};\n                zrUtil.each(icons, function (icon, iconName) {\n                    var normalStyle = iconStyleModel.getModel('normal').getItemStyle();\n                    var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n\n                    var style = {\n                        x: -itemSize / 2,\n                        y: -itemSize / 2,\n                        width: itemSize,\n                        height: itemSize\n                    };\n                    var path = icon.indexOf('image://') === 0\n                        ? (\n                            style.image = icon.slice(8),\n                            new graphic.Image({style: style})\n                        )\n                        : graphic.makePath(\n                            icon.replace('path://', ''),\n                            {\n                                style: normalStyle,\n                                hoverStyle: hoverStyle,\n                                rectHover: true\n                            },\n                            style,\n                            'center'\n                        );\n\n                    graphic.setHoverStyle(path);\n\n                    if (toolboxModel.get('showTitle')) {\n                        path.__title = titles[iconName];\n                        path.on('mouseover', function () {\n                                // Should not reuse above hoverStyle, which might be modified.\n                                var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n                                path.setStyle({\n                                    text: titles[iconName],\n                                    textPosition: hoverStyle.textPosition || 'bottom',\n                                    textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\n                                    textAlign: hoverStyle.textAlign || 'center'\n                                });\n                            })\n                            .on('mouseout', function () {\n                                path.setStyle({\n                                    textFill: null\n                                });\n                            });\n                    }\n                    path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');\n\n                    group.add(path);\n                    path.on('click', zrUtil.bind(\n                        feature.onclick, feature, ecModel, api, iconName\n                    ));\n\n                    iconPaths[iconName] = path;\n                });\n            }\n\n            listComponentHelper.layout(group, toolboxModel, api);\n            // Render background after group is layout\n            // FIXME\n            listComponentHelper.addBackground(group, toolboxModel);\n\n            // Adjust icon title positions to avoid them out of screen\n            group.eachChild(function (icon) {\n                var titleText = icon.__title;\n                var hoverStyle = icon.hoverStyle;\n                // May be background element\n                if (hoverStyle && titleText) {\n                    var rect = textContain.getBoundingRect(\n                        titleText, hoverStyle.font\n                    );\n                    var offsetX = icon.position[0] + group.position[0];\n                    var offsetY = icon.position[1] + group.position[1] + itemSize;\n\n                    var needPutOnTop = false;\n                    if (offsetY + rect.height > api.getHeight()) {\n                        hoverStyle.textPosition = 'top';\n                        needPutOnTop = true;\n                    }\n                    var topOffset = needPutOnTop ? (-5 - rect.height) : (itemSize + 8);\n                    if (offsetX + rect.width /  2 > api.getWidth()) {\n                        hoverStyle.textPosition = ['100%', topOffset];\n                        hoverStyle.textAlign = 'right';\n                    }\n                    else if (offsetX - rect.width / 2 < 0) {\n                        hoverStyle.textPosition = [0, topOffset];\n                        hoverStyle.textAlign = 'left';\n                    }\n                }\n            });\n        },\n\n        updateView: function (toolboxModel, ecModel, api, payload) {\n            zrUtil.each(this._features, function (feature) {\n                feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n            });\n        },\n\n        updateLayout: function (toolboxModel, ecModel, api, payload) {\n            zrUtil.each(this._features, function (feature) {\n                feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);\n            });\n        },\n\n        remove: function (ecModel, api) {\n            zrUtil.each(this._features, function (feature) {\n                feature.remove && feature.remove(ecModel, api);\n            });\n            this.group.removeAll();\n        },\n\n        dispose: function (ecModel, api) {\n            zrUtil.each(this._features, function (feature) {\n                feature.dispose && feature.dispose(ecModel, api);\n            });\n        }\n    });\n\n    function isUserFeatureName(featureName) {\n        return featureName.indexOf('my') === 0;\n    }\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/toolbox/ToolboxView.js\n// module id = 206\n// module chunks = 0 1","/**\n * @module echarts/component/toolbox/feature/DataView\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var eventTool = require('zrender/lib/core/event');\n\n\n    var BLOCK_SPLITER = new Array(60).join('-');\n    var ITEM_SPLITER = '\\t';\n    /**\n     * Group series into two types\n     *  1. on category axis, like line, bar\n     *  2. others, like scatter, pie\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Object}\n     * @inner\n     */\n    function groupSeries(ecModel) {\n        var seriesGroupByCategoryAxis = {};\n        var otherSeries = [];\n        var meta = [];\n        ecModel.eachRawSeries(function (seriesModel) {\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n                var baseAxis = coordSys.getBaseAxis();\n                if (baseAxis.type === 'category') {\n                    var key = baseAxis.dim + '_' + baseAxis.index;\n                    if (!seriesGroupByCategoryAxis[key]) {\n                        seriesGroupByCategoryAxis[key] = {\n                            categoryAxis: baseAxis,\n                            valueAxis: coordSys.getOtherAxis(baseAxis),\n                            series: []\n                        };\n                        meta.push({\n                            axisDim: baseAxis.dim,\n                            axisIndex: baseAxis.index\n                        });\n                    }\n                    seriesGroupByCategoryAxis[key].series.push(seriesModel);\n                }\n                else {\n                    otherSeries.push(seriesModel);\n                }\n            }\n            else {\n                otherSeries.push(seriesModel);\n            }\n        });\n\n        return {\n            seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n            other: otherSeries,\n            meta: meta\n        };\n    }\n\n    /**\n     * Assemble content of series on cateogory axis\n     * @param {Array.<module:echarts/model/Series>} series\n     * @return {string}\n     * @inner\n     */\n    function assembleSeriesWithCategoryAxis(series) {\n        var tables = [];\n        zrUtil.each(series, function (group, key) {\n            var categoryAxis = group.categoryAxis;\n            var valueAxis = group.valueAxis;\n            var valueAxisDim = valueAxis.dim;\n\n            var headers = [' '].concat(zrUtil.map(group.series, function (series) {\n                return series.name;\n            }));\n            var columns = [categoryAxis.model.getCategories()];\n            zrUtil.each(group.series, function (series) {\n                columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {\n                    return val;\n                }));\n            });\n            // Assemble table content\n            var lines = [headers.join(ITEM_SPLITER)];\n            for (var i = 0; i < columns[0].length; i++) {\n                var items = [];\n                for (var j = 0; j < columns.length; j++) {\n                    items.push(columns[j][i]);\n                }\n                lines.push(items.join(ITEM_SPLITER));\n            }\n            tables.push(lines.join('\\n'));\n        });\n        return tables.join('\\n\\n' +  BLOCK_SPLITER + '\\n\\n');\n    }\n\n    /**\n     * Assemble content of other series\n     * @param {Array.<module:echarts/model/Series>} series\n     * @return {string}\n     * @inner\n     */\n    function assembleOtherSeries(series) {\n        return zrUtil.map(series, function (series) {\n            var data = series.getRawData();\n            var lines = [series.name];\n            var vals = [];\n            data.each(data.dimensions, function () {\n                var argLen = arguments.length;\n                var dataIndex = arguments[argLen - 1];\n                var name = data.getName(dataIndex);\n                for (var i = 0; i < argLen - 1; i++) {\n                    vals[i] = arguments[i];\n                }\n                lines.push((name ? (name + ITEM_SPLITER) : '') + vals.join(ITEM_SPLITER));\n            });\n            return lines.join('\\n');\n        }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n    }\n\n    /**\n     * @param {module:echarts/model/Global}\n     * @return {string}\n     * @inner\n     */\n    function getContentFromModel(ecModel) {\n\n        var result = groupSeries(ecModel);\n\n        return {\n            value: zrUtil.filter([\n                    assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis),\n                    assembleOtherSeries(result.other)\n                ], function (str) {\n                    return str.replace(/[\\n\\t\\s]/g, '');\n                }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n\n            meta: result.meta\n        };\n    }\n\n\n    function trim(str) {\n        return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    }\n    /**\n     * If a block is tsv format\n     */\n    function isTSVFormat(block) {\n        // Simple method to find out if a block is tsv format\n        var firstLine = block.slice(0, block.indexOf('\\n'));\n        if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n            return true;\n        }\n    }\n\n    var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n    /**\n     * @param {string} tsv\n     * @return {Array.<Object>}\n     */\n    function parseTSVContents(tsv) {\n        var tsvLines = tsv.split(/\\n+/g);\n        var headers = trim(tsvLines.shift()).split(itemSplitRegex);\n\n        var categories = [];\n        var series = zrUtil.map(headers, function (header) {\n            return {\n                name: header,\n                data: []\n            };\n        });\n        for (var i = 0; i < tsvLines.length; i++) {\n            var items = trim(tsvLines[i]).split(itemSplitRegex);\n            categories.push(items.shift());\n            for (var j = 0; j < items.length; j++) {\n                series[j] && (series[j].data[i] = items[j]);\n            }\n        }\n        return {\n            series: series,\n            categories: categories\n        };\n    }\n\n    /**\n     * @param {string} str\n     * @return {Array.<Object>}\n     * @inner\n     */\n    function parseListContents(str) {\n        var lines = str.split(/\\n+/g);\n        var seriesName = trim(lines.shift());\n\n        var data = [];\n        for (var i = 0; i < lines.length; i++) {\n            var items = trim(lines[i]).split(itemSplitRegex);\n            var name = '';\n            var value;\n            var hasName = false;\n            if (isNaN(items[0])) { // First item is name\n                hasName = true;\n                name = items[0];\n                items = items.slice(1);\n                data[i] = {\n                    name: name,\n                    value: []\n                };\n                value = data[i].value;\n            }\n            else {\n                value = data[i] = [];\n            }\n            for (var j = 0; j < items.length; j++) {\n                value.push(+items[j]);\n            }\n            if (value.length === 1) {\n                hasName ? (data[i].value = value[0]) : (data[i] = value[0]);\n            }\n        }\n\n        return {\n            name: seriesName,\n            data: data\n        };\n    }\n\n    /**\n     * @param {string} str\n     * @param {Array.<Object>} blockMetaList\n     * @return {Object}\n     * @inner\n     */\n    function parseContents(str, blockMetaList) {\n        var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n        var newOption = {\n            series: []\n        };\n        zrUtil.each(blocks, function (block, idx) {\n            if (isTSVFormat(block)) {\n                var result = parseTSVContents(block);\n                var blockMeta = blockMetaList[idx];\n                var axisKey = blockMeta.axisDim + 'Axis';\n\n                if (blockMeta) {\n                    newOption[axisKey] = newOption[axisKey] || [];\n                    newOption[axisKey][blockMeta.axisIndex] = {\n                        data: result.categories\n                    };\n                    newOption.series = newOption.series.concat(result.series);\n                }\n            }\n            else {\n                var result = parseListContents(block);\n                newOption.series.push(result);\n            }\n        });\n        return newOption;\n    }\n\n    /**\n     * @alias {module:echarts/component/toolbox/feature/DataView}\n     * @constructor\n     * @param {module:echarts/model/Model} model\n     */\n    function DataView(model) {\n\n        this._dom = null;\n\n        this.model = model;\n    }\n\n    DataView.defaultOption = {\n        show: true,\n        readOnly: false,\n        optionToContent: null,\n        contentToOption: null,\n\n        icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n        title: '',\n        lang: ['', '', ''],\n        backgroundColor: '#fff',\n        textColor: '#000',\n        textareaColor: '#fff',\n        textareaBorderColor: '#333',\n        buttonColor: '#c23531',\n        buttonTextColor: '#fff'\n    };\n\n    DataView.prototype.onclick = function (ecModel, api) {\n        var container = api.getDom();\n        var model = this.model;\n        if (this._dom) {\n            container.removeChild(this._dom);\n        }\n        var root = document.createElement('div');\n        root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';\n        root.style.backgroundColor = model.get('backgroundColor') || '#fff';\n\n        // Create elements\n        var header = document.createElement('h4');\n        var lang = model.get('lang') || [];\n        header.innerHTML = lang[0] || model.get('title');\n        header.style.cssText = 'margin: 10px 20px;';\n        header.style.color = model.get('textColor');\n\n        var viewMain = document.createElement('div');\n        var textarea = document.createElement('textarea');\n        viewMain.style.cssText = 'display:block;width:100%;overflow:hidden;';\n\n        var optionToContent = model.get('optionToContent');\n        var contentToOption = model.get('contentToOption');\n        var result = getContentFromModel(ecModel);\n        if (typeof optionToContent === 'function') {\n            var htmlOrDom = optionToContent(api.getOption());\n            if (typeof htmlOrDom === 'string') {\n                viewMain.innerHTML = htmlOrDom;\n            }\n            else if (zrUtil.isDom(htmlOrDom)) {\n                viewMain.appendChild(htmlOrDom);\n            }\n        }\n        else {\n            // Use default textarea\n            viewMain.appendChild(textarea);\n            textarea.readOnly = model.get('readOnly');\n            textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';\n            textarea.style.color = model.get('textColor');\n            textarea.style.borderColor = model.get('textareaBorderColor');\n            textarea.style.backgroundColor = model.get('textareaColor');\n            textarea.value = result.value;\n        }\n\n        var blockMetaList = result.meta;\n\n        var buttonContainer = document.createElement('div');\n        buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';\n\n        var buttonStyle = 'float:right;margin-right:20px;border:none;'\n            + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n        var closeButton = document.createElement('div');\n        var refreshButton = document.createElement('div');\n\n        buttonStyle += ';background-color:' + model.get('buttonColor');\n        buttonStyle += ';color:' + model.get('buttonTextColor');\n\n        var self = this;\n\n        function close() {\n            container.removeChild(root);\n            self._dom = null;\n        }\n        eventTool.addEventListener(closeButton, 'click', close);\n\n        eventTool.addEventListener(refreshButton, 'click', function () {\n            var newOption;\n            try {\n                if (typeof contentToOption === 'function') {\n                    newOption = contentToOption(viewMain, api.getOption());\n                }\n                else {\n                    newOption = parseContents(textarea.value, blockMetaList);\n                }\n            }\n            catch (e) {\n                close();\n                throw new Error('Data view format error ' + e);\n            }\n            if (newOption) {\n                api.dispatchAction({\n                    type: 'changeDataView',\n                    newOption: newOption\n                });\n            }\n\n            close();\n        });\n\n        closeButton.innerHTML = lang[1];\n        refreshButton.innerHTML = lang[2];\n        refreshButton.style.cssText = buttonStyle;\n        closeButton.style.cssText = buttonStyle;\n\n        !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n        buttonContainer.appendChild(closeButton);\n\n        // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea\n        eventTool.addEventListener(textarea, 'keydown', function (e) {\n            if ((e.keyCode || e.which) === 9) {\n                // get caret position/selection\n                var val = this.value;\n                var start = this.selectionStart;\n                var end = this.selectionEnd;\n\n                // set textarea value to: text before caret + tab + text after caret\n                this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end);\n\n                // put caret at right position again\n                this.selectionStart = this.selectionEnd = start + 1;\n\n                // prevent the focus lose\n                eventTool.stop(e);\n            }\n        });\n\n        root.appendChild(header);\n        root.appendChild(viewMain);\n        root.appendChild(buttonContainer);\n\n        viewMain.style.height = (container.clientHeight - 80) + 'px';\n\n        container.appendChild(root);\n        this._dom = root;\n    };\n\n    DataView.prototype.remove = function (ecModel, api) {\n        this._dom && api.getDom().removeChild(this._dom);\n    };\n\n    DataView.prototype.dispose = function (ecModel, api) {\n        this.remove(ecModel, api);\n    };\n\n    /**\n     * @inner\n     */\n    function tryMergeDataOption(newData, originalData) {\n        return zrUtil.map(newData, function (newVal, idx) {\n            var original = originalData && originalData[idx];\n            if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {\n                if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {\n                    newVal = newVal.value;\n                }\n                // Original data has option\n                return zrUtil.defaults({\n                    value: newVal\n                }, original);\n            }\n            else {\n                return newVal;\n            }\n        });\n    }\n\n    require('../featureManager').register('dataView', DataView);\n\n    require('../../../echarts').registerAction({\n        type: 'changeDataView',\n        event: 'dataViewChanged',\n        update: 'prepareAndUpdate'\n    }, function (payload, ecModel) {\n        var newSeriesOptList = [];\n        zrUtil.each(payload.newOption.series, function (seriesOpt) {\n            var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n            if (!seriesModel) {\n                // New created series\n                // Geuss the series type\n                newSeriesOptList.push(zrUtil.extend({\n                    // Default is scatter\n                    type: 'scatter'\n                }, seriesOpt));\n            }\n            else {\n                var originalData = seriesModel.get('data');\n                newSeriesOptList.push({\n                    name: seriesOpt.name,\n                    data: tryMergeDataOption(seriesOpt.data, originalData)\n                });\n            }\n        });\n\n        ecModel.mergeOption(zrUtil.defaults({\n            series: newSeriesOptList\n        }, payload.newOption));\n    });\n\n    module.exports = DataView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/toolbox/feature/DataView.js\n// module id = 207\n// module chunks = 0 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var BrushController = require('../../helper/BrushController');\n    var brushHelper = require('../../helper/brushHelper');\n    var history = require('../../dataZoom/history');\n\n    var each = zrUtil.each;\n\n    // Use dataZoomSelect\n    require('../../dataZoomSelect');\n\n    // Spectial component id start with \\0ec\\0, see echarts/model/Global.js~hasInnerId\n    var DATA_ZOOM_ID_BASE = '\\0_ec_\\0toolbox-dataZoom_';\n\n    function DataZoom(model, ecModel, api) {\n\n        /**\n         * @private\n         * @type {module:echarts/component/helper/BrushController}\n         */\n        (this._brushController = new BrushController(api.getZr()))\n            .on('brush', zrUtil.bind(this._onBrush, this))\n            .mount();\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._isZoomActive;\n    }\n\n    DataZoom.defaultOption = {\n        show: true,\n        // Icon group\n        icon: {\n            zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n            back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n        },\n        title: {\n            zoom: '',\n            back: ''\n        }\n    };\n\n    var proto = DataZoom.prototype;\n\n    proto.render = function (featureModel, ecModel, api, payload) {\n        this.model = featureModel;\n        this.ecModel = ecModel;\n        this.api = api;\n\n        updateZoomBtnStatus(featureModel, ecModel, this, payload);\n        updateBackBtnStatus(featureModel, ecModel);\n    };\n\n    proto.onclick = function (ecModel, api, type) {\n        handlers[type].call(this);\n    };\n\n    proto.remove = function (ecModel, api) {\n        this._brushController.unmount();\n    };\n\n    proto.dispose = function (ecModel, api) {\n        this._brushController.dispose();\n    };\n\n    /**\n     * @private\n     */\n    var handlers = {\n\n        zoom: function () {\n            var nextActive = !this._isZoomActive;\n\n            this.api.dispatchAction({\n                type: 'takeGlobalCursor',\n                key: 'dataZoomSelect',\n                dataZoomSelectActive: nextActive\n            });\n        },\n\n        back: function () {\n            this._dispatchZoomAction(history.pop(this.ecModel));\n        }\n    };\n\n    /**\n     * @private\n     */\n    proto._onBrush = function (areas, opt) {\n        if (!opt.isEnd || !areas.length) {\n            return;\n        }\n        var snapshot = {};\n        var ecModel = this.ecModel;\n\n        this._brushController.updateCovers([]); // remove cover\n\n        var coordInfoList = brushHelper.makeCoordInfoList(\n            retrieveAxisSetting(this.model.option), ecModel\n        );\n        var rangesCoordInfoList = [];\n        brushHelper.parseOutputRanges(areas, coordInfoList, ecModel, rangesCoordInfoList);\n\n        var area = areas[0]; // dataZoom can not multiple area.\n        var coordInfo = rangesCoordInfoList[0];\n        var coordRange = area.coordRange;\n        var brushType = area.brushType;\n\n        if (coordInfo && coordRange) {\n            if (brushType === 'rect') {\n                setBatch('xAxis', coordRange[0], coordInfo);\n                setBatch('yAxis', coordRange[1], coordInfo);\n            }\n            else {\n                var axisNames = {lineX: 'xAxis', lineY: 'yAxis'};\n                setBatch(axisNames[brushType], coordRange, coordInfo);\n            }\n        }\n\n        history.push(ecModel, snapshot);\n\n        this._dispatchZoomAction(snapshot);\n\n        function setBatch(axisName, minMax, coordInfo) {\n            var dataZoomModel = findDataZoom(axisName, coordInfo[axisName], ecModel);\n            if (dataZoomModel) {\n                snapshot[dataZoomModel.id] = {\n                    dataZoomId: dataZoomModel.id,\n                    startValue: minMax[0],\n                    endValue: minMax[1]\n                };\n            }\n        }\n\n        function findDataZoom(axisName, axisModel, ecModel) {\n            var dataZoomModel;\n            ecModel.eachComponent(\n                {mainType: 'dataZoom', subType: 'select'},\n                function (dzModel, dataZoomIndex) {\n                    var axisIndex = dzModel.get(axisName + 'Index');\n                    if (axisIndex != null\n                        && ecModel.getComponent(axisName, axisIndex) === axisModel\n                    ) {\n                        dataZoomModel = dzModel;\n                    }\n                }\n            );\n            return dataZoomModel;\n        }\n    };\n\n    /**\n     * @private\n     */\n    proto._dispatchZoomAction = function (snapshot) {\n        var batch = [];\n\n        // Convert from hash map to array.\n        each(snapshot, function (batchItem, dataZoomId) {\n            batch.push(zrUtil.clone(batchItem));\n        });\n\n        batch.length && this.api.dispatchAction({\n            type: 'dataZoom',\n            from: this.uid,\n            batch: batch\n        });\n    };\n\n    function retrieveAxisSetting(option) {\n        var setting = {};\n        // Compatible with previous setting: null => all axis, false => no axis.\n        zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {\n            setting[name] = option[name];\n            setting[name] == null && (setting[name] = 'all');\n            (setting[name] === false || setting[name] === 'none') && (setting[name] = []);\n        });\n        return setting;\n    }\n\n    function updateBackBtnStatus(featureModel, ecModel) {\n        featureModel.setIconStatus(\n            'back',\n            history.count(ecModel) > 1 ? 'emphasis' : 'normal'\n        );\n    }\n\n    function updateZoomBtnStatus(featureModel, ecModel, view, payload) {\n        var zoomActive = view._isZoomActive;\n\n        if (payload && payload.type === 'takeGlobalCursor') {\n            zoomActive = payload.key === 'dataZoomSelect'\n                ? payload.dataZoomSelectActive : false;\n        }\n\n        view._isZoomActive = zoomActive;\n\n        featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n\n        var coordInfoList = brushHelper.makeCoordInfoList(\n            retrieveAxisSetting(featureModel.option), ecModel\n        );\n        var brushType = (coordInfoList.xAxisHas && !coordInfoList.yAxisHas)\n            ? 'lineX'\n            : (!coordInfoList.xAxisHas && coordInfoList.yAxisHas)\n            ? 'lineY'\n            : 'rect';\n\n        view._brushController\n            .setPanels(brushHelper.makePanelOpts(coordInfoList))\n            .enableBrush(\n                zoomActive\n                ? {\n                    brushType: brushType,\n                    brushStyle: { // FIXME user customized?\n                        lineWidth: 0,\n                        // stroke: '#333',\n                        fill: 'rgba(0,0,0,0.2)'\n                    }\n                }\n                : false\n            );\n    }\n\n\n    require('../featureManager').register('dataZoom', DataZoom);\n\n\n    // Create special dataZoom option for select\n    require('../../../echarts').registerPreprocessor(function (option) {\n        if (!option) {\n            return;\n        }\n\n        var dataZoomOpts = option.dataZoom || (option.dataZoom = []);\n        if (!zrUtil.isArray(dataZoomOpts)) {\n            option.dataZoom = dataZoomOpts = [dataZoomOpts];\n        }\n\n        var toolboxOpt = option.toolbox;\n        if (toolboxOpt) {\n            // Assume there is only one toolbox\n            if (zrUtil.isArray(toolboxOpt)) {\n                toolboxOpt = toolboxOpt[0];\n            }\n\n            if (toolboxOpt && toolboxOpt.feature) {\n                var dataZoomOpt = toolboxOpt.feature.dataZoom;\n                addForAxis('xAxis', dataZoomOpt);\n                addForAxis('yAxis', dataZoomOpt);\n            }\n        }\n\n        function addForAxis(axisName, dataZoomOpt) {\n            if (!dataZoomOpt) {\n                return;\n            }\n\n            // Try not to modify model, because it is not merged yet.\n            var axisIndicesName = axisName + 'Index';\n            var givenAxisIndices = dataZoomOpt[axisIndicesName];\n            if (givenAxisIndices != null\n                && givenAxisIndices != 'all'\n                && !zrUtil.isArray(givenAxisIndices)\n            ) {\n                givenAxisIndices = (givenAxisIndices === false || givenAxisIndices === 'none') ? [] : [givenAxisIndices];\n            }\n\n            forEachComponent(axisName, function (axisOpt, axisIndex) {\n                if (givenAxisIndices != null\n                    && givenAxisIndices != 'all'\n                    && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1\n                ) {\n                    return;\n                }\n                var newOpt = {\n                    type: 'select',\n                    $fromToolbox: true,\n                    // Id for merge mapping.\n                    id: DATA_ZOOM_ID_BASE + axisName + axisIndex\n                };\n                // FIXME\n                // Only support one axis now.\n                newOpt[axisIndicesName] = axisIndex;\n                dataZoomOpts.push(newOpt);\n            });\n        }\n\n        function forEachComponent(mainType, cb) {\n            var opts = option[mainType];\n            if (!zrUtil.isArray(opts)) {\n                opts = opts ? [opts] : [];\n            }\n            each(opts, cb);\n        }\n    });\n\n    module.exports = DataZoom;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/toolbox/feature/DataZoom.js\n// module id = 208\n// module chunks = 0 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    function MagicType(model) {\n        this.model = model;\n    }\n\n    MagicType.defaultOption = {\n        show: true,\n        type: [],\n        // Icon group\n        icon: {\n            line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n            bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n            stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z', // jshint ignore:line\n            tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'\n        },\n        title: {\n            line: '',\n            bar: '',\n            stack: '',\n            tiled: ''\n        },\n        option: {},\n        seriesIndex: {}\n    };\n\n    var proto = MagicType.prototype;\n\n    proto.getIcons = function () {\n        var model = this.model;\n        var availableIcons = model.get('icon');\n        var icons = {};\n        zrUtil.each(model.get('type'), function (type) {\n            if (availableIcons[type]) {\n                icons[type] = availableIcons[type];\n            }\n        });\n        return icons;\n    };\n\n    var seriesOptGenreator = {\n        'line': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    type: 'line',\n                    // Preserve data related option\n                    data: seriesModel.get('data'),\n                    stack: seriesModel.get('stack'),\n                    markPoint: seriesModel.get('markPoint'),\n                    markLine: seriesModel.get('markLine')\n                }, model.get('option.line') || {}, true);\n            }\n        },\n        'bar': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    type: 'bar',\n                    // Preserve data related option\n                    data: seriesModel.get('data'),\n                    stack: seriesModel.get('stack'),\n                    markPoint: seriesModel.get('markPoint'),\n                    markLine: seriesModel.get('markLine')\n                }, model.get('option.bar') || {}, true);\n            }\n        },\n        'stack': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line' || seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    stack: '__ec_magicType_stack__'\n                }, model.get('option.stack') || {}, true);\n            }\n        },\n        'tiled': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line' || seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    stack: ''\n                }, model.get('option.tiled') || {}, true);\n            }\n        }\n    };\n\n    var radioTypes = [\n        ['line', 'bar'],\n        ['stack', 'tiled']\n    ];\n\n    proto.onclick = function (ecModel, api, type) {\n        var model = this.model;\n        var seriesIndex = model.get('seriesIndex.' + type);\n        // Not supported magicType\n        if (!seriesOptGenreator[type]) {\n            return;\n        }\n        var newOption = {\n            series: []\n        };\n        var generateNewSeriesTypes = function (seriesModel) {\n            var seriesType = seriesModel.subType;\n            var seriesId = seriesModel.id;\n            var newSeriesOpt = seriesOptGenreator[type](\n                seriesType, seriesId, seriesModel, model\n            );\n            if (newSeriesOpt) {\n                // PENDING If merge original option?\n                zrUtil.defaults(newSeriesOpt, seriesModel.option);\n                newOption.series.push(newSeriesOpt);\n            }\n            // Modify boundaryGap\n            var coordSys = seriesModel.coordinateSystem;\n            if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n                var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n                if (categoryAxis) {\n                    var axisDim = categoryAxis.dim;\n                    var axisType = axisDim + 'Axis';\n                    var axisModel = ecModel.queryComponents({\n                        mainType: axisType,\n                        index: seriesModel.get(name + 'Index'),\n                        id: seriesModel.get(name + 'Id')\n                    })[0];\n                    var axisIndex = axisModel.componentIndex;\n\n                    newOption[axisType] = newOption[axisType] || [];\n                    for (var i = 0; i <= axisIndex; i++) {\n                        newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n                    }\n                    newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;\n                }\n            }\n        };\n\n        zrUtil.each(radioTypes, function (radio) {\n            if (zrUtil.indexOf(radio, type) >= 0) {\n                zrUtil.each(radio, function (item) {\n                    model.setIconStatus(item, 'normal');\n                });\n            }\n        });\n\n        model.setIconStatus(type, 'emphasis');\n\n        ecModel.eachComponent(\n            {\n                mainType: 'series',\n                query: seriesIndex == null ? null : {\n                    seriesIndex: seriesIndex\n                }\n            }, generateNewSeriesTypes\n        );\n        api.dispatchAction({\n            type: 'changeMagicType',\n            currentType: type,\n            newOption: newOption\n        });\n    };\n\n    var echarts = require('../../../echarts');\n    echarts.registerAction({\n        type: 'changeMagicType',\n        event: 'magicTypeChanged',\n        update: 'prepareAndUpdate'\n    }, function (payload, ecModel) {\n        ecModel.mergeOption(payload.newOption);\n    });\n\n    require('../featureManager').register('magicType', MagicType);\n\n    module.exports = MagicType;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/toolbox/feature/MagicType.js\n// module id = 209\n// module chunks = 0 1","'use strict';\n\n\n    var history = require('../../dataZoom/history');\n\n    function Restore(model) {\n        this.model = model;\n    }\n\n    Restore.defaultOption = {\n        show: true,\n        icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n        title: ''\n    };\n\n    var proto = Restore.prototype;\n\n    proto.onclick = function (ecModel, api, type) {\n        history.clear(ecModel);\n\n        api.dispatchAction({\n            type: 'restore',\n            from: this.uid\n        });\n    };\n\n\n    require('../featureManager').register('restore', Restore);\n\n\n    require('../../../echarts').registerAction(\n        {type: 'restore', event: 'restore', update: 'prepareAndUpdate'},\n        function (payload, ecModel) {\n            ecModel.resetOption('recreate');\n        }\n    );\n\n    module.exports = Restore;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/toolbox/feature/Restore.js\n// module id = 210\n// module chunks = 0 1","\n\n    var env = require('zrender/lib/core/env');\n\n    function SaveAsImage (model) {\n        this.model = model;\n    }\n\n    SaveAsImage.defaultOption = {\n        show: true,\n        icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n        title: '',\n        type: 'png',\n        // Default use option.backgroundColor\n        // backgroundColor: '#fff',\n        name: '',\n        excludeComponents: ['toolbox'],\n        pixelRatio: 1,\n        lang: ['']\n    };\n\n    SaveAsImage.prototype.unusable = !env.canvasSupported;\n\n    var proto = SaveAsImage.prototype;\n\n    proto.onclick = function (ecModel, api) {\n        var model = this.model;\n        var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n        var $a = document.createElement('a');\n        var type = model.get('type', true) || 'png';\n        $a.download = title + '.' + type;\n        $a.target = '_blank';\n        var url = api.getConnectedDataURL({\n            type: type,\n            backgroundColor: model.get('backgroundColor', true)\n                || ecModel.get('backgroundColor') || '#fff',\n            excludeComponents: model.get('excludeComponents'),\n            pixelRatio: model.get('pixelRatio')\n        });\n        $a.href = url;\n        // Chrome and Firefox\n        if (typeof MouseEvent === 'function') {\n            var evt = new MouseEvent('click', {\n                view: window,\n                bubbles: true,\n                cancelable: false\n            });\n            $a.dispatchEvent(evt);\n        }\n        // IE\n        else {\n            var lang = model.get('lang');\n            var html = ''\n                + '<body style=\"margin:0;\">'\n                + '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + ((lang && lang[0]) || '') + '\" />'\n                + '</body>';\n            var tab = window.open();\n            tab.document.write(html);\n        }\n    };\n\n    require('../featureManager').register(\n        'saveAsImage', SaveAsImage\n    );\n\n    module.exports = SaveAsImage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/toolbox/feature/SaveAsImage.js\n// module id = 211\n// module chunks = 0 1","// FIXME Better way to pack data in graphic element\n\n\n    require('./tooltip/TooltipModel');\n\n    require('./tooltip/TooltipView');\n\n    // Show tip action\n    /**\n     * @action\n     * @property {string} type\n     * @property {number} seriesIndex\n     * @property {number} dataIndex\n     * @property {number} [x]\n     * @property {number} [y]\n     */\n    require('../echarts').registerAction(\n        {\n            type: 'showTip',\n            event: 'showTip',\n            update: 'none'\n        },\n        // noop\n        function () {}\n    );\n    // Hide tip action\n    require('../echarts').registerAction(\n        {\n            type: 'hideTip',\n            event: 'hideTip',\n            update: 'none'\n        },\n        // noop\n        function () {}\n    );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/tooltip.js\n// module id = 212\n// module chunks = 0 1","/**\n * @module echarts/component/tooltip/TooltipContent\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var zrColor = require('zrender/lib/tool/color');\n    var eventUtil = require('zrender/lib/core/event');\n    var formatUtil = require('../../util/format');\n    var each = zrUtil.each;\n    var toCamelCase = formatUtil.toCamelCase;\n    var env = require('zrender/lib/core/env');\n\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    /**\n     * @param {number} duration\n     * @return {string}\n     * @inner\n     */\n    function assembleTransition(duration) {\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                            + 'top ' + duration + 's ' + transitionCurve;\n        return zrUtil.map(vendors, function (vendorPrefix) {\n            return vendorPrefix + 'transition:' + transitionText;\n        }).join(';');\n    }\n\n    /**\n     * @param {Object} textStyle\n     * @return {string}\n     * @inner\n     */\n    function assembleFont(textStyleModel) {\n        var cssText = [];\n\n        var fontSize = textStyleModel.get('fontSize');\n        var color = textStyleModel.getTextColor();\n\n        color && cssText.push('color:' + color);\n\n        cssText.push('font:' + textStyleModel.getFont());\n\n        fontSize &&\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n        each(['decoration', 'align'], function (name) {\n            var val = textStyleModel.get(name);\n            val && cssText.push('text-' + name + ':' + val);\n        });\n\n        return cssText.join(';');\n    }\n\n    /**\n     * @param {Object} tooltipModel\n     * @return {string}\n     * @inner\n     */\n    function assembleCssText(tooltipModel) {\n\n        tooltipModel = tooltipModel;\n\n        var cssText = [];\n\n        var transitionDuration = tooltipModel.get('transitionDuration');\n        var backgroundColor = tooltipModel.get('backgroundColor');\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        var padding = tooltipModel.get('padding');\n\n        // Animation transition\n        transitionDuration &&\n            cssText.push(assembleTransition(transitionDuration));\n\n        if (backgroundColor) {\n            if (env.canvasSupported) {\n                cssText.push('background-Color:' + backgroundColor);\n            }\n            else {\n                // for ie\n                cssText.push(\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\n                );\n                cssText.push('filter:alpha(opacity=70)');\n            }\n        }\n\n        // Border style\n        each(['width', 'color', 'radius'], function (name) {\n            var borderName = 'border-' + name;\n            var camelCase = toCamelCase(borderName);\n            var val = tooltipModel.get(camelCase);\n            val != null &&\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n        });\n\n        // Text style\n        cssText.push(assembleFont(textStyleModel));\n\n        // Padding\n        if (padding != null) {\n            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n        }\n\n        return cssText.join(';') + ';';\n    }\n\n    /**\n     * @alias module:echarts/component/tooltip/TooltipContent\n     * @constructor\n     */\n    function TooltipContent(container, api) {\n        var el = document.createElement('div');\n        var zr = api.getZr();\n\n        this.el = el;\n\n        this._x = api.getWidth() / 2;\n        this._y = api.getHeight() / 2;\n\n        container.appendChild(el);\n\n        this._container = container;\n\n        this._show = false;\n\n        /**\n         * @private\n         */\n        this._hideTimeout;\n\n        var self = this;\n        el.onmouseenter = function () {\n            // clear the timeout in hideLater and keep showing tooltip\n            if (self.enterable) {\n                clearTimeout(self._hideTimeout);\n                self._show = true;\n            }\n            self._inContent = true;\n        };\n        el.onmousemove = function (e) {\n            e = e || window.event;\n            if (!self.enterable) {\n                // Try trigger zrender event to avoid mouse\n                // in and out shape too frequently\n                var handler = zr.handler;\n                eventUtil.normalizeEvent(container, e, true);\n                handler.dispatch('mousemove', e);\n            }\n        };\n        el.onmouseleave = function () {\n            if (self.enterable) {\n                if (self._show) {\n                    self.hideLater(self._hideDelay);\n                }\n            }\n            self._inContent = false;\n        };\n\n        compromiseMobile(el, container);\n    }\n\n    function compromiseMobile(tooltipContentEl, container) {\n        // Prevent default behavior on mobile. For example,\n        // default pinch gesture will cause browser zoom.\n        // We do not preventing event on tooltip content el,\n        // because user may need customization in tooltip el.\n        eventUtil.addEventListener(container, 'touchstart', preventDefault);\n        eventUtil.addEventListener(container, 'touchmove', preventDefault);\n        eventUtil.addEventListener(container, 'touchend', preventDefault);\n\n        function preventDefault(e) {\n            if (!contains(e.target)) {\n                e.preventDefault();\n            }\n        }\n\n        function contains(targetEl) {\n            while (targetEl && targetEl !== container) {\n                if (targetEl === tooltipContentEl) {\n                    return true;\n                }\n                targetEl = targetEl.parentNode;\n            }\n        }\n    }\n\n    TooltipContent.prototype = {\n\n        constructor: TooltipContent,\n\n        enterable: true,\n\n        /**\n         * Update when tooltip is rendered\n         */\n        update: function () {\n            var container = this._container;\n            var stl = container.currentStyle\n                || document.defaultView.getComputedStyle(container);\n            var domStyle = container.style;\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n                domStyle.position = 'relative';\n            }\n            // Hide the tooltip\n            // PENDING\n            // this.hide();\n        },\n\n        show: function (tooltipModel) {\n            clearTimeout(this._hideTimeout);\n            var el = this.el;\n\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n                + (tooltipModel.get('extraCssText') || '');\n\n            el.style.display = el.innerHTML ?  'block' : 'none';\n\n            this._show = true;\n        },\n\n        setContent: function (content) {\n            var el = this.el;\n            el.innerHTML = content;\n            el.style.display = content ? 'block' : 'none';\n        },\n\n        moveTo: function (x, y) {\n            var style = this.el.style;\n            style.left = x + 'px';\n            style.top = y + 'px';\n\n            this._x = x;\n            this._y = y;\n        },\n\n        hide: function () {\n            this.el.style.display = 'none';\n            this._show = false;\n        },\n\n        // showLater: function ()\n\n        hideLater: function (time) {\n            if (this._show && !(this._inContent && this.enterable)) {\n                if (time) {\n                    this._hideDelay = time;\n                    // Set show false to avoid invoke hideLater mutiple times\n                    this._show = false;\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n                }\n                else {\n                    this.hide();\n                }\n            }\n        },\n\n        isShow: function () {\n            return this._show;\n        }\n    };\n\n    module.exports = TooltipContent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/tooltip/TooltipContent.js\n// module id = 213\n// module chunks = 0 1","\n\n    require('../../echarts').extendComponentModel({\n\n        type: 'tooltip',\n\n        defaultOption: {\n            zlevel: 0,\n\n            z: 8,\n\n            show: true,\n\n            // tooltip\n            showContent: true,\n\n            // 'item'  'axis'\n            trigger: 'item',\n\n            //  'click' | 'mousemove' | 'none'\n            triggerOn: 'mousemove',\n\n            //  content\n            alwaysShowContent: false,\n\n            //  {Array} | {Function}\n            // position: null\n\n            // {string}Template  {Function}\n            // formatter: null\n\n            showDelay: 0,\n\n            // ms\n            hideDelay: 100,\n\n            // s\n            transitionDuration: 0.4,\n\n            enterable: false,\n\n            // 0.7\n            backgroundColor: 'rgba(50,50,50,0.7)',\n\n            // \n            borderColor: '#333',\n\n            // px4\n            borderRadius: 4,\n\n            // px0\n            borderWidth: 0,\n\n            // px5\n            // css\n            padding: 5,\n\n            // Extra css text\n            extraCssText: '',\n\n            // \n            axisPointer: {\n                // \n                // 'line' | 'shadow' | 'cross'\n                type: 'line',\n\n                // type  line  tooltip line \n                //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n                //  'auto' cateogry  x \n                //  angle \n                axis: 'auto',\n\n                animation: true,\n                animationDurationUpdate: 200,\n                animationEasingUpdate: 'exponentialOut',\n\n                // \n                lineStyle: {\n                    color: '#555',\n                    width: 1,\n                    type: 'solid'\n                },\n\n                crossStyle: {\n                    color: '#555',\n                    width: 1,\n                    type: 'dashed',\n\n                    // TODO formatter\n                    textStyle: {}\n                },\n\n                // \n                shadowStyle: {\n                    color: 'rgba(150,150,150,0.3)'\n                }\n            },\n            textStyle: {\n                color: '#fff',\n                fontSize: 14\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/tooltip/TooltipModel.js\n// module id = 214\n// module chunks = 0 1","\n\n    var TooltipContent = require('./TooltipContent');\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var numberUtil = require('../../util/number');\n    var modelUtil = require('../../util/model');\n    var parsePercent = numberUtil.parsePercent;\n    var env = require('zrender/lib/core/env');\n    var Model = require('../../model/Model');\n\n    function dataEqual(a, b) {\n        if (!a || !b) {\n            return false;\n        }\n        var round = numberUtil.round;\n        return round(a[0]) === round(b[0])\n            && round(a[1]) === round(b[1]);\n    }\n    /**\n     * @inner\n     */\n    function makeLineShape(x1, y1, x2, y2) {\n        return {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function makeRectShape(x, y, width, height) {\n        return {\n            x: x,\n            y: y,\n            width: width,\n            height: height\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n        return {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            clockwise: true\n        };\n    }\n\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n        var gap = 20;\n\n        if (x + width + gap > viewWidth) {\n            x -= width + gap;\n        }\n        else {\n            x += gap;\n        }\n        if (y + height + gap > viewHeight) {\n            y -= height + gap;\n        }\n        else {\n            y += gap;\n        }\n        return [x, y];\n    }\n\n    function calcTooltipPosition(position, rect, dom) {\n        var domWidth = dom.clientWidth;\n        var domHeight = dom.clientHeight;\n        var gap = 5;\n        var x = 0;\n        var y = 0;\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n        switch (position) {\n            case 'inside':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'top':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y - domHeight - gap;\n                break;\n            case 'bottom':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight + gap;\n                break;\n            case 'left':\n                x = rect.x - domWidth - gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'right':\n                x = rect.x + rectWidth + gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n        }\n        return [x, y];\n    }\n\n    /**\n     * @param  {string|Function|Array.<number>} positionExpr\n     * @param  {number} x Mouse x\n     * @param  {number} y Mouse y\n     * @param  {module:echarts/component/tooltip/TooltipContent} content\n     * @param  {Object|<Array.<Object>} params\n     * @param  {module:zrender/Element} el target element\n     * @param  {module:echarts/ExtensionAPI} api\n     * @return {Array.<number>}\n     */\n    function updatePosition(positionExpr, x, y, content, params, el, api) {\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n\n        var rect = el && el.getBoundingRect().clone();\n        el && rect.applyTransform(el.transform);\n        if (typeof positionExpr === 'function') {\n            // Callback of position can be an array or a string specify the position\n            positionExpr = positionExpr([x, y], params, content.el, rect);\n        }\n\n        if (zrUtil.isArray(positionExpr)) {\n            x = parsePercent(positionExpr[0], viewWidth);\n            y = parsePercent(positionExpr[1], viewHeight);\n        }\n        // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n        else if (typeof positionExpr === 'string' && el) {\n            var pos = calcTooltipPosition(\n                positionExpr, rect, content.el\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n        else {\n            var pos = refixTooltipPosition(\n                x, y, content.el, viewWidth, viewHeight\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n\n        content.moveTo(x, y);\n    }\n\n    function ifSeriesSupportAxisTrigger(seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n        var trigger = seriesModel.get('tooltip.trigger', true);\n        // Ignore series use item tooltip trigger and series coordinate system is not cartesian or\n        return !(!coordSys\n            || (coordSys.type !== 'cartesian2d' && coordSys.type !== 'polar' && coordSys.type !== 'singleAxis')\n            || trigger === 'item');\n    }\n\n    require('../../echarts').extendComponentView({\n\n        type: 'tooltip',\n\n        _axisPointers: {},\n\n        init: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var tooltipContent = new TooltipContent(api.getDom(), api);\n            this._tooltipContent = tooltipContent;\n\n            api.on('showTip', this._manuallyShowTip, this);\n            api.on('hideTip', this._manuallyHideTip, this);\n        },\n\n        render: function (tooltipModel, ecModel, api) {\n            if (env.node) {\n                return;\n            }\n\n            // Reset\n            this.group.removeAll();\n\n            /**\n             * @type {Object}\n             * @private\n             */\n            this._axisPointers = {};\n\n            /**\n             * @private\n             * @type {module:echarts/component/tooltip/TooltipModel}\n             */\n            this._tooltipModel = tooltipModel;\n\n            /**\n             * @private\n             * @type {module:echarts/model/Global}\n             */\n            this._ecModel = ecModel;\n\n            /**\n             * @private\n             * @type {module:echarts/ExtensionAPI}\n             */\n            this._api = api;\n\n            /**\n             * @type {Object}\n             * @private\n             */\n            this._lastHover = {\n                // data\n                // payloadBatch\n            };\n\n            var tooltipContent = this._tooltipContent;\n            tooltipContent.update();\n            tooltipContent.enterable = tooltipModel.get('enterable');\n            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n            /**\n             * @type {Object.<string, Array>}\n             */\n            this._seriesGroupByAxis = this._prepareAxisTriggerData(\n                tooltipModel, ecModel\n            );\n\n            var crossText = this._crossText;\n            if (crossText) {\n                this.group.add(crossText);\n            }\n\n            var triggerOn = tooltipModel.get('triggerOn');\n\n            // Try to keep the tooltip show when refreshing\n            if (this._lastX != null\n                && this._lastY != null\n                // When user is willing to control tooltip totally using API,\n                // self._manuallyShowTip({x, y}) might cause tooltip hide,\n                // which is not expected.\n                && triggerOn !== 'none'\n            ) {\n                var self = this;\n                clearTimeout(this._refreshUpdateTimeout);\n                this._refreshUpdateTimeout = setTimeout(function () {\n                    // Show tip next tick after other charts are rendered\n                    // In case highlight action has wrong result\n                    // FIXME\n                    self._manuallyShowTip({\n                        x: self._lastX,\n                        y: self._lastY\n                    });\n                });\n            }\n\n            var zr = this._api.getZr();\n            zr.off('click', this._tryShow);\n            zr.off('mousemove', this._mousemove);\n            zr.off('mouseout', this._hide);\n            zr.off('globalout', this._hide);\n\n            if (triggerOn === 'click') {\n                zr.on('click', this._tryShow, this);\n            }\n            else if (triggerOn === 'mousemove') {\n                zr.on('mousemove', this._mousemove, this);\n                zr.on('mouseout', this._hide, this);\n                zr.on('globalout', this._hide, this);\n            }\n            // else triggerOn is 'none', which enable user\n            // to control tooltip totally using API.\n        },\n\n        _mousemove: function (e) {\n            var showDelay = this._tooltipModel.get('showDelay');\n            var self = this;\n            clearTimeout(this._showTimeout);\n            if (showDelay > 0) {\n                this._showTimeout = setTimeout(function () {\n                    self._tryShow(e);\n                }, showDelay);\n            }\n            else {\n                this._tryShow(e);\n            }\n        },\n\n        /**\n         * Show tip manually by\n         * dispatchAction({\n         *     type: 'showTip',\n         *     x: 10,\n         *     y: 10\n         * });\n         * Or\n         * dispatchAction({\n         *      type: 'showTip',\n         *      seriesIndex: 0,\n         *      dataIndex or dataIndexInside or name\n         * });\n         *\n         *  TODO Batch\n         */\n        _manuallyShowTip: function (event) {\n            // From self\n            if (event.from === this.uid) {\n                return;\n            }\n\n            var ecModel = this._ecModel;\n            var seriesIndex = event.seriesIndex;\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n            var api = this._api;\n\n            if (event.x == null || event.y == null) {\n                if (!seriesModel) {\n                    // Find the first series can use axis trigger\n                    ecModel.eachSeries(function (_series) {\n                        if (ifSeriesSupportAxisTrigger(_series) && !seriesModel) {\n                            seriesModel = _series;\n                        }\n                    });\n                }\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var dataIndex = modelUtil.queryDataIndex(data, event);\n\n                    if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n                        return;\n                    }\n\n                    var el = data.getItemGraphicEl(dataIndex);\n                    var cx;\n                    var cy;\n                    // Try to get the point in coordinate system\n                    var coordSys = seriesModel.coordinateSystem;\n                    if (seriesModel.getTooltipPosition) {\n                        var point = seriesModel.getTooltipPosition(dataIndex) || [];\n                        cx = point[0];\n                        cy = point[1];\n                    }\n                    else if (coordSys && coordSys.dataToPoint) {\n                        var point = coordSys.dataToPoint(\n                            data.getValues(\n                                zrUtil.map(coordSys.dimensions, function (dim) {\n                                    return seriesModel.coordDimToDataDim(dim)[0];\n                                }), dataIndex, true\n                            )\n                        );\n                        cx = point && point[0];\n                        cy = point && point[1];\n                    }\n                    else if (el) {\n                        // Use graphic bounding rect\n                        var rect = el.getBoundingRect().clone();\n                        rect.applyTransform(el.transform);\n                        cx = rect.x + rect.width / 2;\n                        cy = rect.y + rect.height / 2;\n                    }\n\n                    if (cx != null && cy != null) {\n                        this._tryShow({\n                            offsetX: cx,\n                            offsetY: cy,\n                            position: event.position,\n                            target: el,\n                            event: {}\n                        });\n                    }\n                }\n            }\n            else {\n                var el = api.getZr().handler.findHover(event.x, event.y);\n                this._tryShow({\n                    offsetX: event.x,\n                    offsetY: event.y,\n                    position: event.position,\n                    target: el,\n                    event: {}\n                });\n            }\n        },\n\n        _manuallyHideTip: function (e) {\n            if (e.from === this.uid) {\n                return;\n            }\n\n            this._hide();\n        },\n\n        _prepareAxisTriggerData: function (tooltipModel, ecModel) {\n            // Prepare data for axis trigger\n            var seriesGroupByAxis = {};\n            ecModel.eachSeries(function (seriesModel) {\n                if (ifSeriesSupportAxisTrigger(seriesModel)) {\n                    var coordSys = seriesModel.coordinateSystem;\n                    var baseAxis;\n                    var key;\n\n                    // Only cartesian2d, polar and single support axis trigger\n                    if (coordSys.type === 'cartesian2d') {\n                        // FIXME `axisPointer.axis` is not baseAxis\n                        baseAxis = coordSys.getBaseAxis();\n                        key = baseAxis.dim + baseAxis.index;\n                    }\n                    else if (coordSys.type === 'singleAxis') {\n                        baseAxis = coordSys.getAxis();\n                        key = baseAxis.dim + baseAxis.type;\n                    }\n                    else {\n                        baseAxis = coordSys.getBaseAxis();\n                        key = baseAxis.dim + coordSys.name;\n                    }\n\n                    seriesGroupByAxis[key] = seriesGroupByAxis[key] || {\n                        coordSys: [],\n                        series: []\n                    };\n                    seriesGroupByAxis[key].coordSys.push(coordSys);\n                    seriesGroupByAxis[key].series.push(seriesModel);\n                }\n            }, this);\n\n            return seriesGroupByAxis;\n        },\n\n        /**\n         * mousemove handler\n         * @param {Object} e\n         * @private\n         */\n        _tryShow: function (e) {\n            var el = e.target;\n            var tooltipModel = this._tooltipModel;\n            var globalTrigger = tooltipModel.get('trigger');\n            var ecModel = this._ecModel;\n            var api = this._api;\n\n            if (!tooltipModel) {\n                return;\n            }\n\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n            this._lastX = e.offsetX;\n            this._lastY = e.offsetY;\n\n            // Always show item tooltip if mouse is on the element with dataIndex\n            if (el && el.dataIndex != null) {\n                // Use dataModel in element if possible\n                // Used when mouseover on a element like markPoint or edge\n                // In which case, the data is not main data in series.\n                var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                var dataIndex = el.dataIndex;\n                var itemModel = dataModel.getData().getItemModel(dataIndex);\n                // Series or single data may use item trigger when global is axis trigger\n                if ((itemModel.get('tooltip.trigger') || globalTrigger) === 'axis') {\n                    this._showAxisTooltip(tooltipModel, ecModel, e);\n                }\n                else {\n                    // Reset ticket\n                    this._ticket = '';\n                    // If either single data or series use item trigger\n                    this._hideAxisPointer();\n                    // Reset last hover and dispatch downplay action\n                    this._resetLastHover();\n\n                    this._showItemTooltipContent(dataModel, dataIndex, el.dataType, e);\n                }\n\n                api.dispatchAction({\n                    type: 'showTip',\n                    from: this.uid,\n                    dataIndexInside: el.dataIndex,\n                    seriesIndex: el.seriesIndex\n                });\n            }\n            // Tooltip provided directly. Like legend\n            else if (el && el.tooltip) {\n                var tooltipOpt = el.tooltip;\n                if (typeof tooltipOpt === 'string') {\n                    var content = tooltipOpt;\n                    tooltipOpt = {\n                        content: content,\n                        // Fixed formatter\n                        formatter: content\n                    };\n                }\n                var subTooltipModel = new Model(tooltipOpt, tooltipModel);\n                var defaultHtml = subTooltipModel.get('content');\n                var asyncTicket = Math.random();\n                this._showTooltipContent(\n                    // TODO params\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el, api\n                );\n            }\n            else {\n                if (globalTrigger === 'item') {\n                    this._hide();\n                }\n                else {\n                    // Try show axis tooltip\n                    this._showAxisTooltip(tooltipModel, ecModel, e);\n                }\n\n                // Action of cross pointer\n                // other pointer types will trigger action in _dispatchAndShowSeriesTooltipContent method\n                if (tooltipModel.get('axisPointer.type') === 'cross') {\n                    api.dispatchAction({\n                        type: 'showTip',\n                        from: this.uid,\n                        x: e.offsetX,\n                        y: e.offsetY\n                    });\n                }\n            }\n        },\n\n        /**\n         * Show tooltip on axis\n         * @param {module:echarts/component/tooltip/TooltipModel} tooltipModel\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Object} e\n         * @private\n         */\n        _showAxisTooltip: function (tooltipModel, ecModel, e) {\n            var axisPointerModel = tooltipModel.getModel('axisPointer');\n            var axisPointerType = axisPointerModel.get('type');\n\n            if (axisPointerType === 'cross') {\n                var el = e.target;\n                if (el && el.dataIndex != null) {\n                    var seriesModel = ecModel.getSeriesByIndex(el.seriesIndex);\n                    var dataIndex = el.dataIndex;\n                    this._showItemTooltipContent(seriesModel, dataIndex, el.dataType, e);\n                }\n            }\n\n            this._showAxisPointer();\n            var allNotShow = true;\n            zrUtil.each(this._seriesGroupByAxis, function (seriesCoordSysSameAxis) {\n                // Try show the axis pointer\n                var allCoordSys = seriesCoordSysSameAxis.coordSys;\n                var coordSys = allCoordSys[0];\n\n                // If mouse position is not in the grid or polar\n                var point = [e.offsetX, e.offsetY];\n\n                if (!coordSys.containPoint(point)) {\n                    // Hide axis pointer\n                    this._hideAxisPointer(coordSys.name);\n                    return;\n                }\n\n                allNotShow = false;\n                // Make sure point is discrete on cateogry axis\n                var dimensions = coordSys.dimensions;\n                var value = coordSys.pointToData(point, true);\n                point = coordSys.dataToPoint(value);\n                var baseAxis = coordSys.getBaseAxis();\n                var axisType = axisPointerModel.get('axis');\n                if (axisType === 'auto') {\n                    axisType = baseAxis.dim;\n                }\n\n                var contentNotChange = false;\n                var lastHover = this._lastHover;\n                if (axisPointerType === 'cross') {\n                    // If hover data not changed\n                    // Possible when two axes are all category\n                    if (dataEqual(lastHover.data, value)) {\n                        contentNotChange = true;\n                    }\n                    lastHover.data = value;\n                }\n                else {\n                    var valIndex = zrUtil.indexOf(dimensions, axisType);\n\n                    // If hover data not changed on the axis dimension\n                    if (lastHover.data === value[valIndex]) {\n                        contentNotChange = true;\n                    }\n                    lastHover.data = value[valIndex];\n                }\n\n                if (coordSys.type === 'cartesian2d' && !contentNotChange) {\n                    this._showCartesianPointer(\n                        axisPointerModel, coordSys, axisType, point\n                    );\n                }\n                else if (coordSys.type === 'polar' && !contentNotChange) {\n                    this._showPolarPointer(\n                        axisPointerModel, coordSys, axisType, point\n                    );\n                }\n                else if (coordSys.type === 'singleAxis' && !contentNotChange) {\n                    this._showSinglePointer(\n                        axisPointerModel, coordSys, axisType, point\n                    );\n                }\n\n                if (axisPointerType !== 'cross') {\n                    this._dispatchAndShowSeriesTooltipContent(\n                        coordSys, seriesCoordSysSameAxis.series, point, value, contentNotChange, e.position\n                    );\n                }\n            }, this);\n\n            if (!this._tooltipModel.get('show')) {\n                this._hideAxisPointer();\n            }\n\n            if (allNotShow) {\n                this._hide();\n            }\n        },\n\n        /**\n         * Show tooltip on axis of cartesian coordinate\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @param {module:echarts/coord/cartesian/Cartesian2D} cartesians\n         * @param {string} axisType\n         * @param {Array.<number>} point\n         * @private\n         */\n        _showCartesianPointer: function (axisPointerModel, cartesian, axisType, point) {\n            var self = this;\n\n            var axisPointerType = axisPointerModel.get('type');\n            var baseAxis = cartesian.getBaseAxis();\n            var moveAnimation = axisPointerType !== 'cross'\n                && baseAxis.type === 'category'\n                && baseAxis.getBandWidth() > 20;\n\n            if (axisPointerType === 'cross') {\n                moveGridLine('x', point, cartesian.getAxis('y').getGlobalExtent());\n                moveGridLine('y', point, cartesian.getAxis('x').getGlobalExtent());\n\n                this._updateCrossText(cartesian, point, axisPointerModel);\n            }\n            else {\n                var otherAxis = cartesian.getAxis(axisType === 'x' ? 'y' : 'x');\n                var otherExtent = otherAxis.getGlobalExtent();\n\n                if (cartesian.type === 'cartesian2d') {\n                    (axisPointerType === 'line' ? moveGridLine : moveGridShadow)(\n                        axisType, point, otherExtent\n                    );\n                }\n            }\n\n            /**\n             * @inner\n             */\n            function moveGridLine(axisType, point, otherExtent) {\n                var targetShape = axisType === 'x'\n                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\n                var pointerEl = self._getPointerElement(\n                    cartesian, axisPointerModel, axisType, targetShape\n                );\n                graphic.subPixelOptimizeLine({\n                    shape: targetShape,\n                    style: pointerEl.style\n                });\n\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n            /**\n             * @inner\n             */\n            function moveGridShadow(axisType, point, otherExtent) {\n                var axis = cartesian.getAxis(axisType);\n                var bandWidth = axis.getBandWidth();\n                var span = otherExtent[1] - otherExtent[0];\n                var targetShape = axisType === 'x'\n                    ? makeRectShape(point[0] - bandWidth / 2, otherExtent[0], bandWidth, span)\n                    : makeRectShape(otherExtent[0], point[1] - bandWidth / 2, span, bandWidth);\n\n                var pointerEl = self._getPointerElement(\n                    cartesian, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n        },\n\n        _showSinglePointer: function (axisPointerModel, single, axisType, point) {\n            var self = this;\n            var axisPointerType = axisPointerModel.get('type');\n            var moveAnimation = axisPointerType !== 'cross' && single.getBaseAxis().type === 'category';\n            var rect = single.getRect();\n            var otherExtent = [rect.y, rect.y + rect.height];\n\n            moveSingleLine(axisType, point, otherExtent);\n\n            /**\n             * @inner\n             */\n            function moveSingleLine(axisType, point, otherExtent) {\n                var axis = single.getAxis();\n                var orient = axis.orient;\n\n                var targetShape = orient === 'horizontal'\n                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\n                var pointerEl = self._getPointerElement(\n                    single, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n        },\n\n        /**\n         * Show tooltip on axis of polar coordinate\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @param {Array.<module:echarts/coord/polar/Polar>} polar\n         * @param {string} axisType\n         * @param {Array.<number>} point\n         */\n        _showPolarPointer: function (axisPointerModel, polar, axisType, point) {\n            var self = this;\n\n            var axisPointerType = axisPointerModel.get('type');\n\n            var angleAxis = polar.getAngleAxis();\n            var radiusAxis = polar.getRadiusAxis();\n\n            var moveAnimation = axisPointerType !== 'cross'\n                && polar.getBaseAxis().type === 'category';\n\n            if (axisPointerType === 'cross') {\n                movePolarLine('angle', point, radiusAxis.getExtent());\n                movePolarLine('radius', point, angleAxis.getExtent());\n\n                this._updateCrossText(polar, point, axisPointerModel);\n            }\n            else {\n                var otherAxis = polar.getAxis(axisType === 'radius' ? 'angle' : 'radius');\n                var otherExtent = otherAxis.getExtent();\n\n                (axisPointerType === 'line' ? movePolarLine : movePolarShadow)(\n                    axisType, point, otherExtent\n                );\n            }\n            /**\n             * @inner\n             */\n            function movePolarLine(axisType, point, otherExtent) {\n                var mouseCoord = polar.pointToCoord(point);\n\n                var targetShape;\n\n                if (axisType === 'angle') {\n                    var p1 = polar.coordToPoint([otherExtent[0], mouseCoord[1]]);\n                    var p2 = polar.coordToPoint([otherExtent[1], mouseCoord[1]]);\n                    targetShape = makeLineShape(p1[0], p1[1], p2[0], p2[1]);\n                }\n                else {\n                    targetShape = {\n                        cx: polar.cx,\n                        cy: polar.cy,\n                        r: mouseCoord[0]\n                    };\n                }\n\n                var pointerEl = self._getPointerElement(\n                    polar, axisPointerModel, axisType, targetShape\n                );\n\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n            /**\n             * @inner\n             */\n            function movePolarShadow(axisType, point, otherExtent) {\n                var axis = polar.getAxis(axisType);\n                var bandWidth = axis.getBandWidth();\n\n                var mouseCoord = polar.pointToCoord(point);\n\n                var targetShape;\n\n                var radian = Math.PI / 180;\n\n                if (axisType === 'angle') {\n                    targetShape = makeSectorShape(\n                        polar.cx, polar.cy,\n                        otherExtent[0], otherExtent[1],\n                        // In ECharts y is negative if angle is positive\n                        (-mouseCoord[1] - bandWidth / 2) * radian,\n                        (-mouseCoord[1] + bandWidth / 2) * radian\n                    );\n                }\n                else {\n                    targetShape = makeSectorShape(\n                        polar.cx, polar.cy,\n                        mouseCoord[0] - bandWidth / 2,\n                        mouseCoord[0] + bandWidth / 2,\n                        0, Math.PI * 2\n                    );\n                }\n\n                var pointerEl = self._getPointerElement(\n                    polar, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n        },\n\n        _updateCrossText: function (coordSys, point, axisPointerModel) {\n            var crossStyleModel = axisPointerModel.getModel('crossStyle');\n            var textStyleModel = crossStyleModel.getModel('textStyle');\n\n            var tooltipModel = this._tooltipModel;\n\n            var text = this._crossText;\n            if (!text) {\n                text = this._crossText = new graphic.Text({\n                    style: {\n                        textAlign: 'left',\n                        textVerticalAlign: 'bottom'\n                    }\n                });\n                this.group.add(text);\n            }\n\n            var value = coordSys.pointToData(point);\n\n            var dims = coordSys.dimensions;\n            value = zrUtil.map(value, function (val, idx) {\n                var axis = coordSys.getAxis(dims[idx]);\n                if (axis.type === 'category' || axis.type === 'time') {\n                    val = axis.scale.getLabel(val);\n                }\n                else {\n                    val = formatUtil.addCommas(\n                        val.toFixed(axis.getPixelPrecision())\n                    );\n                }\n                return val;\n            });\n\n            text.setStyle({\n                fill: textStyleModel.getTextColor() || crossStyleModel.get('color'),\n                textFont: textStyleModel.getFont(),\n                text: value.join(', '),\n                x: point[0] + 5,\n                y: point[1] - 5\n            });\n            text.z = tooltipModel.get('z');\n            text.zlevel = tooltipModel.get('zlevel');\n        },\n\n        _getPointerElement: function (coordSys, pointerModel, axisType, initShape) {\n            var tooltipModel = this._tooltipModel;\n            var z = tooltipModel.get('z');\n            var zlevel = tooltipModel.get('zlevel');\n            var axisPointers = this._axisPointers;\n            var coordSysName = coordSys.name;\n            axisPointers[coordSysName] = axisPointers[coordSysName] || {};\n            if (axisPointers[coordSysName][axisType]) {\n                return axisPointers[coordSysName][axisType];\n            }\n\n            // Create if not exists\n            var pointerType = pointerModel.get('type');\n            var styleModel = pointerModel.getModel(pointerType + 'Style');\n            var isShadow = pointerType === 'shadow';\n            var style = styleModel[isShadow ? 'getAreaStyle' : 'getLineStyle']();\n\n            var elementType = coordSys.type === 'polar'\n                ? (isShadow ? 'Sector' : (axisType === 'radius' ? 'Circle' : 'Line'))\n                : (isShadow ? 'Rect' : 'Line');\n\n            isShadow ? (style.stroke = null) : (style.fill = null);\n\n            var el = axisPointers[coordSysName][axisType] = new graphic[elementType]({\n                style: style,\n                z: z,\n                zlevel: zlevel,\n                silent: true,\n                shape: initShape\n            });\n\n            this.group.add(el);\n            return el;\n        },\n\n        /**\n         * Dispatch actions and show tooltip on series\n         * @param {Array.<module:echarts/model/Series>} seriesList\n         * @param {Array.<number>} point\n         * @param {Array.<number>} value\n         * @param {boolean} contentNotChange\n         * @param {Array.<number>|string|Function} [positionExpr]\n         */\n        _dispatchAndShowSeriesTooltipContent: function (\n            coordSys, seriesList, point, value, contentNotChange, positionExpr\n        ) {\n\n            var rootTooltipModel = this._tooltipModel;\n\n            var baseAxis = coordSys.getBaseAxis();\n            var baseDimIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\n            var payloadBatch = zrUtil.map(seriesList, function (series) {\n                return {\n                    seriesIndex: series.seriesIndex,\n                    dataIndexInside: series.getAxisTooltipDataIndex\n                        ? series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim), value, baseAxis)\n                        : series.getData().indexOfNearest(\n                            series.coordDimToDataDim(baseAxis.dim)[0],\n                            value[baseDimIndex],\n                            // Add a threshold to avoid find the wrong dataIndex when data length is not same\n                            false, baseAxis.type === 'category' ? 0.5 : null\n                        )\n                };\n            });\n\n            var lastHover = this._lastHover;\n            var api = this._api;\n            // Dispatch downplay action\n            if (lastHover.payloadBatch && !contentNotChange) {\n                api.dispatchAction({\n                    type: 'downplay',\n                    batch: lastHover.payloadBatch\n                });\n            }\n            // Dispatch highlight action\n            if (!contentNotChange) {\n                api.dispatchAction({\n                    type: 'highlight',\n                    batch: payloadBatch\n                });\n                lastHover.payloadBatch = payloadBatch;\n            }\n            // Dispatch showTip action\n            api.dispatchAction({\n                type: 'showTip',\n                dataIndexInside: payloadBatch[0].dataIndexInside,\n                seriesIndex: payloadBatch[0].seriesIndex,\n                from: this.uid\n            });\n\n            if (baseAxis && rootTooltipModel.get('showContent') && rootTooltipModel.get('show')) {\n                var paramsList = zrUtil.map(seriesList, function (series, index) {\n                    return series.getDataParams(payloadBatch[index].dataIndexInside);\n                });\n\n                if (!contentNotChange) {\n                    // Update html content\n                    var firstDataIndex = payloadBatch[0].dataIndexInside;\n\n                    // Default tooltip content\n                    // FIXME\n                    // (1) shold be the first data which has name?\n                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                    var firstLine = baseAxis.type === 'time'\n                        ? baseAxis.scale.getLabel(value[baseDimIndex])\n                        : seriesList[0].getData().getName(firstDataIndex);\n                    var defaultHtml = (firstLine ? firstLine + '<br />' : '')\n                        + zrUtil.map(seriesList, function (series, index) {\n                            return series.formatTooltip(payloadBatch[index].dataIndexInside, true);\n                        }).join('<br />');\n\n                    var asyncTicket = 'axis_' + coordSys.name + '_' + firstDataIndex;\n\n                    this._showTooltipContent(\n                        rootTooltipModel, defaultHtml, paramsList, asyncTicket,\n                        point[0], point[1], positionExpr, null, api\n                    );\n                }\n                else {\n                    updatePosition(\n                        positionExpr || rootTooltipModel.get('position'), point[0], point[1],\n                        this._tooltipContent, paramsList, null, api\n                    );\n                }\n            }\n        },\n\n        /**\n         * Show tooltip on item\n         * @param {module:echarts/model/Series} seriesModel\n         * @param {number} dataIndex\n         * @param {string} dataType\n         * @param {Object} e\n         */\n        _showItemTooltipContent: function (seriesModel, dataIndex, dataType, e) {\n            // FIXME Graph data\n            var api = this._api;\n            var data = seriesModel.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var tooltipOpt = itemModel.get('tooltip', true);\n            if (typeof tooltipOpt === 'string') {\n                // In each data item tooltip can be simply write:\n                // {\n                //  value: 10,\n                //  tooltip: 'Something you need to know'\n                // }\n                var tooltipContent = tooltipOpt;\n                tooltipOpt = {\n                    formatter: tooltipContent\n                };\n            }\n            var rootTooltipModel = this._tooltipModel;\n            var seriesTooltipModel = seriesModel.getModel(\n                'tooltip', rootTooltipModel\n            );\n            var tooltipModel = new Model(tooltipOpt, seriesTooltipModel, seriesTooltipModel.ecModel);\n\n            var params = seriesModel.getDataParams(dataIndex, dataType);\n            var defaultHtml = seriesModel.formatTooltip(dataIndex, false, dataType);\n\n            var asyncTicket = 'item_' + seriesModel.name + '_' + dataIndex;\n\n            this._showTooltipContent(\n                tooltipModel, defaultHtml, params, asyncTicket,\n                e.offsetX, e.offsetY, e.position, e.target, api\n            );\n        },\n\n        _showTooltipContent: function (\n            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, target, api\n        ) {\n            // Reset ticket\n            this._ticket = '';\n\n            if (tooltipModel.get('showContent') && tooltipModel.get('show')) {\n                var tooltipContent = this._tooltipContent;\n\n                var formatter = tooltipModel.get('formatter');\n                positionExpr = positionExpr || tooltipModel.get('position');\n                var html = defaultHtml;\n\n                if (formatter) {\n                    if (typeof formatter === 'string') {\n                        html = formatUtil.formatTpl(formatter, params);\n                    }\n                    else if (typeof formatter === 'function') {\n                        var self = this;\n                        var ticket = asyncTicket;\n                        var callback = function (cbTicket, html) {\n                            if (cbTicket === self._ticket) {\n                                tooltipContent.setContent(html);\n\n                                updatePosition(\n                                    positionExpr, x, y,\n                                    tooltipContent, params, target, api\n                                );\n                            }\n                        };\n                        self._ticket = ticket;\n                        html = formatter(params, ticket, callback);\n                    }\n                }\n\n                tooltipContent.show(tooltipModel);\n                tooltipContent.setContent(html);\n\n                updatePosition(\n                    positionExpr, x, y,\n                    tooltipContent, params, target, api\n                );\n            }\n        },\n\n        /**\n         * Show axis pointer\n         * @param {string} [coordSysName]\n         */\n        _showAxisPointer: function (coordSysName) {\n            if (coordSysName) {\n                var axisPointers = this._axisPointers[coordSysName];\n                axisPointers && zrUtil.each(axisPointers, function (el) {\n                    el.show();\n                });\n            }\n            else {\n                this.group.eachChild(function (child) {\n                    child.show();\n                });\n                this.group.show();\n            }\n        },\n\n        _resetLastHover: function () {\n            var lastHover = this._lastHover;\n            if (lastHover.payloadBatch) {\n                this._api.dispatchAction({\n                    type: 'downplay',\n                    batch: lastHover.payloadBatch\n                });\n            }\n            // Reset lastHover\n            this._lastHover = {};\n        },\n        /**\n         * Hide axis pointer\n         * @param {string} [coordSysName]\n         */\n        _hideAxisPointer: function (coordSysName) {\n            if (coordSysName) {\n                var axisPointers = this._axisPointers[coordSysName];\n                axisPointers && zrUtil.each(axisPointers, function (el) {\n                    el.hide();\n                });\n            }\n            else {\n                if (this.group.children().length) {\n                    this.group.hide();\n                }\n            }\n        },\n\n        _hide: function () {\n            clearTimeout(this._showTimeout);\n\n            this._hideAxisPointer();\n            this._resetLastHover();\n            if (!this._alwaysShowContent) {\n                this._tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n            }\n\n            this._api.dispatchAction({\n                type: 'hideTip',\n                from: this.uid\n            });\n\n            this._lastX = this._lastY = null;\n        },\n\n        dispose: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var zr = api.getZr();\n            this._tooltipContent.hide();\n\n            zr.off('click', this._tryShow);\n            zr.off('mousemove', this._mousemove);\n            zr.off('mouseout', this._hide);\n            zr.off('globalout', this._hide);\n\n            api.off('showTip', this._manuallyShowTip);\n            api.off('hideTip', this._manuallyHideTip);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/tooltip/TooltipView.js\n// module id = 215\n// module chunks = 0 1","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 217\n// module chunks = 0 1","/**\n * VML Painter.\n *\n * @module zrender/vml/Painter\n */\n\n\n\n    var zrLog = require('../core/log');\n    var vmlCore = require('./core');\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    /**\n     * @alias module:zrender/vml/Painter\n     */\n    function VMLPainter(root, storage) {\n\n        vmlCore.initVML();\n\n        this.root = root;\n\n        this.storage = storage;\n\n        var vmlViewport = document.createElement('div');\n\n        var vmlRoot = document.createElement('div');\n\n        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\n        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\n        root.appendChild(vmlViewport);\n\n        this._vmlRoot = vmlRoot;\n        this._vmlViewport = vmlViewport;\n\n        this.resize();\n\n        // Modify storage\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            if (el) {\n                el.onRemove && el.onRemove(vmlRoot);\n            }\n        };\n\n        storage.addToMap = function (el) {\n            // Displayable already has a vml node\n            el.onAdd && el.onAdd(vmlRoot);\n\n            oldAddToMap.call(storage, el);\n        };\n\n        this._firstPaint = true;\n    }\n\n    VMLPainter.prototype = {\n\n        constructor: VMLPainter,\n\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._vmlViewport;\n        },\n\n        /**\n         * \n         */\n        refresh: function () {\n\n            var list = this.storage.getDisplayList(true, true);\n\n            this._paintList(list);\n        },\n\n        _paintList: function (list) {\n            var vmlRoot = this._vmlRoot;\n            for (var i = 0; i < list.length; i++) {\n                var el = list[i];\n                if (el.invisible || el.ignore) {\n                    if (!el.__alreadyNotVisible) {\n                        el.onRemove(vmlRoot);\n                    }\n                    // Set as already invisible\n                    el.__alreadyNotVisible = true;\n                }\n                else {\n                    if (el.__alreadyNotVisible) {\n                        el.onAdd(vmlRoot);\n                    }\n                    el.__alreadyNotVisible = false;\n                    if (el.__dirty) {\n                        el.beforeBrush && el.beforeBrush();\n                        (el.brushVML || el.brush).call(el, vmlRoot);\n                        el.afterBrush && el.afterBrush();\n                    }\n                }\n                el.__dirty = false;\n            }\n\n            if (this._firstPaint) {\n                // Detached from document at first time\n                // to avoid page refreshing too many times\n\n                // FIXME  removeChild \n                this._vmlViewport.appendChild(vmlRoot);\n                this._firstPaint = false;\n            }\n        },\n\n        resize: function (width, height) {\n            var width = width == null ? this._getWidth() : width;\n            var height = height == null ? this._getHeight() : height;\n\n            if (this._width != width || this._height != height) {\n                this._width = width;\n                this._height = height;\n\n                var vmlViewportStyle = this._vmlViewport.style;\n                vmlViewportStyle.width = width + 'px';\n                vmlViewportStyle.height = height + 'px';\n            }\n        },\n\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this._vmlRoot =\n            this._vmlViewport =\n            this.storage = null;\n        },\n\n        getWidth: function () {\n            return this._width;\n        },\n\n        getHeight: function () {\n            return this._height;\n        },\n\n        clear: function () {\n            if (this._vmlViewport) {\n                this.root.removeChild(this._vmlViewport);\n            }\n        },\n\n        _getWidth: function () {\n            var root = this.root;\n            var stl = root.currentStyle;\n\n            return ((root.clientWidth || parseInt10(stl.width))\n                    - parseInt10(stl.paddingLeft)\n                    - parseInt10(stl.paddingRight)) | 0;\n        },\n\n        _getHeight: function () {\n            var root = this.root;\n            var stl = root.currentStyle;\n\n            return ((root.clientHeight || parseInt10(stl.height))\n                    - parseInt10(stl.paddingTop)\n                    - parseInt10(stl.paddingBottom)) | 0;\n        }\n    };\n\n    // Not supported methods\n    function createMethodNotSupport(method) {\n        return function () {\n            zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n        };\n    }\n\n    var notSupportedMethods = [\n        'getLayer', 'insertLayer', 'eachLayer', 'eachBuildinLayer', 'eachOtherLayer', 'getLayers',\n        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'\n    ];\n\n    for (var i = 0; i < notSupportedMethods.length; i++) {\n        var name = notSupportedMethods[i];\n        VMLPainter.prototype[name] = createMethodNotSupport(name);\n    }\n\n    module.exports = VMLPainter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/Painter.js\n// module id = 218\n// module chunks = 0 1","// http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\n\n\nif (!require('../core/env').canvasSupported) {\n    var vec2 = require('../core/vector');\n    var BoundingRect = require('../core/BoundingRect');\n    var CMD = require('../core/PathProxy').CMD;\n    var colorTool = require('../tool/color');\n    var textContain = require('../contain/text');\n    var RectText = require('../graphic/mixin/RectText');\n    var Displayable = require('../graphic/Displayable');\n    var ZImage = require('../graphic/Image');\n    var Text = require('../graphic/Text');\n    var Path = require('../graphic/Path');\n\n    var Gradient = require('../graphic/Gradient');\n\n    var vmlCore = require('./core');\n\n    var round = Math.round;\n    var sqrt = Math.sqrt;\n    var abs = Math.abs;\n    var cos = Math.cos;\n    var sin = Math.sin;\n    var mathMax = Math.max;\n\n    var applyTransform = vec2.applyTransform;\n\n    var comma = ',';\n    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\n    var Z = 21600;\n    var Z2 = Z / 2;\n\n    var ZLEVEL_BASE = 100000;\n    var Z_BASE = 1000;\n\n    var initRootElStyle = function (el) {\n        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n        el.coordsize = Z + ','  + Z;\n        el.coordorigin = '0,0';\n    };\n\n    var encodeHtmlAttribute = function (s) {\n        return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n    };\n\n    var rgb2Str = function (r, g, b) {\n        return 'rgb(' + [r, g, b].join(',') + ')';\n    };\n\n    var append = function (parent, child) {\n        if (child && parent && child.parentNode !== parent) {\n            parent.appendChild(child);\n        }\n    };\n\n    var remove = function (parent, child) {\n        if (child && parent && child.parentNode === parent) {\n            parent.removeChild(child);\n        }\n    };\n\n    var getZIndex = function (zlevel, z, z2) {\n        // z  [0, 1000]\n        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n    };\n\n    var parsePercent = function (value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    };\n\n    /***************************************************\n     * PATH\n     **************************************************/\n\n    var setColorAndOpacity = function (el, color, opacity) {\n        var colorArr = colorTool.parse(color);\n        opacity = +opacity;\n        if (isNaN(opacity)) {\n            opacity = 1;\n        }\n        if (colorArr) {\n            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n            el.opacity = opacity * colorArr[3];\n        }\n    };\n\n    var getColorAndAlpha = function (color) {\n        var colorArr = colorTool.parse(color);\n        return [\n            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),\n            colorArr[3]\n        ];\n    };\n\n    var updateFillNode = function (el, style, zrEl) {\n        // TODO pattern\n        var fill = style.fill;\n        if (fill != null) {\n            // Modified from excanvas\n            if (fill instanceof Gradient) {\n                var gradientType;\n                var angle = 0;\n                var focus = [0, 0];\n                // additional offset\n                var shift = 0;\n                // scale factor for offset\n                var expansion = 1;\n                var rect = zrEl.getBoundingRect();\n                var rectWidth = rect.width;\n                var rectHeight = rect.height;\n                if (fill.type === 'linear') {\n                    gradientType = 'gradient';\n                    var transform = zrEl.transform;\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                        applyTransform(p1, p1, transform);\n                    }\n                    var dx = p1[0] - p0[0];\n                    var dy = p1[1] - p0[1];\n                    angle = Math.atan2(dx, dy) * 180 / Math.PI;\n                    // The angle should be a non-negative number.\n                    if (angle < 0) {\n                        angle += 360;\n                    }\n\n                    // Very small angles produce an unexpected result because they are\n                    // converted to a scientific notation string.\n                    if (angle < 1e-6) {\n                        angle = 0;\n                    }\n                }\n                else {\n                    gradientType = 'gradientradial';\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var transform = zrEl.transform;\n                    var scale = zrEl.scale;\n                    var width = rectWidth;\n                    var height = rectHeight;\n                    focus = [\n                        // Percent in bounding rect\n                        (p0[0] - rect.x) / width,\n                        (p0[1] - rect.y) / height\n                    ];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                    }\n\n                    width /= scale[0] * Z;\n                    height /= scale[1] * Z;\n                    var dimension = mathMax(width, height);\n                    shift = 2 * 0 / dimension;\n                    expansion = 2 * fill.r / dimension - shift;\n                }\n\n                // We need to sort the color stops in ascending order by offset,\n                // otherwise IE won't interpret it correctly.\n                var stops = fill.colorStops.slice();\n                stops.sort(function(cs1, cs2) {\n                    return cs1.offset - cs2.offset;\n                });\n\n                var length = stops.length;\n                // Color and alpha list of first and last stop\n                var colorAndAlphaList = [];\n                var colors = [];\n                for (var i = 0; i < length; i++) {\n                    var stop = stops[i];\n                    var colorAndAlpha = getColorAndAlpha(stop.color);\n                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n                    if (i === 0 || i === length - 1) {\n                        colorAndAlphaList.push(colorAndAlpha);\n                    }\n                }\n\n                if (length >= 2) {\n                    var color1 = colorAndAlphaList[0][0];\n                    var color2 = colorAndAlphaList[1][0];\n                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\n                    el.type = gradientType;\n                    el.method = 'none';\n                    el.focus = '100%';\n                    el.angle = angle;\n                    el.color = color1;\n                    el.color2 = color2;\n                    el.colors = colors.join(',');\n                    // When colors attribute is used, the meanings of opacity and o:opacity2\n                    // are reversed.\n                    el.opacity = opacity2;\n                    // FIXME g_o_:opacity ?\n                    el.opacity2 = opacity1;\n                }\n                if (gradientType === 'radial') {\n                    el.focusposition = focus.join(',');\n                }\n            }\n            else {\n                // FIXME Change from Gradient fill to color fill\n                setColorAndOpacity(el, fill, style.opacity);\n            }\n        }\n    };\n\n    var updateStrokeNode = function (el, style) {\n        // if (style.lineJoin != null) {\n        //     el.joinstyle = style.lineJoin;\n        // }\n        // if (style.miterLimit != null) {\n        //     el.miterlimit = style.miterLimit * Z;\n        // }\n        // if (style.lineCap != null) {\n        //     el.endcap = style.lineCap;\n        // }\n        if (style.lineDash != null) {\n            el.dashstyle = style.lineDash.join(' ');\n        }\n        if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n            setColorAndOpacity(el, style.stroke, style.opacity);\n        }\n    };\n\n    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n        var isFill = type == 'fill';\n        var el = vmlEl.getElementsByTagName(type)[0];\n        // Stroke must have lineWidth\n        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';\n            // FIXME Remove before updating, or set `colors` will throw error\n            if (style[type] instanceof Gradient) {\n                remove(vmlEl, el);\n            }\n            if (!el) {\n                el = vmlCore.createNode(type);\n            }\n\n            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n            append(vmlEl, el);\n        }\n        else {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n            remove(vmlEl, el);\n        }\n    };\n\n    var points = [[], [], []];\n    var pathDataToString = function (data, m) {\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        var str = [];\n        var nPoint;\n        var cmdStr;\n        var cmd;\n        var i;\n        var xi;\n        var yi;\n        for (i = 0; i < data.length;) {\n            cmd = data[i++];\n            cmdStr = '';\n            nPoint = 0;\n            switch (cmd) {\n                case M:\n                    cmdStr = ' m ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points[0][0] = xi;\n                    points[0][1] = yi;\n                    break;\n                case L:\n                    cmdStr = ' l ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points[0][0] = xi;\n                    points[0][1] = yi;\n                    break;\n                case Q:\n                case C:\n                    cmdStr = ' c ';\n                    nPoint = 3;\n                    var x1 = data[i++];\n                    var y1 = data[i++];\n                    var x2 = data[i++];\n                    var y2 = data[i++];\n                    var x3;\n                    var y3;\n                    if (cmd === Q) {\n                        // Convert quadratic to cubic using degree elevation\n                        x3 = x2;\n                        y3 = y2;\n                        x2 = (x2 + 2 * x1) / 3;\n                        y2 = (y2 + 2 * y1) / 3;\n                        x1 = (xi + 2 * x1) / 3;\n                        y1 = (yi + 2 * y1) / 3;\n                    }\n                    else {\n                        x3 = data[i++];\n                        y3 = data[i++];\n                    }\n                    points[0][0] = x1;\n                    points[0][1] = y1;\n                    points[1][0] = x2;\n                    points[1][1] = y2;\n                    points[2][0] = x3;\n                    points[2][1] = y3;\n\n                    xi = x3;\n                    yi = y3;\n                    break;\n                case A:\n                    var x = 0;\n                    var y = 0;\n                    var sx = 1;\n                    var sy = 1;\n                    var angle = 0;\n                    if (m) {\n                        // Extract SRT from matrix\n                        x = m[4];\n                        y = m[5];\n                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n                        angle = Math.atan2(-m[1] / sy, m[0] / sx);\n                    }\n\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++] + angle;\n                    var endAngle = data[i++] + startAngle + angle;\n                    // FIXME\n                    // var psi = data[i++];\n                    i++;\n                    var clockwise = data[i++];\n\n                    var x0 = cx + cos(startAngle) * rx;\n                    var y0 = cy + sin(startAngle) * ry;\n\n                    var x1 = cx + cos(endAngle) * rx;\n                    var y1 = cy + sin(endAngle) * ry;\n\n                    var type = clockwise ? ' wa ' : ' at ';\n                    if (Math.abs(x0 - x1) < 1e-10) {\n                        // IE won't render arches drawn counter clockwise if x0 == x1.\n                        if (Math.abs(endAngle - startAngle) > 1e-2) {\n                            // Offset x0 by 1/80 of a pixel. Use something\n                            // that can be represented in binary\n                            if (clockwise) {\n                                x0 += 270 / Z;\n                            }\n                        }\n                        else {\n                            // Avoid case draw full circle\n                            if (Math.abs(y0 - cy) < 1e-10) {\n                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {\n                                    y1 -= 270 / Z;\n                                }\n                                else {\n                                    y1 += 270 / Z;\n                                }\n                            }\n                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {\n                                x1 += 270 / Z;\n                            }\n                            else {\n                                x1 -= 270 / Z;\n                            }\n                        }\n                    }\n                    str.push(\n                        type,\n                        round(((cx - rx) * sx + x) * Z - Z2), comma,\n                        round(((cy - ry) * sy + y) * Z - Z2), comma,\n                        round(((cx + rx) * sx + x) * Z - Z2), comma,\n                        round(((cy + ry) * sy + y) * Z - Z2), comma,\n                        round((x0 * sx + x) * Z - Z2), comma,\n                        round((y0 * sy + y) * Z - Z2), comma,\n                        round((x1 * sx + x) * Z - Z2), comma,\n                        round((y1 * sy + y) * Z - Z2)\n                    );\n\n                    xi = x1;\n                    yi = y1;\n                    break;\n                case CMD.R:\n                    var p0 = points[0];\n                    var p1 = points[1];\n                    // x0, y0\n                    p0[0] = data[i++];\n                    p0[1] = data[i++];\n                    // x1, y1\n                    p1[0] = p0[0] + data[i++];\n                    p1[1] = p0[1] + data[i++];\n\n                    if (m) {\n                        applyTransform(p0, p0, m);\n                        applyTransform(p1, p1, m);\n                    }\n\n                    p0[0] = round(p0[0] * Z - Z2);\n                    p1[0] = round(p1[0] * Z - Z2);\n                    p0[1] = round(p0[1] * Z - Z2);\n                    p1[1] = round(p1[1] * Z - Z2);\n                    str.push(\n                        // x0, y0\n                        ' m ', p0[0], comma, p0[1],\n                        // x1, y0\n                        ' l ', p1[0], comma, p0[1],\n                        // x1, y1\n                        ' l ', p1[0], comma, p1[1],\n                        // x0, y1\n                        ' l ', p0[0], comma, p1[1]\n                    );\n                    break;\n                case CMD.Z:\n                    // FIXME Update xi, yi\n                    str.push(' x ');\n            }\n\n            if (nPoint > 0) {\n                str.push(cmdStr);\n                for (var k = 0; k < nPoint; k++) {\n                    var p = points[k];\n\n                    m && applyTransform(p, p, m);\n                    //  round \n                    str.push(\n                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),\n                        k < nPoint - 1 ? comma : ''\n                    );\n                }\n            }\n        }\n\n        return str.join('');\n    };\n\n    // Rewrite the original path method\n    Path.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            vmlEl = vmlCore.createNode('shape');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        updateFillAndStroke(vmlEl, 'fill', style, this);\n        updateFillAndStroke(vmlEl, 'stroke', style, this);\n\n        var m = this.transform;\n        var needTransform = m != null;\n        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n        if (strokeEl) {\n            var lineWidth = style.lineWidth;\n            // Get the line scale.\n            // Determinant of this.m_ means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            if (needTransform && !style.strokeNoScale) {\n                var det = m[0] * m[3] - m[1] * m[2];\n                lineWidth *= sqrt(abs(det));\n            }\n            strokeEl.weight = lineWidth + 'px';\n        }\n\n        var path = this.path;\n        if (this.__dirtyPath) {\n            path.beginPath();\n            this.buildPath(path, this.shape);\n            path.toStatic();\n            this.__dirtyPath = false;\n        }\n\n        vmlEl.path = pathDataToString(path.data, this.transform);\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Path.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n        this.removeRectText(vmlRoot);\n    };\n\n    Path.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n    /***************************************************\n     * IMAGE\n     **************************************************/\n    var isImage = function (img) {\n        // FIXME img instanceof Image  img IE8 \n        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';\n        // return img instanceof Image;\n    };\n\n    // Rewrite the original path method\n    ZImage.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        var image = style.image;\n\n        // Image original width, height\n        var ow;\n        var oh;\n\n        if (isImage(image)) {\n            var src = image.src;\n            if (src === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n            else {\n                var imageRuntimeStyle = image.runtimeStyle;\n                var oldRuntimeWidth = imageRuntimeStyle.width;\n                var oldRuntimeHeight = imageRuntimeStyle.height;\n                imageRuntimeStyle.width = 'auto';\n                imageRuntimeStyle.height = 'auto';\n\n                // get the original size\n                ow = image.width;\n                oh = image.height;\n\n                // and remove overides\n                imageRuntimeStyle.width = oldRuntimeWidth;\n                imageRuntimeStyle.height = oldRuntimeHeight;\n\n                // Caching image original width, height and src\n                this._imageSrc = src;\n                this._imageWidth = ow;\n                this._imageHeight = oh;\n            }\n            image = src;\n        }\n        else {\n            if (image === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n        }\n        if (!image) {\n            return;\n        }\n\n        var x = style.x || 0;\n        var y = style.y || 0;\n\n        var dw = style.width;\n        var dh = style.height;\n\n        var sw = style.sWidth;\n        var sh = style.sHeight;\n        var sx = style.sx || 0;\n        var sy = style.sy || 0;\n\n        var hasCrop = sw && sh;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            // FIXME  group  left, top  0 \n            // vmlEl = vmlCore.createNode('group');\n            vmlEl = vmlCore.doc.createElement('div');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        var vmlElStyle = vmlEl.style;\n        var hasRotation = false;\n        var m;\n        var scaleX = 1;\n        var scaleY = 1;\n        if (this.transform) {\n            m = this.transform;\n            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\n            hasRotation = m[1] || m[2];\n        }\n        if (hasRotation) {\n            // If filters are necessary (rotation exists), create them\n            // filters are bog-slow, so only create them if abbsolutely necessary\n            // The following check doesn't account for skews (which don't exist\n            // in the canvas spec (yet) anyway.\n            // From excanvas\n            var p0 = [x, y];\n            var p1 = [x + dw, y];\n            var p2 = [x, y + dh];\n            var p3 = [x + dw, y + dh];\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n            applyTransform(p2, p2, m);\n            applyTransform(p3, p3, m);\n\n            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\n            var transformFilter = [];\n            transformFilter.push('M11=', m[0] / scaleX, comma,\n                        'M12=', m[2] / scaleY, comma,\n                        'M21=', m[1] / scaleX, comma,\n                        'M22=', m[3] / scaleY, comma,\n                        'Dx=', round(x * scaleX + m[4]), comma,\n                        'Dy=', round(y * scaleY + m[5]));\n\n            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';\n            // FIXME DXImageTransform  IE11 \n            vmlElStyle.filter = imageTransformPrefix + '.Matrix('\n                + transformFilter.join('') + ', SizingMethod=clip)';\n\n        }\n        else {\n            if (m) {\n                x = x * scaleX + m[4];\n                y = y * scaleY + m[5];\n            }\n            vmlElStyle.filter = '';\n            vmlElStyle.left = round(x) + 'px';\n            vmlElStyle.top = round(y) + 'px';\n        }\n\n        var imageEl = this._imageEl;\n        var cropEl = this._cropEl;\n\n        if (!imageEl) {\n            imageEl = vmlCore.doc.createElement('div');\n            this._imageEl = imageEl;\n        }\n        var imageELStyle = imageEl.style;\n        if (hasCrop) {\n            // Needs know image original width and height\n            if (! (ow && oh)) {\n                var tmpImage = new Image();\n                var self = this;\n                tmpImage.onload = function () {\n                    tmpImage.onload = null;\n                    ow = tmpImage.width;\n                    oh = tmpImage.height;\n                    // Adjust image width and height to fit the ratio destinationSize / sourceSize\n                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\n                    // Caching image original width, height and src\n                    self._imageWidth = ow;\n                    self._imageHeight = oh;\n                    self._imageSrc = image;\n                };\n                tmpImage.src = image;\n            }\n            else {\n                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n            }\n\n            if (! cropEl) {\n                cropEl = vmlCore.doc.createElement('div');\n                cropEl.style.overflow = 'hidden';\n                this._cropEl = cropEl;\n            }\n            var cropElStyle = cropEl.style;\n            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='\n                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';\n\n            if (! cropEl.parentNode) {\n                vmlEl.appendChild(cropEl);\n            }\n            if (imageEl.parentNode != cropEl) {\n                cropEl.appendChild(imageEl);\n            }\n        }\n        else {\n            imageELStyle.width = round(scaleX * dw) + 'px';\n            imageELStyle.height = round(scaleY * dh) + 'px';\n\n            vmlEl.appendChild(imageEl);\n\n            if (cropEl && cropEl.parentNode) {\n                vmlEl.removeChild(cropEl);\n                this._cropEl = null;\n            }\n        }\n\n        var filterStr = '';\n        var alpha = style.opacity;\n        if (alpha < 1) {\n            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n        }\n        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\n        imageELStyle.filter = filterStr;\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n    };\n\n    ZImage.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n\n        this._vmlEl = null;\n        this._cropEl = null;\n        this._imageEl = null;\n\n        this.removeRectText(vmlRoot);\n    };\n\n    ZImage.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n\n    /***************************************************\n     * TEXT\n     **************************************************/\n\n    var DEFAULT_STYLE_NORMAL = 'normal';\n\n    var fontStyleCache = {};\n    var fontStyleCacheCount = 0;\n    var MAX_FONT_CACHE_SIZE = 100;\n    var fontEl = document.createElement('div');\n\n    var getFontStyle = function (fontString) {\n        var fontStyle = fontStyleCache[fontString];\n        if (!fontStyle) {\n            // Clear cache\n            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n                fontStyleCacheCount = 0;\n                fontStyleCache = {};\n            }\n\n            var style = fontEl.style;\n            var fontFamily;\n            try {\n                style.font = fontString;\n                fontFamily = style.fontFamily.split(',')[0];\n            }\n            catch (e) {\n            }\n\n            fontStyle = {\n                style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n                size: parseFloat(style.fontSize || 12) | 0,\n                family: fontFamily || 'Microsoft YaHei'\n            };\n\n            fontStyleCache[fontString] = fontStyle;\n            fontStyleCacheCount++;\n        }\n        return fontStyle;\n    };\n\n    var textMeasureEl;\n    // Overwrite measure text method\n    textContain.measureText = function (text, textFont) {\n        var doc = vmlCore.doc;\n        if (!textMeasureEl) {\n            textMeasureEl = doc.createElement('div');\n            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'\n                + 'padding:0;margin:0;border:none;white-space:pre;';\n            vmlCore.doc.body.appendChild(textMeasureEl);\n        }\n\n        try {\n            textMeasureEl.style.font = textFont;\n        } catch (ex) {\n            // Ignore failures to set to invalid font.\n        }\n        textMeasureEl.innerHTML = '';\n        // Don't use innerHTML or innerText because they allow markup/whitespace.\n        textMeasureEl.appendChild(doc.createTextNode(text));\n        return {\n            width: textMeasureEl.offsetWidth\n        };\n    };\n\n    var tmpRect = new BoundingRect();\n\n    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\n        var style = this.style;\n        var text = style.text;\n        // Convert to string\n        text != null && (text += '');\n        if (!text) {\n            return;\n        }\n\n        var x;\n        var y;\n        var align = style.textAlign;\n        var fontStyle = getFontStyle(style.textFont);\n        // FIXME encodeHtmlAttribute ?\n        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '\n            + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\n        var baseline = style.textBaseline;\n        var verticalAlign = style.textVerticalAlign;\n\n        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n        // Transform rect to view space\n        var m = this.transform;\n        // Ignore transform for text in other element\n        if (m && !fromTextEl) {\n            tmpRect.copy(rect);\n            tmpRect.applyTransform(m);\n            rect = tmpRect;\n        }\n\n        if (!fromTextEl) {\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n\n                align = align || 'left';\n                baseline = baseline || 'top';\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n        }\n        else {\n            x = rect.x;\n            y = rect.y;\n        }\n        if (verticalAlign) {\n            switch (verticalAlign) {\n                case 'middle':\n                    y -= textRect.height / 2;\n                    break;\n                case 'bottom':\n                    y -= textRect.height;\n                    break;\n                // 'top'\n            }\n            // Ignore baseline\n            baseline = 'top';\n        }\n\n        var fontSize = fontStyle.size;\n        // 1.75 is an arbitrary number, as there is no info about the text baseline\n        switch (baseline) {\n            case 'hanging':\n            case 'top':\n                y += fontSize / 1.75;\n                break;\n            case 'middle':\n                break;\n            default:\n            // case null:\n            // case 'alphabetic':\n            // case 'ideographic':\n            // case 'bottom':\n                y -= fontSize / 2.25;\n                break;\n        }\n        switch (align) {\n            case 'left':\n                break;\n            case 'center':\n                x -= textRect.width / 2;\n                break;\n            case 'right':\n                x -= textRect.width;\n                break;\n            // case 'end':\n                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n                // break;\n            // case 'start':\n                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n                // break;\n            // default:\n            //     align = 'left';\n        }\n\n        var createNode = vmlCore.createNode;\n\n        var textVmlEl = this._textVmlEl;\n        var pathEl;\n        var textPathEl;\n        var skewEl;\n        if (!textVmlEl) {\n            textVmlEl = createNode('line');\n            pathEl = createNode('path');\n            textPathEl = createNode('textpath');\n            skewEl = createNode('skew');\n\n            // FIXME Why here is not cammel case\n            // Align 'center' seems wrong\n            textPathEl.style['v-text-align'] = 'left';\n\n            initRootElStyle(textVmlEl);\n\n            pathEl.textpathok = true;\n            textPathEl.on = true;\n\n            textVmlEl.from = '0 0';\n            textVmlEl.to = '1000 0.05';\n\n            append(textVmlEl, skewEl);\n            append(textVmlEl, pathEl);\n            append(textVmlEl, textPathEl);\n\n            this._textVmlEl = textVmlEl;\n        }\n        else {\n            //  appendChild \n            skewEl = textVmlEl.firstChild;\n            pathEl = skewEl.nextSibling;\n            textPathEl = pathEl.nextSibling;\n        }\n\n        var coords = [x, y];\n        var textVmlElStyle = textVmlEl.style;\n        // Ignore transform for text in other element\n        if (m && fromTextEl) {\n            applyTransform(coords, coords, m);\n\n            skewEl.on = true;\n\n            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +\n            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';\n\n            // Text position\n            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);\n            // Left top point as origin\n            skewEl.origin = '0 0';\n\n            textVmlElStyle.left = '0px';\n            textVmlElStyle.top = '0px';\n        }\n        else {\n            skewEl.on = false;\n            textVmlElStyle.left = round(x) + 'px';\n            textVmlElStyle.top = round(y) + 'px';\n        }\n\n        textPathEl.string = encodeHtmlAttribute(text);\n        // TODO\n        try {\n            textPathEl.style.font = font;\n        }\n        // Error font format\n        catch (e) {}\n\n        updateFillAndStroke(textVmlEl, 'fill', {\n            fill: fromTextEl ? style.fill : style.textFill,\n            opacity: style.opacity\n        }, this);\n        updateFillAndStroke(textVmlEl, 'stroke', {\n            stroke: fromTextEl ? style.stroke : style.textStroke,\n            opacity: style.opacity,\n            lineDash: style.lineDash\n        }, this);\n\n        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Attached to root\n        append(vmlRoot, textVmlEl);\n    };\n\n    var removeRectText = function (vmlRoot) {\n        remove(vmlRoot, this._textVmlEl);\n        this._textVmlEl = null;\n    };\n\n    var appendRectText = function (vmlRoot) {\n        append(vmlRoot, this._textVmlEl);\n    };\n\n    var list = [RectText, Displayable, ZImage, Path, Text];\n\n    // In case Displayable has been mixed in RectText\n    for (var i = 0; i < list.length; i++) {\n        var proto = list[i].prototype;\n        proto.drawRectText = drawRectText;\n        proto.removeRectText = removeRectText;\n        proto.appendRectText = appendRectText;\n    }\n\n    Text.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, {\n                x: style.x || 0, y: style.y || 0,\n                width: 0, height: 0\n            }, this.getBoundingRect(), true);\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Text.prototype.onRemove = function (vmlRoot) {\n        this.removeRectText(vmlRoot);\n    };\n\n    Text.prototype.onAdd = function (vmlRoot) {\n        this.appendRectText(vmlRoot);\n    };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/graphic.js\n// module id = 219\n// module chunks = 0 1","\n    require('./graphic');\n    require('../zrender').registerPainter('vml', require('./Painter'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/vml/vml.js\n// module id = 220\n// module chunks = 0 1"],"sourceRoot":""}