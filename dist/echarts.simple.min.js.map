{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6*","webpack:///echarts.simple.min.js","webpack:///webpack/bootstrap e2f5d11b7ea9dedb1522?96a2*","webpack:///./index.simple.js","webpack:///./~/zrender/lib/core/util.js?10f4*","webpack:///./lib/echarts.js?e6e0*","webpack:///./lib/util/graphic.js?9184*","webpack:///./lib/util/number.js?f4a1*","webpack:///./~/zrender/lib/core/vector.js?6654*","webpack:///./~/zrender/lib/graphic/Path.js?c119*","webpack:///./lib/util/model.js?e40b*","webpack:///./~/zrender/lib/core/BoundingRect.js?76f6*","webpack:///./lib/util/format.js?a0a6*","webpack:///./lib/model/Model.js?c24b*","webpack:///./~/zrender/lib/core/env.js?9ccc*","webpack:///./lib/model/Component.js?4968*","webpack:///./lib/util/layout.js?fd92*","webpack:///./lib/data/List.js?a3f0*","webpack:///./lib/model/Series.js?7862*","webpack:///./~/zrender/lib/contain/text.js?3a43*","webpack:///./~/zrender/lib/core/curve.js?9511*","webpack:///./~/zrender/lib/tool/color.js?284f*","webpack:///./~/zrender/lib/core/matrix.js?97a2*","webpack:///./~/zrender/lib/mixin/Eventful.js?223b*","webpack:///./lib/util/clazz.js?7f2c*","webpack:///./lib/coord/axisHelper.js?db6e*","webpack:///./lib/CoordinateSystem.js?d208*","webpack:///./~/zrender/lib/core/event.js?24ff*","webpack:///./lib/util/symbol.js?714b*","webpack:///./lib/view/Chart.js?81ad*","webpack:///./~/zrender/lib/core/PathProxy.js?69e9*","webpack:///./~/zrender/lib/graphic/Gradient.js?5165*","webpack:///./lib/data/helper/completeDimensions.js?9dc8*","webpack:///./lib/model/mixin/makeStyleMapper.js?ad94*","webpack:///./lib/scale/Scale.js?fcd6*","webpack:///./~/zrender/lib/config.js?2861*","webpack:///./~/zrender/lib/container/Group.js?8d57*","webpack:///./lib/chart/helper/createListFromArray.js?a2b3*","webpack:///./lib/component/grid.js?6810*","webpack:///./~/zrender/lib/graphic/Displayable.js?5c45*","webpack:///./lib/scale/Interval.js?a2bb*","webpack:///./lib/chart/helper/SymbolDraw.js?9ca8*","webpack:///./lib/coord/Axis.js?0aab*","webpack:///./lib/util/component.js?aafc*","webpack:///./~/zrender/lib/core/timsort.js?0a74*","webpack:///./lib/data/DataDiffer.js?84f6*","webpack:///./lib/visual/symbol.js?c9ef*","webpack:///./~/zrender/lib/core/log.js?26a2*","webpack:///./~/zrender/lib/graphic/Image.js?bf1b*","webpack:///./lib/chart/helper/Symbol.js?4e27*","webpack:///./lib/component/axis/AxisBuilder.js?0a10*","webpack:///./lib/coord/axisModelCommonMixin.js?e4d6*","webpack:///./lib/coord/axisModelCreator.js?bf3f*","webpack:///./lib/coord/cartesian/AxisModel.js?818f*","webpack:///./lib/coord/cartesian/Grid.js?05e4*","webpack:///./lib/layout/points.js?b5cd*","webpack:///./lib/model/mixin/colorPalette.js?ee06*","webpack:///./lib/view/Component.js?a404*","webpack:///./~/zrender/lib/Element.js?325b*","webpack:///./~/zrender/lib/animation/Animator.js?d2b9*","webpack:///./~/zrender/lib/animation/requestAnimationFrame.js?6d88*","webpack:///./~/zrender/lib/contain/util.js?0031*","webpack:///./~/zrender/lib/core/guid.js?f0e4*","webpack:///./~/zrender/lib/graphic/Pattern.js?a97e*","webpack:///./~/zrender/lib/graphic/Style.js?22d9*","webpack:///./~/zrender/lib/graphic/helper/poly.js?788c*","webpack:///./lib/component/helper/selectableMixin.js?6edb*","webpack:///./lib/processor/dataFilter.js?190d*","webpack:///./lib/visual/dataColor.js?8fc7*","webpack:///./~/zrender/lib/core/bbox.js?1b56*","webpack:///./~/zrender/lib/graphic/Text.js?3244*","webpack:///./~/zrender/lib/graphic/mixin/RectText.js?94ea*","webpack:///./~/zrender/lib/zrender.js?5dcd*","webpack:///./lib/action/createDataSelectAction.js?6a00*","webpack:///./lib/coord/axisDefault.js?767d*","webpack:///./lib/coord/axisModelZoomMixin.js?6df9*","webpack:///./~/zrender/lib/contain/line.js?4326*","webpack:///./~/zrender/lib/contain/quadratic.js?f589*","webpack:///./~/zrender/lib/contain/windingLine.js?625a*","webpack:///./~/zrender/lib/graphic/LinearGradient.js?4250*","webpack:///./~/zrender/lib/mixin/Transformable.js?f61b*","webpack:///./lib/ExtensionAPI.js?024b*","webpack:///./lib/chart/bar.js?a725*","webpack:///./lib/chart/bar/BarSeries.js?3b85*","webpack:///./lib/chart/bar/BarView.js?9f5d*","webpack:///./lib/chart/bar/barItemStyle.js?da00*","webpack:///./lib/chart/line.js?8f10*","webpack:///./lib/chart/line/LineSeries.js?c09a*","webpack:///./lib/chart/line/LineView.js?c76c*","webpack:///./lib/chart/line/lineAnimationDiff.js?ed41*","webpack:///./lib/chart/line/poly.js?c10a*","webpack:///./lib/chart/pie.js?a050*","webpack:///./lib/chart/pie/PieSeries.js?2c87*","webpack:///./lib/chart/pie/PieView.js?6515*","webpack:///./lib/chart/pie/labelLayout.js?c38b*","webpack:///./lib/chart/pie/pieLayout.js?ebc4*","webpack:///./lib/component/axis.js?7b6c*","webpack:///./lib/component/axis/AxisView.js?a70c*","webpack:///./lib/coord/cartesian/Axis2D.js?5107*","webpack:///./lib/coord/cartesian/Cartesian.js?b907*","webpack:///./lib/coord/cartesian/Cartesian2D.js?c5a5*","webpack:///./lib/coord/cartesian/GridModel.js?9110*","webpack:///./lib/coord/cartesian/axisLabelInterval.js?cb6f*","webpack:///./lib/layout/barGrid.js?6b5f*","webpack:///./lib/loading/default.js?7c3a*","webpack:///./lib/model/Global.js?1c6f*","webpack:///./lib/model/OptionManager.js?ce4b*","webpack:///./lib/model/globalDefault.js?507f*","webpack:///./lib/model/mixin/areaStyle.js?2e6d*","webpack:///./lib/model/mixin/boxLayout.js?3478*","webpack:///./lib/model/mixin/itemStyle.js?3f71*","webpack:///./lib/model/mixin/lineStyle.js?0fa2*","webpack:///./lib/model/mixin/textStyle.js?140e*","webpack:///./lib/preprocessor/backwardCompat.js?0937*","webpack:///./lib/preprocessor/helper/compatStyle.js?e728*","webpack:///./lib/processor/dataSample.js?d230*","webpack:///./lib/scale/Log.js?26a9*","webpack:///./lib/scale/Ordinal.js?4c4b*","webpack:///./lib/scale/Time.js?495f*","webpack:///./lib/visual/seriesColor.js?1cd6*","webpack:///./~/zrender/lib/Handler.js?fbeb*","webpack:///./~/zrender/lib/Layer.js?f586*","webpack:///./~/zrender/lib/Painter.js?ee99*","webpack:///./~/zrender/lib/Storage.js?7e93*","webpack:///./~/zrender/lib/animation/Animation.js?8743*","webpack:///./~/zrender/lib/animation/Clip.js?fef9*","webpack:///./~/zrender/lib/animation/easing.js?64b6*","webpack:///./~/zrender/lib/contain/arc.js?7367*","webpack:///./~/zrender/lib/contain/cubic.js?b90e*","webpack:///./~/zrender/lib/contain/path.js?2e7f*","webpack:///./~/zrender/lib/core/GestureMgr.js?00fd*","webpack:///./~/zrender/lib/core/LRU.js?018e*","webpack:///./~/zrender/lib/dom/HandlerProxy.js?2fc7*","webpack:///./~/zrender/lib/graphic/CompoundPath.js?8636*","webpack:///./~/zrender/lib/graphic/RadialGradient.js?895e*","webpack:///./~/zrender/lib/graphic/helper/roundRect.js?418d*","webpack:///./~/zrender/lib/graphic/helper/smoothBezier.js?2713*","webpack:///./~/zrender/lib/graphic/helper/smoothSpline.js?a17c*","webpack:///./~/zrender/lib/graphic/shape/Arc.js?2994*","webpack:///./~/zrender/lib/graphic/shape/BezierCurve.js?f5c4*","webpack:///./~/zrender/lib/graphic/shape/Circle.js?076e*","webpack:///./~/zrender/lib/graphic/shape/Line.js?7728*","webpack:///./~/zrender/lib/graphic/shape/Polygon.js?d37d*","webpack:///./~/zrender/lib/graphic/shape/Polyline.js?3cdb*","webpack:///./~/zrender/lib/graphic/shape/Rect.js?3b3d*","webpack:///./~/zrender/lib/graphic/shape/Ring.js?b71c*","webpack:///./~/zrender/lib/graphic/shape/Sector.js?9767*","webpack:///./~/zrender/lib/mixin/Animatable.js?35cb*","webpack:///./~/zrender/lib/mixin/Draggable.js?fbca*","webpack:///./~/zrender/lib/tool/path.js?dc4b*","webpack:///./~/zrender/lib/tool/transformPath.js?ddb2*"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","clone","source","result","typeStr","objToString","i","len","length","TYPED_ARRAY","constructor","from","BUILTIN_OBJECT","isDom","key","hasOwnProperty","merge","target","overwrite","isObject","targetProp","sourceProp","isArray","isBuildInObject","mergeAll","targetAndSources","extend","defaults","overlay","createCanvas","document","createElement","getContext","_ctx","util","indexOf","array","value","inherits","clazz","baseClazz","F","clazzPrototype","prototype","prop","superClass","mixin","isArrayLike","data","each","obj","cb","context","forEach","nativeForEach","map","nativeMap","push","reduce","memo","nativeReduce","filter","nativeFilter","find","bind","func","args","nativeSlice","arguments","apply","concat","curry","isFunction","isString","type","nodeType","ownerDocument","retrieve","values","slice","Function","assert","condition","message","Error","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","Object","toString","arrayProto","Array","noop","createRegisterEventWithLowercaseName","method","eventName","handler","toLowerCase","Eventful","MessageCenter","ECharts","dom","theme","opts","prioritySortFunc","a","b","prio","themeStorage","group","_dom","_zr","zrender","init","renderer","devicePixelRatio","width","height","_theme","zrUtil","_chartsViews","_chartsMap","_componentsViews","_componentsMap","_api","ExtensionAPI","_coordSysMgr","CoordinateSystemManager","_messageCenter","_initEvents","resize","_pendingActions","timsort","visualFuncs","dataProcessorFuncs","animation","on","_onframe","doConvertPixel","methodName","finder","ecModel","_model","coordSysList","getCoordinateSystems","modelUtil","parseFinder","coordSys","toggleHighlight","payload","eachComponent","mainType","query","seriesModel","index","chartView","__viewId","__alive","invokeUpdateMethod","api","component","componentModel","__model","updateZ","eachSeries","idx","chart","updateProgressiveAndBlend","updateHoverLayerStatus","prepareView","isComponent","viewList","viewMap","zr","componentType","model","viewId","view","classType","ComponentModel","parseClassType","Clazz","ComponentView","getClass","main","sub","ChartView","add","__id","remove","dispose","splice","processData","process","stackSeriesData","stackedDataMap","series","stack","get","getData","previousStack","stackedOn","doLayout","visual","isLayout","doVisualEncoding","clearColorPalette","doRender","componentView","render","silent","storage","elCount","traverse","el","isGroup","env","node","useHoverLayer","ignore","frameDrawNum","needProgressive","progressive","Math","floor","stopAnimation","blendMode","setStyle","z","zlevel","enableConnect","updateConnectedChartsStatus","charts","status","otherChart","STATUS_KEY","STATUS_PENDING","STATUS_UPDATING","STATUS_UPDATED","eventActionMap","actionType","eventType","event","connectedGroups","action","makeActionFromEvent","otherCharts","instances","dispatchAction","GlobalModel","OptionManager","SeriesModel","graphic","colorTool","PRIORITY_PROCESSOR_FILTER","PRIORITY_PROCESSOR_STATISTIC","PRIORITY_VISUAL_LAYOUT","PRIORITY_VISUAL_GLOBAL","PRIORITY_VISUAL_CHART","PRIORITY_VISUAL_COMPONENT","PRIORITY_VISUAL_BRUSH","IN_MAIN_PROCESS","HAS_GRADIENT_OR_PATTERN_BG","OPTION_UPDATED","off","one","echartsProto","updateMethods","prepareAndUpdate","getDom","getZr","setOption","option","notMerge","lazyUpdate","optionManager","optionPreprocessorFuncs","refreshImmediately","_flushPendingActions","setTheme","console","log","getModel","getOption","getWidth","getHeight","getRenderedCanvas","canvasSupported","pixelRatio","backgroundColor","list","getDisplayList","painter","getDataURL","excludeComponents","excludesComponentViews","self","url","toDataURL","getConnectedDataURL","groupId","mathMin","min","mathMax","max","MAX_NUMBER","Infinity","left","top","right","bottom","canvasList","dpr","canvas","boundingRect","getBoundingClientRect","targetCanvas","item","img","Image","style","x","y","image","convertToPixel","convertFromPixel","containPixel","models","coordinateSystem","containPoint","getVisual","visualType","defaultMainType","dataIndexInside","indexOfRawIndex","dataIndex","getItemVisual","update","coordSysMgr","restoreData","create","isSingleCanvas","configLayer","clearColor","colorArr","parse","stringify","colorStops","background","updateView","clearAllVisual","updateVisual","updateLayout","highlight","downplay","optionChanged","resetOption","_loadingFX","showLoading","name","cfg","hideLoading","loadingEffects","eventObj","actionWrap","actions","actionInfo","updateMethod","payloads","batched","batch","eventObjBatch","isHighlightOrDownplay","batchItem","trigger","pendingActions","shift","MOUSE_EVENT_NAMES","eveName","e","params","dataModel","getSeriesByIndex","seriesIndex","getDataParams","dataType","eventData","isDisposed","_disposed","clear","idBase","Date","groupIdBase","DOM_ATTRIBUTE_KEY","echarts","version","dependencies","setAttribute","connect","disConnect","getInstanceByDom","getAttribute","getInstanceById","registerTheme","registerPreprocessor","preprocessorFunc","registerProcessor","priority","processorFunc","registerAction","registerCoordinateSystem","CoordinateSystem","register","registerLayout","layoutFunc","registerVisual","visualFunc","registerLoading","loadingFx","extendComponentModel","extendComponentView","extendSeriesModel","replace","extendChartView","setCanvasCreator","creator","List","Model","number","format","matrix","vector","color","PRIORITY","PROCESSOR","FILTER","STATISTIC","VISUAL","LAYOUT","GLOBAL","CHART","COMPONENT","BRUSH","hasFillOrStroke","fillOrStroke","liftColor","lift","cacheElementStl","__hoverStlDirty","stroke","fill","hoverStyle","__hoverStl","normalStyle","__normalStl","doSingleEnterHover","__isHover","__zr","addHover","z2","doSingleLeaveHover","normalStl","removeHover","doEnterHover","child","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","props","animatableModel","animationEnabled","ifEnableAnimation","getShallow","postfix","duration","animationEasing","animationDelay","animateTo","attr","pathTool","round","Path","Group","Text","Circle","Sector","Ring","Polygon","Polyline","Rect","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","BoundingRect","extendShape","extendPath","pathData","extendFromString","makePath","rect","layout","path","createFromString","getBoundingRect","aspect","cx","cy","resizePath","mergePath","applyTransform","pathRect","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","shape","lineWidth","x1","x2","y1","y2","subPixelOptimizeRect","originX","originY","originWidth","originHeight","position","positiveOrNegative","doubledPosition","setHoverStyle","setText","textStyle","labelModel","labelPosition","labelColor","textStyleModel","textDistance","textFont","getFont","textPosition","textFill","getTextColor","updateProps","initProps","getTransform","ancestor","mat","identity","mul","getLocalTransform","parent","vertex","transform","invert","transformDirection","direction","hBase","abs","vBase","groupTransition","g1","g2","getElMap","g","elMap","anid","getAnimatableProps","rotation","elMap1","oldEl","newProp","_trim","str","RADIAN_EPSILON","linearMap","val","domain","range","clamp","subDomain","subRange","parsePercent","percent","all","match","parseFloat","NaN","precision","toFixed","asc","arr","sort","getPrecision","isNaN","count","getPrecisionSafe","dotIndex","getPixelPrecision","dataExtent","pixelExtent","LN10","dataQuantity","sizeQuantity","MAX_SAFE_INTEGER","remRadian","radian","pi2","PI","isRadianAroundZero","parseDate","ret","quantity","pow","nice","nf","exp10","f","ArrayCtor","Float32Array","out","copy","v","set","v1","v2","scaleAndAdd","sqrt","lenSquare","div","dot","scale","s","normalize","d","distance","distanceSquare","negate","lerp","t","lengthSquare","dist","distSquare","Displayable","PathProxy","pathContain","Pattern","getCanvasPattern","__dirtyPath","strokeContainThreshold","brush","ctx","prevEl","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","__dirty","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","setScale","beginPath","setLineDashOffset","buildPath","rebuildPath","restoreTransform","text","drawRectText","shapeCfg","inBundle","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","w","lineScale","strokeNoScale","getLineScale","contain","localPos","transformCoordToLocal","containStroke","dirty","dirtyPath","refresh","__clipTarget","animateShape","loop","animate","attrKV","setShape","Sub","extendFrom","defaultShape","thisShape","has","formatUtil","nubmerUtil","normalizeToArray","defaultEmphasis","opt","subOpts","emphasisOpt","emphasis","normalOpt","normal","subOptName","LABEL_OPTIONS","getDataItemValue","dataItem","isDataItemOption","converDataValue","dimInfo","dimType","isFinite","createDataFormatModel","dataFormatMixin","subType","seriesName","rawValue","getRawValue","rawDataIndex","getRawIndex","getName","itemOpt","getRawDataItem","componentSubType","seriesType","$vars","getFormattedLabel","dimIndex","itemModel","getItemModel","formatter","formatTpl","formatTooltip","mappingToExists","exists","newCptOptions","exist","cptOption","isIdInner","compressBatches","batchA","batchB","makeMap","sourceBatch","otherMap","seriesId","dataIndices","otherDataIndices","j","lenj","mapToArray","isData","mapA","mapB","queryDataIndex","indexOfName","parsedKey","queryType","queryParam","queryComponents","vec2","v2ApplyTransform","union","other","lt","rb","lb","rt","maxX","maxY","sx","sy","translate","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","numberUtil","textContain","addCommas","split","toCamelCase","group1","toUpperCase","normalizeCssArray","encodeHTML","String","TPL_VAR_ALIAS","wrapVar","varName","seriesIdx","tpl","paramsList","seriesLen","alias","k","s2d","formatTime","date","getFullYear","M","getMonth","getDate","h","getHours","getMinutes","getSeconds","capitalFirst","charAt","substr","truncateText","parentModel","clazzUtil","mergeOption","ignoreParent","thisParentModel","isEmpty","Ctor","setReadOnly","properties","enableClassExtend","detect","ua","os","browser","firefox","ie","edge","weChat","test","touchEventsSupported","window","pointerEventsSupported","navigator","userAgent","getDependencies","deps","getClassesByMainType","arrayPush","componentUtil","componentIndex","defaultOption","dependentModels","uid","layoutMode","$constructor","extraOpt","getUID","mergeDefaultAndTheme","inputPositionParams","getLayoutParams","themeModel","getTheme","getDefaultOption","mergeLayoutParam","optionUpdated","newCptOption","isInit","optList","Class","__defaultOption","getReferringComponents","enableClassManagement","registerWhenExtend","enableSubTypeDefaulter","enableTopologicalTravel","boxLayout","orient","gap","maxWidth","maxHeight","currentLineMaxSize","eachChild","nextX","nextY","nextChild","childAt","nextChildRect","moveX","newline","moveY","LOCATION_PARAMS","box","vbox","hbox","getAvailableSize","positionInfo","containerRect","margin","containerWidth","containerHeight","getLayoutRect","verticalMargin","horizontalMargin","positionGroup","groupRect","targetOption","newOption","names","newParams","newValueCount","merged","mergedValueCount","enoughParamNumber","ignoreSize","hasProp","hasValue","hNames","vNames","hResult","vResult","copyLayoutParams","global","normalizeDimensions","dimensions","cloneListForMapAndSample","original","excludeDimensions","allDimensions","getDimensionInfo","hostModel","transferProperties","_storage","originalStorage","dim","dimStore","UNDEFINED","globalObj","Float64Array","Int32Array","dataCtors","float","int","ordinal","time","DataDiffer","TRANSFERABLE_PROPERTIES","__wrappedMethods","propName","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","stackable","_dimensionInfos","indices","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","_extent","listProto","hasItemOption","getDimension","initData","nameList","dimValueGetter","size","dimensionInfoMap","idList","nameRepeatCount","DataCtor","dimName","dimStorage","stackedValue","getValues","getDataExtent","dimData","dimExtent","getSum","sum","rawIndex","mid","indexOfNearest","maxDistance","nearestIdx","minDist","Number","MAX_VALUE","diff","rawIdx","getId","dims","dimSize","filterSelf","newIndices","keep","mapArray","tmpRetValue","retValue","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","setVisual","setLayout","getLayout","getItemLayout","setItemLayout","clearItemLayouts","itemVisual","setItemVisual","setItemDataAndSeriesIndex","setItemGraphicEl","getItemGraphicEl","eachItemGraphicEl","cloneShallow","dimensionInfoList","wrapMethod","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","colorPaletteMixin","legendDataProvider","visualColorAccessPath","_dataBeforeProcessed","getInitialData","_data","label","fillDataTextStyle","newSeriesOption","getLinkedData","setData","getRawData","coordDimToDataDim","coordDim","dataDimToCoordDim","dataDim","getBaseAxis","multipleSeries","formatArrayValue","valStr","join","formattedValue","colorEl","getColorFromPalette","scope","getAxisTooltipDataIndex","getTooltipPosition","getTextWidth","textWidthCache","textLines","l","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getTextRect","textAlign","textBaseline","textLineLen","lineHeight","adjustTextPositionOnRect","textRect","textHeight","halfHeight","ellipsis","options","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","font","isAroundZero","EPSILON","isNotAroundZero","cubicAt","p0","p1","p2","p3","onet","cubicDerivativeAt","cubicRootAt","roots","A","B","C","n","t1","disc","K","t2","discSqrt","mathSqrt","Y1","Y2","mathPow","ONE_THIRD","T","theta","acos","ASqrt","tmp","cos","THREE_SQRT","sin","t3","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","x0","y0","x3","y3","prev","next","d1","d2","interval","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseInt","parseCssFloat","cssHueToRgb","m1","m2","colorStr","kCSSColorTable","op","ep","fname","alpha","pop","hsla2rgba","iv","hsla","rgba","rgba2hsla","H","S","R","G","vMin","vMax","delta","L","deltaR","deltaG","deltaB","level","toHex","fastMapToColor","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","out0","out1","out2","out3","out4","out5","rotate","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","arrySlice","_$handlers","_h","isSilent","newList","argLen","triggerWithContext","superCall","superApply","TYPE_DELIMITER","IS_CONTAINER","RootClass","mandatoryMethods","proto","ExtendedClass","entity","makeContainer","container","registerClass","componentTypeMain","throwWhenNotFound","o","hasClass","getAllClassMainTypes","types","hasSubTypes","originalExtend","OrdinalScale","IntervalScale","Scale","axisHelper","getScaleExtent","axis","originalExtent","getExtent","span","getMin","getMax","crossZero","getNeedCrossZero","boundaryGap","fixMin","fixMax","niceScaleExtent","extent","splitNumber","base","setExtent","niceExtent","minInterval","getInterval","intervalScale","origin","setInterval","createScaleByModel","axisType","getCategories","ifAxisCrossZero","getAxisLabelInterval","tickCoords","labels","isAxisHorizontal","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","step","tickCoord","getFormattedLabels","labelFormatter","getTicksLabels","ticks","getTicks","tick","getLabel","_coordinateSystems","coordinateSystemCreators","coordinateSystems","creater","coordinateSystemCreator","clientToLocal","calculate","defaultGetZrXY","layerX","offsetX","zrX","zrY","layerY","offsetY","clientX","clientY","normalizeEvent","isTouch","touch","targetTouches","changedTouches","zrDelta","wheelDelta","detail","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","stop","preventDefault","stopPropagation","cancelBubble","returnValue","Dispatcher","Triangle","moveTo","lineTo","closePath","Diamond","Pin","r","dy","angle","asin","dx","tanX","tanY","arc","cpLen","cpLen2","bezierCurveTo","Arrow","symbolCtors","line","roundRect","square","circle","diamond","pin","arrow","triangle","symbolShapeMakers","symbolBuildProxies","Symbol","symbolType","beforeBrush","textVerticalAlign","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","symbolUtil","createSymbol","symbolPath","setColor","Chart","elSetState","state","childCount","dataIdx","removeAll","chartProto","curve","bbox","CMD","Q","Z","min2","max2","mathCos","mathSin","mathAbs","hasTypedArray","_len","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","addData","exceedUnit","_needsDash","_dashedLineTo","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","startAngle","endAngle","anticlockwise","arcTo","radius","toStatic","lineDashSum","offset","appendPath","appendSize","appendPathData","cmd","_expandData","_prevCmd","newData","dash","dashSum","nDash","bezierLen","tmpLen","xi","yi","fromLine","fromCubic","fromQuadratic","rx","ry","fromArc","ux","uy","dTheta","psi","fs","scaleX","scaleY","isEllipse","Gradient","addColorStop","completeDimensions","defaultNames","extraPrefix","value0","retrieveValue","guessOrdinal","excludes","_interval","scaleProto","unionExtent","start","end","thisExtent","config","debugMode","Element","_children","__storage","children","childOfName","_doAdd","addBefore","nextSibling","addToMap","addChildrenToStorage","delFromMap","delChildrenFromStorage","includeChildren","tmpRect","tmpMat","invisible","childRect","firstDataNotNull","ifNeedCompleteOrdinalData","sampleItem","createListFromArray","coordSysName","creators","registeredCoordSys","axesInfo","categoryIndex","createNameList","categories","categoryAxesModels","isStackable","getDimTypeByAxis","categoryAxisModel","categoryDim","dataLen","cartesian2d","axesModels","xAxisModel","yAxisModel","xAxisType","yAxisType","isXAxisCateogry","isYAxisCategory","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","geo","gridModel","getRect","getItemStyle","xAxis","yAxis","grid","Style","__clipPaths","RectText","draggable","dragging","culling","cursor","rectHover","afterBrush","rectContain","coord","animateStyle","useStyle","mathFloor","mathCeil","roundingErrorFix","niceTicks","_niceExtent","safeLimit","reverse","expandSize","SymbolDraw","symbolCtor","_symbolCtor","symbolNeedsDraw","isIgnore","point","symbolDrawProto","updateData","oldData","SymbolCtor","seriesScope","itemStyle","hoverItemStyle","symbolRotate","symbolOffset","hoverAnimation","hoverLabelModel","newIdx","symbolEl","oldIdx","fadeOut","execute","enableAnimation","fixExtentWithBands","nTick","normalizedExtent","Axis","inverse","onBand","containData","dataToCoord","coordToData","getTicksCoords","alignWithLabel","bands","getBands","coords","getLabelsCoords","getBandWidth","axisExtent","DELIMITER","random","subTypeDefaulters","registerSubTypeDefaulter","defaulter","determineSubType","dependencyGetter","makeDepndencyGraph","fullNameList","graph","noEntryList","thisItem","createDependencyGraphItem","originalDeps","availableDeps","getAvailableDependencies","entryCount","dependentName","predecessor","thatItem","successor","dep","topologicalTravel","targetNameList","callback","removeEdge","succComponentType","removeEdgeAndAdd","targetNameSet","currComponentType","currVertex","isInTargetNameSet","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","defaultKeyGetter","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","keyArr","keyGetter","existence","_add","_update","_remove","oldDataIndexMap","newDataIndexMap","oldDataKeyArr","newDataKeyArr","unshift","defaultSymbolType","legendSymbol","eachRawSeriesByType","symbolSize","symbol","isSeriesFiltered","itemSymbolType","itemSymbolSize","ZImage","LRU","globalImageCache","src","_image","cachedImgObj","onload","pending","put","sWidth","sHeight","drawImage","normalizeSymbolSize","driftSymbol","drift","symbolProto","_createSymbol","_symbolType","stopSymbolAnimation","toLastFrame","getSymbolPath","getScale","setZ","setDraggable","_updateCommon","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","elStyle","opacity","valueDim","onEmphasis","ratio","onNormal","makeAxisEventDataBase","axisModel","innerTextLayout","textRotation","verticalAlign","rotationDiff","endTextLayout","textRotate","onLeft","tooltipOpt","show","AxisBuilder","labelOffset","nameDirection","tickDirection","labelDirection","dumbGroup","updateTransform","_transform","_dumbGroup","hasBuilder","builders","getGroup","axisLine","pt1","pt2","lineCap","getLineStyle","axisTick","tickModel","lineStyleModel","tickLen","tickInterval","labelInterval","ticksCoords","ifIgnoreOnTick","axisLabel","isTwoLabelOverlapped","current","firstRect","nextRect","axisLabelShow","labelMargin","labelRotation","labelLayout","categoryData","textEls","triggerEvent","itemTextStyleModel","textColor","pos","labelBeforeFormat","textEl","targetType","decomposeTransform","firstLabel","nextLabel","lastLabel","prevLabel","axisName","nameLocation","gapSignal","nameRotation","axisNameAvailableWidth","truncateOpt","truncatedText","formatterParams","__fullText","__truncatedText","tooltip","content","rawTick","axisDefault","AXIS_TYPES","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","getAxisType","axisDim","axisModelCreator","AxisModel","resetRange","findGridModel","extraOption","isAxisUsedInTheGrid","getLabelUnionRect","labelCount","isLabelIgnored","singleRect","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","updateAxisTransfrom","coordBase","axisExtentSum","toGlobalCoord","toLocalCoord","findAxesModels","axesTypes","isCartesian2D","Cartesian2D","Axis2D","gridProto","ifAxisCanNotOnZero","otherAxisDim","axes","axesMap","_updateScale","onZero","adjustAxes","axesList","isHorizontal","gridRect","getBoxLayoutParams","labelUnionRect","getAxis","axisIndex","axesMapOnDim","getCartesian","xAxisIndex","yAxisIndex","coordList","_findConvertTarget","cartesian","dataToPoint","pointToData","coordsList","createAxisCreator","axisPosition","axisPositionUsed","isCategory","axesCount","addAxis","grids","eachSeriesByType","_colorIdx","_colorNameMap","colorIdx","colorNameMap","colorPalette","Component","componentProto","guid","Transformable","Animatable","clipPath","beforeUpdate","afterUpdate","hide","setClipPath","addSelfToZr","removeClipPath","removeSelfFromZr","animators","addAnimator","removeAnimator","defaultGetter","defaultSetter","interpolateNumber","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isArraySame","catmullRomInterpolateArray","catmullRomInterpolate","v0","cloneValue","rgba2String","createTrackClip","animator","easing","oneTrackDone","keyframes","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","lastValue","_target","lastFrame","lastFramePercent","onframe","frame","clip","Clip","life","_loop","delay","_delay","ondestroy","Animator","_tracks","_clipCount","_doneList","_onframeList","_clipList","when","tracks","during","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","forwardToLast","clipList","removeClip","done","getClips","requestAnimationFrame","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","setTimeout","PI2","normalizeRadian","idStart","repeat","_canvasPattern","createPattern","createLinearGradient","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","shadowBlur","shadowOffsetX","shadowOffsetY","textStroke","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","newStyle","styleProto","smoothSpline","smoothBezier","points","smooth","controlPoints","smoothConstraint","cp1","cp2","updateSelectedMap","targetList","_selectTargetMap","targetMap","select","selectedMode","selected","unSelect","toggleSelected","isSelected","legendModels","findComponents","paletteScope","dataAll","idxMap","filteredIdx","singleDataColor","extremity","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","fillText","strokeText","maxValue","lastIndexOf","save","align","baseline","shadowColor","textShadowColor","restore","delInstance","Handler","Storage","Animation","HandlerProxy","useVML","painterCtors","ZRender","getInstance","registerPainter","rendererType","vml","handerProxy","getViewportRoot","stage","flush","_needsRefresh","oldDelFromMap","oldAddToMap","elId","addRoot","delRoot","zLevel","_needsRefreshHover","refreshHoverImmediately","refreshHover","clearHover","clearAnimation","pathToImage","setCursorStyle","cursorStyle","eventHandler","actionInfos","nameRotate","nameTruncate","nameTextStyle","nameGap","lineStyle","inside","fontSize","splitLine","splitArea","areaStyle","categoryAxis","valueAxis","timeAxis","logAxis","logBase","rangeStart","rangeEnd","setRange","_l","_a","_b","_s","dir","x_","globalCoord","mIdentity","transformableProto","needLocalTransform","parentHasTransform","invTransform","tmpTransform","atan2","transformCoordToGlobal","chartInstance","echartsAPIList","barLayoutGrid","getMarkerPosition","pt","offsetIndex","brushSelector","legendHoverLink","barMinHeight","fixLayoutWithLineWidth","signX","signY","coordinateSystemType","_renderOnCartesian","createRect","barBorderWidthQuery","rectShape","animateProperty","animateTarget","baseAxis","newIndex","oldIndex","_updateStyle","setLabel","labelText","labelPositionOutside","itemStyleModel","getBarItemStyle","rectStyle","getBorderLineDash","clipOverflow","smoothMonotone","showSymbol","showAllSymbol","connectNulls","sampling","hoverLayerThreshold","isPointsSame","points1","points2","getSmooth","getAxisExtentWithGap","getGlobalExtent","halfBandWidth","sign","getStackedOnPoints","getOtherAxis","valueStart","baseDataOffset","stackedOnSameSign","stackedData","createGridClipShape","hasAnimation","xExtent","yExtent","createPolarClipShape","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","radiusExtent","angleExtent","RADIAN","r0","clockwise","createClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","nextPt","stepPt","middle","stepPt2","getVisualGradient","visualMetaList","visualMeta","stops","firstStop","lastStop","stopsSpan","gradient","lineAnimationDiff","polyHelper","lineGroup","symbolDraw","_symbolDraw","_lineGroup","areaStyleModel","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","polygon","_polygon","isAreaChart","stackedOnPoints","isSymbolIgnore","_getSymbolIgnoreFunc","__temp","_step","_newPolygon","_stackedOnPoints","_points","_updateAnimation","_newPolyline","visualColor","lineJoin","stackedOnSmooth","getAreaStyle","stackedOnSeries","getAxesByScale","stackedOnCurrent","stackedOnNext","__points","updatedDataInfo","diffStatus","idx1","ptIdx","getStackedOnPoint","diffData","diffResult","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","diffItem","pointAdded","currentPt","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","isPointNull","drawSegment","segLen","allLen","smoothMin","smoothMax","prevIdx","v2Copy","cp0","nextIdx","nextP","ratioNextSeg","prevP","lenPrevSeg","lenNextSeg","getBoundingBox","ptMin","ptMax","stackedOnBBox","dataSelectableMixin","PieSeries","_defaultLabelLine","labelLine","labelLineNormalOpt","labelLineEmphasisOpt","center","minAngle","selectedOffset","avoidLabelOverlap","borderWidth","updateDataSelected","toggleItemSelected","midAngle","PiePiece","hoverIgnore","normalIgnore","sector","getLabelStyle","isLabelInside","piePieceProto","firstCreate","sectorShape","_updateLabel","linePoints","labelHoverModel","labelLineModel","labelLineHoverModel","Pie","sectorGroup","_sectorGroup","isFirstRender","onSectorClick","piePiece","_createClipPath","itemLayout","adjustSingleSide","viewWidth","viewHeight","shiftDown","shiftUp","changeX","isDownList","lastDeltaX","deltaY","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textX","textY","labelLineLen","labelLineLen2","labelRotate","unitRadian","roseType","restAngle","valueSumLargerThanMinAngle","currentAngle","layoutAxis","getZero","theAxis","rawAxisPosition","rectBound","axisOffset","posMap","dirMap","getLabelInterval","axisBuilderAttrs","selfBuilderAttrs","AxisView","oldAxisGroup","_axisGroup","axisBuilder","_splitLine","splitLineModel","lineColors","lineInterval","lineCount","colorIndex","_splitArea","splitAreaModel","areaColors","prevX","prevY","areaInterval","axisLabelInterval","coordExtent","_labelInterval","dimAxisMapper","_axes","Cartesian","_dimList","getAxes","scaleType","_dataCoordConvert","input","dimList","output","axisX","axisY","dataToPoints","containLabel","borderColor","getSeriesStackId","getAxisKey","calBarWidthAndOffset","barSeries","columnsMap","bandWidth","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","stacks","stackId","barWidth","barMaxWidth","barGap","barCategoryGap","barGapPercent","autoWidth","column","lastColumn","widthSum","barWidthAndOffset","getSeriesByType","lastStackCoords","lastStackCoordsOrigin","columnLayoutInfo","columnOffset","columnWidth","valueAxisStart","lastCoord","lastCoordOrigin","maskColor","mask","labelRect","mergeTheme","themeItem","initBase","baseOption","OPTION_INNER_KEY","_seriesIndices","globalDefault","getComponentsByTypes","componentsMap","makeKeyInfo","mapResult","idMap","existCpt","keyInfo","idNum","existComponent","createSeriesIndices","seriesModels","filterBySubType","components","cpt","assertSeriesInitialized","_optionManager","mountOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","mediaOption","visitComponent","newCptOptionList","resultItem","ComponentModelClass","newCptTypes","componentOption","getComponent","cpts","isIdArray","isNameArray","getQueryCond","q","indexAttr","idAttr","nameAttr","doFilter","queryCond","queryResult","getSeriesByName","oneSeries","getSeries","rawSeriesIndex","eachRawSeries","filterSeries","filteredSeries","componentTypes","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","parseRawOption","rawOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","media","singleMedia","preProcess","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","matched","QUERY_REG","operator","realAttr","real","expect","indicesEquals","indices1","indices2","oldOption","newCptOpt","oldCptOpt","oldOptionBackup","newParsedOption","isRecreate","optionBackup","timelineModel","getCurrentIndex","platform","fontFamily","fontStyle","fontWeight","animationDuration","animationDurationUpdate","animationEasingUpdate","animationThreshold","progressiveThreshold","lineType","getLineDash","dotSize","dashSize","gTextStyleModel","compatLayoutProperties","LAYOUT_PROPERTIES","compatStyle","COMPATITABLE_COMPONENTS","COMPATITABLE_SERIES","seriesOpt","clockWise","pointerColor","dataRange","visualMap","componentName","compatItemStyle","itemStyleOpt","POSSIBLE_STYLES","normalItemStyleOpt","emphasisItemStyleOpt","markPoint","markLine","mpData","mlData","samplers","average","nearest","indexSampler","sampler","fixRoundingError","originalVal","intervalScaleProto","mathLog","LogScale","_originalScale","originalScale","powVal","__fixMin","__fixMax","approxTickNum","err","rank","ONE_SECOND","ONE_MINUTE","ONE_HOUR","ONE_DAY","bisect","TimeScale","stepLvl","_stepLvl","approxInterval","scaleLevelsLen","scaleLevels","yearSpan","yearStep","encodeColor","colorAccessPath","makeEventPacket","eveType","gestureEvent","pinchX","pinchY","pinchScale","zrByTouch","EmptyProxy","isHover","displayable","Draggable","handlerNames","proxy","painterRoot","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","hovered","findHover","lastHovered","setCursor","dispatchToElement","mouseout","innerDom","element","toElement","relatedTarget","parentNode","dispatch","eventArgs","targetEl","eventPacket","eachOtherLayer","layer","exclude","_downel","_upel","returnFalse","createDom","newDom","newDomStyle","Layer","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","initContext","createBackBuffer","clearAll","haveMotionBLur","clearRect","clearColorGradientOrPattern","__canvasGradient","fillRect","parseInt10","isLayerValid","isBuildin","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","clipPaths","prevClipPaths","doClip","createRoot","domRoot","cssText","MAX_PROGRESSIVE_LAYER_NUMBER","Painter","singleCanvas","nodeName","_opts","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","_getSize","_domRoot","appendChild","_createPathToImage","_progressiveLayers","_hoverlayer","_hoverElements","paintAll","_paintList","_startProgessive","__hoverMir","elMirror","__from","hoverElements","hoverLayer","displayableSortFunc","getLayer","originalEl","_doPaintEl","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuildinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","imageLayer","displayList","whIdx","wh","cwh","plt","prb","stl","defaultView","getComputedStyle","_pathToImage","pathTransform","ImageShape","imgShape","me","shapeCompareFunc","_elements","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","_updateAndAddDisplayable","elements","_renderList","_clips","_running","_time","_pausedTime","_pauseStart","_paused","clips","getTime","deferredEvents","deferredClips","_needsRemove","fire","_startLoop","pause","resume","_life","_initialized","onrestart","easingFuncs","globalTime","_startTime","easingFunc","schedule","restart","remainder","arg","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","windingQuadratic","y_","windingArc","containPath","isStroke","windingLine","cubic","quadratic","_x","pointPair","eventUtil","GestureMgr","_track","recognize","_doTrack","_recognize","touches","trackItem","recognizers","gestureInfo","pinch","track","pinchEnd","pinchPre","pinchCenter","LinkedList","head","tail","linkedListProto","insert","entry","Entry","insertEntry","maxSize","_list","_map","_maxSize","LRUProto","leastUsedEntry","eventNameFix","processGesture","gestureMgr","_gestureMgr","setTouchTimer","instance","_touching","clearTimeout","_touchTimer","useTouchEvent","initDomHandler","makeMouseHandler","fn","touchHandlerNames","_handlers","domHandlers","mouseHandlerNames","HandlerDomProxy","mountHandlers","eventTool","TOUCH_CLICK_DELAY","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","paths","_updatePathDirty","r1","r2","r3","r4","total","v2Min","v2Max","v2Scale","v2Distance","v2Add","isLoop","constraint","prevPoint","nextPoint","cps","d0","interpolate","segs","w2","w3","unitX","unitY","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","curveTool","pointAt","tangentAt","roundRectHelper","animatingShape","pathSplitted","_animateToShallow","objShallow","propertyCount","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","_y","dropTarget","lastDropTarget","_dropTarget","processArc","fa","psiDeg","xp","yp","lambda","cxp","cyp","vAngle","u","vRatio","createPathProxyFromString","cs","cc","RegExp","prevCmd","cpx","cpy","ctlPtx","ctlPty","createPathOptions","pathProxy","transformPath","vMag","pathEls","pathList","pathEl","pathBundle","nPoint","mathAtan2"],"mappings":"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","file":"echarts.simple.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"echarts\"] = factory();\n\telse\n\t\troot[\"echarts\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"echarts\"] = factory();\n\telse\n\t\troot[\"echarts\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!*************************!*\\\n  !*** ./index.simple.js ***!\n  \\*************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Export echarts as CommonJS module\n\t */\n\tmodule.exports = __webpack_require__(/*! ./lib/echarts */ 2);\n\t\n\t__webpack_require__(/*! ./lib/chart/line */ 96);\n\t__webpack_require__(/*! ./lib/chart/bar */ 90);\n\t__webpack_require__(/*! ./lib/chart/pie */ 101);\n\t__webpack_require__(/*! ./lib/component/grid */ 36);\n\n/***/ },\n/* 1 */\n/*!************************************!*\\\n  !*** ./~/zrender/lib/core/util.js ***!\n  \\************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/core/util\n\t */\n\t\n\t\n\t    // mergeDate\n\t    var BUILTIN_OBJECT = {\n\t        '[object Function]': 1,\n\t        '[object RegExp]': 1,\n\t        '[object Date]': 1,\n\t        '[object Error]': 1,\n\t        '[object CanvasGradient]': 1,\n\t        '[object CanvasPattern]': 1,\n\t        // For node-canvas\n\t        '[object Image]': 1,\n\t        '[object Canvas]': 1\n\t    };\n\t\n\t    var TYPED_ARRAY = {\n\t        '[object Int8Array]': 1,\n\t        '[object Uint8Array]': 1,\n\t        '[object Uint8ClampedArray]': 1,\n\t        '[object Int16Array]': 1,\n\t        '[object Uint16Array]': 1,\n\t        '[object Int32Array]': 1,\n\t        '[object Uint32Array]': 1,\n\t        '[object Float32Array]': 1,\n\t        '[object Float64Array]': 1\n\t    };\n\t\n\t    var objToString = Object.prototype.toString;\n\t\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t\n\t    /**\n\t     * Those data types can be cloned:\n\t     *     Plain object, Array, TypedArray, number, string, null, undefined.\n\t     * Those data types will be assgined using the orginal data:\n\t     *     BUILTIN_OBJECT\n\t     * Instance of user defined class will be cloned to a plain object, without\n\t     * properties in prototype.\n\t     * Other data types is not supported (not sure what will happen).\n\t     *\n\t     * Caution: do not support clone Date, for performance consideration.\n\t     * (There might be a large number of date in `series.data`).\n\t     * So date should not be modified in and out of echarts.\n\t     *\n\t     * @param {*} source\n\t     * @return {*} new\n\t     */\n\t    function clone(source) {\n\t        if (source == null || typeof source != 'object') {\n\t            return source;\n\t        }\n\t\n\t        var result = source;\n\t        var typeStr = objToString.call(source);\n\t\n\t        if (typeStr === '[object Array]') {\n\t            result = [];\n\t            for (var i = 0, len = source.length; i < len; i++) {\n\t                result[i] = clone(source[i]);\n\t            }\n\t        }\n\t        else if (TYPED_ARRAY[typeStr]) {\n\t            result = source.constructor.from(source);\n\t        }\n\t        else if (!BUILTIN_OBJECT[typeStr] && !isDom(source)) {\n\t            result = {};\n\t            for (var key in source) {\n\t                if (source.hasOwnProperty(key)) {\n\t                    result[key] = clone(source[key]);\n\t                }\n\t            }\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t\n\t                if (isObject(sourceProp)\n\t                    && isObject(targetProp)\n\t                    && !isArray(sourceProp)\n\t                    && !isArray(targetProp)\n\t                    && !isDom(sourceProp)\n\t                    && !isDom(targetProp)\n\t                    && !isBuildInObject(sourceProp)\n\t                    && !isBuildInObject(targetProp)\n\t                ) {\n\t                    // merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                }\n\t                else if (overwrite || !(key in target)) {\n\t                    // overwritetrue\n\t                    // NOTE target[key] \n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolen} [overlay=false]\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)\n\t                && (overlay ? source[key] != null : target[key] == null)\n\t            ) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    function createCanvas() {\n\t        return document.createElement('canvas');\n\t    }\n\t    // FIXME\n\t    var _ctx;\n\t    function getContext() {\n\t        if (!_ctx) {\n\t            // Use util.createCanvas instead of createCanvas\n\t            // because createCanvas may be overwritten in different environment\n\t            _ctx = util.createCanvas().getContext('2d');\n\t        }\n\t        return _ctx;\n\t    }\n\t\n\t    /**\n\t     * index\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /**\n\t     * \n\t     *\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} clazz \n\t     * @param {Function} baseClazz \n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {}\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t\n\t        defaults(target, source, overlay);\n\t    }\n\t\n\t    /**\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (! data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        }\n\t        else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        }\n\t        else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        }\n\t        else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || (!!value && type == 'object');\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuildInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)];\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return typeof value === 'object'\n\t            && typeof value.nodeType === 'number'\n\t            && typeof value.ownerDocument === 'object';\n\t    }\n\t\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * @memberOf module:zrender/core/util\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t\n\t    var util = {\n\t        inherits: inherits,\n\t        mixin: mixin,\n\t        clone: clone,\n\t        merge: merge,\n\t        mergeAll: mergeAll,\n\t        extend: extend,\n\t        defaults: defaults,\n\t        getContext: getContext,\n\t        createCanvas: createCanvas,\n\t        indexOf: indexOf,\n\t        slice: slice,\n\t        find: find,\n\t        isArrayLike: isArrayLike,\n\t        each: each,\n\t        map: map,\n\t        reduce: reduce,\n\t        filter: filter,\n\t        bind: bind,\n\t        curry: curry,\n\t        isArray: isArray,\n\t        isString: isString,\n\t        isObject: isObject,\n\t        isFunction: isFunction,\n\t        isBuildInObject: isBuildInObject,\n\t        isDom: isDom,\n\t        retrieve: retrieve,\n\t        assert: assert,\n\t        noop: function () {}\n\t    };\n\t    module.exports = util;\n\t\n\n\n/***/ },\n/* 2 */\n/*!************************!*\\\n  !*** ./lib/echarts.js ***!\n  \\************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Enable DEV mode when using source code without build. which has no __DEV__ variable\n\t// In build process 'typeof __DEV__' will be replace with 'boolean'\n\t// So this code will be removed or disabled anyway after built.\n\tif (false) {\n\t    // In browser\n\t    if (typeof window !== 'undefined') {\n\t        window.__DEV__ = true;\n\t    }\n\t    // In node\n\t    else if (typeof global !== 'undefined') {\n\t        global.__DEV__ = true;\n\t    }\n\t}\n\t\n\t/*!\n\t * ECharts, a javascript interactive chart library.\n\t *\n\t * Copyright (c) 2015, Baidu Inc.\n\t * All rights reserved.\n\t *\n\t * LICENSE\n\t * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n\t */\n\t\n\t/**\n\t * @module echarts\n\t */\n\t\n\t\n\t    var env = __webpack_require__(/*! zrender/lib/core/env */ 11);\n\t\n\t    var GlobalModel = __webpack_require__(/*! ./model/Global */ 124);\n\t    var ExtensionAPI = __webpack_require__(/*! ./ExtensionAPI */ 89);\n\t    var CoordinateSystemManager = __webpack_require__(/*! ./CoordinateSystem */ 23);\n\t    var OptionManager = __webpack_require__(/*! ./model/OptionManager */ 125);\n\t\n\t    var ComponentModel = __webpack_require__(/*! ./model/Component */ 12);\n\t    var SeriesModel = __webpack_require__(/*! ./model/Series */ 15);\n\t\n\t    var ComponentView = __webpack_require__(/*! ./view/Component */ 57);\n\t    var ChartView = __webpack_require__(/*! ./view/Chart */ 27);\n\t    var graphic = __webpack_require__(/*! ./util/graphic */ 3);\n\t    var modelUtil = __webpack_require__(/*! ./util/model */ 7);\n\t\n\t    var zrender = __webpack_require__(/*! zrender */ 76);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var colorTool = __webpack_require__(/*! zrender/lib/tool/color */ 18);\n\t    var Eventful = __webpack_require__(/*! zrender/lib/mixin/Eventful */ 20);\n\t    var timsort = __webpack_require__(/*! zrender/lib/core/timsort */ 44);\n\t\n\t    var each = zrUtil.each;\n\t\n\t    var PRIORITY_PROCESSOR_FILTER = 1000;\n\t    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\t\n\t\n\t    var PRIORITY_VISUAL_LAYOUT = 1000;\n\t    var PRIORITY_VISUAL_GLOBAL = 2000;\n\t    var PRIORITY_VISUAL_CHART = 3000;\n\t    var PRIORITY_VISUAL_COMPONENT = 4000;\n\t    var PRIORITY_VISUAL_BRUSH = 5000;\n\t\n\t    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n\t    // where they must not be invoked nestedly, except the only case: invoke\n\t    // dispatchAction with updateMethod \"none\" in main process.\n\t    // This flag is used to carry out this rule.\n\t    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n\t    var IN_MAIN_PROCESS = '__flag_in_main_process';\n\t    var HAS_GRADIENT_OR_PATTERN_BG = '_hasGradientOrPatternBg';\n\t\n\t\n\t    var OPTION_UPDATED = '_optionUpdated';\n\t\n\t    function createRegisterEventWithLowercaseName(method) {\n\t        return function (eventName, handler, context) {\n\t            // Event name is all lowercase\n\t            eventName = eventName && eventName.toLowerCase();\n\t            Eventful.prototype[method].call(this, eventName, handler, context);\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @module echarts~MessageCenter\n\t     */\n\t    function MessageCenter() {\n\t        Eventful.call(this);\n\t    }\n\t    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n\t    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n\t    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n\t    zrUtil.mixin(MessageCenter, Eventful);\n\t\n\t    /**\n\t     * @module echarts~ECharts\n\t     */\n\t    function ECharts (dom, theme, opts) {\n\t        opts = opts || {};\n\t\n\t        // Get theme by name\n\t        if (typeof theme === 'string') {\n\t            theme = themeStorage[theme];\n\t        }\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id;\n\t        /**\n\t         * Group id\n\t         * @type {string}\n\t         */\n\t        this.group;\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         * @private\n\t         */\n\t        this._dom = dom;\n\t        /**\n\t         * @type {module:zrender/ZRender}\n\t         * @private\n\t         */\n\t        this._zr = zrender.init(dom, {\n\t            renderer: opts.renderer || 'canvas',\n\t            devicePixelRatio: opts.devicePixelRatio,\n\t            width: opts.width,\n\t            height: opts.height\n\t        });\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._theme = zrUtil.clone(theme);\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsViews = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsMap = {};\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsViews = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t\n\t        /**\n\t         * @type {module:echarts/ExtensionAPI}\n\t         * @private\n\t         */\n\t        this._api = new ExtensionAPI(this);\n\t\n\t        /**\n\t         * @type {module:echarts/CoordinateSystem}\n\t         * @private\n\t         */\n\t        this._coordSysMgr = new CoordinateSystemManager();\n\t\n\t        Eventful.call(this);\n\t\n\t        /**\n\t         * @type {module:echarts~MessageCenter}\n\t         * @private\n\t         */\n\t        this._messageCenter = new MessageCenter();\n\t\n\t        // Init mouse events\n\t        this._initEvents();\n\t\n\t        // In case some people write `window.onresize = chart.resize`\n\t        this.resize = zrUtil.bind(this.resize, this);\n\t\n\t        // Can't dispatch action during rendering procedure\n\t        this._pendingActions = [];\n\t        // Sort on demand\n\t        function prioritySortFunc(a, b) {\n\t            return a.prio - b.prio;\n\t        }\n\t        timsort(visualFuncs, prioritySortFunc);\n\t        timsort(dataProcessorFuncs, prioritySortFunc);\n\t\n\t        this._zr.animation.on('frame', this._onframe, this);\n\t    }\n\t\n\t    var echartsProto = ECharts.prototype;\n\t\n\t    echartsProto._onframe = function () {\n\t        // Lazy update\n\t        if (this[OPTION_UPDATED]) {\n\t\n\t            this[IN_MAIN_PROCESS] = true;\n\t\n\t            updateMethods.prepareAndUpdate.call(this);\n\t\n\t            this[IN_MAIN_PROCESS] = false;\n\t\n\t            this[OPTION_UPDATED] = false;\n\t        }\n\t    };\n\t    /**\n\t     * @return {HTMLDomElement}\n\t     */\n\t    echartsProto.getDom = function () {\n\t        return this._dom;\n\t    };\n\t\n\t    /**\n\t     * @return {module:zrender~ZRender}\n\t     */\n\t    echartsProto.getZr = function () {\n\t        return this._zr;\n\t    };\n\t\n\t    /**\n\t     * @param {Object} option\n\t     * @param {boolean} notMerge\n\t     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.\n\t     */\n\t    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n\t        if (false) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = true;\n\t\n\t        if (!this._model || notMerge) {\n\t            var optionManager = new OptionManager(this._api);\n\t            var theme = this._theme;\n\t            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n\t            ecModel.init(null, null, theme, optionManager);\n\t        }\n\t\n\t        this._model.setOption(option, optionPreprocessorFuncs);\n\t\n\t        if (lazyUpdate) {\n\t            this[OPTION_UPDATED] = true;\n\t        }\n\t        else {\n\t            updateMethods.prepareAndUpdate.call(this);\n\t            this._zr.refreshImmediately();\n\t            this[OPTION_UPDATED] = false;\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = false;\n\t\n\t        this._flushPendingActions();\n\t    };\n\t\n\t    /**\n\t     * @DEPRECATED\n\t     */\n\t    echartsProto.setTheme = function () {\n\t        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n\t    };\n\t\n\t    /**\n\t     * @return {module:echarts/model/Global}\n\t     */\n\t    echartsProto.getModel = function () {\n\t        return this._model;\n\t    };\n\t\n\t    /**\n\t     * @return {Object}\n\t     */\n\t    echartsProto.getOption = function () {\n\t        return this._model && this._model.getOption();\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getWidth = function () {\n\t        return this._zr.getWidth();\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getHeight = function () {\n\t        return this._zr.getHeight();\n\t    };\n\t\n\t    /**\n\t     * Get canvas which has all thing rendered\n\t     * @param {Object} opts\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getRenderedCanvas = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        opts = opts || {};\n\t        opts.pixelRatio = opts.pixelRatio || 1;\n\t        opts.backgroundColor = opts.backgroundColor\n\t            || this._model.get('backgroundColor');\n\t        var zr = this._zr;\n\t        var list = zr.storage.getDisplayList();\n\t        // Stop animations\n\t        zrUtil.each(list, function (el) {\n\t            el.stopAnimation(true);\n\t        });\n\t        return zr.painter.getRenderedCanvas(opts);\n\t    };\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getDataURL = function (opts) {\n\t        opts = opts || {};\n\t        var excludeComponents = opts.excludeComponents;\n\t        var ecModel = this._model;\n\t        var excludesComponentViews = [];\n\t        var self = this;\n\t\n\t        each(excludeComponents, function (componentType) {\n\t            ecModel.eachComponent({\n\t                mainType: componentType\n\t            }, function (component) {\n\t                var view = self._componentsMap[component.__viewId];\n\t                if (!view.group.ignore) {\n\t                    excludesComponentViews.push(view);\n\t                    view.group.ignore = true;\n\t                }\n\t            });\n\t        });\n\t\n\t        var url = this.getRenderedCanvas(opts).toDataURL(\n\t            'image/' + (opts && opts.type || 'png')\n\t        );\n\t\n\t        each(excludesComponentViews, function (view) {\n\t            view.group.ignore = false;\n\t        });\n\t        return url;\n\t    };\n\t\n\t\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getConnectedDataURL = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        var groupId = this.group;\n\t        var mathMin = Math.min;\n\t        var mathMax = Math.max;\n\t        var MAX_NUMBER = Infinity;\n\t        if (connectedGroups[groupId]) {\n\t            var left = MAX_NUMBER;\n\t            var top = MAX_NUMBER;\n\t            var right = -MAX_NUMBER;\n\t            var bottom = -MAX_NUMBER;\n\t            var canvasList = [];\n\t            var dpr = (opts && opts.pixelRatio) || 1;\n\t\n\t            zrUtil.each(instances, function (chart, id) {\n\t                if (chart.group === groupId) {\n\t                    var canvas = chart.getRenderedCanvas(\n\t                        zrUtil.clone(opts)\n\t                    );\n\t                    var boundingRect = chart.getDom().getBoundingClientRect();\n\t                    left = mathMin(boundingRect.left, left);\n\t                    top = mathMin(boundingRect.top, top);\n\t                    right = mathMax(boundingRect.right, right);\n\t                    bottom = mathMax(boundingRect.bottom, bottom);\n\t                    canvasList.push({\n\t                        dom: canvas,\n\t                        left: boundingRect.left,\n\t                        top: boundingRect.top\n\t                    });\n\t                }\n\t            });\n\t\n\t            left *= dpr;\n\t            top *= dpr;\n\t            right *= dpr;\n\t            bottom *= dpr;\n\t            var width = right - left;\n\t            var height = bottom - top;\n\t            var targetCanvas = zrUtil.createCanvas();\n\t            targetCanvas.width = width;\n\t            targetCanvas.height = height;\n\t            var zr = zrender.init(targetCanvas);\n\t\n\t            each(canvasList, function (item) {\n\t                var img = new graphic.Image({\n\t                    style: {\n\t                        x: item.left * dpr - left,\n\t                        y: item.top * dpr - top,\n\t                        image: item.dom\n\t                    }\n\t                });\n\t                zr.add(img);\n\t            });\n\t            zr.refreshImmediately();\n\t\n\t            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n\t        }\n\t        else {\n\t            return this.getDataURL(opts);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Convert from logical coordinate system to pixel coordinate system.\n\t     * See CoordinateSystem#convertToPixel.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            geoIndex / geoId, geoName,\n\t     *            bmapIndex / bmapId / bmapName,\n\t     *            xAxisIndex / xAxisId / xAxisName,\n\t     *            yAxisIndex / yAxisId / yAxisName,\n\t     *            gridIndex / gridId / gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     * @param {Array|number} value\n\t     * @return {Array|number} result\n\t     */\n\t    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\t\n\t    /**\n\t     * Convert from pixel coordinate system to logical coordinate system.\n\t     * See CoordinateSystem#convertFromPixel.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            geoIndex / geoId / geoName,\n\t     *            bmapIndex / bmapId / bmapName,\n\t     *            xAxisIndex / xAxisId / xAxisName,\n\t     *            yAxisIndex / yAxisId / yAxisName\n\t     *            gridIndex / gridId / gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     * @param {Array|number} value\n\t     * @return {Array|number} result\n\t     */\n\t    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\t\n\t    function doConvertPixel(methodName, finder, value) {\n\t        var ecModel = this._model;\n\t        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n\t        var result;\n\t\n\t        finder = modelUtil.parseFinder(ecModel, finder);\n\t\n\t        for (var i = 0; i < coordSysList.length; i++) {\n\t            var coordSys = coordSysList[i];\n\t            if (coordSys[methodName]\n\t                && (result = coordSys[methodName](ecModel, finder, value)) != null\n\t            ) {\n\t                return result;\n\t            }\n\t        }\n\t\n\t        if (false) {\n\t            console.warn(\n\t                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n\t            );\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Is the specified coordinate systems or components contain the given pixel point.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            geoIndex / geoId / geoName,\n\t     *            bmapIndex / bmapId / bmapName,\n\t     *            xAxisIndex / xAxisId / xAxisName,\n\t     *            yAxisIndex / yAxisId / yAxisName\n\t     *            gridIndex / gridId / gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     * @param {Array|number} value\n\t     * @return {boolean} result\n\t     */\n\t    echartsProto.containPixel = function (finder, value) {\n\t        var ecModel = this._model;\n\t        var result;\n\t\n\t        finder = modelUtil.parseFinder(ecModel, finder);\n\t\n\t        zrUtil.each(finder, function (models, key) {\n\t            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n\t                var coordSys = model.coordinateSystem;\n\t                if (coordSys && coordSys.containPoint) {\n\t                    result |= !!coordSys.containPoint(value);\n\t                }\n\t                else if (key === 'seriesModels') {\n\t                    var view = this._chartsMap[model.__viewId];\n\t                    if (view && view.containPoint) {\n\t                        result |= view.containPoint(value, model);\n\t                    }\n\t                    else {\n\t                        if (false) {\n\t                            console.warn(key + ': ' + (view\n\t                                ? 'The found component do not support containPoint.'\n\t                                : 'No view mapping to the found component.'\n\t                            ));\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    if (false) {\n\t                        console.warn(key + ': containPoint is not supported');\n\t                    }\n\t                }\n\t            }, this);\n\t        }, this);\n\t\n\t        return !!result;\n\t    };\n\t\n\t    /**\n\t     * Get visual from series or data.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'series', means {seriesIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            dataIndex / dataIndexInside\n\t     *        }\n\t     *        If dataIndex is not specified, series visual will be fetched,\n\t     *        but not data item visual.\n\t     *        If all of seriesIndex, seriesId, seriesName are not specified,\n\t     *        visual will be fetched from first series.\n\t     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n\t     */\n\t    echartsProto.getVisual = function (finder, visualType) {\n\t        var ecModel = this._model;\n\t\n\t        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\t\n\t        var seriesModel = finder.seriesModel;\n\t\n\t        if (false) {\n\t            if (!seriesModel) {\n\t                console.warn('There is no specified seires model');\n\t            }\n\t        }\n\t\n\t        var data = seriesModel.getData();\n\t\n\t        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n\t            ? finder.dataIndexInside\n\t            : finder.hasOwnProperty('dataIndex')\n\t            ? data.indexOfRawIndex(finder.dataIndex)\n\t            : null;\n\t\n\t        return dataIndexInside != null\n\t            ? data.getItemVisual(dataIndexInside, visualType)\n\t            : data.getVisual(visualType);\n\t    };\n\t\n\t\n\t    var updateMethods = {\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        update: function (payload) {\n\t            // console.time && console.time('update');\n\t\n\t            var ecModel = this._model;\n\t            var api = this._api;\n\t            var coordSysMgr = this._coordSysMgr;\n\t            var zr = this._zr;\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            // Fixme First time update ?\n\t            ecModel.restoreData();\n\t\n\t            // TODO\n\t            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n\t            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\t\n\t            // Create new coordinate system each update\n\t            // In LineView may save the old coordinate system and use it to get the orignal point\n\t            coordSysMgr.create(this._model, this._api);\n\t\n\t            processData.call(this, ecModel, api);\n\t\n\t            stackSeriesData.call(this, ecModel);\n\t\n\t            coordSysMgr.update(ecModel, api);\n\t\n\t            doVisualEncoding.call(this, ecModel, payload);\n\t\n\t            doRender.call(this, ecModel, payload);\n\t\n\t            // Set background\n\t            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\t\n\t            var painter = zr.painter;\n\t            // TODO all use clearColor ?\n\t            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n\t                zr.configLayer(0, {\n\t                    clearColor: backgroundColor\n\t                });\n\t            }\n\t            else {\n\t                // In IE8\n\t                if (!env.canvasSupported) {\n\t                    var colorArr = colorTool.parse(backgroundColor);\n\t                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n\t                    if (colorArr[3] === 0) {\n\t                        backgroundColor = 'transparent';\n\t                    }\n\t                }\n\t                if (backgroundColor.colorStops || backgroundColor.image) {\n\t                    // Gradient background\n\t                    // FIXME Fixed layer\n\t                    zr.configLayer(0, {\n\t                        clearColor: backgroundColor\n\t                    });\n\t                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\t\n\t                    this._dom.style.background = 'transparent';\n\t                }\n\t                else {\n\t                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n\t                        zr.configLayer(0, {\n\t                            clearColor: null\n\t                        });\n\t                    }\n\t                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\t\n\t                    this._dom.style.background = backgroundColor;\n\t                }\n\t            }\n\t\n\t            // console.time && console.timeEnd('update');\n\t        },\n\t\n\t        // PENDING\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        updateView: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                seriesModel.getData().clearAllVisual();\n\t            });\n\t\n\t            doVisualEncoding.call(this, ecModel, payload);\n\t\n\t            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        updateVisual: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                seriesModel.getData().clearAllVisual();\n\t            });\n\t\n\t            doVisualEncoding.call(this, ecModel, payload);\n\t\n\t            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        updateLayout: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            doLayout.call(this, ecModel, payload);\n\t\n\t            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        highlight: function (payload) {\n\t            toggleHighlight.call(this, 'highlight', payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        downplay: function (payload) {\n\t            toggleHighlight.call(this, 'downplay', payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        prepareAndUpdate: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            prepareView.call(this, 'component', ecModel);\n\t\n\t            prepareView.call(this, 'chart', ecModel);\n\t\n\t            updateMethods.update.call(this, payload);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {Object} payload\n\t     * @private\n\t     */\n\t    function toggleHighlight(method, payload) {\n\t        var ecModel = this._model;\n\t\n\t        // dispatchAction before setOption\n\t        if (!ecModel) {\n\t            return;\n\t        }\n\t\n\t        ecModel.eachComponent(\n\t            {mainType: 'series', query: payload},\n\t            function (seriesModel, index) {\n\t                var chartView = this._chartsMap[seriesModel.__viewId];\n\t                if (chartView && chartView.__alive) {\n\t                    chartView[method](\n\t                        seriesModel, ecModel, this._api, payload\n\t                    );\n\t                }\n\t            },\n\t            this\n\t        );\n\t    }\n\t\n\t    /**\n\t     * Resize the chart\n\t     * @param {Object} opts\n\t     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     */\n\t    echartsProto.resize = function (opts) {\n\t        if (false) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = true;\n\t\n\t        this._zr.resize(opts);\n\t\n\t        var optionChanged = this._model && this._model.resetOption('media');\n\t        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);\n\t\n\t        // Resize loading effect\n\t        this._loadingFX && this._loadingFX.resize();\n\t\n\t        this[IN_MAIN_PROCESS] = false;\n\t\n\t        this._flushPendingActions();\n\t    };\n\t\n\t    /**\n\t     * Show loading effect\n\t     * @param  {string} [name='default']\n\t     * @param  {Object} [cfg]\n\t     */\n\t    echartsProto.showLoading = function (name, cfg) {\n\t        if (zrUtil.isObject(name)) {\n\t            cfg = name;\n\t            name = '';\n\t        }\n\t        name = name || 'default';\n\t\n\t        this.hideLoading();\n\t        if (!loadingEffects[name]) {\n\t            if (false) {\n\t                console.warn('Loading effects ' + name + ' not exists.');\n\t            }\n\t            return;\n\t        }\n\t        var el = loadingEffects[name](this._api, cfg);\n\t        var zr = this._zr;\n\t        this._loadingFX = el;\n\t\n\t        zr.add(el);\n\t    };\n\t\n\t    /**\n\t     * Hide loading effect\n\t     */\n\t    echartsProto.hideLoading = function () {\n\t        this._loadingFX && this._zr.remove(this._loadingFX);\n\t        this._loadingFX = null;\n\t    };\n\t\n\t    /**\n\t     * @param {Object} eventObj\n\t     * @return {Object}\n\t     */\n\t    echartsProto.makeActionFromEvent = function (eventObj) {\n\t        var payload = zrUtil.extend({}, eventObj);\n\t        payload.type = eventActionMap[eventObj.type];\n\t        return payload;\n\t    };\n\t\n\t    /**\n\t     * @pubilc\n\t     * @param {Object} payload\n\t     * @param {string} [payload.type] Action type\n\t     * @param {boolean} [silent=false] Whether trigger event.\n\t     */\n\t    echartsProto.dispatchAction = function (payload, silent) {\n\t        var actionWrap = actions[payload.type];\n\t        if (!actionWrap) {\n\t            return;\n\t        }\n\t\n\t        var actionInfo = actionWrap.actionInfo;\n\t        var updateMethod = actionInfo.update || 'update';\n\t\n\t        // if (__DEV__) {\n\t        //     zrUtil.assert(\n\t        //         !this[IN_MAIN_PROCESS],\n\t        //         '`dispatchAction` should not be called during main process.'\n\t        //         + 'unless updateMathod is \"none\".'\n\t        //     );\n\t        // }\n\t\n\t        // May dispatchAction in rendering procedure\n\t        if (this[IN_MAIN_PROCESS]) {\n\t            this._pendingActions.push(payload);\n\t            return;\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = true;\n\t\n\t        var payloads = [payload];\n\t        var batched = false;\n\t        // Batch action\n\t        if (payload.batch) {\n\t            batched = true;\n\t            payloads = zrUtil.map(payload.batch, function (item) {\n\t                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n\t                item.batch = null;\n\t                return item;\n\t            });\n\t        }\n\t\n\t        var eventObjBatch = [];\n\t        var eventObj;\n\t        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';\n\t        for (var i = 0; i < payloads.length; i++) {\n\t            var batchItem = payloads[i];\n\t            // Action can specify the event by return it.\n\t            eventObj = actionWrap.action(batchItem, this._model);\n\t            // Emit event outside\n\t            eventObj = eventObj || zrUtil.extend({}, batchItem);\n\t            // Convert type to eventType\n\t            eventObj.type = actionInfo.event || eventObj.type;\n\t            eventObjBatch.push(eventObj);\n\t\n\t            // Highlight and downplay are special.\n\t            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);\n\t        }\n\t\n\t        if (updateMethod !== 'none' && !isHighlightOrDownplay) {\n\t            // Still dirty\n\t            if (this[OPTION_UPDATED]) {\n\t                // FIXME Pass payload ?\n\t                updateMethods.prepareAndUpdate.call(this, payload);\n\t                this[OPTION_UPDATED] = false;\n\t            }\n\t            else {\n\t                updateMethods[updateMethod].call(this, payload);\n\t            }\n\t        }\n\t\n\t        // Follow the rule of action batch\n\t        if (batched) {\n\t            eventObj = {\n\t                type: actionInfo.event || payload.type,\n\t                batch: eventObjBatch\n\t            };\n\t        }\n\t        else {\n\t            eventObj = eventObjBatch[0];\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = false;\n\t\n\t        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n\t\n\t        this._flushPendingActions();\n\t\n\t    };\n\t\n\t    echartsProto._flushPendingActions = function () {\n\t        var pendingActions = this._pendingActions;\n\t        while (pendingActions.length) {\n\t            var payload = pendingActions.shift();\n\t            this.dispatchAction(payload);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Register event\n\t     * @method\n\t     */\n\t    echartsProto.on = createRegisterEventWithLowercaseName('on');\n\t    echartsProto.off = createRegisterEventWithLowercaseName('off');\n\t    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\t\n\t    /**\n\t     * @param {string} methodName\n\t     * @private\n\t     */\n\t    function invokeUpdateMethod(methodName, ecModel, payload) {\n\t        var api = this._api;\n\t\n\t        // Update all components\n\t        each(this._componentsViews, function (component) {\n\t            var componentModel = component.__model;\n\t            component[methodName](componentModel, ecModel, api, payload);\n\t\n\t            updateZ(componentModel, component);\n\t        }, this);\n\t\n\t        // Upate all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chart = this._chartsMap[seriesModel.__viewId];\n\t            chart[methodName](seriesModel, ecModel, api, payload);\n\t\n\t            updateZ(seriesModel, chart);\n\t\n\t            updateProgressiveAndBlend(seriesModel, chart);\n\t        }, this);\n\t\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t    }\n\t\n\t    /**\n\t     * Prepare view instances of charts and components\n\t     * @param  {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function prepareView(type, ecModel) {\n\t        var isComponent = type === 'component';\n\t        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n\t        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n\t        var zr = this._zr;\n\t\n\t        for (var i = 0; i < viewList.length; i++) {\n\t            viewList[i].__alive = false;\n\t        }\n\t\n\t        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n\t            if (isComponent) {\n\t                if (componentType === 'series') {\n\t                    return;\n\t                }\n\t            }\n\t            else {\n\t                model = componentType;\n\t            }\n\t\n\t            // Consider: id same and type changed.\n\t            var viewId = model.id + '_' + model.type;\n\t            var view = viewMap[viewId];\n\t            if (!view) {\n\t                var classType = ComponentModel.parseClassType(model.type);\n\t                var Clazz = isComponent\n\t                    ? ComponentView.getClass(classType.main, classType.sub)\n\t                    : ChartView.getClass(classType.sub);\n\t                if (Clazz) {\n\t                    view = new Clazz();\n\t                    view.init(ecModel, this._api);\n\t                    viewMap[viewId] = view;\n\t                    viewList.push(view);\n\t                    zr.add(view.group);\n\t                }\n\t                else {\n\t                    // Error\n\t                    return;\n\t                }\n\t            }\n\t\n\t            model.__viewId = viewId;\n\t            view.__alive = true;\n\t            view.__id = viewId;\n\t            view.__model = model;\n\t        }, this);\n\t\n\t        for (var i = 0; i < viewList.length;) {\n\t            var view = viewList[i];\n\t            if (!view.__alive) {\n\t                zr.remove(view.group);\n\t                view.dispose(ecModel, this._api);\n\t                viewList.splice(i, 1);\n\t                delete viewMap[view.__id];\n\t            }\n\t            else {\n\t                i++;\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Processor data in each series\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function processData(ecModel, api) {\n\t        each(dataProcessorFuncs, function (process) {\n\t            process.func(ecModel, api);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    function stackSeriesData(ecModel) {\n\t        var stackedDataMap = {};\n\t        ecModel.eachSeries(function (series) {\n\t            var stack = series.get('stack');\n\t            var data = series.getData();\n\t            if (stack && data.type === 'list') {\n\t                var previousStack = stackedDataMap[stack];\n\t                if (previousStack) {\n\t                    data.stackedOn = previousStack;\n\t                }\n\t                stackedDataMap[stack] = data;\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Layout before each chart render there series, special visual encoding stage\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doLayout(ecModel, payload) {\n\t        var api = this._api;\n\t        each(visualFuncs, function (visual) {\n\t            if (visual.isLayout) {\n\t                visual.func(ecModel, api, payload);\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Encode visual infomation from data after data processing\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doVisualEncoding(ecModel, payload) {\n\t        var api = this._api;\n\t        ecModel.clearColorPalette();\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            seriesModel.clearColorPalette();\n\t        });\n\t        each(visualFuncs, function (visual) {\n\t            visual.func(ecModel, api, payload);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Render each chart and component\n\t     * @private\n\t     */\n\t    function doRender(ecModel, payload) {\n\t        var api = this._api;\n\t        // Render all components\n\t        each(this._componentsViews, function (componentView) {\n\t            var componentModel = componentView.__model;\n\t            componentView.render(componentModel, ecModel, api, payload);\n\t\n\t            updateZ(componentModel, componentView);\n\t        }, this);\n\t\n\t        each(this._chartsViews, function (chart) {\n\t            chart.__alive = false;\n\t        }, this);\n\t\n\t        // Render all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chartView = this._chartsMap[seriesModel.__viewId];\n\t            chartView.__alive = true;\n\t            chartView.render(seriesModel, ecModel, api, payload);\n\t\n\t            chartView.group.silent = !!seriesModel.get('silent');\n\t\n\t            updateZ(seriesModel, chartView);\n\t\n\t            updateProgressiveAndBlend(seriesModel, chartView);\n\t\n\t        }, this);\n\t\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t\n\t        // Remove groups of unrendered charts\n\t        each(this._chartsViews, function (chart) {\n\t            if (!chart.__alive) {\n\t                chart.remove(ecModel, api);\n\t            }\n\t        }, this);\n\t    }\n\t\n\t    var MOUSE_EVENT_NAMES = [\n\t        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n\t        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n\t    ];\n\t    /**\n\t     * @private\n\t     */\n\t    echartsProto._initEvents = function () {\n\t        each(MOUSE_EVENT_NAMES, function (eveName) {\n\t            this._zr.on(eveName, function (e) {\n\t                var ecModel = this.getModel();\n\t                var el = e.target;\n\t                var params;\n\t\n\t                // no e.target when 'globalout'.\n\t                if (eveName === 'globalout') {\n\t                    params = {};\n\t                }\n\t                else if (el && el.dataIndex != null) {\n\t                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n\t                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n\t                }\n\t                // If element has custom eventData of components\n\t                else if (el && el.eventData) {\n\t                    params = zrUtil.extend({}, el.eventData);\n\t                }\n\t\n\t                if (params) {\n\t                    params.event = e;\n\t                    params.type = eveName;\n\t                    this.trigger(eveName, params);\n\t                }\n\t\n\t            }, this);\n\t        }, this);\n\t\n\t        each(eventActionMap, function (actionType, eventType) {\n\t            this._messageCenter.on(eventType, function (event) {\n\t                this.trigger(eventType, event);\n\t            }, this);\n\t        }, this);\n\t    };\n\t\n\t    /**\n\t     * @return {boolean}\n\t     */\n\t    echartsProto.isDisposed = function () {\n\t        return this._disposed;\n\t    };\n\t\n\t    /**\n\t     * Clear\n\t     */\n\t    echartsProto.clear = function () {\n\t        this.setOption({ series: [] }, true);\n\t    };\n\t    /**\n\t     * Dispose instance\n\t     */\n\t    echartsProto.dispose = function () {\n\t        if (this._disposed) {\n\t            if (false) {\n\t                console.warn('Instance ' + this.id + ' has been disposed');\n\t            }\n\t            return;\n\t        }\n\t        this._disposed = true;\n\t\n\t        var api = this._api;\n\t        var ecModel = this._model;\n\t\n\t        each(this._componentsViews, function (component) {\n\t            component.dispose(ecModel, api);\n\t        });\n\t        each(this._chartsViews, function (chart) {\n\t            chart.dispose(ecModel, api);\n\t        });\n\t\n\t        // Dispose after all views disposed\n\t        this._zr.dispose();\n\t\n\t        delete instances[this.id];\n\t    };\n\t\n\t    zrUtil.mixin(ECharts, Eventful);\n\t\n\t    function updateHoverLayerStatus(zr, ecModel) {\n\t        var storage = zr.storage;\n\t        var elCount = 0;\n\t        storage.traverse(function (el) {\n\t            if (!el.isGroup) {\n\t                elCount++;\n\t            }\n\t        });\n\t        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n\t            storage.traverse(function (el) {\n\t                if (!el.isGroup) {\n\t                    el.useHoverLayer = true;\n\t                }\n\t            });\n\t        }\n\t    }\n\t    /**\n\t     * Update chart progressive and blend.\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateProgressiveAndBlend(seriesModel, chartView) {\n\t        // Progressive configuration\n\t        var elCount = 0;\n\t        chartView.group.traverse(function (el) {\n\t            if (el.type !== 'group' && !el.ignore) {\n\t                elCount++;\n\t            }\n\t        });\n\t        var frameDrawNum = +seriesModel.get('progressive');\n\t        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n\t        if (needProgressive) {\n\t            chartView.group.traverse(function (el) {\n\t                // FIXME marker and other components\n\t                if (!el.isGroup) {\n\t                    el.progressive = needProgressive ?\n\t                        Math.floor(elCount++ / frameDrawNum) : -1;\n\t                    if (needProgressive) {\n\t                        el.stopAnimation(true);\n\t                    }\n\t                }\n\t            });\n\t        }\n\t\n\t        // Blend configration\n\t        var blendMode = seriesModel.get('blendMode') || null;\n\t        if (false) {\n\t            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n\t                console.warn('Only canvas support blendMode');\n\t            }\n\t        }\n\t        chartView.group.traverse(function (el) {\n\t            // FIXME marker and other components\n\t            if (!el.isGroup) {\n\t                el.setStyle('blend', blendMode);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateZ(model, view) {\n\t        var z = model.get('z');\n\t        var zlevel = model.get('zlevel');\n\t        // Set z and zlevel\n\t        view.group.traverse(function (el) {\n\t            if (el.type !== 'group') {\n\t                z != null && (el.z = z);\n\t                zlevel != null && (el.zlevel = zlevel);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var actions = [];\n\t\n\t    /**\n\t     * Map eventType to actionType\n\t     * @type {Object}\n\t     */\n\t    var eventActionMap = {};\n\t\n\t    /**\n\t     * Data processor functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var dataProcessorFuncs = [];\n\t\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var optionPreprocessorFuncs = [];\n\t\n\t    /**\n\t     * Visual encoding functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var visualFuncs = [];\n\t    /**\n\t     * Theme storage\n\t     * @type {Object.<key, Object>}\n\t     */\n\t    var themeStorage = {};\n\t    /**\n\t     * Loading effects\n\t     */\n\t    var loadingEffects = {};\n\t\n\t\n\t    var instances = {};\n\t    var connectedGroups = {};\n\t\n\t    var idBase = new Date() - 0;\n\t    var groupIdBase = new Date() - 0;\n\t    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\t    /**\n\t     * @alias module:echarts\n\t     */\n\t    var echarts = {\n\t        /**\n\t         * @type {number}\n\t         */\n\t        version: '3.3.1',\n\t        dependencies: {\n\t            zrender: '3.2.1'\n\t        }\n\t    };\n\t\n\t    function enableConnect(chart) {\n\t\n\t        var STATUS_PENDING = 0;\n\t        var STATUS_UPDATING = 1;\n\t        var STATUS_UPDATED = 2;\n\t        var STATUS_KEY = '__connectUpdateStatus';\n\t        function updateConnectedChartsStatus(charts, status) {\n\t            for (var i = 0; i < charts.length; i++) {\n\t                var otherChart = charts[i];\n\t                otherChart[STATUS_KEY] = status;\n\t            }\n\t        }\n\t        zrUtil.each(eventActionMap, function (actionType, eventType) {\n\t            chart._messageCenter.on(eventType, function (event) {\n\t                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n\t                    var action = chart.makeActionFromEvent(event);\n\t                    var otherCharts = [];\n\t\n\t                    zrUtil.each(instances, function (otherChart) {\n\t                        if (otherChart !== chart && otherChart.group === chart.group) {\n\t                            otherCharts.push(otherChart);\n\t                        }\n\t                    });\n\t\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n\t                    each(otherCharts, function (otherChart) {\n\t                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n\t                            otherChart.dispatchAction(action);\n\t                        }\n\t                    });\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n\t                }\n\t            });\n\t        });\n\t\n\t    }\n\t    /**\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} [theme]\n\t     * @param {Object} opts\n\t     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n\t     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n\t     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n\t     *                              Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n\t     *                               Can be 'auto' (the same as null/undefined)\n\t     */\n\t    echarts.init = function (dom, theme, opts) {\n\t        if (false) {\n\t            // Check version\n\t            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n\t                throw new Error(\n\t                    'ZRender ' + zrender.version\n\t                    + ' is too old for ECharts ' + echarts.version\n\t                    + '. Current version need ZRender '\n\t                    + echarts.dependencies.zrender + '+'\n\t                );\n\t            }\n\t            if (!dom) {\n\t                throw new Error('Initialize failed: invalid dom.');\n\t            }\n\t            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n\t                console.warn('Can\\'t get dom width or height');\n\t            }\n\t        }\n\t\n\t        var chart = new ECharts(dom, theme, opts);\n\t        chart.id = 'ec_' + idBase++;\n\t        instances[chart.id] = chart;\n\t\n\t        dom.setAttribute &&\n\t            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\t\n\t        enableConnect(chart);\n\t\n\t        return chart;\n\t    };\n\t\n\t    /**\n\t     * @return {string|Array.<module:echarts~ECharts>} groupId\n\t     */\n\t    echarts.connect = function (groupId) {\n\t        // Is array of charts\n\t        if (zrUtil.isArray(groupId)) {\n\t            var charts = groupId;\n\t            groupId = null;\n\t            // If any chart has group\n\t            zrUtil.each(charts, function (chart) {\n\t                if (chart.group != null) {\n\t                    groupId = chart.group;\n\t                }\n\t            });\n\t            groupId = groupId || ('g_' + groupIdBase++);\n\t            zrUtil.each(charts, function (chart) {\n\t                chart.group = groupId;\n\t            });\n\t        }\n\t        connectedGroups[groupId] = true;\n\t        return groupId;\n\t    };\n\t\n\t    /**\n\t     * @return {string} groupId\n\t     */\n\t    echarts.disConnect = function (groupId) {\n\t        connectedGroups[groupId] = false;\n\t    };\n\t\n\t    /**\n\t     * Dispose a chart instance\n\t     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n\t     */\n\t    echarts.dispose = function (chart) {\n\t        if (zrUtil.isDom(chart)) {\n\t            chart = echarts.getInstanceByDom(chart);\n\t        }\n\t        else if (typeof chart === 'string') {\n\t            chart = instances[chart];\n\t        }\n\t        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n\t            chart.dispose();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param  {HTMLDomElement} dom\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceByDom = function (dom) {\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n\t        return instances[key];\n\t    };\n\t    /**\n\t     * @param {string} key\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceById = function (key) {\n\t        return instances[key];\n\t    };\n\t\n\t    /**\n\t     * Register theme\n\t     */\n\t    echarts.registerTheme = function (name, theme) {\n\t        themeStorage[name] = theme;\n\t    };\n\t\n\t    /**\n\t     * Register option preprocessor\n\t     * @param {Function} preprocessorFunc\n\t     */\n\t    echarts.registerPreprocessor = function (preprocessorFunc) {\n\t        optionPreprocessorFuncs.push(preprocessorFunc);\n\t    };\n\t\n\t    /**\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} processorFunc\n\t     */\n\t    echarts.registerProcessor = function (priority, processorFunc) {\n\t        if (typeof priority === 'function') {\n\t            processorFunc = priority;\n\t            priority = PRIORITY_PROCESSOR_FILTER;\n\t        }\n\t        if (false) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown processor priority');\n\t            }\n\t        }\n\t        dataProcessorFuncs.push({\n\t            prio: priority,\n\t            func: processorFunc\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Usage:\n\t     * registerAction('someAction', 'someEvent', function () { ... });\n\t     * registerAction('someAction', function () { ... });\n\t     * registerAction(\n\t     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n\t     *     function () { ... }\n\t     * );\n\t     *\n\t     * @param {(string|Object)} actionInfo\n\t     * @param {string} actionInfo.type\n\t     * @param {string} [actionInfo.event]\n\t     * @param {string} [actionInfo.update]\n\t     * @param {string} [eventName]\n\t     * @param {Function} action\n\t     */\n\t    echarts.registerAction = function (actionInfo, eventName, action) {\n\t        if (typeof eventName === 'function') {\n\t            action = eventName;\n\t            eventName = '';\n\t        }\n\t        var actionType = zrUtil.isObject(actionInfo)\n\t            ? actionInfo.type\n\t            : ([actionInfo, actionInfo = {\n\t                event: eventName\n\t            }][0]);\n\t\n\t        // Event name is all lowercase\n\t        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n\t        eventName = actionInfo.event;\n\t\n\t        if (!actions[actionType]) {\n\t            actions[actionType] = {action: action, actionInfo: actionInfo};\n\t        }\n\t        eventActionMap[eventName] = actionType;\n\t    };\n\t\n\t    /**\n\t     * @param {string} type\n\t     * @param {*} CoordinateSystem\n\t     */\n\t    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n\t        CoordinateSystemManager.register(type, CoordinateSystem);\n\t    };\n\t\n\t    /**\n\t     * Layout is a special stage of visual encoding\n\t     * Most visual encoding like color are common for different chart\n\t     * But each chart has it's own layout algorithm\n\t     *\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} layoutFunc\n\t     */\n\t    echarts.registerLayout = function (priority, layoutFunc) {\n\t        if (typeof priority === 'function') {\n\t            layoutFunc = priority;\n\t            priority = PRIORITY_VISUAL_LAYOUT;\n\t        }\n\t        if (false) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown layout priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: layoutFunc,\n\t            isLayout: true\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @param {number} [priority=3000]\n\t     * @param {Function} visualFunc\n\t     */\n\t    echarts.registerVisual = function (priority, visualFunc) {\n\t        if (typeof priority === 'function') {\n\t            visualFunc = priority;\n\t            priority = PRIORITY_VISUAL_CHART;\n\t        }\n\t        if (false) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown visual priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: visualFunc\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @param {string} name\n\t     */\n\t    echarts.registerLoading = function (name, loadingFx) {\n\t        loadingEffects[name] = loadingFx;\n\t    };\n\t\n\t\n\t    var parseClassType = ComponentModel.parseClassType;\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentModel = function (opts, superClass) {\n\t        var Clazz = ComponentModel;\n\t        if (superClass) {\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentView = function (opts, superClass) {\n\t        var Clazz = ComponentView;\n\t        if (superClass) {\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendSeriesModel = function (opts, superClass) {\n\t        var Clazz = SeriesModel;\n\t        if (superClass) {\n\t            superClass = 'series.' + superClass.replace('series.', '');\n\t            var classType = parseClassType(superClass);\n\t            Clazz = SeriesModel.getClass(classType.main, classType.sub, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendChartView = function (opts, superClass) {\n\t        var Clazz = ChartView;\n\t        if (superClass) {\n\t            superClass.replace('series.', '');\n\t            var classType = parseClassType(superClass);\n\t            Clazz = ChartView.getClass(classType.main, true);\n\t        }\n\t        return Clazz.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * ZRender need a canvas context to do measureText.\n\t     * But in node environment canvas may be created by node-canvas.\n\t     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n\t     *\n\t     * Be careful of using it in the browser.\n\t     *\n\t     * @param {Function} creator\n\t     * @example\n\t     *     var Canvas = require('canvas');\n\t     *     var echarts = require('echarts');\n\t     *     echarts.setCanvasCreator(function () {\n\t     *         // Small size is enough.\n\t     *         return new Canvas(32, 32);\n\t     *     });\n\t     */\n\t    echarts.setCanvasCreator = function (creator) {\n\t        zrUtil.createCanvas = creator;\n\t    };\n\t\n\t    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, __webpack_require__(/*! ./visual/seriesColor */ 138));\n\t    echarts.registerPreprocessor(__webpack_require__(/*! ./preprocessor/backwardCompat */ 132));\n\t    echarts.registerLoading('default', __webpack_require__(/*! ./loading/default */ 123));\n\t\n\t    // Default action\n\t    echarts.registerAction({\n\t        type: 'highlight',\n\t        event: 'highlight',\n\t        update: 'highlight'\n\t    }, zrUtil.noop);\n\t    echarts.registerAction({\n\t        type: 'downplay',\n\t        event: 'downplay',\n\t        update: 'downplay'\n\t    }, zrUtil.noop);\n\t\n\t\n\t    // --------\n\t    // Exports\n\t    // --------\n\t    //\n\t    echarts.List = __webpack_require__(/*! ./data/List */ 14);\n\t    echarts.Model = __webpack_require__(/*! ./model/Model */ 10);\n\t\n\t    echarts.graphic = __webpack_require__(/*! ./util/graphic */ 3);\n\t    echarts.number = __webpack_require__(/*! ./util/number */ 4);\n\t    echarts.format = __webpack_require__(/*! ./util/format */ 9);\n\t    echarts.matrix = __webpack_require__(/*! zrender/lib/core/matrix */ 19);\n\t    echarts.vector = __webpack_require__(/*! zrender/lib/core/vector */ 5);\n\t    echarts.color = __webpack_require__(/*! zrender/lib/tool/color */ 18);\n\t\n\t    echarts.util = {};\n\t    each([\n\t            'map', 'each', 'filter', 'indexOf', 'inherits',\n\t            'reduce', 'filter', 'bind', 'curry', 'isArray',\n\t            'isString', 'isObject', 'isFunction', 'extend', 'defaults'\n\t        ],\n\t        function (name) {\n\t            echarts.util[name] = zrUtil[name];\n\t        }\n\t    );\n\t\n\t    // PRIORITY\n\t    echarts.PRIORITY = {\n\t        PROCESSOR: {\n\t            FILTER: PRIORITY_PROCESSOR_FILTER,\n\t            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n\t        },\n\t        VISUAL: {\n\t            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n\t            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n\t            CHART: PRIORITY_VISUAL_CHART,\n\t            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n\t            BRUSH: PRIORITY_VISUAL_BRUSH\n\t        }\n\t    };\n\t\n\t    module.exports = echarts;\n\n\n/***/ },\n/* 3 */\n/*!*****************************!*\\\n  !*** ./lib/util/graphic.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var pathTool = __webpack_require__(/*! zrender/lib/tool/path */ 168);\n\t    var round = Math.round;\n\t    var Path = __webpack_require__(/*! zrender/lib/graphic/Path */ 6);\n\t    var colorTool = __webpack_require__(/*! zrender/lib/tool/color */ 18);\n\t    var matrix = __webpack_require__(/*! zrender/lib/core/matrix */ 19);\n\t    var vector = __webpack_require__(/*! zrender/lib/core/vector */ 5);\n\t    var Gradient = __webpack_require__(/*! zrender/lib/graphic/Gradient */ 29);\n\t\n\t    var graphic = {};\n\t\n\t    graphic.Group = __webpack_require__(/*! zrender/lib/container/Group */ 34);\n\t\n\t    graphic.Image = __webpack_require__(/*! zrender/lib/graphic/Image */ 48);\n\t\n\t    graphic.Text = __webpack_require__(/*! zrender/lib/graphic/Text */ 74);\n\t\n\t    graphic.Circle = __webpack_require__(/*! zrender/lib/graphic/shape/Circle */ 159);\n\t\n\t    graphic.Sector = __webpack_require__(/*! zrender/lib/graphic/shape/Sector */ 165);\n\t\n\t    graphic.Ring = __webpack_require__(/*! zrender/lib/graphic/shape/Ring */ 164);\n\t\n\t    graphic.Polygon = __webpack_require__(/*! zrender/lib/graphic/shape/Polygon */ 161);\n\t\n\t    graphic.Polyline = __webpack_require__(/*! zrender/lib/graphic/shape/Polyline */ 162);\n\t\n\t    graphic.Rect = __webpack_require__(/*! zrender/lib/graphic/shape/Rect */ 163);\n\t\n\t    graphic.Line = __webpack_require__(/*! zrender/lib/graphic/shape/Line */ 160);\n\t\n\t    graphic.BezierCurve = __webpack_require__(/*! zrender/lib/graphic/shape/BezierCurve */ 158);\n\t\n\t    graphic.Arc = __webpack_require__(/*! zrender/lib/graphic/shape/Arc */ 157);\n\t\n\t    graphic.CompoundPath = __webpack_require__(/*! zrender/lib/graphic/CompoundPath */ 152);\n\t\n\t    graphic.LinearGradient = __webpack_require__(/*! zrender/lib/graphic/LinearGradient */ 87);\n\t\n\t    graphic.RadialGradient = __webpack_require__(/*! zrender/lib/graphic/RadialGradient */ 153);\n\t\n\t    graphic.BoundingRect = __webpack_require__(/*! zrender/lib/core/BoundingRect */ 8);\n\t\n\t    /**\n\t     * Extend shape with parameters\n\t     */\n\t    graphic.extendShape = function (opts) {\n\t        return Path.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * Extend path\n\t     */\n\t    graphic.extendPath = function (pathData, opts) {\n\t        return pathTool.extendFromString(pathData, opts);\n\t    };\n\t\n\t    /**\n\t     * Create a path element from path data string\n\t     * @param {string} pathData\n\t     * @param {Object} opts\n\t     * @param {module:zrender/core/BoundingRect} rect\n\t     * @param {string} [layout=cover] 'center' or 'cover'\n\t     */\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\n\t        var path = pathTool.createFromString(pathData, opts);\n\t        var boundingRect = path.getBoundingRect();\n\t        if (rect) {\n\t            var aspect = boundingRect.width / boundingRect.height;\n\t\n\t            if (layout === 'center') {\n\t                // Set rect to center, keep width / height ratio.\n\t                var width = rect.height * aspect;\n\t                var height;\n\t                if (width <= rect.width) {\n\t                    height = rect.height;\n\t                }\n\t                else {\n\t                    width = rect.width;\n\t                    height = width / aspect;\n\t                }\n\t                var cx = rect.x + rect.width / 2;\n\t                var cy = rect.y + rect.height / 2;\n\t\n\t                rect.x = cx - width / 2;\n\t                rect.y = cy - height / 2;\n\t                rect.width = width;\n\t                rect.height = height;\n\t            }\n\t\n\t            this.resizePath(path, rect);\n\t        }\n\t        return path;\n\t    };\n\t\n\t    graphic.mergePath = pathTool.mergePath,\n\t\n\t    /**\n\t     * Resize a path to fit the rect\n\t     * @param {module:zrender/graphic/Path} path\n\t     * @param {Object} rect\n\t     */\n\t    graphic.resizePath = function (path, rect) {\n\t        if (!path.applyTransform) {\n\t            return;\n\t        }\n\t\n\t        var pathRect = path.getBoundingRect();\n\t\n\t        var m = pathRect.calculateTransform(rect);\n\t\n\t        path.applyTransform(m);\n\t    };\n\t\n\t    /**\n\t     * Sub pixel optimize line for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x1]\n\t     * @param {number} [param.shape.y1]\n\t     * @param {number} [param.shape.x2]\n\t     * @param {number} [param.shape.y2]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeLine = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n\t        }\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n\t        }\n\t        return param;\n\t    };\n\t\n\t    /**\n\t     * Sub pixel optimize rect for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x]\n\t     * @param {number} [param.shape.y]\n\t     * @param {number} [param.shape.width]\n\t     * @param {number} [param.shape.height]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeRect = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t        var originX = shape.x;\n\t        var originY = shape.y;\n\t        var originWidth = shape.width;\n\t        var originHeight = shape.height;\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n\t        shape.width = Math.max(\n\t            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n\t            originWidth === 0 ? 0 : 1\n\t        );\n\t        shape.height = Math.max(\n\t            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n\t            originHeight === 0 ? 0 : 1\n\t        );\n\t        return param;\n\t    };\n\t\n\t    /**\n\t     * Sub pixel optimize for canvas\n\t     *\n\t     * @param {number} position Coordinate, such as x, y\n\t     * @param {number} lineWidth Should be nonnegative integer.\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\n\t     * @return {number} Optimized position.\n\t     */\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\n\t        // otherwise line will be fuzzy in canvas.\n\t        var doubledPosition = round(position * 2);\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0\n\t            ? doubledPosition / 2\n\t            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n\t    };\n\t\n\t    function hasFillOrStroke(fillOrStroke) {\n\t        return fillOrStroke != null && fillOrStroke != 'none';\n\t    }\n\t\n\t    function liftColor(color) {\n\t        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    function cacheElementStl(el) {\n\t        if (el.__hoverStlDirty) {\n\t            var stroke = el.style.stroke;\n\t            var fill = el.style.fill;\n\t\n\t            // Create hoverStyle on mouseover\n\t            var hoverStyle = el.__hoverStl;\n\t            hoverStyle.fill = hoverStyle.fill\n\t                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n\t            hoverStyle.stroke = hoverStyle.stroke\n\t                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\t\n\t            var normalStyle = {};\n\t            for (var name in hoverStyle) {\n\t                if (hoverStyle.hasOwnProperty(name)) {\n\t                    normalStyle[name] = el.style[name];\n\t                }\n\t            }\n\t\n\t            el.__normalStl = normalStyle;\n\t\n\t            el.__hoverStlDirty = false;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    function doSingleEnterHover(el) {\n\t        if (el.__isHover) {\n\t            return;\n\t        }\n\t\n\t        cacheElementStl(el);\n\t\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n\t        }\n\t        else {\n\t            el.setStyle(el.__hoverStl);\n\t            el.z2 += 1;\n\t        }\n\t\n\t        el.__isHover = true;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function doSingleLeaveHover(el) {\n\t        if (!el.__isHover) {\n\t            return;\n\t        }\n\t\n\t        var normalStl = el.__normalStl;\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.removeHover(el);\n\t        }\n\t        else {\n\t            normalStl && el.setStyle(normalStl);\n\t            el.z2 -= 1;\n\t        }\n\t\n\t        el.__isHover = false;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function doEnterHover(el) {\n\t        el.type === 'group'\n\t            ? el.traverse(function (child) {\n\t                if (child.type !== 'group') {\n\t                    doSingleEnterHover(child);\n\t                }\n\t            })\n\t            : doSingleEnterHover(el);\n\t    }\n\t\n\t    function doLeaveHover(el) {\n\t        el.type === 'group'\n\t            ? el.traverse(function (child) {\n\t                if (child.type !== 'group') {\n\t                    doSingleLeaveHover(child);\n\t                }\n\t            })\n\t            : doSingleLeaveHover(el);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function setElementHoverStl(el, hoverStl) {\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n\t        // Often used when item group has a label element and it's hoverStyle is different\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\n\t        el.__hoverStlDirty = true;\n\t\n\t        if (el.__isHover) {\n\t            cacheElementStl(el);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOver() {\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doEnterHover(this);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOut() {\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doLeaveHover(this);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function enterEmphasis() {\n\t        this.__isEmphasis = true;\n\t        doEnterHover(this);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function leaveEmphasis() {\n\t        this.__isEmphasis = false;\n\t        doLeaveHover(this);\n\t    }\n\t\n\t    /**\n\t     * Set hover style of element\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} [hoverStyle]\n\t     */\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\n\t        el.type === 'group'\n\t            ? el.traverse(function (child) {\n\t                if (child.type !== 'group') {\n\t                    setElementHoverStl(child, hoverStyle);\n\t                }\n\t            })\n\t            : setElementHoverStl(el, hoverStyle);\n\t        // Remove previous bound handlers\n\t        el.on('mouseover', onElementMouseOver)\n\t          .on('mouseout', onElementMouseOut);\n\t\n\t        // Emphasis, normal can be triggered manually\n\t        el.on('emphasis', enterEmphasis)\n\t          .on('normal', leaveEmphasis);\n\t    };\n\t\n\t    /**\n\t     * Set text option in the style\n\t     * @param {Object} textStyle\n\t     * @param {module:echarts/model/Model} labelModel\n\t     * @param {string} color\n\t     */\n\t    graphic.setText = function (textStyle, labelModel, color) {\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        zrUtil.extend(textStyle, {\n\t            textDistance: labelModel.getShallow('distance') || 5,\n\t            textFont: textStyleModel.getFont(),\n\t            textPosition: labelPosition,\n\t            textFill: textStyleModel.getTextColor() || labelColor\n\t        });\n\t    };\n\t\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n\t        if (typeof dataIndex === 'function') {\n\t            cb = dataIndex;\n\t            dataIndex = null;\n\t        }\n\t        var animationEnabled = animatableModel\n\t            && (\n\t                animatableModel.ifEnableAnimation\n\t                ? animatableModel.ifEnableAnimation()\n\t                // Directly use animation property\n\t                : animatableModel.getShallow('animation')\n\t            );\n\t\n\t        if (animationEnabled) {\n\t            var postfix = isUpdate ? 'Update' : '';\n\t            var duration = animatableModel\n\t                && animatableModel.getShallow('animationDuration' + postfix);\n\t            var animationEasing = animatableModel\n\t                && animatableModel.getShallow('animationEasing' + postfix);\n\t            var animationDelay = animatableModel\n\t                && animatableModel.getShallow('animationDelay' + postfix);\n\t            if (typeof animationDelay === 'function') {\n\t                animationDelay = animationDelay(dataIndex);\n\t            }\n\t            duration > 0\n\t                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n\t                : (el.attr(props), cb && cb());\n\t        }\n\t        else {\n\t            el.attr(props);\n\t            cb && cb();\n\t        }\n\t    }\n\t    /**\n\t     * Update graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} [cb]\n\t     * @example\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n\t     *     // Or\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, function () { console.log('Animation done!'); });\n\t     */\n\t    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t\n\t    /**\n\t     * Init graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} cb\n\t     */\n\t    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t\n\t    /**\n\t     * Get transform matrix of target (param target),\n\t     * in coordinate of its ancestor (param ancestor)\n\t     *\n\t     * @param {module:zrender/mixin/Transformable} target\n\t     * @param {module:zrender/mixin/Transformable} [ancestor]\n\t     */\n\t    graphic.getTransform = function (target, ancestor) {\n\t        var mat = matrix.identity([]);\n\t\n\t        while (target && target !== ancestor) {\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\n\t            target = target.parent;\n\t        }\n\t\n\t        return mat;\n\t    };\n\t\n\t    /**\n\t     * Apply transform to an vertex.\n\t     * @param {Array.<number>} vertex [x, y]\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {Array.<number>} [x, y]\n\t     */\n\t    graphic.applyTransform = function (vertex, transform, invert) {\n\t        if (invert) {\n\t            transform = matrix.invert([], transform);\n\t        }\n\t        return vector.applyTransform([], vertex, transform);\n\t    };\n\t\n\t    /**\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n\t     */\n\t    graphic.transformDirection = function (direction, transform, invert) {\n\t\n\t        // Pick a base, ensure that transform result will not be (0, 0).\n\t        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n\t            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n\t        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n\t            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\t\n\t        var vertex = [\n\t            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n\t            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n\t        ];\n\t\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\n\t\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n\t            ? (vertex[0] > 0 ? 'right' : 'left')\n\t            : (vertex[1] > 0 ? 'bottom' : 'top');\n\t    };\n\t\n\t    /**\n\t     * Apply group transition animation from g1 to g2\n\t     */\n\t    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n\t        if (!g1 || !g2) {\n\t            return;\n\t        }\n\t\n\t        function getElMap(g) {\n\t            var elMap = {};\n\t            g.traverse(function (el) {\n\t                if (!el.isGroup && el.anid) {\n\t                    elMap[el.anid] = el;\n\t                }\n\t            });\n\t            return elMap;\n\t        }\n\t        function getAnimatableProps(el) {\n\t            var obj = {\n\t                position: vector.clone(el.position),\n\t                rotation: el.rotation\n\t            };\n\t            if (el.shape) {\n\t                obj.shape = zrUtil.extend({}, el.shape);\n\t            }\n\t            return obj;\n\t        }\n\t        var elMap1 = getElMap(g1);\n\t\n\t        g2.traverse(function (el) {\n\t            if (!el.isGroup && el.anid) {\n\t                var oldEl = elMap1[el.anid];\n\t                if (oldEl) {\n\t                    var newProp = getAnimatableProps(el);\n\t                    el.attr(getAnimatableProps(oldEl));\n\t                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n\t                }\n\t                // else {\n\t                //     if (el.previousProps) {\n\t                //         graphic.updateProps\n\t                //     }\n\t                // }\n\t            }\n\t        });\n\t    };\n\t\n\t    module.exports = graphic;\n\n\n/***/ },\n/* 4 */\n/*!****************************!*\\\n  !*** ./lib/util/number.js ***!\n  \\****************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * \n\t * @module echarts/util/number\n\t */\n\t\n\t\n\t\n\t    var number = {};\n\t\n\t    var RADIAN_EPSILON = 1e-4;\n\t\n\t    function _trim(str) {\n\t        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n\t    }\n\t\n\t    /**\n\t     * Linear mapping a value from domain to range\n\t     * @memberOf module:echarts/util/number\n\t     * @param  {(number|Array.<number>)} val\n\t     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n\t     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n\t     * @param  {boolean} clamp\n\t     * @return {(number|Array.<number>}\n\t     */\n\t    number.linearMap = function (val, domain, range, clamp) {\n\t        var subDomain = domain[1] - domain[0];\n\t        var subRange = range[1] - range[0];\n\t\n\t        if (subDomain === 0) {\n\t            return subRange === 0\n\t                ? range[0]\n\t                : (range[0] + range[1]) / 2;\n\t        }\n\t\n\t        // Avoid accuracy problem in edge, such as\n\t        // 146.39 - 62.83 === 83.55999999999999.\n\t        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n\t        // It is a little verbose for efficiency considering this method\n\t        // is a hotspot.\n\t        if (clamp) {\n\t            if (subDomain > 0) {\n\t                if (val <= domain[0]) {\n\t                    return range[0];\n\t                }\n\t                else if (val >= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            }\n\t            else {\n\t                if (val >= domain[0]) {\n\t                    return range[0];\n\t                }\n\t                else if (val <= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            if (val === domain[0]) {\n\t                return range[0];\n\t            }\n\t            if (val === domain[1]) {\n\t                return range[1];\n\t            }\n\t        }\n\t\n\t        return (val - domain[0]) / subDomain * subRange + range[0];\n\t    };\n\t\n\t    /**\n\t     * Convert a percent string to absolute number.\n\t     * Returns NaN if percent is not a valid string or number\n\t     * @memberOf module:echarts/util/number\n\t     * @param {string|number} percent\n\t     * @param {number} all\n\t     * @return {number}\n\t     */\n\t    number.parsePercent = function(percent, all) {\n\t        switch (percent) {\n\t            case 'center':\n\t            case 'middle':\n\t                percent = '50%';\n\t                break;\n\t            case 'left':\n\t            case 'top':\n\t                percent = '0%';\n\t                break;\n\t            case 'right':\n\t            case 'bottom':\n\t                percent = '100%';\n\t                break;\n\t        }\n\t        if (typeof percent === 'string') {\n\t            if (_trim(percent).match(/%$/)) {\n\t                return parseFloat(percent) / 100 * all;\n\t            }\n\t\n\t            return parseFloat(percent);\n\t        }\n\t\n\t        return percent == null ? NaN : +percent;\n\t    };\n\t\n\t    /**\n\t     * Fix rounding error of float numbers\n\t     * @param {number} x\n\t     * @return {number}\n\t     */\n\t    number.round = function (x, precision) {\n\t        if (precision == null) {\n\t            precision = 10;\n\t        }\n\t        // Avoid range error\n\t        precision = Math.min(Math.max(0, precision), 20);\n\t        return +(+x).toFixed(precision);\n\t    };\n\t\n\t    number.asc = function (arr) {\n\t        arr.sort(function (a, b) {\n\t            return a - b;\n\t        });\n\t        return arr;\n\t    };\n\t\n\t    /**\n\t     * Get precision\n\t     * @param {number} val\n\t     */\n\t    number.getPrecision = function (val) {\n\t        val = +val;\n\t        if (isNaN(val)) {\n\t            return 0;\n\t        }\n\t        // It is much faster than methods converting number to string as follows\n\t        //      var tmp = val.toString();\n\t        //      return tmp.length - 1 - tmp.indexOf('.');\n\t        // especially when precision is low\n\t        var e = 1;\n\t        var count = 0;\n\t        while (Math.round(val * e) / e !== val) {\n\t            e *= 10;\n\t            count++;\n\t        }\n\t        return count;\n\t    };\n\t\n\t    number.getPrecisionSafe = function (val) {\n\t        var str = val.toString();\n\t        var dotIndex = str.indexOf('.');\n\t        if (dotIndex < 0) {\n\t            return 0;\n\t        }\n\t        return str.length - 1 - dotIndex;\n\t    };\n\t\n\t    /**\n\t     * @param {Array.<number>} dataExtent\n\t     * @param {Array.<number>} pixelExtent\n\t     * @return {number}  precision\n\t     */\n\t    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n\t        var log = Math.log;\n\t        var LN10 = Math.LN10;\n\t        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n\t        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n\t        return Math.max(\n\t            -dataQuantity + sizeQuantity,\n\t            0\n\t        );\n\t    };\n\t\n\t    // Number.MAX_SAFE_INTEGER, ie do not support.\n\t    number.MAX_SAFE_INTEGER = 9007199254740991;\n\t\n\t    /**\n\t     * To 0 - 2 * PI, considering negative radian.\n\t     * @param {number} radian\n\t     * @return {number}\n\t     */\n\t    number.remRadian = function (radian) {\n\t        var pi2 = Math.PI * 2;\n\t        return (radian % pi2 + pi2) % pi2;\n\t    };\n\t\n\t    /**\n\t     * @param {type} radian\n\t     * @return {boolean}\n\t     */\n\t    number.isRadianAroundZero = function (val) {\n\t        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n\t    };\n\t\n\t    /**\n\t     * @param {string|Date|number} value\n\t     * @return {Date} date\n\t     */\n\t    number.parseDate = function (value) {\n\t        if (value instanceof Date) {\n\t            return value;\n\t        }\n\t        else if (typeof value === 'string') {\n\t            // Treat as ISO format. See issue #3623\n\t            var ret = new Date(value);\n\t            if (isNaN(+ret)) {\n\t                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n\t                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n\t            }\n\t            return ret;\n\t        }\n\t\n\t        return new Date(Math.round(value));\n\t    };\n\t\n\t    /**\n\t     * Quantity of a number. e.g. 0.1, 1, 10, 100\n\t     * @param  {number} val\n\t     * @return {number}\n\t     */\n\t    number.quantity = function (val) {\n\t        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n\t    };\n\t\n\t    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t    /**\n\t     * find a nice number approximately equal to x. Round the number if round = true, take ceiling if round = false\n\t     * The primary observation is that the nicest numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n\t     * @param  {number} val\n\t     * @param  {boolean} round\n\t     * @return {number}\n\t     */\n\t    number.nice = function (val, round) {\n\t        var exp10 = number.quantity(val);\n\t        var f = val / exp10; // between 1 and 10\n\t        var nf;\n\t        if (round) {\n\t            if (f < 1.5) { nf = 1; }\n\t            else if (f < 2.5) { nf = 2; }\n\t            else if (f < 4) { nf = 3; }\n\t            else if (f < 7) { nf = 5; }\n\t            else { nf = 10; }\n\t        }\n\t        else {\n\t            if (f < 1) { nf = 1; }\n\t            else if (f < 2) { nf = 2; }\n\t            else if (f < 3) { nf = 3; }\n\t            else if (f < 5) { nf = 5; }\n\t            else { nf = 10; }\n\t        }\n\t        return nf * exp10;\n\t    };\n\t\n\t    module.exports = number;\n\n\n/***/ },\n/* 5 */\n/*!**************************************!*\\\n  !*** ./~/zrender/lib/core/vector.js ***!\n  \\**************************************/\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * \n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t        /**\n\t         * \n\t         * @param {number} [x=0]\n\t         * @param {number} [y=0]\n\t         * @return {Vector2}\n\t         */\n\t        create: function (x, y) {\n\t            var out = new ArrayCtor(2);\n\t            if (x == null) {\n\t                x = 0;\n\t            }\n\t            if (y == null) {\n\t                y = 0;\n\t            }\n\t            out[0] = x;\n\t            out[1] = y;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        copy: function (out, v) {\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        clone: function (v) {\n\t            var out = new ArrayCtor(2);\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {number} a\n\t         * @param {number} b\n\t         * @return {Vector2} \n\t         */\n\t        set: function (out, a, b) {\n\t            out[0] = a;\n\t            out[1] = b;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        add: function (out, v1, v2) {\n\t            out[0] = v1[0] + v2[0];\n\t            out[1] = v1[1] + v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} a\n\t         */\n\t        scaleAndAdd: function (out, v1, v2, a) {\n\t            out[0] = v1[0] + v2[0] * a;\n\t            out[1] = v1[1] + v2[1] * a;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        sub: function (out, v1, v2) {\n\t            out[0] = v1[0] - v2[0];\n\t            out[1] = v1[1] - v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        len: function (v) {\n\t            return Math.sqrt(this.lenSquare(v));\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        lenSquare: function (v) {\n\t            return v[0] * v[0] + v[1] * v[1];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        mul: function (out, v1, v2) {\n\t            out[0] = v1[0] * v2[0];\n\t            out[1] = v1[1] * v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        div: function (out, v1, v2) {\n\t            out[0] = v1[0] / v2[0];\n\t            out[1] = v1[1] / v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        dot: function (v1, v2) {\n\t            return v1[0] * v2[0] + v1[1] * v2[1];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {number} s\n\t         */\n\t        scale: function (out, v, s) {\n\t            out[0] = v[0] * s;\n\t            out[1] = v[1] * s;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        normalize: function (out, v) {\n\t            var d = vector.len(v);\n\t            if (d === 0) {\n\t                out[0] = 0;\n\t                out[1] = 0;\n\t            }\n\t            else {\n\t                out[0] = v[0] / d;\n\t                out[1] = v[1] / d;\n\t            }\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distance: function (v1, v2) {\n\t            return Math.sqrt(\n\t                (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n\t            );\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distanceSquare: function (v1, v2) {\n\t            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        negate: function (out, v) {\n\t            out[0] = -v[0];\n\t            out[1] = -v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} t\n\t         */\n\t        lerp: function (out, v1, v2, t) {\n\t            out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t            out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {Vector2} m\n\t         */\n\t        applyTransform: function (out, v, m) {\n\t            var x = v[0];\n\t            var y = v[1];\n\t            out[0] = m[0] * x + m[2] * y + m[4];\n\t            out[1] = m[1] * x + m[3] * y + m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        min: function (out, v1, v2) {\n\t            out[0] = Math.min(v1[0], v2[0]);\n\t            out[1] = Math.min(v1[1], v2[1]);\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        max: function (out, v1, v2) {\n\t            out[0] = Math.max(v1[0], v2[0]);\n\t            out[1] = Math.max(v1[1], v2[1]);\n\t            return out;\n\t        }\n\t    };\n\t\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t\n\t    module.exports = vector;\n\t\n\n\n/***/ },\n/* 6 */\n/*!***************************************!*\\\n  !*** ./~/zrender/lib/graphic/Path.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Path element\n\t * @module zrender/graphic/Path\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(/*! ./Displayable */ 37);\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t    var PathProxy = __webpack_require__(/*! ../core/PathProxy */ 28);\n\t    var pathContain = __webpack_require__(/*! ../contain/path */ 148);\n\t\n\t    var Pattern = __webpack_require__(/*! ./Pattern */ 63);\n\t    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\t\n\t    var abs = Math.abs;\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = new PathProxy();\n\t    }\n\t\n\t    Path.prototype = {\n\t\n\t        constructor: Path,\n\t\n\t        type: 'path',\n\t\n\t        __dirtyPath: true,\n\t\n\t        strokeContainThreshold: 5,\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var path = this.path;\n\t            var hasStroke = style.hasStroke();\n\t            var hasFill = style.hasFill();\n\t            var fill = style.fill;\n\t            var stroke = style.stroke;\n\t            var hasFillGradient = hasFill && !!(fill.colorStops);\n\t            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n\t            var hasFillPattern = hasFill && !!(fill.image);\n\t            var hasStrokePattern = hasStroke && !!(stroke.image);\n\t\n\t            style.bind(ctx, this, prevEl);\n\t            this.setTransform(ctx);\n\t\n\t            if (this.__dirty) {\n\t                var rect = this.getBoundingRect();\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFillGradient) {\n\t                    this._fillGradient = style.getGradient(ctx, fill, rect);\n\t                }\n\t                if (hasStrokeGradient) {\n\t                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t                }\n\t            }\n\t            // Use the gradient or pattern\n\t            if (hasFillGradient) {\n\t                // PENDING If may have affect the state\n\t                ctx.fillStyle = this._fillGradient;\n\t            }\n\t            else if (hasFillPattern) {\n\t                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t            }\n\t            if (hasStrokeGradient) {\n\t                ctx.strokeStyle = this._strokeGradient;\n\t            }\n\t            else if (hasStrokePattern) {\n\t                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t            }\n\t\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t\n\t            // Update path sx, sy\n\t            var scale = this.getGlobalScale();\n\t            path.setScale(scale[0], scale[1]);\n\t\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath || (\n\t                lineDash && !ctxLineDash && hasStroke\n\t            )) {\n\t                path = this.path.beginPath(ctx);\n\t\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t\n\t                this.buildPath(path, this.shape, false);\n\t\n\t                // Clear path dirty flag\n\t                this.__dirtyPath = false;\n\t            }\n\t            else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t\n\t            hasFill && path.fill(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t\n\t            hasStroke && path.stroke(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                // PENDING\n\t                // Remove lineDash\n\t                ctx.setLineDash([]);\n\t            }\n\t\n\t\n\t            this.restoreTransform(ctx);\n\t\n\t            // Draw rect text\n\t            if (style.text != null) {\n\t                // var rect = this.getBoundingRect();\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t\n\t        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n\t        // Like in circle\n\t        buildPath: function (ctx, shapeCfg, inBundle) {},\n\t\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            var needsUpdateRect = !rect;\n\t            if (needsUpdateRect) {\n\t                var path = this.path;\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape, false);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            this._rect = rect;\n\t\n\t            if (style.hasStroke()) {\n\t                // Needs update rect with stroke lineWidth when\n\t                // 1. Element changes scale or lineWidth\n\t                // 2. Shape is changed\n\t                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t                if (this.__dirty || needsUpdateRect) {\n\t                    rectWithStroke.copy(rect);\n\t                    // FIXME Must after updateTransform\n\t                    var w = style.lineWidth;\n\t                    // PENDING, Min line width is needed when line is horizontal or vertical\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t\n\t                    // Only add extra hover lineWidth when there are no fill\n\t                    if (!style.hasFill()) {\n\t                        w = Math.max(w, this.strokeContainThreshold || 4);\n\t                    }\n\t                    // Consider line width\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        rectWithStroke.width += w / lineScale;\n\t                        rectWithStroke.height += w / lineScale;\n\t                        rectWithStroke.x -= w / lineScale / 2;\n\t                        rectWithStroke.y -= w / lineScale / 2;\n\t                    }\n\t                }\n\t\n\t                // Return rect with stroke\n\t                return rectWithStroke;\n\t            }\n\t\n\t            return rect;\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (style.hasStroke()) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!style.hasFill()) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(\n\t                            pathData, lineWidth / lineScale, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (style.hasFill()) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t\n\t        /**\n\t         * @param  {boolean} dirtyPath\n\t         */\n\t        dirty: function (dirtyPath) {\n\t            if (dirtyPath == null) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t\n\t            this.__dirty = true;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Alias for animate('shape')\n\t         * @param {boolean} loop\n\t         */\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t\n\t        // Overwrite attrKV\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t                this.__dirtyPath = true;\n\t                this._rect = null;\n\t            }\n\t            else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        if (key.hasOwnProperty(name)) {\n\t                            shape[name] = key[name];\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n\t                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n\t                : 1;\n\t        }\n\t    };\n\t\n\t    /**\n\t     *  Path element, \n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (\n\t                        ! thisShape.hasOwnProperty(name)\n\t                        && defaultShape.hasOwnProperty(name)\n\t                    ) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t\n\t        zrUtil.inherits(Sub, Path);\n\t\n\t        // FIXME  extend position, rotation \n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t\n\t        return Sub;\n\t    };\n\t\n\t    zrUtil.inherits(Path, Displayable);\n\t\n\t    module.exports = Path;\n\n\n/***/ },\n/* 7 */\n/*!***************************!*\\\n  !*** ./lib/util/model.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var formatUtil = __webpack_require__(/*! ./format */ 9);\n\t    var nubmerUtil = __webpack_require__(/*! ./number */ 4);\n\t    var Model = __webpack_require__(/*! ../model/Model */ 10);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var modelUtil = {};\n\t\n\t    /**\n\t     * If value is not array, then translate it to array.\n\t     * @param  {*} value\n\t     * @return {Array} [value] or value\n\t     */\n\t    modelUtil.normalizeToArray = function (value) {\n\t        return value instanceof Array\n\t            ? value\n\t            : value == null\n\t            ? []\n\t            : [value];\n\t    };\n\t\n\t    /**\n\t     * Sync default option between normal and emphasis like `position` and `show`\n\t     * In case some one will write code like\n\t     *     label: {\n\t     *         normal: {\n\t     *             show: false,\n\t     *             position: 'outside',\n\t     *             textStyle: {\n\t     *                 fontSize: 18\n\t     *             }\n\t     *         },\n\t     *         emphasis: {\n\t     *             show: true\n\t     *         }\n\t     *     }\n\t     * @param {Object} opt\n\t     * @param {Array.<string>} subOpts\n\t     */\n\t     modelUtil.defaultEmphasis = function (opt, subOpts) {\n\t        if (opt) {\n\t            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n\t            var normalOpt = opt.normal = opt.normal || {};\n\t\n\t            // Default emphasis option from normal\n\t            zrUtil.each(subOpts, function (subOptName) {\n\t                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n\t                if (val != null) {\n\t                    emphasisOpt[subOptName] = val;\n\t                }\n\t            });\n\t        }\n\t    };\n\t\n\t    modelUtil.LABEL_OPTIONS = ['position', 'show', 'textStyle', 'distance', 'formatter'];\n\t\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method retieves value from data.\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     * @return {number|string|Date|Array.<number|string|Date>}\n\t     */\n\t    modelUtil.getDataItemValue = function (dataItem) {\n\t        // Performance sensitive.\n\t        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n\t    };\n\t\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method determine if dataItem has extra option besides value\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     */\n\t    modelUtil.isDataItemOption = function (dataItem) {\n\t        return zrUtil.isObject(dataItem)\n\t            && !(dataItem instanceof Array);\n\t            // // markLine data can be array\n\t            // && !(dataItem[0] && zrUtil.isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n\t    };\n\t\n\t    /**\n\t     * This helper method convert value in data.\n\t     * @param {string|number|Date} value\n\t     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n\t     */\n\t    modelUtil.converDataValue = function (value, dimInfo) {\n\t        // Performance sensitive.\n\t        var dimType = dimInfo && dimInfo.type;\n\t        if (dimType === 'ordinal') {\n\t            return value;\n\t        }\n\t\n\t        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n\t            value = +nubmerUtil.parseDate(value);\n\t        }\n\t\n\t        // dimType defaults 'number'.\n\t        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n\t        // parse to NaN.\n\t        return (value == null || value === '')\n\t            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n\t    };\n\t\n\t    /**\n\t     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Object} opt\n\t     * @param {string} [opt.seriesIndex]\n\t     * @param {Object} [opt.name]\n\t     * @param {Object} [opt.mainType]\n\t     * @param {Object} [opt.subType]\n\t     */\n\t    modelUtil.createDataFormatModel = function (data, opt) {\n\t        var model = new Model();\n\t        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n\t        model.seriesIndex = opt.seriesIndex;\n\t        model.name = opt.name || '';\n\t        model.mainType = opt.mainType;\n\t        model.subType = opt.subType;\n\t\n\t        model.getData = function () {\n\t            return data;\n\t        };\n\t        return model;\n\t    };\n\t\n\t    // PENDING A little ugly\n\t    modelUtil.dataFormatMixin = {\n\t        /**\n\t         * Get params for formatter\n\t         * @param {number} dataIndex\n\t         * @param {string} [dataType]\n\t         * @return {Object}\n\t         */\n\t        getDataParams: function (dataIndex, dataType) {\n\t            var data = this.getData(dataType);\n\t\n\t            var seriesIndex = this.seriesIndex;\n\t            var seriesName = this.name;\n\t\n\t            var rawValue = this.getRawValue(dataIndex, dataType);\n\t            var rawDataIndex = data.getRawIndex(dataIndex);\n\t            var name = data.getName(dataIndex, true);\n\t            var itemOpt = data.getRawDataItem(dataIndex);\n\t\n\t            return {\n\t                componentType: this.mainType,\n\t                componentSubType: this.subType,\n\t                seriesType: this.mainType === 'series' ? this.subType : null,\n\t                seriesIndex: seriesIndex,\n\t                seriesName: seriesName,\n\t                name: name,\n\t                dataIndex: rawDataIndex,\n\t                data: itemOpt,\n\t                dataType: dataType,\n\t                value: rawValue,\n\t                color: data.getItemVisual(dataIndex, 'color'),\n\t\n\t                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n\t                $vars: ['seriesName', 'name', 'value']\n\t            };\n\t        },\n\t\n\t        /**\n\t         * Format label\n\t         * @param {number} dataIndex\n\t         * @param {string} [status='normal'] 'normal' or 'emphasis'\n\t         * @param {string} [dataType]\n\t         * @param {number} [dimIndex]\n\t         * @return {string}\n\t         */\n\t        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n\t            status = status || 'normal';\n\t            var data = this.getData(dataType);\n\t            var itemModel = data.getItemModel(dataIndex);\n\t\n\t            var params = this.getDataParams(dataIndex, dataType);\n\t            if (dimIndex != null && (params.value instanceof Array)) {\n\t                params.value = params.value[dimIndex];\n\t            }\n\t\n\t            var formatter = itemModel.get(['label', status, 'formatter']);\n\t\n\t            if (typeof formatter === 'function') {\n\t                params.status = status;\n\t                return formatter(params);\n\t            }\n\t            else if (typeof formatter === 'string') {\n\t                return formatUtil.formatTpl(formatter, params);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get raw value in option\n\t         * @param {number} idx\n\t         * @param {string} [dataType]\n\t         * @return {Object}\n\t         */\n\t        getRawValue: function (idx, dataType) {\n\t            var data = this.getData(dataType);\n\t            var dataItem = data.getRawDataItem(idx);\n\t            if (dataItem != null) {\n\t                return (zrUtil.isObject(dataItem) && !(dataItem instanceof Array))\n\t                    ? dataItem.value : dataItem;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Should be implemented.\n\t         * @param {number} dataIndex\n\t         * @param {boolean} [multipleSeries=false]\n\t         * @param {number} [dataType]\n\t         * @return {string} tooltip string\n\t         */\n\t        formatTooltip: zrUtil.noop\n\t    };\n\t\n\t    /**\n\t     * Mapping to exists for merge.\n\t     *\n\t     * @public\n\t     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n\t     * @param {Object|Array.<Object>} newCptOptions\n\t     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n\t     *                          which order is the same as exists.\n\t     */\n\t    modelUtil.mappingToExists = function (exists, newCptOptions) {\n\t        // Mapping by the order by original option (but not order of\n\t        // new option) in merge mode. Because we should ensure\n\t        // some specified index (like xAxisIndex) is consistent with\n\t        // original option, which is easy to understand, espatially in\n\t        // media query. And in most case, merge option is used to\n\t        // update partial option but not be expected to change order.\n\t        newCptOptions = (newCptOptions || []).slice();\n\t\n\t        var result = zrUtil.map(exists || [], function (obj, index) {\n\t            return {exist: obj};\n\t        });\n\t\n\t        // Mapping by id or name if specified.\n\t        zrUtil.each(newCptOptions, function (cptOption, index) {\n\t            if (!zrUtil.isObject(cptOption)) {\n\t                return;\n\t            }\n\t\n\t            // id has highest priority.\n\t            for (var i = 0; i < result.length; i++) {\n\t                if (!result[i].option // Consider name: two map to one.\n\t                    && cptOption.id != null\n\t                    && result[i].exist.id === cptOption.id + ''\n\t                ) {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t\n\t            for (var i = 0; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option // Consider name: two map to one.\n\t                    // Can not match when both ids exist but different.\n\t                    && (exist.id == null || cptOption.id == null)\n\t                    && cptOption.name != null\n\t                    && !modelUtil.isIdInner(cptOption)\n\t                    && !modelUtil.isIdInner(exist)\n\t                    && exist.name === cptOption.name + ''\n\t                ) {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t        });\n\t\n\t        // Otherwise mapping by index.\n\t        zrUtil.each(newCptOptions, function (cptOption, index) {\n\t            if (!zrUtil.isObject(cptOption)) {\n\t                return;\n\t            }\n\t\n\t            var i = 0;\n\t            for (; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option\n\t                    && !modelUtil.isIdInner(exist)\n\t                    // Caution:\n\t                    // Do not overwrite id. But name can be overwritten,\n\t                    // because axis use name as 'show label text'.\n\t                    // 'exist' always has id and name and we dont\n\t                    // need to check it.\n\t                    && cptOption.id == null\n\t                ) {\n\t                    result[i].option = cptOption;\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (i >= result.length) {\n\t                result.push({option: cptOption});\n\t            }\n\t        });\n\t\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * @public\n\t     * @param {Object} cptOption\n\t     * @return {boolean}\n\t     */\n\t    modelUtil.isIdInner = function (cptOption) {\n\t        return zrUtil.isObject(cptOption)\n\t            && cptOption.id\n\t            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n\t    };\n\t\n\t    /**\n\t     * A helper for removing duplicate items between batchA and batchB,\n\t     * and in themselves, and categorize by series.\n\t     *\n\t     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n\t     */\n\t    modelUtil.compressBatches = function (batchA, batchB) {\n\t        var mapA = {};\n\t        var mapB = {};\n\t\n\t        makeMap(batchA || [], mapA);\n\t        makeMap(batchB || [], mapB, mapA);\n\t\n\t        return [mapToArray(mapA), mapToArray(mapB)];\n\t\n\t        function makeMap(sourceBatch, map, otherMap) {\n\t            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n\t                var seriesId = sourceBatch[i].seriesId;\n\t                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n\t                var otherDataIndices = otherMap && otherMap[seriesId];\n\t\n\t                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n\t                    var dataIndex = dataIndices[j];\n\t\n\t                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n\t                        otherDataIndices[dataIndex] = null;\n\t                    }\n\t                    else {\n\t                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        function mapToArray(map, isData) {\n\t            var result = [];\n\t            for (var i in map) {\n\t                if (map.hasOwnProperty(i) && map[i] != null) {\n\t                    if (isData) {\n\t                        result.push(+i);\n\t                    }\n\t                    else {\n\t                        var dataIndices = mapToArray(map[i], true);\n\t                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n\t                    }\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n\t     *                         each of which can be Array or primary type.\n\t     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n\t     */\n\t    modelUtil.queryDataIndex = function (data, payload) {\n\t        if (payload.dataIndexInside != null) {\n\t            return payload.dataIndexInside;\n\t        }\n\t        else if (payload.dataIndex != null) {\n\t            return zrUtil.isArray(payload.dataIndex)\n\t                ? zrUtil.map(payload.dataIndex, function (value) {\n\t                    return data.indexOfRawIndex(value);\n\t                })\n\t                : data.indexOfRawIndex(payload.dataIndex);\n\t        }\n\t        else if (payload.name != null) {\n\t            return zrUtil.isArray(payload.name)\n\t                ? zrUtil.map(payload.name, function (value) {\n\t                    return data.indexOfName(value);\n\t                })\n\t                : data.indexOfName(payload.name);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex, seriesId, seriesName,\n\t     *            geoIndex, geoId, goeName,\n\t     *            bmapIndex, bmapId, bmapName,\n\t     *            xAxisIndex, xAxisId, xAxisName,\n\t     *            yAxisIndex, yAxisId, yAxisName,\n\t     *            gridIndex, gridId, gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     *        Each properties can be number|string|Array.<number>|Array.<string>\n\t     *        For example, a finder could be\n\t     *        {\n\t     *            seriesIndex: 3,\n\t     *            geoId: ['aa', 'cc'],\n\t     *            gridName: ['xx', 'rr']\n\t     *        }\n\t     * @param {Object} [opt]\n\t     * @param {string} [opt.defaultMainType]\n\t     * @return {Object} result like:\n\t     *        {\n\t     *            seriesModels: [seriesModel1, seriesModel2],\n\t     *            seriesModel: seriesModel1, // The first model\n\t     *            geoModels: [geoModel1, geoModel2],\n\t     *            geoModel: geoModel1, // The first model\n\t     *            ...\n\t     *        }\n\t     */\n\t    modelUtil.parseFinder = function (ecModel, finder, opt) {\n\t        if (zrUtil.isString(finder)) {\n\t            var obj = {};\n\t            obj[finder + 'Index'] = 0;\n\t            finder = obj;\n\t        }\n\t\n\t        var defaultMainType = opt && opt.defaultMainType;\n\t        if (defaultMainType\n\t            && !has(finder, defaultMainType + 'Index')\n\t            && !has(finder, defaultMainType + 'Id')\n\t            && !has(finder, defaultMainType + 'Name')\n\t        ) {\n\t            finder[defaultMainType + 'Index'] = 0;\n\t        }\n\t\n\t        var result = {};\n\t\n\t        zrUtil.each(finder, function (value, key) {\n\t            var value = finder[key];\n\t\n\t            // Exclude 'dataIndex' and other illgal keys.\n\t            if (key === 'dataIndex' || key === 'dataIndexInside') {\n\t                result[key] = value;\n\t                return;\n\t            }\n\t\n\t            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n\t            var mainType = parsedKey[1];\n\t            var queryType = parsedKey[2];\n\t\n\t            if (!mainType || !queryType) {\n\t                return;\n\t            }\n\t\n\t            var queryParam = {mainType: mainType};\n\t            queryParam[queryType.toLowerCase()] = value;\n\t            var models = ecModel.queryComponents(queryParam);\n\t            result[mainType + 'Models'] = models;\n\t            result[mainType + 'Model'] = models[0];\n\t        });\n\t\n\t        return result;\n\t    };\n\t\n\t    function has(obj, prop) {\n\t        return obj && obj.hasOwnProperty(prop);\n\t    }\n\t\n\t    module.exports = modelUtil;\n\n\n/***/ },\n/* 8 */\n/*!********************************************!*\\\n  !*** ./~/zrender/lib/core/BoundingRect.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(/*! ./vector */ 5);\n\t    var matrix = __webpack_require__(/*! ./matrix */ 19);\n\t\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t\n\t        if (width < 0) {\n\t            x = x + width;\n\t            width = -width;\n\t        }\n\t        if (height < 0) {\n\t            y = y + height;\n\t            height = -height;\n\t        }\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t\n\t    BoundingRect.prototype = {\n\t\n\t        constructor: BoundingRect,\n\t\n\t        /**\n\t         * @param {module:echarts/core/BoundingRect} other\n\t         */\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t\n\t            this.width = mathMax(\n\t                    other.x + other.width,\n\t                    this.x + this.width\n\t                ) - x;\n\t            this.height = mathMax(\n\t                    other.y + other.height,\n\t                    this.y + this.height\n\t                ) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} m\n\t         * @methods\n\t         */\n\t        applyTransform: (function () {\n\t            var lt = [];\n\t            var rb = [];\n\t            var lb = [];\n\t            var rt = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                lt[0] = lb[0] = this.x;\n\t                lt[1] = rt[1] = this.y;\n\t                rb[0] = rt[0] = this.x + this.width;\n\t                rb[1] = lb[1] = this.y + this.height;\n\t\n\t                v2ApplyTransform(lt, lt, m);\n\t                v2ApplyTransform(rb, rb, m);\n\t                v2ApplyTransform(lb, lb, m);\n\t                v2ApplyTransform(rt, rt, m);\n\t\n\t                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n\t                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n\t                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n\t                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n\t                this.width = maxX - this.x;\n\t                this.height = maxY - this.y;\n\t            };\n\t        })(),\n\t\n\t        /**\n\t         * Calculate matrix of transforming from self to target rect\n\t         * @param  {module:zrender/core/BoundingRect} b\n\t         * @return {Array.<number>}\n\t         */\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t\n\t            var m = matrix.create();\n\t\n\t            // \n\t            matrix.translate(m, m, [-a.x, -a.y]);\n\t            matrix.scale(m, m, [sx, sy]);\n\t            matrix.translate(m, m, [b.x, b.y]);\n\t\n\t            return m;\n\t        },\n\t\n\t        /**\n\t         * @param {(module:echarts/core/BoundingRect|Object)} b\n\t         * @return {boolean}\n\t         */\n\t        intersect: function (b) {\n\t            if (!b) {\n\t                return false;\n\t            }\n\t\n\t            if (!(b instanceof BoundingRect)) {\n\t                // Normalize negative width/height.\n\t                b = BoundingRect.create(b);\n\t            }\n\t\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t\n\t            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x\n\t                && x <= (rect.x + rect.width)\n\t                && y >= rect.y\n\t                && y <= (rect.y + rect.height);\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/core/BoundingRect}\n\t         */\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t\n\t        /**\n\t         * Copy from another rect\n\t         */\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        },\n\t\n\t        plain: function () {\n\t            return {\n\t                x: this.x,\n\t                y: this.y,\n\t                width: this.width,\n\t                height: this.height\n\t            };\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {Object|module:zrender/core/BoundingRect} rect\n\t     * @param {number} rect.x\n\t     * @param {number} rect.y\n\t     * @param {number} rect.width\n\t     * @param {number} rect.height\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    BoundingRect.create = function (rect) {\n\t        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n\t    };\n\t\n\t    module.exports = BoundingRect;\n\n\n/***/ },\n/* 9 */\n/*!****************************!*\\\n  !*** ./lib/util/format.js ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var numberUtil = __webpack_require__(/*! ./number */ 4);\n\t    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 16);\n\t\n\t    var formatUtil = {};\n\t    /**\n\t     * ,\n\t     * @type {string|number} x\n\t     */\n\t    formatUtil.addCommas = function (x) {\n\t        if (isNaN(x)) {\n\t            return '-';\n\t        }\n\t        x = (x + '').split('.');\n\t        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n\t               + (x.length > 1 ? ('.' + x[1]) : '');\n\t    };\n\t\n\t    /**\n\t     * @param {string} str\n\t     * @return {string} str\n\t     */\n\t    formatUtil.toCamelCase = function (str) {\n\t        return str.toLowerCase().replace(/-(.)/g, function(match, group1) {\n\t            return group1.toUpperCase();\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Normalize css liked array configuration\n\t     * e.g.\n\t     *  3 => [3, 3, 3, 3]\n\t     *  [4, 2] => [4, 2, 4, 2]\n\t     *  [4, 3, 2] => [4, 3, 2, 3]\n\t     * @param {number|Array.<number>} val\n\t     */\n\t    formatUtil.normalizeCssArray = function (val) {\n\t        var len = val.length;\n\t        if (typeof (val) === 'number') {\n\t            return [val, val, val, val];\n\t        }\n\t        else if (len === 2) {\n\t            // vertical | horizontal\n\t            return [val[0], val[1], val[0], val[1]];\n\t        }\n\t        else if (len === 3) {\n\t            // top | horizontal | bottom\n\t            return [val[0], val[1], val[2], val[1]];\n\t        }\n\t        return val;\n\t    };\n\t\n\t    formatUtil.encodeHTML = function (source) {\n\t        return String(source)\n\t            .replace(/&/g, '&amp;')\n\t            .replace(/</g, '&lt;')\n\t            .replace(/>/g, '&gt;')\n\t            .replace(/\"/g, '&quot;')\n\t            .replace(/'/g, '&#39;');\n\t    };\n\t\n\t    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\t\n\t    var wrapVar = function (varName, seriesIdx) {\n\t        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n\t    };\n\t\n\t    /**\n\t     * Template formatter\n\t     * @param  {string} tpl\n\t     * @param  {Array.<Object>|Object} paramsList\n\t     * @return {string}\n\t     */\n\t    formatUtil.formatTpl = function (tpl, paramsList) {\n\t        if (!zrUtil.isArray(paramsList)) {\n\t            paramsList = [paramsList];\n\t        }\n\t        var seriesLen = paramsList.length;\n\t        if (!seriesLen) {\n\t            return '';\n\t        }\n\t\n\t        var $vars = paramsList[0].$vars || [];\n\t        for (var i = 0; i < $vars.length; i++) {\n\t            var alias = TPL_VAR_ALIAS[i];\n\t            tpl = tpl.replace(wrapVar(alias),  wrapVar(alias, 0));\n\t        }\n\t        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n\t            for (var k = 0; k < $vars.length; k++) {\n\t                tpl = tpl.replace(\n\t                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n\t                    paramsList[seriesIdx][$vars[k]]\n\t                );\n\t            }\n\t        }\n\t\n\t        return tpl;\n\t    };\n\t\n\t\n\t    /**\n\t     * @param {string} str\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    var s2d = function (str) {\n\t        return str < 10 ? ('0' + str) : str;\n\t    };\n\t\n\t    /**\n\t     * ISO Date format\n\t     * @param {string} tpl\n\t     * @param {number} value\n\t     * @inner\n\t     */\n\t    formatUtil.formatTime = function (tpl, value) {\n\t        if (tpl === 'week'\n\t            || tpl === 'month'\n\t            || tpl === 'quarter'\n\t            || tpl === 'half-year'\n\t            || tpl === 'year'\n\t        ) {\n\t            tpl = 'MM-dd\\nyyyy';\n\t        }\n\t\n\t        var date = numberUtil.parseDate(value);\n\t        var y = date.getFullYear();\n\t        var M = date.getMonth() + 1;\n\t        var d = date.getDate();\n\t        var h = date.getHours();\n\t        var m = date.getMinutes();\n\t        var s = date.getSeconds();\n\t\n\t        tpl = tpl.replace('MM', s2d(M))\n\t            .toLowerCase()\n\t            .replace('yyyy', y)\n\t            .replace('yy', y % 100)\n\t            .replace('dd', s2d(d))\n\t            .replace('d', d)\n\t            .replace('hh', s2d(h))\n\t            .replace('h', h)\n\t            .replace('mm', s2d(m))\n\t            .replace('m', m)\n\t            .replace('ss', s2d(s))\n\t            .replace('s', s);\n\t\n\t        return tpl;\n\t    };\n\t\n\t    /**\n\t     * Capital first\n\t     * @param {string} str\n\t     * @return {string}\n\t     */\n\t    formatUtil.capitalFirst = function (str) {\n\t        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n\t    };\n\t\n\t    formatUtil.truncateText = textContain.truncateText;\n\t\n\t    module.exports = formatUtil;\n\n\n/***/ },\n/* 10 */\n/*!****************************!*\\\n  !*** ./lib/model/Model.js ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/model/Model\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 21);\n\t\n\t    /**\n\t     * @alias module:echarts/model/Model\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} [parentModel]\n\t     * @param {module:echarts/model/Global} [ecModel]\n\t     */\n\t    function Model(option, parentModel, ecModel) {\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         * @readOnly\n\t         */\n\t        this.parentModel = parentModel;\n\t\n\t        /**\n\t         * @type {module:echarts/model/Global}\n\t         * @readOnly\n\t         */\n\t        this.ecModel = ecModel;\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        this.option = option;\n\t\n\t        // Simple optimization\n\t        // if (this.init) {\n\t        //     if (arguments.length <= 4) {\n\t        //         this.init(option, parentModel, ecModel, extraOpt);\n\t        //     }\n\t        //     else {\n\t        //         this.init.apply(this, arguments);\n\t        //     }\n\t        // }\n\t    }\n\t\n\t    Model.prototype = {\n\t\n\t        constructor: Model,\n\t\n\t        /**\n\t         * Model \n\t         * @param {Object} option\n\t         */\n\t        init: null,\n\t\n\t        /**\n\t         *  Option merge\n\t         */\n\t        mergeOption: function (option) {\n\t            zrUtil.merge(this.option, option, true);\n\t        },\n\t\n\t        /**\n\t         * @param {string} path\n\t         * @param {boolean} [ignoreParent=false]\n\t         * @return {*}\n\t         */\n\t        get: function (path, ignoreParent) {\n\t            if (!path) {\n\t                return this.option;\n\t            }\n\t\n\t            if (typeof path === 'string') {\n\t                path = path.split('.');\n\t            }\n\t\n\t            var obj = this.option;\n\t            var parentModel = this.parentModel;\n\t            for (var i = 0; i < path.length; i++) {\n\t                // Ignore empty\n\t                if (!path[i]) {\n\t                    continue;\n\t                }\n\t                // obj could be number/string/... (like 0)\n\t                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\n\t                if (obj == null) {\n\t                    break;\n\t                }\n\t            }\n\t            if (obj == null && parentModel && !ignoreParent) {\n\t                obj = parentModel.get(path);\n\t            }\n\t            return obj;\n\t        },\n\t\n\t        /**\n\t         * @param {string} key\n\t         * @param {boolean} [ignoreParent=false]\n\t         * @return {*}\n\t         */\n\t        getShallow: function (key, ignoreParent) {\n\t            var option = this.option;\n\t\n\t            var val = option == null ? option : option[key];\n\t            var parentModel = this.parentModel;\n\t            if (val == null && parentModel && !ignoreParent) {\n\t                val = parentModel.getShallow(key);\n\t            }\n\t            return val;\n\t        },\n\t\n\t        /**\n\t         * @param {string} path\n\t         * @param {module:echarts/model/Model} [parentModel]\n\t         * @return {module:echarts/model/Model}\n\t         */\n\t        getModel: function (path, parentModel) {\n\t            var obj = this.get(path, true);\n\t            var thisParentModel = this.parentModel;\n\t            var model = new Model(\n\t                obj, parentModel || (thisParentModel && thisParentModel.getModel(path)),\n\t                this.ecModel\n\t            );\n\t            return model;\n\t        },\n\t\n\t        /**\n\t         * If model has option\n\t         */\n\t        isEmpty: function () {\n\t            return this.option == null;\n\t        },\n\t\n\t        restoreData: function () {},\n\t\n\t        // Pending\n\t        clone: function () {\n\t            var Ctor = this.constructor;\n\t            return new Ctor(zrUtil.clone(this.option));\n\t        },\n\t\n\t        setReadOnly: function (properties) {\n\t            clazzUtil.setReadOnly(this, properties);\n\t        }\n\t    };\n\t\n\t    // Enable Model.extend.\n\t    clazzUtil.enableClassExtend(Model);\n\t\n\t    var mixin = zrUtil.mixin;\n\t    mixin(Model, __webpack_require__(/*! ./mixin/lineStyle */ 130));\n\t    mixin(Model, __webpack_require__(/*! ./mixin/areaStyle */ 127));\n\t    mixin(Model, __webpack_require__(/*! ./mixin/textStyle */ 131));\n\t    mixin(Model, __webpack_require__(/*! ./mixin/itemStyle */ 129));\n\t\n\t    module.exports = Model;\n\n\n/***/ },\n/* 11 */\n/*!***********************************!*\\\n  !*** ./~/zrender/lib/core/env.js ***!\n  \\***********************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * echarts\n\t *\n\t * @desc echartsCanvasJavascript\n\t * @author firede[firede@firede.us]\n\t * @desc thanks zepto.\n\t */\n\t\n\t    var env = {};\n\t    if (typeof navigator === 'undefined') {\n\t        // In node\n\t        env = {\n\t            browser: {},\n\t            os: {},\n\t            node: true,\n\t            // Assume canvas is supported\n\t            canvasSupported: true\n\t        };\n\t    }\n\t    else {\n\t        env = detect(navigator.userAgent);\n\t    }\n\t\n\t    module.exports = env;\n\t\n\t    // Zepto.js\n\t    // (c) 2010-2013 Thomas Fuchs\n\t    // Zepto.js may be freely distributed under the MIT license.\n\t\n\t    function detect(ua) {\n\t        var os = {};\n\t        var browser = {};\n\t        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t        // var touchpad = webos && ua.match(/TouchPad/);\n\t        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t        // var playbook = ua.match(/PlayBook/);\n\t        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n\t        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n\t            // IE 11 Trident/7.0; rv:11.0\n\t            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\t\n\t        var weChat = (/micromessenger/i).test(ua);\n\t\n\t        // Todo: clean this up with a better OS/browser seperation:\n\t        // - discern (more) between multiple browsers on android\n\t        // - decide if kindle fire in silk mode is android or not\n\t        // - Firefox on Android doesn't specify the Android version\n\t        // - possibly devide in os, device and browser hashes\n\t\n\t        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t\n\t        // if (android) os.android = true, os.version = android[2];\n\t        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t        // if (webos) os.webos = true, os.version = webos[2];\n\t        // if (touchpad) os.touchpad = true;\n\t        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t        // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t        // if (playbook) browser.playbook = true;\n\t        // if (kindle) os.kindle = true, os.version = kindle[1];\n\t        // if (silk) browser.silk = true, browser.version = silk[1];\n\t        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t        if (firefox) {\n\t            browser.firefox = true;\n\t            browser.version = firefox[1];\n\t        }\n\t        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t        // if (webview) browser.webview = true;\n\t\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t\n\t        if (edge) {\n\t            browser.edge = true;\n\t            browser.version = edge[1];\n\t        }\n\t\n\t        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n\t        // not be set on win phone. So we do not consider Win Phone.\n\t        if (weChat) {\n\t            browser.weChat = true;\n\t        }\n\t\n\t        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t\n\t        return {\n\t            browser: browser,\n\t            os: os,\n\t            node: false,\n\t            // canvas\n\t            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n\t            canvasSupported : document.createElement('canvas').getContext ? true : false,\n\t            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n\t            // works on most browsers\n\t            // IE10/11 does not support touch event, and MS Edge supports them but not by\n\t            // default, so we dont check navigator.maxTouchPoints for them here.\n\t            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t            // <http://caniuse.com/#search=pointer%20event>.\n\t            pointerEventsSupported: 'onpointerdown' in window\n\t                // Firefox supports pointer but not by default,\n\t                // only MS browsers are reliable on pointer events currently.\n\t                && (browser.edge || (browser.ie && browser.version >= 10))\n\t        };\n\t    }\n\n\n/***/ },\n/* 12 */\n/*!********************************!*\\\n  !*** ./lib/model/Component.js ***!\n  \\********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Component model\n\t *\n\t * @module echarts/model/Component\n\t */\n\t\n\t\n\t    var Model = __webpack_require__(/*! ./Model */ 10);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var arrayPush = Array.prototype.push;\n\t    var componentUtil = __webpack_require__(/*! ../util/component */ 43);\n\t    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 21);\n\t    var layout = __webpack_require__(/*! ../util/layout */ 13);\n\t\n\t    /**\n\t     * @alias module:echarts/model/Component\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {module:echarts/model/Model} ecModel\n\t     */\n\t    var ComponentModel = Model.extend({\n\t\n\t        type: 'component',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {string}\n\t         */\n\t        id: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {string}\n\t         */\n\t        mainType: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {string}\n\t         */\n\t        subType: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {number}\n\t         */\n\t        componentIndex: 0,\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        defaultOption: null,\n\t\n\t        /**\n\t         * @type {module:echarts/model/Global}\n\t         * @readOnly\n\t         */\n\t        ecModel: null,\n\t\n\t        /**\n\t         * key: componentType\n\t         * value:  Component model list, can not be null.\n\t         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n\t         * @readOnly\n\t         */\n\t        dependentModels: [],\n\t\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        uid: null,\n\t\n\t        /**\n\t         * Support merge layout params.\n\t         * Only support 'box' now (left/right/top/bottom/width/height).\n\t         * @type {string|Object} Object can be {ignoreSize: true}\n\t         * @readOnly\n\t         */\n\t        layoutMode: null,\n\t\n\t        $constructor: function (option, parentModel, ecModel, extraOpt) {\n\t            Model.call(this, option, parentModel, ecModel, extraOpt);\n\t\n\t            this.uid = componentUtil.getUID('componentModel');\n\t        },\n\t\n\t\n\t        init: function (option, parentModel, ecModel, extraOpt) {\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t        },\n\t\n\t        mergeDefaultAndTheme: function (option, ecModel) {\n\t            var layoutMode = this.layoutMode;\n\t            var inputPositionParams = layoutMode\n\t                ? layout.getLayoutParams(option) : {};\n\t\n\t            var themeModel = ecModel.getTheme();\n\t            zrUtil.merge(option, themeModel.get(this.mainType));\n\t            zrUtil.merge(option, this.getDefaultOption());\n\t\n\t            if (layoutMode) {\n\t                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t            }\n\t        },\n\t\n\t        mergeOption: function (option, extraOpt) {\n\t            zrUtil.merge(this.option, option, true);\n\t\n\t            var layoutMode = this.layoutMode;\n\t            if (layoutMode) {\n\t                layout.mergeLayoutParam(this.option, option, layoutMode);\n\t            }\n\t        },\n\t\n\t        // Hooker after init or mergeOption\n\t        optionUpdated: function (newCptOption, isInit) {},\n\t\n\t        getDefaultOption: function () {\n\t            if (!this.hasOwnProperty('__defaultOption')) {\n\t                var optList = [];\n\t                var Class = this.constructor;\n\t                while (Class) {\n\t                    var opt = Class.prototype.defaultOption;\n\t                    opt && optList.push(opt);\n\t                    Class = Class.superClass;\n\t                }\n\t\n\t                var defaultOption = {};\n\t                for (var i = optList.length - 1; i >= 0; i--) {\n\t                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n\t                }\n\t                this.__defaultOption = defaultOption;\n\t            }\n\t            return this.__defaultOption;\n\t        },\n\t\n\t        getReferringComponents: function (mainType) {\n\t            return this.ecModel.queryComponents({\n\t                mainType: mainType,\n\t                index: this.get(mainType + 'Index', true),\n\t                id: this.get(mainType + 'Id', true)\n\t            });\n\t        }\n\t\n\t    });\n\t\n\t    // Reset ComponentModel.extend, add preConstruct.\n\t    // clazzUtil.enableClassExtend(\n\t    //     ComponentModel,\n\t    //     function (option, parentModel, ecModel, extraOpt) {\n\t    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n\t    //         zrUtil.extend(this, extraOpt);\n\t\n\t    //         this.uid = componentUtil.getUID('componentModel');\n\t\n\t    //         // this.setReadOnly([\n\t    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n\t    //         //     'dependentModels', 'componentIndex'\n\t    //         // ]);\n\t    //     }\n\t    // );\n\t\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(\n\t        ComponentModel, {registerWhenExtend: true}\n\t    );\n\t    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\t\n\t    // Add capability of ComponentModel.topologicalTravel.\n\t    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\t\n\t    function getDependencies(componentType) {\n\t        var deps = [];\n\t        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n\t            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n\t        });\n\t        // Ensure main type\n\t        return zrUtil.map(deps, function (type) {\n\t            return clazzUtil.parseClassType(type).main;\n\t        });\n\t    }\n\t\n\t    zrUtil.mixin(ComponentModel, __webpack_require__(/*! ./mixin/boxLayout */ 128));\n\t\n\t    module.exports = ComponentModel;\n\n\n/***/ },\n/* 13 */\n/*!****************************!*\\\n  !*** ./lib/util/layout.js ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Layout helpers for each component positioning\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var BoundingRect = __webpack_require__(/*! zrender/lib/core/BoundingRect */ 8);\n\t    var numberUtil = __webpack_require__(/*! ./number */ 4);\n\t    var formatUtil = __webpack_require__(/*! ./format */ 9);\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var each = zrUtil.each;\n\t\n\t    var layout = {};\n\t\n\t    var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n\t\n\t    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n\t        var x = 0;\n\t        var y = 0;\n\t        if (maxWidth == null) {\n\t            maxWidth = Infinity;\n\t        }\n\t        if (maxHeight == null) {\n\t            maxHeight = Infinity;\n\t        }\n\t        var currentLineMaxSize = 0;\n\t        group.eachChild(function (child, idx) {\n\t            var position = child.position;\n\t            var rect = child.getBoundingRect();\n\t            var nextChild = group.childAt(idx + 1);\n\t            var nextChildRect = nextChild && nextChild.getBoundingRect();\n\t            var nextX;\n\t            var nextY;\n\t            if (orient === 'horizontal') {\n\t                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n\t                nextX = x + moveX;\n\t                // Wrap when width exceeds maxWidth or meet a `newline` group\n\t                if (nextX > maxWidth || child.newline) {\n\t                    x = 0;\n\t                    nextX = moveX;\n\t                    y += currentLineMaxSize + gap;\n\t                    currentLineMaxSize = rect.height;\n\t                }\n\t                else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n\t                }\n\t            }\n\t            else {\n\t                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n\t                nextY = y + moveY;\n\t                // Wrap when width exceeds maxHeight or meet a `newline` group\n\t                if (nextY > maxHeight || child.newline) {\n\t                    x += currentLineMaxSize + gap;\n\t                    y = 0;\n\t                    nextY = moveY;\n\t                    currentLineMaxSize = rect.width;\n\t                }\n\t                else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n\t                }\n\t            }\n\t\n\t            if (child.newline) {\n\t                return;\n\t            }\n\t\n\t            position[0] = x;\n\t            position[1] = y;\n\t\n\t            orient === 'horizontal'\n\t                ? (x = nextX + gap)\n\t                : (y = nextY + gap);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * VBox or HBox layouting\n\t     * @param {string} orient\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.box = boxLayout;\n\t\n\t    /**\n\t     * VBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\t\n\t    /**\n\t     * HBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\t\n\t    /**\n\t     * If x or x2 is not specified or 'center' 'left' 'right',\n\t     * the width would be as long as possible.\n\t     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n\t     * the height would be as long as possible.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.x]\n\t     * @param {number|string} [positionInfo.y]\n\t     * @param {number|string} [positionInfo.x2]\n\t     * @param {number|string} [positionInfo.y2]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     * @return {Object} {width, height}\n\t     */\n\t    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t\n\t        var x = parsePercent(positionInfo.x, containerWidth);\n\t        var y = parsePercent(positionInfo.y, containerHeight);\n\t        var x2 = parsePercent(positionInfo.x2, containerWidth);\n\t        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\t\n\t        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n\t        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n\t        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n\t        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\t\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t\n\t        return {\n\t            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n\t            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Parse position info.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {number|string} [positionInfo.width]\n\t     * @param {number|string} [positionInfo.height]\n\t     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n\t     * @param {Object} containerRect\n\t     * @param {string|number} [margin]\n\t     *\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    layout.getLayoutRect = function (\n\t        positionInfo, containerRect, margin\n\t    ) {\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t\n\t        var left = parsePercent(positionInfo.left, containerWidth);\n\t        var top = parsePercent(positionInfo.top, containerHeight);\n\t        var right = parsePercent(positionInfo.right, containerWidth);\n\t        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n\t        var width = parsePercent(positionInfo.width, containerWidth);\n\t        var height = parsePercent(positionInfo.height, containerHeight);\n\t\n\t        var verticalMargin = margin[2] + margin[0];\n\t        var horizontalMargin = margin[1] + margin[3];\n\t        var aspect = positionInfo.aspect;\n\t\n\t        // If width is not specified, calculate width from left and right\n\t        if (isNaN(width)) {\n\t            width = containerWidth - right - horizontalMargin - left;\n\t        }\n\t        if (isNaN(height)) {\n\t            height = containerHeight - bottom - verticalMargin - top;\n\t        }\n\t\n\t        // If width and height are not given\n\t        // 1. Graph should not exceeds the container\n\t        // 2. Aspect must be keeped\n\t        // 3. Graph should take the space as more as possible\n\t        if (isNaN(width) && isNaN(height)) {\n\t            if (aspect > containerWidth / containerHeight) {\n\t                width = containerWidth * 0.8;\n\t            }\n\t            else {\n\t                height = containerHeight * 0.8;\n\t            }\n\t        }\n\t\n\t        if (aspect != null) {\n\t            // Calculate width or height with given aspect\n\t            if (isNaN(width)) {\n\t                width = aspect * height;\n\t            }\n\t            if (isNaN(height)) {\n\t                height = width / aspect;\n\t            }\n\t        }\n\t\n\t        // If left is not specified, calculate left from right and width\n\t        if (isNaN(left)) {\n\t            left = containerWidth - right - width - horizontalMargin;\n\t        }\n\t        if (isNaN(top)) {\n\t            top = containerHeight - bottom - height - verticalMargin;\n\t        }\n\t\n\t        // Align left and top\n\t        switch (positionInfo.left || positionInfo.right) {\n\t            case 'center':\n\t                left = containerWidth / 2 - width / 2 - margin[3];\n\t                break;\n\t            case 'right':\n\t                left = containerWidth - width - horizontalMargin;\n\t                break;\n\t        }\n\t        switch (positionInfo.top || positionInfo.bottom) {\n\t            case 'middle':\n\t            case 'center':\n\t                top = containerHeight / 2 - height / 2 - margin[0];\n\t                break;\n\t            case 'bottom':\n\t                top = containerHeight - height - verticalMargin;\n\t                break;\n\t        }\n\t        // If something is wrong and left, top, width, height are calculated as NaN\n\t        left = left || 0;\n\t        top = top || 0;\n\t        if (isNaN(width)) {\n\t            // Width may be NaN if only one value is given except width\n\t            width = containerWidth - left - (right || 0);\n\t        }\n\t        if (isNaN(height)) {\n\t            // Height may be NaN if only one value is given except height\n\t            height = containerHeight - top - (bottom || 0);\n\t        }\n\t\n\t        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n\t        rect.margin = margin;\n\t        return rect;\n\t    };\n\t\n\t    /**\n\t     * Position group of component in viewport\n\t     *  Group position is specified by either\n\t     *  {left, top}, {right, bottom}\n\t     *  If all properties exists, right and bottom will be igonred.\n\t     *\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     */\n\t    layout.positionGroup = function (\n\t        group, positionInfo, containerRect, margin\n\t    ) {\n\t        var groupRect = group.getBoundingRect();\n\t\n\t        positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {\n\t            width: groupRect.width,\n\t            height: groupRect.height\n\t        });\n\t\n\t        positionInfo = layout.getLayoutRect(\n\t            positionInfo, containerRect, margin\n\t        );\n\t\n\t        group.attr('position', [\n\t            positionInfo.x - groupRect.x,\n\t            positionInfo.y - groupRect.y\n\t        ]);\n\t    };\n\t\n\t    /**\n\t     * Consider Case:\n\t     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n\t     * through setOption or media query, using normal zrUtil.merge will cause\n\t     * {right: 0} does not take effect.\n\t     *\n\t     * @example\n\t     * ComponentModel.extend({\n\t     *     init: function () {\n\t     *         ...\n\t     *         var inputPositionParams = layout.getLayoutParams(option);\n\t     *         this.mergeOption(inputPositionParams);\n\t     *     },\n\t     *     mergeOption: function (newOption) {\n\t     *         newOption && zrUtil.merge(thisOption, newOption, true);\n\t     *         layout.mergeLayoutParam(thisOption, newOption);\n\t     *     }\n\t     * });\n\t     *\n\t     * @param {Object} targetOption\n\t     * @param {Object} newOption\n\t     * @param {Object|string} [opt]\n\t     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n\t     */\n\t    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n\t        !zrUtil.isObject(opt) && (opt = {});\n\t        var hNames = ['width', 'left', 'right']; // Order by priority.\n\t        var vNames = ['height', 'top', 'bottom']; // Order by priority.\n\t        var hResult = merge(hNames);\n\t        var vResult = merge(vNames);\n\t\n\t        copy(hNames, targetOption, hResult);\n\t        copy(vNames, targetOption, vResult);\n\t\n\t        function merge(names) {\n\t            var newParams = {};\n\t            var newValueCount = 0;\n\t            var merged = {};\n\t            var mergedValueCount = 0;\n\t            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\t\n\t            each(names, function (name) {\n\t                merged[name] = targetOption[name];\n\t            });\n\t            each(names, function (name) {\n\t                // Consider case: newOption.width is null, which is\n\t                // set by user for removing width setting.\n\t                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n\t                hasValue(newParams, name) && newValueCount++;\n\t                hasValue(merged, name) && mergedValueCount++;\n\t            });\n\t\n\t            // Case: newOption: {width: ..., right: ...},\n\t            // or targetOption: {right: ...} and newOption: {width: ...},\n\t            // There is no conflict when merged only has params count\n\t            // little than enoughParamNumber.\n\t            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n\t                return merged;\n\t            }\n\t            // Case: newOption: {width: ..., right: ...},\n\t            // Than we can make sure user only want those two, and ignore\n\t            // all origin params in targetOption.\n\t            else if (newValueCount >= enoughParamNumber) {\n\t                return newParams;\n\t            }\n\t            else {\n\t                // Chose another param from targetOption by priority.\n\t                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n\t                for (var i = 0; i < names.length; i++) {\n\t                    var name = names[i];\n\t                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n\t                        newParams[name] = targetOption[name];\n\t                        break;\n\t                    }\n\t                }\n\t                return newParams;\n\t            }\n\t        }\n\t\n\t        function hasProp(obj, name) {\n\t            return obj.hasOwnProperty(name);\n\t        }\n\t\n\t        function hasValue(obj, name) {\n\t            return obj[name] != null && obj[name] !== 'auto';\n\t        }\n\t\n\t        function copy(names, target, source) {\n\t            each(names, function (name) {\n\t                target[name] = source[name];\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.getLayoutParams = function (source) {\n\t        return layout.copyLayoutParams({}, source);\n\t    };\n\t\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.copyLayoutParams = function (target, source) {\n\t        source && target && each(LOCATION_PARAMS, function (name) {\n\t            source.hasOwnProperty(name) && (target[name] = source[name]);\n\t        });\n\t        return target;\n\t    };\n\t\n\t    module.exports = layout;\n\n\n/***/ },\n/* 14 */\n/*!**************************!*\\\n  !*** ./lib/data/List.js ***!\n  \\**************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * List for data storage\n\t * @module echarts/data/List\n\t */\n\t\n\t\n\t    var UNDEFINED = 'undefined';\n\t    var globalObj = typeof window === 'undefined' ? global : window;\n\t    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n\t        ? Array : globalObj.Float64Array;\n\t    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n\t        ? Array : globalObj.Int32Array;\n\t\n\t    var dataCtors = {\n\t        'float': Float64Array,\n\t        'int': Int32Array,\n\t        // Ordinal data type can be string or int\n\t        'ordinal': Array,\n\t        'number': Array,\n\t        'time': Array\n\t    };\n\t\n\t    var Model = __webpack_require__(/*! ../model/Model */ 10);\n\t    var DataDiffer = __webpack_require__(/*! ./DataDiffer */ 45);\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var modelUtil = __webpack_require__(/*! ../util/model */ 7);\n\t    var isObject = zrUtil.isObject;\n\t\n\t    var TRANSFERABLE_PROPERTIES = [\n\t        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n\t    ];\n\t\n\t    var transferProperties = function (a, b) {\n\t        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n\t            if (b.hasOwnProperty(propName)) {\n\t                a[propName] = b[propName];\n\t            }\n\t        });\n\t\n\t        a.__wrappedMethods = b.__wrappedMethods;\n\t    };\n\t\n\t    /**\n\t     * @constructor\n\t     * @alias module:echarts/data/List\n\t     *\n\t     * @param {Array.<string>} dimensions\n\t     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n\t     * @param {module:echarts/model/Model} hostModel\n\t     */\n\t    var List = function (dimensions, hostModel) {\n\t\n\t        dimensions = dimensions || ['x', 'y'];\n\t\n\t        var dimensionInfos = {};\n\t        var dimensionNames = [];\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimensionName;\n\t            var dimensionInfo = {};\n\t            if (typeof dimensions[i] === 'string') {\n\t                dimensionName = dimensions[i];\n\t                dimensionInfo = {\n\t                    name: dimensionName,\n\t                    stackable: false,\n\t                    // Type can be 'float', 'int', 'number'\n\t                    // Default is number, Precision of float may not enough\n\t                    type: 'number'\n\t                };\n\t            }\n\t            else {\n\t                dimensionInfo = dimensions[i];\n\t                dimensionName = dimensionInfo.name;\n\t                dimensionInfo.type = dimensionInfo.type || 'number';\n\t            }\n\t            dimensionNames.push(dimensionName);\n\t            dimensionInfos[dimensionName] = dimensionInfo;\n\t        }\n\t        /**\n\t         * @readOnly\n\t         * @type {Array.<string>}\n\t         */\n\t        this.dimensions = dimensionNames;\n\t\n\t        /**\n\t         * Infomation of each data dimension, like data type.\n\t         * @type {Object}\n\t         */\n\t        this._dimensionInfos = dimensionInfos;\n\t\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.hostModel = hostModel;\n\t\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.dataType;\n\t\n\t        /**\n\t         * Indices stores the indices of data subset after filtered.\n\t         * This data subset will be used in chart.\n\t         * @type {Array.<number>}\n\t         * @readOnly\n\t         */\n\t        this.indices = [];\n\t\n\t        /**\n\t         * Data storage\n\t         * @type {Object.<key, TypedArray|Array>}\n\t         * @private\n\t         */\n\t        this._storage = {};\n\t\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._nameList = [];\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._idList = [];\n\t        /**\n\t         * Models of data option is stored sparse for optimizing memory cost\n\t         * @type {Array.<module:echarts/model/Model>}\n\t         * @private\n\t         */\n\t        this._optionModels = [];\n\t\n\t        /**\n\t         * @param {module:echarts/data/List}\n\t         */\n\t        this.stackedOn = null;\n\t\n\t        /**\n\t         * Global visual properties after visual coding\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._visual = {};\n\t\n\t        /**\n\t         * Globel layout properties.\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._layout = {};\n\t\n\t        /**\n\t         * Item visual properties after visual coding\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemVisuals = [];\n\t\n\t        /**\n\t         * Item layout properties after layout\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemLayouts = [];\n\t\n\t        /**\n\t         * Graphic elemnents\n\t         * @type {Array.<module:zrender/Element>}\n\t         * @private\n\t         */\n\t        this._graphicEls = [];\n\t\n\t        /**\n\t         * @type {Array.<Array|Object>}\n\t         * @private\n\t         */\n\t        this._rawData;\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._extent;\n\t    };\n\t\n\t    var listProto = List.prototype;\n\t\n\t    listProto.type = 'list';\n\t    /**\n\t     * If each data item has it's own option\n\t     * @type {boolean}\n\t     */\n\t    listProto.hasItemOption = true;\n\t\n\t    /**\n\t     * Get dimension name\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     * @return {string} Concrete dim name.\n\t     */\n\t    listProto.getDimension = function (dim) {\n\t        if (!isNaN(dim)) {\n\t            dim = this.dimensions[dim] || dim;\n\t        }\n\t        return dim;\n\t    };\n\t    /**\n\t     * Get type and stackable info of particular dimension\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     */\n\t    listProto.getDimensionInfo = function (dim) {\n\t        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n\t    };\n\t\n\t    /**\n\t     * Initialize from data\n\t     * @param {Array.<Object|number|Array>} data\n\t     * @param {Array.<string>} [nameList]\n\t     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n\t     */\n\t    listProto.initData = function (data, nameList, dimValueGetter) {\n\t        data = data || [];\n\t\n\t        if (false) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t\n\t        this._rawData = data;\n\t\n\t        // Clear\n\t        var storage = this._storage = {};\n\t        var indices = this.indices = [];\n\t\n\t        var dimensions = this.dimensions;\n\t        var size = data.length;\n\t        var dimensionInfoMap = this._dimensionInfos;\n\t\n\t        var idList = [];\n\t        var nameRepeatCount = {};\n\t\n\t        nameList = nameList || [];\n\t\n\t        // Init storage\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimInfo = dimensionInfoMap[dimensions[i]];\n\t            var DataCtor = dataCtors[dimInfo.type];\n\t            storage[dimensions[i]] = new DataCtor(size);\n\t        }\n\t\n\t        var self = this;\n\t        if (!dimValueGetter) {\n\t            self.hasItemOption = false;\n\t        }\n\t        // Default dim value getter\n\t        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n\t            var value = modelUtil.getDataItemValue(dataItem);\n\t            // If any dataItem is like { value: 10 }\n\t            if (modelUtil.isDataItemOption(dataItem)) {\n\t                self.hasItemOption = true;\n\t            }\n\t            return modelUtil.converDataValue(\n\t                (value instanceof Array)\n\t                    ? value[dimIndex]\n\t                    // If value is a single number or something else not array.\n\t                    : value,\n\t                dimensionInfoMap[dimName]\n\t            );\n\t        };\n\t\n\t        for (var idx = 0; idx < data.length; idx++) {\n\t            var dataItem = data[idx];\n\t            // Each data item is value\n\t            // [1, 2]\n\t            // 2\n\t            // Bar chart, line chart which uses category axis\n\t            // only gives the 'y' value. 'x' value is the indices of cateogry\n\t            // Use a tempValue to normalize the value to be a (x, y) value\n\t\n\t            // Store the data by dimensions\n\t            for (var k = 0; k < dimensions.length; k++) {\n\t                var dim = dimensions[k];\n\t                var dimStorage = storage[dim];\n\t                // PENDING NULL is empty or zero\n\t                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n\t            }\n\t\n\t            indices.push(idx);\n\t        }\n\t\n\t        // Use the name in option and create id\n\t        for (var i = 0; i < data.length; i++) {\n\t            if (!nameList[i]) {\n\t                if (data[i] && data[i].name != null) {\n\t                    nameList[i] = data[i].name;\n\t                }\n\t            }\n\t            var name = nameList[i] || '';\n\t            // Try using the id in option\n\t            var id = data[i] && data[i].id;\n\t\n\t            if (!id && name) {\n\t                // Use name as id and add counter to avoid same name\n\t                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n\t                id = name;\n\t                if (nameRepeatCount[name] > 0) {\n\t                    id += '__ec__' + nameRepeatCount[name];\n\t                }\n\t                nameRepeatCount[name]++;\n\t            }\n\t            id && (idList[i] = id);\n\t        }\n\t\n\t        this._nameList = nameList;\n\t        this._idList = idList;\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    listProto.count = function () {\n\t        return this.indices.length;\n\t    };\n\t\n\t    /**\n\t     * Get value. Return NaN if idx is out of range.\n\t     * @param {string} dim Dim must be concrete name.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.get = function (dim, idx, stack) {\n\t        var storage = this._storage;\n\t        var dataIndex = this.indices[idx];\n\t\n\t        // If value not exists\n\t        if (dataIndex == null) {\n\t            return NaN;\n\t        }\n\t\n\t        var value = storage[dim] && storage[dim][dataIndex];\n\t        // FIXME ordinal data type is not stackable\n\t        if (stack) {\n\t            var dimensionInfo = this._dimensionInfos[dim];\n\t            if (dimensionInfo && dimensionInfo.stackable) {\n\t                var stackedOn = this.stackedOn;\n\t                while (stackedOn) {\n\t                    // Get no stacked data of stacked on\n\t                    var stackedValue = stackedOn.get(dim, idx);\n\t                    // Considering positive stack, negative stack and empty data\n\t                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n\t                        || (value <= 0 && stackedValue < 0) // Negative stack\n\t                    ) {\n\t                        value += stackedValue;\n\t                    }\n\t                    stackedOn = stackedOn.stackedOn;\n\t                }\n\t            }\n\t        }\n\t        return value;\n\t    };\n\t\n\t    /**\n\t     * Get value for multi dimensions.\n\t     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.getValues = function (dimensions, idx, stack) {\n\t        var values = [];\n\t\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            stack = idx;\n\t            idx = dimensions;\n\t            dimensions = this.dimensions;\n\t        }\n\t\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            values.push(this.get(dimensions[i], idx, stack));\n\t        }\n\t\n\t        return values;\n\t    };\n\t\n\t    /**\n\t     * If value is NaN. Inlcuding '-'\n\t     * @param {string} dim\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.hasValue = function (idx) {\n\t        var dimensions = this.dimensions;\n\t        var dimensionInfos = this._dimensionInfos;\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            if (\n\t                // Ordinal type can be string or number\n\t                dimensionInfos[dimensions[i]].type !== 'ordinal'\n\t                && isNaN(this.get(dimensions[i], idx))\n\t            ) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t\n\t    /**\n\t     * Get extent of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getDataExtent = function (dim, stack) {\n\t        dim = this.getDimension(dim);\n\t        var dimData = this._storage[dim];\n\t        var dimInfo = this.getDimensionInfo(dim);\n\t        stack = (dimInfo && dimInfo.stackable) && stack;\n\t        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n\t        var value;\n\t        if (dimExtent) {\n\t            return dimExtent;\n\t        }\n\t        // var dimInfo = this._dimensionInfos[dim];\n\t        if (dimData) {\n\t            var min = Infinity;\n\t            var max = -Infinity;\n\t            // var isOrdinal = dimInfo.type === 'ordinal';\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                value = this.get(dim, i, stack);\n\t                // FIXME\n\t                // if (isOrdinal && typeof value === 'string') {\n\t                //     value = zrUtil.indexOf(dimData, value);\n\t                // }\n\t                value < min && (min = value);\n\t                value > max && (max = value);\n\t            }\n\t            return (this._extent[dim + !!stack] = [min, max]);\n\t        }\n\t        else {\n\t            return [Infinity, -Infinity];\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Get sum of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getSum = function (dim, stack) {\n\t        var dimData = this._storage[dim];\n\t        var sum = 0;\n\t        if (dimData) {\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var value = this.get(dim, i, stack);\n\t                if (!isNaN(value)) {\n\t                    sum += value;\n\t                }\n\t            }\n\t        }\n\t        return sum;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index with given value\n\t     * @param {number} idx\n\t     * @param {number} value\n\t     * @return {number}\n\t     */\n\t    // FIXME Precision of float value\n\t    listProto.indexOf = function (dim, value) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t        var indices = this.indices;\n\t\n\t        if (dimData) {\n\t            for (var i = 0, len = indices.length; i < len; i++) {\n\t                var rawIndex = indices[i];\n\t                if (dimData[rawIndex] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index with given name\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfName = function (name) {\n\t        var indices = this.indices;\n\t        var nameList = this._nameList;\n\t\n\t        for (var i = 0, len = indices.length; i < len; i++) {\n\t            var rawIndex = indices[i];\n\t            if (nameList[rawIndex] === name) {\n\t                return i;\n\t            }\n\t        }\n\t\n\t        return -1;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index with given raw data index\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfRawIndex = function (rawIndex) {\n\t        // Indices are ascending\n\t        var indices = this.indices;\n\t\n\t        // If rawIndex === dataIndex\n\t        var rawDataIndex = indices[rawIndex];\n\t        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n\t            return rawIndex;\n\t        }\n\t\n\t        var left = 0;\n\t        var right = indices.length - 1;\n\t        while (left <= right) {\n\t            var mid = (left + right) / 2 | 0;\n\t            if (indices[mid] < rawIndex) {\n\t                left = mid + 1;\n\t            }\n\t            else if (indices[mid] > rawIndex) {\n\t                right = mid - 1;\n\t            }\n\t            else {\n\t                return mid;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index of nearest value\n\t     * @param {string} dim\n\t     * @param {number} value\n\t     * @param {boolean} stack If given value is after stacked\n\t     * @param {number} [maxDistance=Infinity]\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t\n\t        if (maxDistance == null) {\n\t            maxDistance = Infinity;\n\t        }\n\t\n\t        var nearestIdx = -1;\n\t        if (dimData) {\n\t            var minDist = Number.MAX_VALUE;\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var diff = value - this.get(dim, i, stack);\n\t                var dist = Math.abs(diff);\n\t                if (\n\t                    diff <= maxDistance\n\t                    && (dist < minDist\n\t                        // For the case of two data are same on xAxis, which has sequence data.\n\t                        // Show the nearest index\n\t                        // https://github.com/ecomfe/echarts/issues/2869\n\t                        || (dist === minDist && diff > 0)\n\t                    )\n\t                ) {\n\t                    minDist = dist;\n\t                    nearestIdx = i;\n\t                }\n\t            }\n\t        }\n\t        return nearestIdx;\n\t    };\n\t\n\t    /**\n\t     * Get raw data index\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawIndex = function (idx) {\n\t        var rawIdx = this.indices[idx];\n\t        return rawIdx == null ? -1 : rawIdx;\n\t    };\n\t\n\t    /**\n\t     * Get raw data item\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawDataItem = function (idx) {\n\t        return this._rawData[this.getRawIndex(idx)];\n\t    };\n\t\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getName = function (idx) {\n\t        return this._nameList[this.indices[idx]] || '';\n\t    };\n\t\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getId = function (idx) {\n\t        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n\t    };\n\t\n\t\n\t    function normalizeDimensions(dimensions) {\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            dimensions = [dimensions];\n\t        }\n\t        return dimensions;\n\t    }\n\t\n\t    /**\n\t     * Data iteration\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     *\n\t     * @example\n\t     *  list.each('x', function (x, idx) {});\n\t     *  list.each(['x', 'y'], function (x, y, idx) {});\n\t     *  list.each(function (idx) {})\n\t     */\n\t    listProto.each = function (dims, cb, stack, context) {\n\t        if (typeof dims === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dims;\n\t            dims = [];\n\t        }\n\t\n\t        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\t\n\t        var value = [];\n\t        var dimSize = dims.length;\n\t        var indices = this.indices;\n\t\n\t        context = context || this;\n\t\n\t        for (var i = 0; i < indices.length; i++) {\n\t            // Simple optimization\n\t            switch (dimSize) {\n\t                case 0:\n\t                    cb.call(context, i);\n\t                    break;\n\t                case 1:\n\t                    cb.call(context, this.get(dims[0], i, stack), i);\n\t                    break;\n\t                case 2:\n\t                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n\t                    break;\n\t                default:\n\t                    for (var k = 0; k < dimSize; k++) {\n\t                        value[k] = this.get(dims[k], i, stack);\n\t                    }\n\t                    // Index\n\t                    value[k] = i;\n\t                    cb.apply(context, value);\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Data filter\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     */\n\t    listProto.filterSelf = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t\n\t        dimensions = zrUtil.map(\n\t            normalizeDimensions(dimensions), this.getDimension, this\n\t        );\n\t\n\t        var newIndices = [];\n\t        var value = [];\n\t        var dimSize = dimensions.length;\n\t        var indices = this.indices;\n\t\n\t        context = context || this;\n\t\n\t        for (var i = 0; i < indices.length; i++) {\n\t            var keep;\n\t            // Simple optimization\n\t            if (dimSize === 1) {\n\t                keep = cb.call(\n\t                    context, this.get(dimensions[0], i, stack), i\n\t                );\n\t            }\n\t            else {\n\t                for (var k = 0; k < dimSize; k++) {\n\t                    value[k] = this.get(dimensions[k], i, stack);\n\t                }\n\t                value[k] = i;\n\t                keep = cb.apply(context, value);\n\t            }\n\t            if (keep) {\n\t                newIndices.push(indices[i]);\n\t            }\n\t        }\n\t\n\t        this.indices = newIndices;\n\t\n\t        // Reset data extent\n\t        this._extent = {};\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Data mapping to a plain array\n\t     * @param {string|Array.<string>} [dimensions]\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.mapArray = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t\n\t        var result = [];\n\t        this.each(dimensions, function () {\n\t            result.push(cb && cb.apply(this, arguments));\n\t        }, stack, context);\n\t        return result;\n\t    };\n\t\n\t    function cloneListForMapAndSample(original, excludeDimensions) {\n\t        var allDimensions = original.dimensions;\n\t        var list = new List(\n\t            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n\t            original.hostModel\n\t        );\n\t        // FIXME If needs stackedOn, value may already been stacked\n\t        transferProperties(list, original);\n\t\n\t        var storage = list._storage = {};\n\t        var originalStorage = original._storage;\n\t        // Init storage\n\t        for (var i = 0; i < allDimensions.length; i++) {\n\t            var dim = allDimensions[i];\n\t            var dimStore = originalStorage[dim];\n\t            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n\t                storage[dim] = new dimStore.constructor(\n\t                    originalStorage[dim].length\n\t                );\n\t            }\n\t            else {\n\t                // Direct reference for other dimensions\n\t                storage[dim] = originalStorage[dim];\n\t            }\n\t        }\n\t        return list;\n\t    }\n\t\n\t    /**\n\t     * Data mapping to a new List with given dimensions\n\t     * @param {string|Array.<string>} dimensions\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.map = function (dimensions, cb, stack, context) {\n\t        dimensions = zrUtil.map(\n\t            normalizeDimensions(dimensions), this.getDimension, this\n\t        );\n\t\n\t        var list = cloneListForMapAndSample(this, dimensions);\n\t        // Following properties are all immutable.\n\t        // So we can reference to the same value\n\t        var indices = list.indices = this.indices;\n\t\n\t        var storage = list._storage;\n\t\n\t        var tmpRetValue = [];\n\t        this.each(dimensions, function () {\n\t            var idx = arguments[arguments.length - 1];\n\t            var retValue = cb && cb.apply(this, arguments);\n\t            if (retValue != null) {\n\t                // a number\n\t                if (typeof retValue === 'number') {\n\t                    tmpRetValue[0] = retValue;\n\t                    retValue = tmpRetValue;\n\t                }\n\t                for (var i = 0; i < retValue.length; i++) {\n\t                    var dim = dimensions[i];\n\t                    var dimStore = storage[dim];\n\t                    var rawIdx = indices[idx];\n\t                    if (dimStore) {\n\t                        dimStore[rawIdx] = retValue[i];\n\t                    }\n\t                }\n\t            }\n\t        }, stack, context);\n\t\n\t        return list;\n\t    };\n\t\n\t    /**\n\t     * Large data down sampling on given dimension\n\t     * @param {string} dimension\n\t     * @param {number} rate\n\t     * @param {Function} sampleValue\n\t     * @param {Function} sampleIndex Sample index for name and id\n\t     */\n\t    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n\t        var list = cloneListForMapAndSample(this, [dimension]);\n\t        var storage = this._storage;\n\t        var targetStorage = list._storage;\n\t\n\t        var originalIndices = this.indices;\n\t        var indices = list.indices = [];\n\t\n\t        var frameValues = [];\n\t        var frameIndices = [];\n\t        var frameSize = Math.floor(1 / rate);\n\t\n\t        var dimStore = targetStorage[dimension];\n\t        var len = this.count();\n\t        // Copy data from original data\n\t        for (var i = 0; i < storage[dimension].length; i++) {\n\t            targetStorage[dimension][i] = storage[dimension][i];\n\t        }\n\t        for (var i = 0; i < len; i += frameSize) {\n\t            // Last frame\n\t            if (frameSize > len - i) {\n\t                frameSize = len - i;\n\t                frameValues.length = frameSize;\n\t            }\n\t            for (var k = 0; k < frameSize; k++) {\n\t                var idx = originalIndices[i + k];\n\t                frameValues[k] = dimStore[idx];\n\t                frameIndices[k] = idx;\n\t            }\n\t            var value = sampleValue(frameValues);\n\t            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n\t            // Only write value on the filtered data\n\t            dimStore[idx] = value;\n\t            indices.push(idx);\n\t        }\n\t\n\t        return list;\n\t    };\n\t\n\t    /**\n\t     * Get model of one data item.\n\t     *\n\t     * @param {number} idx\n\t     */\n\t    // FIXME Model proxy ?\n\t    listProto.getItemModel = function (idx) {\n\t        var hostModel = this.hostModel;\n\t        idx = this.indices[idx];\n\t        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n\t    };\n\t\n\t    /**\n\t     * Create a data differ\n\t     * @param {module:echarts/data/List} otherList\n\t     * @return {module:echarts/data/DataDiffer}\n\t     */\n\t    listProto.diff = function (otherList) {\n\t        var idList = this._idList;\n\t        var otherIdList = otherList && otherList._idList;\n\t        return new DataDiffer(\n\t            otherList ? otherList.indices : [], this.indices, function (idx) {\n\t                return otherIdList[idx] || (idx + '');\n\t            }, function (idx) {\n\t                return idList[idx] || (idx + '');\n\t            }\n\t        );\n\t    };\n\t    /**\n\t     * Get visual property.\n\t     * @param {string} key\n\t     */\n\t    listProto.getVisual = function (key) {\n\t        var visual = this._visual;\n\t        return visual && visual[key];\n\t    };\n\t\n\t    /**\n\t     * Set visual property\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setVisual('color', color);\n\t     *  setVisual({\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setVisual = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setVisual(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._visual = this._visual || {};\n\t        this._visual[key] = val;\n\t    };\n\t\n\t    /**\n\t     * Set layout property.\n\t     * @param {string} key\n\t     * @param {*} [val]\n\t     */\n\t    listProto.setLayout = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setLayout(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._layout[key] = val;\n\t    };\n\t\n\t    /**\n\t     * Get layout property.\n\t     * @param  {string} key.\n\t     * @return {*}\n\t     */\n\t    listProto.getLayout = function (key) {\n\t        return this._layout[key];\n\t    };\n\t\n\t    /**\n\t     * Get layout of single data item\n\t     * @param {number} idx\n\t     */\n\t    listProto.getItemLayout = function (idx) {\n\t        return this._itemLayouts[idx];\n\t    };\n\t\n\t    /**\n\t     * Set layout of single data item\n\t     * @param {number} idx\n\t     * @param {Object} layout\n\t     * @param {boolean=} [merge=false]\n\t     */\n\t    listProto.setItemLayout = function (idx, layout, merge) {\n\t        this._itemLayouts[idx] = merge\n\t            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n\t            : layout;\n\t    };\n\t\n\t    /**\n\t     * Clear all layout of single data item\n\t     */\n\t    listProto.clearItemLayouts = function () {\n\t        this._itemLayouts.length = 0;\n\t    };\n\t\n\t    /**\n\t     * Get visual property of single data item\n\t     * @param {number} idx\n\t     * @param {string} key\n\t     * @param {boolean} ignoreParent\n\t     */\n\t    listProto.getItemVisual = function (idx, key, ignoreParent) {\n\t        var itemVisual = this._itemVisuals[idx];\n\t        var val = itemVisual && itemVisual[key];\n\t        if (val == null && !ignoreParent) {\n\t            // Use global visual property\n\t            return this.getVisual(key);\n\t        }\n\t        return val;\n\t    };\n\t\n\t    /**\n\t     * Set visual property of single data item\n\t     *\n\t     * @param {number} idx\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setItemVisual(0, 'color', color);\n\t     *  setItemVisual(0, {\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setItemVisual = function (idx, key, value) {\n\t        var itemVisual = this._itemVisuals[idx] || {};\n\t        this._itemVisuals[idx] = itemVisual;\n\t\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    itemVisual[name] = key[name];\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        itemVisual[key] = value;\n\t    };\n\t\n\t    /**\n\t     * Clear itemVisuals and list visual.\n\t     */\n\t    listProto.clearAllVisual = function () {\n\t        this._visual = {};\n\t        this._itemVisuals = [];\n\t    };\n\t\n\t    var setItemDataAndSeriesIndex = function (child) {\n\t        child.seriesIndex = this.seriesIndex;\n\t        child.dataIndex = this.dataIndex;\n\t        child.dataType = this.dataType;\n\t    };\n\t    /**\n\t     * Set graphic element relative to data. It can be set as null\n\t     * @param {number} idx\n\t     * @param {module:zrender/Element} [el]\n\t     */\n\t    listProto.setItemGraphicEl = function (idx, el) {\n\t        var hostModel = this.hostModel;\n\t\n\t        if (el) {\n\t            // Add data index and series index for indexing the data by element\n\t            // Useful in tooltip\n\t            el.dataIndex = idx;\n\t            el.dataType = this.dataType;\n\t            el.seriesIndex = hostModel && hostModel.seriesIndex;\n\t            if (el.type === 'group') {\n\t                el.traverse(setItemDataAndSeriesIndex, el);\n\t            }\n\t        }\n\t\n\t        this._graphicEls[idx] = el;\n\t    };\n\t\n\t    /**\n\t     * @param {number} idx\n\t     * @return {module:zrender/Element}\n\t     */\n\t    listProto.getItemGraphicEl = function (idx) {\n\t        return this._graphicEls[idx];\n\t    };\n\t\n\t    /**\n\t     * @param {Function} cb\n\t     * @param {*} context\n\t     */\n\t    listProto.eachItemGraphicEl = function (cb, context) {\n\t        zrUtil.each(this._graphicEls, function (el, idx) {\n\t            if (el) {\n\t                cb && cb.call(context, el, idx);\n\t            }\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Shallow clone a new list except visual and layout properties, and graph elements.\n\t     * New list only change the indices.\n\t     */\n\t    listProto.cloneShallow = function () {\n\t        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n\t        var list = new List(dimensionInfoList, this.hostModel);\n\t\n\t        // FIXME\n\t        list._storage = this._storage;\n\t\n\t        transferProperties(list, this);\n\t\n\t\n\t        // Clone will not change the data extent and indices\n\t        list.indices = this.indices.slice();\n\t\n\t        if (this._extent) {\n\t            list._extent = zrUtil.extend({}, this._extent);\n\t        }\n\t\n\t        return list;\n\t    };\n\t\n\t    /**\n\t     * Wrap some method to add more feature\n\t     * @param {string} methodName\n\t     * @param {Function} injectFunction\n\t     */\n\t    listProto.wrapMethod = function (methodName, injectFunction) {\n\t        var originalMethod = this[methodName];\n\t        if (typeof originalMethod !== 'function') {\n\t            return;\n\t        }\n\t        this.__wrappedMethods = this.__wrappedMethods || [];\n\t        this.__wrappedMethods.push(methodName);\n\t        this[methodName] = function () {\n\t            var res = originalMethod.apply(this, arguments);\n\t            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n\t        };\n\t    };\n\t\n\t    // Methods that create a new list based on this list should be listed here.\n\t    // Notice that those method should `RETURN` the new list.\n\t    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n\t    // Methods that change indices of this list should be listed here.\n\t    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\t\n\t    module.exports = List;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 15 */\n/*!*****************************!*\\\n  !*** ./lib/model/Series.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var formatUtil = __webpack_require__(/*! ../util/format */ 9);\n\t    var modelUtil = __webpack_require__(/*! ../util/model */ 7);\n\t    var ComponentModel = __webpack_require__(/*! ./Component */ 12);\n\t    var colorPaletteMixin = __webpack_require__(/*! ./mixin/colorPalette */ 56);\n\t    var env = __webpack_require__(/*! zrender/lib/core/env */ 11);\n\t\n\t    var encodeHTML = formatUtil.encodeHTML;\n\t    var addCommas = formatUtil.addCommas;\n\t\n\t    var SeriesModel = ComponentModel.extend({\n\t\n\t        type: 'series.__base__',\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        seriesIndex: 0,\n\t\n\t        // coodinateSystem will be injected in the echarts/CoordinateSystem\n\t        coordinateSystem: null,\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        defaultOption: null,\n\t\n\t        /**\n\t         * Data provided for legend\n\t         * @type {Function}\n\t         */\n\t        // PENDING\n\t        legendDataProvider: null,\n\t\n\t        /**\n\t         * Access path of color for visual\n\t         */\n\t        visualColorAccessPath: 'itemStyle.normal.color',\n\t\n\t        init: function (option, parentModel, ecModel, extraOpt) {\n\t\n\t            /**\n\t             * @type {number}\n\t             * @readOnly\n\t             */\n\t            this.seriesIndex = this.componentIndex;\n\t\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t\n\t            /**\n\t             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n\t             * @private\n\t             */\n\t            this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n\t\n\t            // If we reverse the order (make this._data firstly, and then make\n\t            // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n\t            // cause this._data.graph.data !== this._data when using\n\t            // module:echarts/data/Graph or module:echarts/data/Tree.\n\t            // See module:echarts/data/helper/linkList\n\t            this._data = this._dataBeforeProcessed.cloneShallow();\n\t        },\n\t\n\t        /**\n\t         * Util for merge default and theme to option\n\t         * @param  {Object} option\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         */\n\t        mergeDefaultAndTheme: function (option, ecModel) {\n\t            zrUtil.merge(\n\t                option,\n\t                ecModel.getTheme().get(this.subType)\n\t            );\n\t            zrUtil.merge(option, this.getDefaultOption());\n\t\n\t            // Default label emphasis `position` and `show`\n\t            // FIXME Set label in mergeOption\n\t            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\t\n\t            this.fillDataTextStyle(option.data);\n\t        },\n\t\n\t        mergeOption: function (newSeriesOption, ecModel) {\n\t            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n\t            this.fillDataTextStyle(newSeriesOption.data);\n\t\n\t            var data = this.getInitialData(newSeriesOption, ecModel);\n\t            // TODO Merge data?\n\t            if (data) {\n\t                this._data = data;\n\t                this._dataBeforeProcessed = data.cloneShallow();\n\t            }\n\t        },\n\t\n\t        fillDataTextStyle: function (data) {\n\t            // Default data label emphasis `position` and `show`\n\t            // FIXME Tree structure data ?\n\t            // FIXME Performance ?\n\t            if (data) {\n\t                for (var i = 0; i < data.length; i++) {\n\t                    if (data[i] && data[i].label) {\n\t                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Init a data structure from data related option in series\n\t         * Must be overwritten\n\t         */\n\t        getInitialData: function () {},\n\t\n\t        /**\n\t         * @param {string} [dataType]\n\t         * @return {module:echarts/data/List}\n\t         */\n\t        getData: function (dataType) {\n\t            return dataType == null ? this._data : this._data.getLinkedData(dataType);\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/data/List} data\n\t         */\n\t        setData: function (data) {\n\t            this._data = data;\n\t        },\n\t\n\t        /**\n\t         * Get data before processed\n\t         * @return {module:echarts/data/List}\n\t         */\n\t        getRawData: function () {\n\t            return this._dataBeforeProcessed;\n\t        },\n\t\n\t        /**\n\t         * Coord dimension to data dimension.\n\t         *\n\t         * By default the result is the same as dimensions of series data.\n\t         * But in some series data dimensions are different from coord dimensions (i.e.\n\t         * candlestick and boxplot). Override this method to handle those cases.\n\t         *\n\t         * Coord dimension to data dimension can be one-to-many\n\t         *\n\t         * @param {string} coordDim\n\t         * @return {Array.<string>} dimensions on the axis.\n\t         */\n\t        coordDimToDataDim: function (coordDim) {\n\t            return [coordDim];\n\t        },\n\t\n\t        /**\n\t         * Convert data dimension to coord dimension.\n\t         *\n\t         * @param {string|number} dataDim\n\t         * @return {string}\n\t         */\n\t        dataDimToCoordDim: function (dataDim) {\n\t            return dataDim;\n\t        },\n\t\n\t        /**\n\t         * Get base axis if has coordinate system and has axis.\n\t         * By default use coordSys.getBaseAxis();\n\t         * Can be overrided for some chart.\n\t         * @return {type} description\n\t         */\n\t        getBaseAxis: function () {\n\t            var coordSys = this.coordinateSystem;\n\t            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n\t        },\n\t\n\t        // FIXME\n\t        /**\n\t         * Default tooltip formatter\n\t         *\n\t         * @param {number} dataIndex\n\t         * @param {boolean} [multipleSeries=false]\n\t         * @param {number} [dataType]\n\t         */\n\t        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n\t            function formatArrayValue(value) {\n\t                var result = [];\n\t\n\t                zrUtil.each(value, function (val, idx) {\n\t                    var dimInfo = data.getDimensionInfo(idx);\n\t                    var dimType = dimInfo && dimInfo.type;\n\t                    var valStr;\n\t\n\t                    if (dimType === 'ordinal') {\n\t                        valStr = val + '';\n\t                    }\n\t                    else if (dimType === 'time') {\n\t                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/mm/dd hh:mm:ss', val);\n\t                    }\n\t                    else {\n\t                        valStr = addCommas(val);\n\t                    }\n\t\n\t                    valStr && result.push(valStr);\n\t                });\n\t\n\t                return result.join(', ');\n\t            }\n\t\n\t            var data = this._data;\n\t\n\t            var value = this.getRawValue(dataIndex);\n\t            var formattedValue = zrUtil.isArray(value)\n\t                ? formatArrayValue(value) : addCommas(value);\n\t            var name = data.getName(dataIndex);\n\t            var color = data.getItemVisual(dataIndex, 'color');\n\t            var colorEl = '<span style=\"display:inline-block;margin-right:5px;'\n\t                + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n\t\n\t            var seriesName = this.name;\n\t            // FIXME\n\t            if (seriesName === '\\0-') {\n\t                // Not show '-'\n\t                seriesName = '';\n\t            }\n\t            return !multipleSeries\n\t                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl\n\t                    + (name\n\t                        ? encodeHTML(name) + ' : ' + formattedValue\n\t                        : formattedValue)\n\t                  )\n\t                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);\n\t        },\n\t\n\t        /**\n\t         * @return {boolean}\n\t         */\n\t        ifEnableAnimation: function () {\n\t            if (env.node) {\n\t                return false;\n\t            }\n\t\n\t            var animationEnabled = this.getShallow('animation');\n\t            if (animationEnabled) {\n\t                if (this.getData().count() > this.getShallow('animationThreshold')) {\n\t                    animationEnabled = false;\n\t                }\n\t            }\n\t            return animationEnabled;\n\t        },\n\t\n\t        restoreData: function () {\n\t            this._data = this._dataBeforeProcessed.cloneShallow();\n\t        },\n\t\n\t        getColorFromPalette: function (name, scope) {\n\t            var ecModel = this.ecModel;\n\t            // PENDING\n\t            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n\t            if (!color) {\n\t                color = ecModel.getColorFromPalette(name, scope);\n\t            }\n\t            return color;\n\t        },\n\t\n\t        /**\n\t         * Get data indices for show tooltip content. See tooltip.\n\t         * @abstract\n\t         * @param {Array.<string>|string} dim\n\t         * @param {Array.<number>} value\n\t         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n\t         * @return {Array.<number>} data indices.\n\t         */\n\t        getAxisTooltipDataIndex: null,\n\t\n\t        /**\n\t         * See tooltip.\n\t         * @abstract\n\t         * @param {number} dataIndex\n\t         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n\t         */\n\t        getTooltipPosition: null\n\t    });\n\t\n\t    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n\t    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\t\n\t    module.exports = SeriesModel;\n\n\n/***/ },\n/* 16 */\n/*!***************************************!*\\\n  !*** ./~/zrender/lib/contain/text.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t    var TEXT_CACHE_MAX = 5000;\n\t\n\t    var util = __webpack_require__(/*! ../core/util */ 1);\n\t    var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ 8);\n\t    var retrieve = util.retrieve;\n\t\n\t    function getTextWidth(text, textFont) {\n\t        var key = text + ':' + textFont;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // measureText  Canvas \n\t            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n\t        }\n\t\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t\n\t        return width;\n\t    }\n\t\n\t    function getTextRect(text, textFont, textAlign, textBaseline) {\n\t        var textLineLen = ((text || '') + '').split('\\n').length;\n\t\n\t        var width = getTextWidth(text, textFont);\n\t        // FIXME \n\t        var lineHeight = getTextWidth('', textFont);\n\t        var height = textLineLen * lineHeight;\n\t\n\t        var rect = new BoundingRect(0, 0, width, height);\n\t        // Text has a special line height property\n\t        rect.lineHeight = lineHeight;\n\t\n\t        switch (textBaseline) {\n\t            case 'bottom':\n\t            case 'alphabetic':\n\t                rect.y -= lineHeight;\n\t                break;\n\t            case 'middle':\n\t                rect.y -= lineHeight / 2;\n\t                break;\n\t            // case 'hanging':\n\t            // case 'top':\n\t        }\n\t\n\t        // FIXME Right to left language\n\t        switch (textAlign) {\n\t            case 'end':\n\t            case 'right':\n\t                rect.x -= rect.width;\n\t                break;\n\t            case 'center':\n\t                rect.x -= rect.width / 2;\n\t                break;\n\t            // case 'start':\n\t            // case 'left':\n\t        }\n\t\n\t        return rect;\n\t    }\n\t\n\t    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\t\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t\n\t        var textHeight = textRect.height;\n\t\n\t        var halfHeight = height / 2 - textHeight / 2;\n\t\n\t        var textAlign = 'left';\n\t\n\t        switch (textPosition) {\n\t            case 'left':\n\t                x -= distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'right':\n\t                x += distance + width;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'top':\n\t                x += width / 2;\n\t                y -= distance + textHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'bottom':\n\t                x += width / 2;\n\t                y += height + distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'inside':\n\t                x += width / 2;\n\t                y += halfHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideLeft':\n\t                x += distance;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideRight':\n\t                x += width - distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideTop':\n\t                x += width / 2;\n\t                y += distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideBottom':\n\t                x += width / 2;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideTopLeft':\n\t                x += distance;\n\t                y += distance;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideTopRight':\n\t                x += width - distance;\n\t                y += distance;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideBottomLeft':\n\t                x += distance;\n\t                y += height - textHeight - distance;\n\t                break;\n\t            case 'insideBottomRight':\n\t                x += width - distance;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'right';\n\t                break;\n\t        }\n\t\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textBaseline: 'top'\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @param  {string} text\n\t     * @param  {string} containerWidth\n\t     * @param  {string} textFont\n\t     * @param  {number} [ellipsis='...']\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minChar=0] If truncate result are less\n\t     *                  then minChar, ellipsis will not show, which is\n\t     *                  better for user hint in some cases.\n\t     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t     * @return {string}\n\t     */\n\t    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t\n\t        options = options || {};\n\t\n\t        ellipsis = retrieve(ellipsis, '...');\n\t        var maxIterations = retrieve(options.maxIterations, 2);\n\t        var minChar = retrieve(options.minChar, 0);\n\t        // FIXME\n\t        // Other languages?\n\t        var cnCharWidth = getTextWidth('', textFont);\n\t        // FIXME\n\t        // Consider proportional font?\n\t        var ascCharWidth = getTextWidth('a', textFont);\n\t        var placeholder = retrieve(options.placeholder, '');\n\t\n\t        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n\t        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\t        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t            contentWidth -= ascCharWidth;\n\t        }\n\t\n\t        var ellipsisWidth = getTextWidth(ellipsis);\n\t        if (ellipsisWidth > contentWidth) {\n\t            ellipsis = '';\n\t            ellipsisWidth = 0;\n\t        }\n\t\n\t        contentWidth = containerWidth - ellipsisWidth;\n\t\n\t        var textLines = (text + '').split('\\n');\n\t\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            var textLine = textLines[i];\n\t            var lineWidth = getTextWidth(textLine, textFont);\n\t\n\t            if (lineWidth <= containerWidth) {\n\t                continue;\n\t            }\n\t\n\t            for (var j = 0;; j++) {\n\t                if (lineWidth <= contentWidth || j >= maxIterations) {\n\t                    textLine += ellipsis;\n\t                    break;\n\t                }\n\t\n\t                var subLength = j === 0\n\t                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n\t                    : lineWidth > 0\n\t                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n\t                    : 0;\n\t\n\t                textLine = textLine.substr(0, subLength);\n\t                lineWidth = getTextWidth(textLine, textFont);\n\t            }\n\t\n\t            if (textLine === '') {\n\t                textLine = placeholder;\n\t            }\n\t\n\t            textLines[i] = textLine;\n\t        }\n\t\n\t        return textLines.join('\\n');\n\t    }\n\t\n\t    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < contentWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t\n\t    var textContain = {\n\t\n\t        getWidth: getTextWidth,\n\t\n\t        getBoundingRect: getTextRect,\n\t\n\t        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t\n\t        truncateText: truncateText,\n\t\n\t        measureText: function (text, textFont) {\n\t            var ctx = util.getContext();\n\t            ctx.font = textFont || '12px sans-serif';\n\t            return ctx.measureText(text);\n\t        }\n\t    };\n\t\n\t    module.exports = textContain;\n\n\n/***/ },\n/* 17 */\n/*!*************************************!*\\\n  !*** ./~/zrender/lib/core/curve.js ***!\n  \\*************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(/*! ./vector */ 5);\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t\n\t    var EPSILON = 1e-8;\n\t    var EPSILON_NUMERIC = 1e-4;\n\t\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t\n\t    // \n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1)\n\t             + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (\n\t            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n\t            + (p3 - p2) * t * t\n\t        );\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} \n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1  - p0);\n\t        var d = p0 - val;\n\t\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t\n\t        var n = 0;\n\t\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            }\n\t            else {\n\t                var t1 = -c / b;  //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = B * B - 4 * A * C;\n\t\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;  // t1, a is not zero\n\t                var t2 = -K / 2;  // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} \n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <=1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * \n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] \n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(\n\t        x0, y0, x1, y1, x2, y2, x3, y3,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        //  t \n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t\n\t            d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} \n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        }\n\t        else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * \n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out \n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(\n\t        x0, y0, x1, y1, x2, y2,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        //  t \n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        cubicAt: cubicAt,\n\t\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t\n\t        cubicRootAt: cubicRootAt,\n\t\n\t        cubicExtrema: cubicExtrema,\n\t\n\t        cubicSubdivide: cubicSubdivide,\n\t\n\t        cubicProjectPoint: cubicProjectPoint,\n\t\n\t        quadraticAt: quadraticAt,\n\t\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t\n\t        quadraticRootAt: quadraticRootAt,\n\t\n\t        quadraticExtremum: quadraticExtremum,\n\t\n\t        quadraticSubdivide: quadraticSubdivide,\n\t\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\n\n/***/ },\n/* 18 */\n/*!*************************************!*\\\n  !*** ./~/zrender/lib/tool/color.js ***!\n  \\*************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/tool/color\n\t */\n\t\n\t\n\t    var kCSSColorTable = {\n\t        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n\t        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n\t        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n\t        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n\t        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n\t        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n\t        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n\t        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n\t        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n\t        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n\t        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n\t        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n\t        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n\t        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n\t        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n\t        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n\t        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n\t        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n\t        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n\t        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n\t        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n\t        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n\t        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n\t        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n\t        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n\t        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n\t        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n\t        'gray': [128,128,128,1], 'green': [0,128,0,1],\n\t        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n\t        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n\t        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n\t        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n\t        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n\t        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n\t        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n\t        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n\t        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n\t        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n\t        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n\t        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n\t        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n\t        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n\t        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n\t        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n\t        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n\t        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n\t        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n\t        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n\t        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n\t        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n\t        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n\t        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n\t        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n\t        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n\t        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n\t        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n\t        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n\t        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n\t        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n\t        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n\t        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n\t        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n\t        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n\t        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n\t        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n\t        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n\t        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n\t        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n\t        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n\t        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n\t        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n\t        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n\t        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n\t        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n\t    };\n\t\n\t    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t\n\t    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t\n\t    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t\n\t    function parseCssInt(str) {  // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t\n\t    function parseCssFloat(str) {  // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        }\n\t        else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2/3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t\n\t    function lerp(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t\n\t    /**\n\t     * @param {string} colorStr\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            return kCSSColorTable[str].slice();  // dup.\n\t        }\n\t\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xfff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n\t                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n\t                    (iv & 0xf) | ((iv & 0xf) << 4),\n\t                    1\n\t                ];\n\t            }\n\t            else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xffffff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 0xff0000) >> 16,\n\t                    (iv & 0xff00) >> 8,\n\t                    iv & 0xff,\n\t                    1\n\t                ];\n\t            }\n\t\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;  // To allow case fallthrough.\n\t            switch (fname) {\n\t                case 'rgba':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n\t                // Fall through.\n\t                case 'rgb':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return [\n\t                        parseCssInt(params[0]),\n\t                        parseCssInt(params[1]),\n\t                        parseCssInt(params[2]),\n\t                        alpha\n\t                    ];\n\t                case 'hsla':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    params[3] = parseCssFloat(params[3]);\n\t                    return hsla2rgba(params);\n\t                case 'hsl':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return hsla2rgba(params);\n\t                default:\n\t                    return;\n\t            }\n\t        }\n\t\n\t        return;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla) {\n\t        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t\n\t        var rgba = [\n\t            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n\t        ];\n\t\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t\n\t        return rgba;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t\n\t        var vMin = Math.min(R, G, B); // Min. value of RGB\n\t        var vMax = Math.max(R, G, B); // Max. value of RGB\n\t        var delta = vMax - vMin; // Delta RGB value\n\t\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        }\n\t        else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            }\n\t            else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t\n\t            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n\t            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n\t            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\t\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            }\n\t            else if (G === vMax) {\n\t                H = (1 / 3) + deltaR - deltaB;\n\t            }\n\t            else if (B === vMax) {\n\t                H = (2 / 3) + deltaG - deltaR;\n\t            }\n\t\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t\n\t        var hsla = [H * 360, S, L];\n\t\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t\n\t        return hsla;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                }\n\t                else {\n\t                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>}\n\t     */\n\t    function fastMapToColor(normalizedValue, colors, out) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t        out = out || [0, 0, 0, 0];\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n\t        return out;\n\t    }\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapToColor(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t\n\t        var color = stringify(\n\t            [\n\t                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n\t            ],\n\t            'rgba'\n\t        );\n\t\n\t        return fullOutput\n\t            ? {\n\t                color: color,\n\t                leftIndex: leftIndex,\n\t                rightIndex: rightIndex,\n\t                value: value\n\t            }\n\t            : color;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color.\n\t     */\n\t    function stringify(arrColor, type) {\n\t        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t            colorStr += ',' + arrColor[3];\n\t        }\n\t        return type + '(' + colorStr + ')';\n\t    }\n\t\n\t    module.exports = {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastMapToColor: fastMapToColor,\n\t        mapToColor: mapToColor,\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t\n\t\n\n\n/***/ },\n/* 19 */\n/*!**************************************!*\\\n  !*** ./~/zrender/lib/core/matrix.js ***!\n  \\**************************************/\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t    /**\n\t     * 3x2\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t        /**\n\t         * \n\t         * @return {Float32Array|Array.<number>}\n\t         */\n\t        create : function() {\n\t            var out = new ArrayCtor(6);\n\t            matrix.identity(out);\n\t\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         */\n\t        identity : function(out) {\n\t            out[0] = 1;\n\t            out[1] = 0;\n\t            out[2] = 0;\n\t            out[3] = 1;\n\t            out[4] = 0;\n\t            out[5] = 0;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m\n\t         */\n\t        copy: function(out, m) {\n\t            out[0] = m[0];\n\t            out[1] = m[1];\n\t            out[2] = m[2];\n\t            out[3] = m[3];\n\t            out[4] = m[4];\n\t            out[5] = m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m1\n\t         * @param {Float32Array|Array.<number>} m2\n\t         */\n\t        mul : function (out, m1, m2) {\n\t            // Consider matrix.mul(m, m2, m);\n\t            // where out is the same as m2.\n\t            // So use temp variable to escape error.\n\t            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t            out[0] = out0;\n\t            out[1] = out1;\n\t            out[2] = out2;\n\t            out[3] = out3;\n\t            out[4] = out4;\n\t            out[5] = out5;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        translate : function(out, a, v) {\n\t            out[0] = a[0];\n\t            out[1] = a[1];\n\t            out[2] = a[2];\n\t            out[3] = a[3];\n\t            out[4] = a[4] + v[0];\n\t            out[5] = a[5] + v[1];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {number} rad\n\t         */\n\t        rotate : function(out, a, rad) {\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t            var st = Math.sin(rad);\n\t            var ct = Math.cos(rad);\n\t\n\t            out[0] = aa * ct + ab * st;\n\t            out[1] = -aa * st + ab * ct;\n\t            out[2] = ac * ct + ad * st;\n\t            out[3] = -ac * st + ct * ad;\n\t            out[4] = ct * atx + st * aty;\n\t            out[5] = ct * aty - st * atx;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        scale : function(out, a, v) {\n\t            var vx = v[0];\n\t            var vy = v[1];\n\t            out[0] = a[0] * vx;\n\t            out[1] = a[1] * vy;\n\t            out[2] = a[2] * vx;\n\t            out[3] = a[3] * vy;\n\t            out[4] = a[4] * vx;\n\t            out[5] = a[5] * vy;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         */\n\t        invert : function(out, a) {\n\t\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t\n\t            var det = aa * ad - ab * ac;\n\t            if (!det) {\n\t                return null;\n\t            }\n\t            det = 1.0 / det;\n\t\n\t            out[0] = ad * det;\n\t            out[1] = -ab * det;\n\t            out[2] = -ac * det;\n\t            out[3] = aa * det;\n\t            out[4] = (ac * aty - ad * atx) * det;\n\t            out[5] = (ab * atx - aa * aty) * det;\n\t            return out;\n\t        }\n\t    };\n\t\n\t    module.exports = matrix;\n\t\n\n\n/***/ },\n/* 20 */\n/*!*****************************************!*\\\n  !*** ./~/zrender/lib/mixin/Eventful.js ***!\n  \\*****************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * \n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var arrySlice = Array.prototype.slice;\n\t\n\t    /**\n\t     * \n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t\n\t    Eventful.prototype = {\n\t\n\t        constructor: Eventful,\n\t\n\t        /**\n\t         * trigger\n\t         *\n\t         * @param {string} event \n\t         * @param {Function} handler \n\t         * @param {Object} context\n\t         */\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {string} event \n\t         * @param {Function} handler \n\t         * @param {Object} [context]\n\t         */\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {string}  event\n\t         * @return {boolean}\n\t         */\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {string} event \n\t         * @param {Function} [handler] \n\t         */\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            }\n\t            else {\n\t                delete _h[event];\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         *\n\t         * @param {string} type \n\t         */\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(_h[i]['ctx']);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * context, context\n\t         * @param {string} type \n\t         */\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(ctx);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(ctx, args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(ctx, args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(ctx, args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    //  onxxxx \n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrag\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t\n\t    module.exports = Eventful;\n\t\n\n\n/***/ },\n/* 21 */\n/*!***************************!*\\\n  !*** ./lib/util/clazz.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var clazz = {};\n\t\n\t    var TYPE_DELIMITER = '.';\n\t    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n\t    /**\n\t     * @public\n\t     */\n\t    var parseClassType = clazz.parseClassType = function (componentType) {\n\t        var ret = {main: '', sub: ''};\n\t        if (componentType) {\n\t            componentType = componentType.split(TYPE_DELIMITER);\n\t            ret.main = componentType[0] || '';\n\t            ret.sub = componentType[1] || '';\n\t        }\n\t        return ret;\n\t    };\n\t    /**\n\t     * @public\n\t     */\n\t    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\t\n\t        RootClass.$constructor = RootClass;\n\t        RootClass.extend = function (proto) {\n\t\n\t            if (false) {\n\t                zrUtil.each(mandatoryMethods, function (method) {\n\t                    if (!proto[method]) {\n\t                        console.warn(\n\t                            'Method `' + method + '` should be implemented'\n\t                            + (proto.type ? ' in ' + proto.type : '') + '.'\n\t                        );\n\t                    }\n\t                });\n\t            }\n\t\n\t            var superClass = this;\n\t            var ExtendedClass = function () {\n\t                if (!proto.$constructor) {\n\t                    superClass.apply(this, arguments);\n\t                }\n\t                else {\n\t                    proto.$constructor.apply(this, arguments);\n\t                }\n\t            };\n\t\n\t            zrUtil.extend(ExtendedClass.prototype, proto);\n\t\n\t            ExtendedClass.extend = this.extend;\n\t            ExtendedClass.superCall = superCall;\n\t            ExtendedClass.superApply = superApply;\n\t            zrUtil.inherits(ExtendedClass, this);\n\t            ExtendedClass.superClass = superClass;\n\t\n\t            return ExtendedClass;\n\t        };\n\t    };\n\t\n\t    // superCall should have class info, which can not be fetch from 'this'.\n\t    // Consider this case:\n\t    // class A has method f,\n\t    // class B inherits class A, overrides method f, f call superApply('f'),\n\t    // class C inherits class B, do not overrides method f,\n\t    // then when method of class C is called, dead loop occured.\n\t    function superCall(context, methodName) {\n\t        var args = zrUtil.slice(arguments, 2);\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t\n\t    function superApply(context, methodName, args) {\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t\n\t    /**\n\t     * @param {Object} entity\n\t     * @param {Object} options\n\t     * @param {boolean} [options.registerWhenExtend]\n\t     * @public\n\t     */\n\t    clazz.enableClassManagement = function (entity, options) {\n\t        options = options || {};\n\t\n\t        /**\n\t         * Component model classes\n\t         * key: componentType,\n\t         * value:\n\t         *     componentClass, when componentType is 'xxx'\n\t         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n\t         * @type {Object}\n\t         */\n\t        var storage = {};\n\t\n\t        entity.registerClass = function (Clazz, componentType) {\n\t            if (componentType) {\n\t                componentType = parseClassType(componentType);\n\t\n\t                if (!componentType.sub) {\n\t                    if (false) {\n\t                        if (storage[componentType.main]) {\n\t                            console.warn(componentType.main + ' exists.');\n\t                        }\n\t                    }\n\t                    storage[componentType.main] = Clazz;\n\t                }\n\t                else if (componentType.sub !== IS_CONTAINER) {\n\t                    var container = makeContainer(componentType);\n\t                    container[componentType.sub] = Clazz;\n\t                }\n\t            }\n\t            return Clazz;\n\t        };\n\t\n\t        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\n\t            var Clazz = storage[componentTypeMain];\n\t\n\t            if (Clazz && Clazz[IS_CONTAINER]) {\n\t                Clazz = subType ? Clazz[subType] : null;\n\t            }\n\t\n\t            if (throwWhenNotFound && !Clazz) {\n\t                throw new Error(\n\t                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\n\t                );\n\t            }\n\t\n\t            return Clazz;\n\t        };\n\t\n\t        entity.getClassesByMainType = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t\n\t            var result = [];\n\t            var obj = storage[componentType.main];\n\t\n\t            if (obj && obj[IS_CONTAINER]) {\n\t                zrUtil.each(obj, function (o, type) {\n\t                    type !== IS_CONTAINER && result.push(o);\n\t                });\n\t            }\n\t            else {\n\t                result.push(obj);\n\t            }\n\t\n\t            return result;\n\t        };\n\t\n\t        entity.hasClass = function (componentType) {\n\t            // Just consider componentType.main.\n\t            componentType = parseClassType(componentType);\n\t            return !!storage[componentType.main];\n\t        };\n\t\n\t        /**\n\t         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n\t         */\n\t        entity.getAllClassMainTypes = function () {\n\t            var types = [];\n\t            zrUtil.each(storage, function (obj, type) {\n\t                types.push(type);\n\t            });\n\t            return types;\n\t        };\n\t\n\t        /**\n\t         * If a main type is container and has sub types\n\t         * @param  {string}  mainType\n\t         * @return {boolean}\n\t         */\n\t        entity.hasSubTypes = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t            var obj = storage[componentType.main];\n\t            return obj && obj[IS_CONTAINER];\n\t        };\n\t\n\t        entity.parseClassType = parseClassType;\n\t\n\t        function makeContainer(componentType) {\n\t            var container = storage[componentType.main];\n\t            if (!container || !container[IS_CONTAINER]) {\n\t                container = storage[componentType.main] = {};\n\t                container[IS_CONTAINER] = true;\n\t            }\n\t            return container;\n\t        }\n\t\n\t        if (options.registerWhenExtend) {\n\t            var originalExtend = entity.extend;\n\t            if (originalExtend) {\n\t                entity.extend = function (proto) {\n\t                    var ExtendedClass = originalExtend.call(this, proto);\n\t                    return entity.registerClass(ExtendedClass, proto.type);\n\t                };\n\t            }\n\t        }\n\t\n\t        return entity;\n\t    };\n\t\n\t    /**\n\t     * @param {string|Array.<string>} properties\n\t     */\n\t    clazz.setReadOnly = function (obj, properties) {\n\t        // FIXME It seems broken in IE8 simulation of IE11\n\t        // if (!zrUtil.isArray(properties)) {\n\t        //     properties = properties != null ? [properties] : [];\n\t        // }\n\t        // zrUtil.each(properties, function (prop) {\n\t        //     var value = obj[prop];\n\t\n\t        //     Object.defineProperty\n\t        //         && Object.defineProperty(obj, prop, {\n\t        //             value: value, writable: false\n\t        //         });\n\t        //     zrUtil.isArray(obj[prop])\n\t        //         && Object.freeze\n\t        //         && Object.freeze(obj[prop]);\n\t        // });\n\t    };\n\t\n\t    module.exports = clazz;\n\n\n/***/ },\n/* 22 */\n/*!*********************************!*\\\n  !*** ./lib/coord/axisHelper.js ***!\n  \\*********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var OrdinalScale = __webpack_require__(/*! ../scale/Ordinal */ 136);\n\t    var IntervalScale = __webpack_require__(/*! ../scale/Interval */ 38);\n\t    __webpack_require__(/*! ../scale/Time */ 137);\n\t    __webpack_require__(/*! ../scale/Log */ 135);\n\t    var Scale = __webpack_require__(/*! ../scale/Scale */ 32);\n\t\n\t    var numberUtil = __webpack_require__(/*! ../util/number */ 4);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 16);\n\t    var axisHelper = {};\n\t\n\t    /**\n\t     * Get axis scale extent before niced.\n\t     */\n\t    axisHelper.getScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var originalExtent = scale.getExtent();\n\t        var span = originalExtent[1] - originalExtent[0];\n\t        if (scale.type === 'ordinal') {\n\t            // If series has no data, scale extent may be wrong\n\t            if (!isFinite(span)) {\n\t                return [0, 0];\n\t            }\n\t            else {\n\t                return originalExtent;\n\t            }\n\t        }\n\t        var min = model.getMin ? model.getMin() : model.get('min');\n\t        var max = model.getMax ? model.getMax() : model.get('max');\n\t        var crossZero = model.getNeedCrossZero\n\t            ? model.getNeedCrossZero() : !model.get('scale');\n\t        var boundaryGap = model.get('boundaryGap');\n\t        if (!zrUtil.isArray(boundaryGap)) {\n\t            boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n\t        }\n\t        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n\t        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n\t        var fixMin = true;\n\t        var fixMax = true;\n\t        // Add boundary gap\n\t        if (min == null) {\n\t            min = originalExtent[0] - boundaryGap[0] * span;\n\t            fixMin = false;\n\t        }\n\t        if (max == null) {\n\t            max = originalExtent[1] + boundaryGap[1] * span;\n\t            fixMax = false;\n\t        }\n\t        if (min === 'dataMin') {\n\t            min = originalExtent[0];\n\t        }\n\t        if (max === 'dataMax') {\n\t            max = originalExtent[1];\n\t        }\n\t        // Evaluate if axis needs cross zero\n\t        if (crossZero) {\n\t            // Axis is over zero and min is not set\n\t            if (min > 0 && max > 0 && !fixMin) {\n\t                min = 0;\n\t            }\n\t            // Axis is under zero and max is not set\n\t            if (min < 0 && max < 0 && !fixMax) {\n\t                max = 0;\n\t            }\n\t        }\n\t        return [min, max];\n\t    };\n\t\n\t    axisHelper.niceScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var extent = axisHelper.getScaleExtent(axis, model);\n\t        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;\n\t        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;\n\t        var splitNumber = model.get('splitNumber');\n\t\n\t        if (scale.type === 'log') {\n\t            scale.base = model.get('logBase');\n\t        }\n\t\n\t        scale.setExtent(extent[0], extent[1]);\n\t        scale.niceExtent(splitNumber, fixMin, fixMax);\n\t\n\t        // Use minInterval to constraint the calculated interval.\n\t        // If calculated interval is less than minInterval. increase the interval quantity until\n\t        // it is larger than minInterval.\n\t        // For example:\n\t        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n\t        //  an integer axis.\n\t        var minInterval = model.get('minInterval');\n\t        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n\t            var interval = scale.getInterval();\n\t            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n\t            // while (interval < minInterval) {\n\t            //     var quantity = numberUtil.quantity(interval);\n\t            //     interval = quantity * 10;\n\t            //     scaleQuantity *= 10;\n\t            // }\n\t            extent = scale.getExtent();\n\t            var origin = (extent[1] + extent[0]) / 2;\n\t            scale.setExtent(\n\t                intervalScale * (extent[0] - origin) + origin,\n\t                intervalScale * (extent[1] - origin) + origin\n\t            );\n\t            scale.niceExtent(splitNumber);\n\t        }\n\t\n\t        // If some one specified the min, max. And the default calculated interval\n\t        // is not good enough. He can specify the interval. It is often appeared\n\t        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n\t        // to be 60.\n\t        // FIXME\n\t        var interval = model.get('interval');\n\t        if (interval != null) {\n\t            scale.setInterval && scale.setInterval(interval);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {module:echarts/model/Model} model\n\t     * @param {string} [axisType] Default retrieve from model.type\n\t     * @return {module:echarts/scale/*}\n\t     */\n\t    axisHelper.createScaleByModel = function(model, axisType) {\n\t        axisType = axisType || model.get('type');\n\t        if (axisType) {\n\t            switch (axisType) {\n\t                // Buildin scale\n\t                case 'category':\n\t                    return new OrdinalScale(\n\t                        model.getCategories(), [Infinity, -Infinity]\n\t                    );\n\t                case 'value':\n\t                    return new IntervalScale();\n\t                // Extended scale, like time and log\n\t                default:\n\t                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Check if the axis corss 0\n\t     */\n\t    axisHelper.ifAxisCrossZero = function (axis) {\n\t        var dataExtent = axis.scale.getExtent();\n\t        var min = dataExtent[0];\n\t        var max = dataExtent[1];\n\t        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n\t    };\n\t\n\t    /**\n\t     * @param {Array.<number>} tickCoords In axis self coordinate.\n\t     * @param {Array.<string>} labels\n\t     * @param {string} font\n\t     * @param {boolean} isAxisHorizontal\n\t     * @return {number}\n\t     */\n\t    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n\t        // FIXME\n\t        // axislabelhorizontalvertical.\n\t\n\t        var textSpaceTakenRect;\n\t        var autoLabelInterval = 0;\n\t        var accumulatedLabelInterval = 0;\n\t\n\t        var step = 1;\n\t        if (labels.length > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.floor(labels.length / 40);\n\t        }\n\t\n\t        for (var i = 0; i < tickCoords.length; i += step) {\n\t            var tickCoord = tickCoords[i];\n\t            var rect = textContain.getBoundingRect(\n\t                labels[i], font, 'center', 'top'\n\t            );\n\t            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n\t            // FIXME Magic number 1.5\n\t            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n\t            if (!textSpaceTakenRect) {\n\t                textSpaceTakenRect = rect.clone();\n\t            }\n\t            // There is no space for current label;\n\t            else if (textSpaceTakenRect.intersect(rect)) {\n\t                accumulatedLabelInterval++;\n\t                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n\t            }\n\t            else {\n\t                textSpaceTakenRect.union(rect);\n\t                // Reset\n\t                accumulatedLabelInterval = 0;\n\t            }\n\t        }\n\t        if (autoLabelInterval === 0 && step > 1) {\n\t            return step;\n\t        }\n\t        return (autoLabelInterval + 1) * step - 1;\n\t    };\n\t\n\t    /**\n\t     * @param {Object} axis\n\t     * @param {Function} labelFormatter\n\t     * @return {Array.<string>}\n\t     */\n\t    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n\t        var scale = axis.scale;\n\t        var labels = scale.getTicksLabels();\n\t        var ticks = scale.getTicks();\n\t        if (typeof labelFormatter === 'string') {\n\t            labelFormatter = (function (tpl) {\n\t                return function (val) {\n\t                    return tpl.replace('{value}', val);\n\t                };\n\t            })(labelFormatter);\n\t            return zrUtil.map(labels, labelFormatter);\n\t        }\n\t        else if (typeof labelFormatter === 'function') {\n\t            return zrUtil.map(ticks, function (tick, idx) {\n\t                return labelFormatter(\n\t                    axis.type === 'category' ? scale.getLabel(tick) : tick,\n\t                    idx\n\t                );\n\t            }, this);\n\t        }\n\t        else {\n\t            return labels;\n\t        }\n\t    };\n\t\n\t    module.exports = axisHelper;\n\n\n/***/ },\n/* 23 */\n/*!*********************************!*\\\n  !*** ./lib/CoordinateSystem.js ***!\n  \\*********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    /**\n\t     * Interface of Coordinate System Class\n\t     *\n\t     * create:\n\t     *     @param {module:echarts/model/Global} ecModel\n\t     *     @param {module:echarts/ExtensionAPI} api\n\t     *     @return {Object} coordinate system instance\n\t     *\n\t     * update:\n\t     *     @param {module:echarts/model/Global} ecModel\n\t     *     @param {module:echarts/ExtensionAPI} api\n\t     *\n\t     * convertToPixel:\n\t     * convertFromPixel:\n\t     *     These two methods is also responsible for determine whether this\n\t     *     coodinate system is applicable to the given `finder`.\n\t     *     Each coordinate system will be tried, util one returns none\n\t     *     null/undefined value.\n\t     *     @param {module:echarts/model/Global} ecModel\n\t     *     @param {Object} finder\n\t     *     @param {Array|number} value\n\t     *     @return {Array|number} convert result.\n\t     *\n\t     * containPoint:\n\t     *     @param {Array.<number>} point In pixel coordinate system.\n\t     *     @return {boolean}\n\t     */\n\t\n\t    var coordinateSystemCreators = {};\n\t\n\t    function CoordinateSystemManager() {\n\t\n\t        this._coordinateSystems = [];\n\t    }\n\t\n\t    CoordinateSystemManager.prototype = {\n\t\n\t        constructor: CoordinateSystemManager,\n\t\n\t        create: function (ecModel, api) {\n\t            var coordinateSystems = [];\n\t            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n\t                var list = creater.create(ecModel, api);\n\t                coordinateSystems = coordinateSystems.concat(list || []);\n\t            });\n\t\n\t            this._coordinateSystems = coordinateSystems;\n\t        },\n\t\n\t        update: function (ecModel, api) {\n\t            zrUtil.each(this._coordinateSystems, function (coordSys) {\n\t                // FIXME MUST have\n\t                coordSys.update && coordSys.update(ecModel, api);\n\t            });\n\t        },\n\t\n\t        getCoordinateSystems: function () {\n\t            return this._coordinateSystems.slice();\n\t        }\n\t    };\n\t\n\t    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n\t        coordinateSystemCreators[type] = coordinateSystemCreator;\n\t    };\n\t\n\t    CoordinateSystemManager.get = function (type) {\n\t        return coordinateSystemCreators[type];\n\t    };\n\t\n\t    module.exports = CoordinateSystemManager;\n\n\n/***/ },\n/* 24 */\n/*!*************************************!*\\\n  !*** ./~/zrender/lib/core/event.js ***!\n  \\*************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/core/event\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t */\n\t\n\t\n\t    var Eventful = __webpack_require__(/*! ../mixin/Eventful */ 20);\n\t    var env = __webpack_require__(/*! ./env */ 11);\n\t\n\t    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\t\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n\t    }\n\t\n\t    // `calculate` is optional, default false\n\t    function clientToLocal(el, e, out, calculate) {\n\t        out = out || {};\n\t\n\t        // According to the W3C Working Draft, offsetX and offsetY should be relative\n\t        // to the padding edge of the target element. The only browser using this convention\n\t        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n\t        // not support the properties.\n\t        // (see http://www.jacklmoore.com/notes/mouse-position/)\n\t        // In zr painter.dom, padding edge equals to border edge.\n\t\n\t        // FIXME\n\t        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n\t        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n\t        // is too complex. So css-transfrom dont support in this case temporarily.\n\t        if (calculate || !env.canvasSupported) {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n\t        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n\t        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n\t        // zoom-factor, overflow / opacity layers, transforms ...)\n\t        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n\t        // <https://bugs.jquery.com/ticket/8523#comment:14>\n\t        // BTW3, In ff, offsetX/offsetY is always 0.\n\t        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n\t            out.zrX = e.layerX;\n\t            out.zrY = e.layerY;\n\t        }\n\t        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n\t        else if (e.offsetX != null) {\n\t            out.zrX = e.offsetX;\n\t            out.zrY = e.offsetY;\n\t        }\n\t        // For some other device, e.g., IOS safari.\n\t        else {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t\n\t        return out;\n\t    }\n\t\n\t    function defaultGetZrXY(el, e, out) {\n\t        // This well-known method below does not support css transform.\n\t        var box = getBoundingClientRect(el);\n\t        out.zrX = e.clientX - box.left;\n\t        out.zrY = e.clientY - box.top;\n\t    }\n\t\n\t    /**\n\t     * domtouch.\n\t     * `calculate` is optional, default false.\n\t     */\n\t    function normalizeEvent(el, e, calculate) {\n\t\n\t        e = e || window.event;\n\t\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t        if (!isTouch) {\n\t            clientToLocal(el, e, e, calculate);\n\t            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        }\n\t        else {\n\t            var touch = eventType != 'touchend'\n\t                ? e.targetTouches[0]\n\t                : e.changedTouches[0];\n\t            touch && clientToLocal(el, touch, e, calculate);\n\t        }\n\t\n\t        return e;\n\t    }\n\t\n\t    function addEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.addEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.attachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    function removeEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.removeEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.detachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event\n\t     */\n\t    var stop = isDomLevel2\n\t        ? function (e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            e.cancelBubble = true;\n\t        }\n\t        : function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t\n\t    module.exports = {\n\t        clientToLocal: clientToLocal,\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t\n\t        stop: stop,\n\t        // \n\t        Dispatcher: Eventful\n\t    };\n\t\n\n\n/***/ },\n/* 25 */,\n/* 26 */\n/*!****************************!*\\\n  !*** ./lib/util/symbol.js ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Symbol factory\n\t\n\t\n\t    var graphic = __webpack_require__(/*! ./graphic */ 3);\n\t    var BoundingRect = __webpack_require__(/*! zrender/lib/core/BoundingRect */ 8);\n\t\n\t    /**\n\t     * Triangle shape\n\t     * @inner\n\t     */\n\t    var Triangle = graphic.extendShape({\n\t        type: 'triangle',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t        buildPath: function (path, shape) {\n\t            var cx = shape.cx;\n\t            var cy = shape.cy;\n\t            var width = shape.width / 2;\n\t            var height = shape.height / 2;\n\t            path.moveTo(cx, cy - height);\n\t            path.lineTo(cx + width, cy + height);\n\t            path.lineTo(cx - width, cy + height);\n\t            path.closePath();\n\t        }\n\t    });\n\t    /**\n\t     * Diamond shape\n\t     * @inner\n\t     */\n\t    var Diamond = graphic.extendShape({\n\t        type: 'diamond',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t        buildPath: function (path, shape) {\n\t            var cx = shape.cx;\n\t            var cy = shape.cy;\n\t            var width = shape.width / 2;\n\t            var height = shape.height / 2;\n\t            path.moveTo(cx, cy - height);\n\t            path.lineTo(cx + width, cy);\n\t            path.lineTo(cx, cy + height);\n\t            path.lineTo(cx - width, cy);\n\t            path.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Pin shape\n\t     * @inner\n\t     */\n\t    var Pin = graphic.extendShape({\n\t        type: 'pin',\n\t        shape: {\n\t            // x, y on the cusp\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (path, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var w = shape.width / 5 * 3;\n\t            // Height must be larger than width\n\t            var h = Math.max(w, shape.height);\n\t            var r = w / 2;\n\t\n\t            // Dist on y with tangent point and circle center\n\t            var dy = r * r / (h - r);\n\t            var cy = y - h + r + dy;\n\t            var angle = Math.asin(dy / r);\n\t            // Dist on x with tangent point and circle center\n\t            var dx = Math.cos(angle) * r;\n\t\n\t            var tanX = Math.sin(angle);\n\t            var tanY = Math.cos(angle);\n\t\n\t            path.arc(\n\t                x, cy, r,\n\t                Math.PI - angle,\n\t                Math.PI * 2 + angle\n\t            );\n\t\n\t            var cpLen = r * 0.6;\n\t            var cpLen2 = r * 0.7;\n\t            path.bezierCurveTo(\n\t                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n\t                x, y - cpLen2,\n\t                x, y\n\t            );\n\t            path.bezierCurveTo(\n\t                x, y - cpLen2,\n\t                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n\t                x - dx, cy + dy\n\t            );\n\t            path.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Arrow shape\n\t     * @inner\n\t     */\n\t    var Arrow = graphic.extendShape({\n\t\n\t        type: 'arrow',\n\t\n\t        shape: {\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var height = shape.height;\n\t            var width = shape.width;\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var dx = width / 3 * 2;\n\t            ctx.moveTo(x, y);\n\t            ctx.lineTo(x + dx, y + height);\n\t            ctx.lineTo(x, y + height / 4 * 3);\n\t            ctx.lineTo(x - dx, y + height);\n\t            ctx.lineTo(x, y);\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Map of path contructors\n\t     * @type {Object.<string, module:zrender/graphic/Path>}\n\t     */\n\t    var symbolCtors = {\n\t        line: graphic.Line,\n\t\n\t        rect: graphic.Rect,\n\t\n\t        roundRect: graphic.Rect,\n\t\n\t        square: graphic.Rect,\n\t\n\t        circle: graphic.Circle,\n\t\n\t        diamond: Diamond,\n\t\n\t        pin: Pin,\n\t\n\t        arrow: Arrow,\n\t\n\t        triangle: Triangle\n\t    };\n\t\n\t    var symbolShapeMakers = {\n\t\n\t        line: function (x, y, w, h, shape) {\n\t            // FIXME\n\t            shape.x1 = x;\n\t            shape.y1 = y + h / 2;\n\t            shape.x2 = x + w;\n\t            shape.y2 = y + h / 2;\n\t        },\n\t\n\t        rect: function (x, y, w, h, shape) {\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        roundRect: function (x, y, w, h, shape) {\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = w;\n\t            shape.height = h;\n\t            shape.r = Math.min(w, h) / 4;\n\t        },\n\t\n\t        square: function (x, y, w, h, shape) {\n\t            var size = Math.min(w, h);\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = size;\n\t            shape.height = size;\n\t        },\n\t\n\t        circle: function (x, y, w, h, shape) {\n\t            // Put circle in the center of square\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.r = Math.min(w, h) / 2;\n\t        },\n\t\n\t        diamond: function (x, y, w, h, shape) {\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        pin: function (x, y, w, h, shape) {\n\t            shape.x = x + w / 2;\n\t            shape.y = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        arrow: function (x, y, w, h, shape) {\n\t            shape.x = x + w / 2;\n\t            shape.y = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        triangle: function (x, y, w, h, shape) {\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        }\n\t    };\n\t\n\t    var symbolBuildProxies = {};\n\t    for (var name in symbolCtors) {\n\t        if (symbolCtors.hasOwnProperty(name)) {\n\t            symbolBuildProxies[name] = new symbolCtors[name]();\n\t        }\n\t    }\n\t\n\t    var Symbol = graphic.extendShape({\n\t\n\t        type: 'symbol',\n\t\n\t        shape: {\n\t            symbolType: '',\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        beforeBrush: function () {\n\t            var style = this.style;\n\t            var shape = this.shape;\n\t            // FIXME\n\t            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n\t                style.textPosition = ['50%', '40%'];\n\t                style.textAlign = 'center';\n\t                style.textVerticalAlign = 'middle';\n\t            }\n\t        },\n\t\n\t        buildPath: function (ctx, shape, inBundle) {\n\t            var symbolType = shape.symbolType;\n\t            var proxySymbol = symbolBuildProxies[symbolType];\n\t            if (shape.symbolType !== 'none') {\n\t                if (!proxySymbol) {\n\t                    // Default rect\n\t                    symbolType = 'rect';\n\t                    proxySymbol = symbolBuildProxies[symbolType];\n\t                }\n\t                symbolShapeMakers[symbolType](\n\t                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n\t                );\n\t                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n\t            }\n\t        }\n\t    });\n\t\n\t    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n\t    var symbolPathSetColor = function (color) {\n\t        if (this.type !== 'image') {\n\t            var symbolStyle = this.style;\n\t            var symbolShape = this.shape;\n\t            if (symbolShape && symbolShape.symbolType === 'line') {\n\t                symbolStyle.stroke = color;\n\t            }\n\t            else if (this.__isEmptyBrush) {\n\t                symbolStyle.stroke = color;\n\t                symbolStyle.fill = '#fff';\n\t            }\n\t            else {\n\t                // FIXME  onlyStroke ?\n\t                symbolStyle.fill && (symbolStyle.fill = color);\n\t                symbolStyle.stroke && (symbolStyle.stroke = color);\n\t            }\n\t            this.dirty(false);\n\t        }\n\t    };\n\t\n\t    var symbolUtil = {\n\t        /**\n\t         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n\t         * @param {string} symbolType\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {number} w\n\t         * @param {number} h\n\t         * @param {string} color\n\t         */\n\t        createSymbol: function (symbolType, x, y, w, h, color) {\n\t            var isEmpty = symbolType.indexOf('empty') === 0;\n\t            if (isEmpty) {\n\t                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n\t            }\n\t            var symbolPath;\n\t\n\t            if (symbolType.indexOf('image://') === 0) {\n\t                symbolPath = new graphic.Image({\n\t                    style: {\n\t                        image: symbolType.slice(8),\n\t                        x: x,\n\t                        y: y,\n\t                        width: w,\n\t                        height: h\n\t                    }\n\t                });\n\t            }\n\t            else if (symbolType.indexOf('path://') === 0) {\n\t                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n\t            }\n\t            else {\n\t                symbolPath = new Symbol({\n\t                    shape: {\n\t                        symbolType: symbolType,\n\t                        x: x,\n\t                        y: y,\n\t                        width: w,\n\t                        height: h\n\t                    }\n\t                });\n\t            }\n\t\n\t            symbolPath.__isEmptyBrush = isEmpty;\n\t\n\t            symbolPath.setColor = symbolPathSetColor;\n\t\n\t            symbolPath.setColor(color);\n\t\n\t            return symbolPath;\n\t        }\n\t    };\n\t\n\t    module.exports = symbolUtil;\n\n\n/***/ },\n/* 27 */\n/*!***************************!*\\\n  !*** ./lib/view/Chart.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Group = __webpack_require__(/*! zrender/lib/container/Group */ 34);\n\t    var componentUtil = __webpack_require__(/*! ../util/component */ 43);\n\t    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 21);\n\t    var modelUtil = __webpack_require__(/*! ../util/model */ 7);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    function Chart() {\n\t\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewChart');\n\t    }\n\t\n\t    Chart.prototype = {\n\t\n\t        type: 'chart',\n\t\n\t        /**\n\t         * Init the chart\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         */\n\t        init: function (ecModel, api) {},\n\t\n\t        /**\n\t         * Render the chart\n\t         * @param  {module:echarts/model/Series} seriesModel\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         * @param  {Object} payload\n\t         */\n\t        render: function (seriesModel, ecModel, api, payload) {},\n\t\n\t        /**\n\t         * Highlight series or specified data item\n\t         * @param  {module:echarts/model/Series} seriesModel\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         * @param  {Object} payload\n\t         */\n\t        highlight: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n\t        },\n\t\n\t        /**\n\t         * Downplay series or specified data item\n\t         * @param  {module:echarts/model/Series} seriesModel\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         * @param  {Object} payload\n\t         */\n\t        downplay: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'normal');\n\t        },\n\t\n\t        /**\n\t         * Remove self\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         */\n\t        remove: function (ecModel, api) {\n\t            this.group.removeAll();\n\t        },\n\t\n\t        /**\n\t         * Dispose self\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         */\n\t        dispose: function () {}\n\t\n\t        /**\n\t         * The view contains the given point.\n\t         * @interface\n\t         * @param {Array.<number>} point\n\t         * @return {boolean}\n\t         */\n\t        // containPoint: function () {}\n\t\n\t    };\n\t\n\t    var chartProto = Chart.prototype;\n\t    chartProto.updateView\n\t        = chartProto.updateLayout\n\t        = chartProto.updateVisual\n\t        = function (seriesModel, ecModel, api, payload) {\n\t            this.render(seriesModel, ecModel, api, payload);\n\t        };\n\t\n\t    /**\n\t     * Set state of single element\n\t     * @param  {module:zrender/Element} el\n\t     * @param  {string} state\n\t     */\n\t    function elSetState(el, state) {\n\t        if (el) {\n\t            el.trigger(state);\n\t            if (el.type === 'group') {\n\t                for (var i = 0; i < el.childCount(); i++) {\n\t                    elSetState(el.childAt(i), state);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @param  {module:echarts/data/List} data\n\t     * @param  {Object} payload\n\t     * @param  {string} state 'normal'|'emphasis'\n\t     * @inner\n\t     */\n\t    function toggleHighlight(data, payload, state) {\n\t        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\t\n\t        if (dataIndex != null) {\n\t            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n\t                elSetState(data.getItemGraphicEl(dataIdx), state);\n\t            });\n\t        }\n\t        else {\n\t            data.eachItemGraphicEl(function (el) {\n\t                elSetState(el, state);\n\t            });\n\t        }\n\t    }\n\t\n\t    // Enable Chart.extend.\n\t    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\t\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\t\n\t    module.exports = Chart;\n\n\n/***/ },\n/* 28 */\n/*!*****************************************!*\\\n  !*** ./~/zrender/lib/core/PathProxy.js ***!\n  \\*****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Path `buildPath``ctx`, pathpathCommands\n\t *  isInsidePath boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t\n\t // TODO getTotalLength, getPointAtLength\n\t\n\t\n\t    var curve = __webpack_require__(/*! ./curve */ 17);\n\t    var vec2 = __webpack_require__(/*! ./vector */ 5);\n\t    var bbox = __webpack_require__(/*! ./bbox */ 73);\n\t    var BoundingRect = __webpack_require__(/*! ./BoundingRect */ 8);\n\t    var dpr = __webpack_require__(/*! ../config */ 33).devicePixelRatio;\n\t\n\t    var CMD = {\n\t        M: 1,\n\t        L: 2,\n\t        C: 3,\n\t        Q: 4,\n\t        A: 5,\n\t        Z: 6,\n\t        // Rect\n\t        R: 7\n\t    };\n\t\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAbs = Math.abs;\n\t\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function () {\n\t\n\t        /**\n\t         * Path data. Stored as flat array\n\t         * @type {Array.<Object>}\n\t         */\n\t        this.data = [];\n\t\n\t        this._len = 0;\n\t\n\t        this._ctx = null;\n\t\n\t        this._xi = 0;\n\t        this._yi = 0;\n\t\n\t        this._x0 = 0;\n\t        this._y0 = 0;\n\t\n\t        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t        this._ux = 0;\n\t        this._uy = 0;\n\t    };\n\t\n\t    /**\n\t     * Path\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t\n\t        constructor: PathProxy,\n\t\n\t        _lineDash: null,\n\t\n\t        _dashOffset: 0,\n\t\n\t        _dashIdx: 0,\n\t\n\t        _dashSum: 0,\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        setScale: function (sx, sy) {\n\t            this._ux = mathAbs(1 / dpr / sx) || 0;\n\t            this._uy = mathAbs(1 / dpr / sy) || 0;\n\t        },\n\t\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t\n\t        /**\n\t         * @param  {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        beginPath: function (ctx) {\n\t\n\t            this._ctx = ctx;\n\t\n\t            ctx && ctx.beginPath();\n\t\n\t            ctx && (this.dpr = ctx.dpr);\n\t\n\t            // Reset\n\t            this._len = 0;\n\t\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t\n\t                this._dashOffset = 0;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t\n\t            // x0, y0, xi, yi  _dashedXXXXTo \n\t            // xi, yi , x0, y0  closePath \n\t            //  beginPath  lineTo x0, y0 \n\t            //  lineTo dashed line  IE10- \n\t            this._x0 = x;\n\t            this._y0 = y;\n\t\n\t            this._xi = x;\n\t            this._yi = y;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        lineTo: function (x, y) {\n\t            var exceedUnit = mathAbs(x - this._xi) > this._ux\n\t                || mathAbs(y - this._yi) > this._uy\n\t                // Force draw the first segment\n\t                || this._len < 5;\n\t\n\t            this.addData(CMD.L, x, y);\n\t\n\t            if (this._ctx && exceedUnit) {\n\t                this._needsDash() ? this._dashedLineTo(x, y)\n\t                    : this._ctx.lineTo(x, y);\n\t            }\n\t            if (exceedUnit) {\n\t                this._xi = x;\n\t                this._yi = y;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @param  {number} x3\n\t         * @param  {number} y3\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n\t                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n\t                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} cx\n\t         * @param  {number} cy\n\t         * @param  {number} r\n\t         * @param  {number} startAngle\n\t         * @param  {number} endAngle\n\t         * @param  {boolean} anticlockwise\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(\n\t                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n\t            );\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._xi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Context  rebuildPath  fill\n\t         * stroke \n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t\n\t                this._dashIdx = 0;\n\t\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *\n\t         * @return {boolean}\n\t         */\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t\n\t        /**\n\t         *  Path \n\t         */\n\t        setData: function (data) {\n\t\n\t            var len = data.length;\n\t\n\t            if (! (this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t\n\t            this._len = len;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t         */\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && (this.data instanceof Float32Array)) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t\n\t        /**\n\t         *  Path \n\t         * \n\t         */\n\t        addData: function (cmd) {\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                //  Float32Array\n\t                // \n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t\n\t            this._prevCmd = cmd;\n\t        },\n\t\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * If needs js implemented dashed line\n\t         * @return {boolean}\n\t         * @private\n\t         */\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t\n\t            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n\t            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n\t                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n\t                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n\t                );\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        // Not accurate dashed line to\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t\n\t            var x;\n\t            var y;\n\t\n\t            var tmpLen = 0;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n\t                    - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n\t                    - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t\n\t            while (t <= 1) {\n\t\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y)\n\t                    : ctx.lineTo(x, y);\n\t\n\t                t += lineDash[idx] / bezierLen;\n\t\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t\n\t            // Finish the last segment and calculate the new offset\n\t            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t\n\t        /**\n\t         *  Float32Array \n\t         * Convert dynamic array to static Float32Array\n\t         */\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t\n\t                if (i == 1) {\n\t                    //  L, C, Q\n\t                    //  previous point  point\n\t                    //\n\t                    //  Arc \n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        // moveTo  subpath, \n\t                        //  closePath \n\t                        x0 = data[i++];\n\t                        y0 = data[i++];\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        min2[0] = x0;\n\t                        min2[1] = y0;\n\t                        max2[0] = x0;\n\t                        max2[1] = y0;\n\t                        break;\n\t                    case CMD.L:\n\t                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.C:\n\t                        bbox.fromCubic(\n\t                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.Q:\n\t                        bbox.fromQuadratic(\n\t                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.A:\n\t                        // TODO Arc \n\t                        var cx = data[i++];\n\t                        var cy = data[i++];\n\t                        var rx = data[i++];\n\t                        var ry = data[i++];\n\t                        var startAngle = data[i++];\n\t                        var endAngle = data[i++] + startAngle;\n\t                        // TODO Arc \n\t                        var psi = data[i++];\n\t                        var anticlockwise = 1 - data[i++];\n\t\n\t                        if (i == 1) {\n\t                            //  arc \n\t                            // \n\t                            x0 = mathCos(startAngle) * rx + cx;\n\t                            y0 = mathSin(startAngle) * ry + cy;\n\t                        }\n\t\n\t                        bbox.fromArc(\n\t                            cx, cy, rx, ry, startAngle, endAngle,\n\t                            anticlockwise, min2, max2\n\t                        );\n\t\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = data[i++];\n\t                        y0 = yi = data[i++];\n\t                        var width = data[i++];\n\t                        var height = data[i++];\n\t                        // Use fromLine\n\t                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                        break;\n\t                    case CMD.Z:\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        break;\n\t                }\n\t\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t\n\t            return new BoundingRect(\n\t                min[0], min[1], max[0] - min[0], max[1] - min[1]\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Rebuild path from current data\n\t         * Rebuild path will not consider javascript implemented line dash.\n\t         * @param {CanvasRenderingContext} ctx\n\t         */\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            var x0, y0;\n\t            var xi, yi;\n\t            var x, y;\n\t            var ux = this._ux;\n\t            var uy = this._uy;\n\t            var len = this._len;\n\t            for (var i = 0; i < len;) {\n\t                var cmd = d[i++];\n\t\n\t                if (i == 1) {\n\t                    //  L, C, Q\n\t                    //  previous point  point\n\t                    //\n\t                    //  Arc \n\t                    xi = d[i];\n\t                    yi = d[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        x0 = xi = d[i++];\n\t                        y0 = yi = d[i++];\n\t                        ctx.moveTo(xi, yi);\n\t                        break;\n\t                    case CMD.L:\n\t                        x = d[i++];\n\t                        y = d[i++];\n\t                        // Not draw too small seg between\n\t                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t                            ctx.lineTo(x, y);\n\t                            xi = x;\n\t                            yi = y;\n\t                        }\n\t                        break;\n\t                    case CMD.C:\n\t                        ctx.bezierCurveTo(\n\t                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n\t                        );\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.Q:\n\t                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.A:\n\t                        var cx = d[i++];\n\t                        var cy = d[i++];\n\t                        var rx = d[i++];\n\t                        var ry = d[i++];\n\t                        var theta = d[i++];\n\t                        var dTheta = d[i++];\n\t                        var psi = d[i++];\n\t                        var fs = d[i++];\n\t                        var r = (rx > ry) ? rx : ry;\n\t                        var scaleX = (rx > ry) ? 1 : rx / ry;\n\t                        var scaleY = (rx > ry) ? ry / rx : 1;\n\t                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t                        var endAngle = theta + dTheta;\n\t                        if (isEllipse) {\n\t                            ctx.translate(cx, cy);\n\t                            ctx.rotate(psi);\n\t                            ctx.scale(scaleX, scaleY);\n\t                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t                            ctx.scale(1 / scaleX, 1 / scaleY);\n\t                            ctx.rotate(-psi);\n\t                            ctx.translate(-cx, -cy);\n\t                        }\n\t                        else {\n\t                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t                        }\n\t\n\t                        if (i == 1) {\n\t                            //  arc \n\t                            // \n\t                            x0 = mathCos(theta) * rx + cx;\n\t                            y0 = mathSin(theta) * ry + cy;\n\t                        }\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = d[i];\n\t                        y0 = yi = d[i + 1];\n\t                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                        break;\n\t                    case CMD.Z:\n\t                        ctx.closePath();\n\t                        xi = x0;\n\t                        yi = y0;\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    PathProxy.CMD = CMD;\n\t\n\t    module.exports = PathProxy;\n\n\n/***/ },\n/* 29 */\n/*!*******************************************!*\\\n  !*** ./~/zrender/lib/graphic/Gradient.js ***!\n  \\*******************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    /**\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var Gradient = function (colorStops) {\n\t\n\t        this.colorStops = colorStops || [];\n\t    };\n\t\n\t    Gradient.prototype = {\n\t\n\t        constructor: Gradient,\n\t\n\t        addColorStop: function (offset, color) {\n\t            this.colorStops.push({\n\t\n\t                offset: offset,\n\t\n\t                color: color\n\t            });\n\t        }\n\t    };\n\t\n\t    module.exports = Gradient;\n\n\n/***/ },\n/* 30 */\n/*!***********************************************!*\\\n  !*** ./lib/data/helper/completeDimensions.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Complete dimensions by data (guess dimension).\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    /**\n\t     * Complete the dimensions array guessed from the data structure.\n\t     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n\t     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n\t     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n\t     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n\t     * @return {Array.<string>}\n\t     */\n\t    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n\t        if (!data) {\n\t            return dimensions;\n\t        }\n\t\n\t        var value0 = retrieveValue(data[0]);\n\t        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\t\n\t        defaultNames = defaultNames || [];\n\t        extraPrefix = extraPrefix || 'extra';\n\t        for (var i = 0; i < dimSize; i++) {\n\t            if (!dimensions[i]) {\n\t                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));\n\t                dimensions[i] = guessOrdinal(data, i)\n\t                    ? {type: 'ordinal', name: name}\n\t                    : name;\n\t            }\n\t        }\n\t\n\t        return dimensions;\n\t    }\n\t\n\t    // The rule should not be complex, otherwise user might not\n\t    // be able to known where the data is wrong.\n\t    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n\t        for (var i = 0, len = data.length; i < len; i++) {\n\t            var value = retrieveValue(data[i]);\n\t\n\t            if (!zrUtil.isArray(value)) {\n\t                return false;\n\t            }\n\t\n\t            var value = value[dimIndex];\n\t            if (value != null && isFinite(value)) {\n\t                return false;\n\t            }\n\t            else if (zrUtil.isString(value) && value !== '-') {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t\n\t    function retrieveValue(o) {\n\t        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n\t    }\n\t\n\t    module.exports = completeDimensions;\n\t\n\n\n/***/ },\n/* 31 */\n/*!********************************************!*\\\n  !*** ./lib/model/mixin/makeStyleMapper.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// TODO Parse shadow style\n\t// TODO Only shallow path support\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    module.exports = function (properties) {\n\t        // Normalize\n\t        for (var i = 0; i < properties.length; i++) {\n\t            if (!properties[i][1]) {\n\t               properties[i][1] = properties[i][0];\n\t            }\n\t        }\n\t        return function (excludes) {\n\t            var style = {};\n\t            for (var i = 0; i < properties.length; i++) {\n\t                var propName = properties[i][1];\n\t                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n\t                    continue;\n\t                }\n\t                var val = this.getShallow(propName);\n\t                if (val != null) {\n\t                    style[properties[i][0]] = val;\n\t                }\n\t            }\n\t            return style;\n\t        };\n\t    };\n\n\n/***/ },\n/* 32 */\n/*!****************************!*\\\n  !*** ./lib/scale/Scale.js ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * // Scale class management\n\t * @module echarts/scale/Scale\n\t */\n\t\n\t\n\t    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 21);\n\t\n\t    function Scale() {\n\t        /**\n\t         * Extent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._extent = [Infinity, -Infinity];\n\t\n\t        /**\n\t         * Step is calculated in adjustExtent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._interval = 0;\n\t\n\t        this.init && this.init.apply(this, arguments);\n\t    }\n\t\n\t    var scaleProto = Scale.prototype;\n\t\n\t    /**\n\t     * Parse input val to valid inner number.\n\t     * @param {*} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.parse = function (val) {\n\t        // Notice: This would be a trap here, If the implementation\n\t        // of this method depends on extent, and this method is used\n\t        // before extent set (like in dataZoom), it would be wrong.\n\t        // Nevertheless, parse does not depend on extent generally.\n\t        return val;\n\t    };\n\t\n\t    scaleProto.contain = function (val) {\n\t        var extent = this._extent;\n\t        return val >= extent[0] && val <= extent[1];\n\t    };\n\t\n\t    /**\n\t     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.normalize = function (val) {\n\t        var extent = this._extent;\n\t        if (extent[1] === extent[0]) {\n\t            return 0.5;\n\t        }\n\t        return (val - extent[0]) / (extent[1] - extent[0]);\n\t    };\n\t\n\t    /**\n\t     * Scale normalized value\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.scale = function (val) {\n\t        var extent = this._extent;\n\t        return val * (extent[1] - extent[0]) + extent[0];\n\t    };\n\t\n\t    /**\n\t     * Set extent from data\n\t     * @param {Array.<number>} other\n\t     */\n\t    scaleProto.unionExtent = function (other) {\n\t        var extent = this._extent;\n\t        other[0] < extent[0] && (extent[0] = other[0]);\n\t        other[1] > extent[1] && (extent[1] = other[1]);\n\t        // not setExtent because in log axis it may transformed to power\n\t        // this.setExtent(extent[0], extent[1]);\n\t    };\n\t\n\t    /**\n\t     * Get extent\n\t     * @return {Array.<number>}\n\t     */\n\t    scaleProto.getExtent = function () {\n\t        return this._extent.slice();\n\t    };\n\t\n\t    /**\n\t     * Set extent\n\t     * @param {number} start\n\t     * @param {number} end\n\t     */\n\t    scaleProto.setExtent = function (start, end) {\n\t        var thisExtent = this._extent;\n\t        if (!isNaN(start)) {\n\t            thisExtent[0] = start;\n\t        }\n\t        if (!isNaN(end)) {\n\t            thisExtent[1] = end;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @return {Array.<string>}\n\t     */\n\t    scaleProto.getTicksLabels = function () {\n\t        var labels = [];\n\t        var ticks = this.getTicks();\n\t        for (var i = 0; i < ticks.length; i++) {\n\t            labels.push(this.getLabel(ticks[i]));\n\t        }\n\t        return labels;\n\t    };\n\t\n\t    clazzUtil.enableClassExtend(Scale);\n\t    clazzUtil.enableClassManagement(Scale, {\n\t        registerWhenExtend: true\n\t    });\n\t\n\t    module.exports = Scale;\n\n\n/***/ },\n/* 33 */\n/*!*********************************!*\\\n  !*** ./~/zrender/lib/config.js ***!\n  \\*********************************/\n/***/ function(module, exports) {\n\n\t\n\t    var dpr = 1;\n\t    // If in browser environment\n\t    if (typeof window !== 'undefined') {\n\t        dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t    }\n\t    /**\n\t     * config\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t        /**\n\t         * debugcatchBrushExceptiontrue\n\t         * 0 : debug\n\t         * 1 : \n\t         * 2 : \n\t         */\n\t        debugMode: 0,\n\t\n\t        // retina \n\t        devicePixelRatio: dpr\n\t    };\n\t    module.exports = config;\n\t\n\t\n\n\n/***/ },\n/* 34 */\n/*!******************************************!*\\\n  !*** ./~/zrender/lib/container/Group.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * GroupGroup\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/lib/container/Group');\n\t *     var Circle = require('zrender/lib/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t    var Element = __webpack_require__(/*! ../Element */ 58);\n\t    var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ 8);\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        for (var key in opts) {\n\t            if (opts.hasOwnProperty(key)) {\n\t                this[key] = opts[key];\n\t            }\n\t        }\n\t\n\t        this._children = [];\n\t\n\t        this.__storage = null;\n\t\n\t        this.__dirty = true;\n\t    };\n\t\n\t    Group.prototype = {\n\t\n\t        constructor: Group,\n\t\n\t        isGroup: true,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        type: 'group',\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/container/Group#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/Element>}\n\t         */\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t\n\t        /**\n\t         *  index \n\t         * @param  {number} idx\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {string} name\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t             }\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/Element} child\n\t         */\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t\n\t                this._children.push(child);\n\t\n\t                this._doAdd(child);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *  nextSibling \n\t         * @param {module:zrender/Element} child\n\t         * @param {module:zrender/Element} nextSibling\n\t         */\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this\n\t                && nextSibling && nextSibling.parent === this) {\n\t\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t\n\t            child.parent = this;\n\t\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t\n\t                storage.addToMap(child);\n\t\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/Element} child\n\t         */\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t\n\t            child.parent = null;\n\t\n\t            if (storage) {\n\t\n\t                storage.delFromMap(child.id);\n\t\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromMap(child.id);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                // TODO\n\t                // The boundingRect cacluated by transforming original\n\t                // rect may be bigger than the actual bundingRect when rotation\n\t                // is used. (Consider a circle rotated aginst its center, where\n\t                // the actual boundingRect should be the same as that not be\n\t                // rotated.) But we can not find better approach to calculate\n\t                // actual boundingRect yet, considering performance.\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                }\n\t                else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Group, Element);\n\t\n\t    module.exports = Group;\n\n\n/***/ },\n/* 35 */\n/*!*************************************************!*\\\n  !*** ./lib/chart/helper/createListFromArray.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var List = __webpack_require__(/*! ../../data/List */ 14);\n\t    var completeDimensions = __webpack_require__(/*! ../../data/helper/completeDimensions */ 30);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var modelUtil = __webpack_require__(/*! ../../util/model */ 7);\n\t    var CoordinateSystem = __webpack_require__(/*! ../../CoordinateSystem */ 23);\n\t    var getDataItemValue = modelUtil.getDataItemValue;\n\t    var converDataValue = modelUtil.converDataValue;\n\t\n\t    function firstDataNotNull(data) {\n\t        var i = 0;\n\t        while (i < data.length && data[i] == null) {\n\t            i++;\n\t        }\n\t        return data[i];\n\t    }\n\t    function ifNeedCompleteOrdinalData(data) {\n\t        var sampleItem = firstDataNotNull(data);\n\t        return sampleItem != null\n\t            && !zrUtil.isArray(getDataItemValue(sampleItem));\n\t    }\n\t\n\t    /**\n\t     * Helper function to create a list from option data\n\t     */\n\t    function createListFromArray(data, seriesModel, ecModel) {\n\t        // If data is undefined\n\t        data = data || [];\n\t\n\t        if (false) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t\n\t        var coordSysName = seriesModel.get('coordinateSystem');\n\t        var creator = creators[coordSysName];\n\t        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n\t        // FIXME\n\t        var axesInfo = creator && creator(data, seriesModel, ecModel);\n\t        var dimensions = axesInfo && axesInfo.dimensions;\n\t        if (!dimensions) {\n\t            // Get dimensions from registered coordinate system\n\t            dimensions = (registeredCoordSys && registeredCoordSys.dimensions) || ['x', 'y'];\n\t            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n\t        }\n\t        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\t\n\t        var list = new List(dimensions, seriesModel);\n\t\n\t        var nameList = createNameList(axesInfo, data);\n\t\n\t        var categories = {};\n\t        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n\t            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t\n\t                // Use dataIndex as ordinal value in categoryAxis\n\t                return dimIndex === categoryIndex\n\t                    ? dataIndex\n\t                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n\t            }\n\t            : function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                var value = getDataItemValue(itemOpt);\n\t                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t\n\t                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n\t                if (categoryAxesModels && categoryAxesModels[dimName]) {\n\t                    // If given value is a category string\n\t                    if (typeof val === 'string') {\n\t                        // Lazy get categories\n\t                        categories[dimName] = categories[dimName]\n\t                            || categoryAxesModels[dimName].getCategories();\n\t                        val = zrUtil.indexOf(categories[dimName], val);\n\t                        if (val < 0 && !isNaN(val)) {\n\t                            // In case some one write '1', '2' istead of 1, 2\n\t                            val = +val;\n\t                        }\n\t                    }\n\t                }\n\t                return val;\n\t            };\n\t\n\t        list.hasItemOption = false;\n\t        list.initData(data, nameList, dimValueGetter);\n\t\n\t        return list;\n\t    }\n\t\n\t    function isStackable(axisType) {\n\t        return axisType !== 'category' && axisType !== 'time';\n\t    }\n\t\n\t    function getDimTypeByAxis(axisType) {\n\t        return axisType === 'category'\n\t            ? 'ordinal'\n\t            : axisType === 'time'\n\t            ? 'time'\n\t            : 'float';\n\t    }\n\t\n\t    /**\n\t     * Creaters for each coord system.\n\t     */\n\t    var creators = {\n\t\n\t        cartesian2d: function (data, seriesModel, ecModel) {\n\t\n\t            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n\t                return ecModel.queryComponents({\n\t                    mainType: name,\n\t                    index: seriesModel.get(name + 'Index'),\n\t                    id: seriesModel.get(name + 'Id')\n\t                })[0];\n\t            });\n\t            var xAxisModel = axesModels[0];\n\t            var yAxisModel = axesModels[1];\n\t\n\t            if (false) {\n\t                if (!xAxisModel) {\n\t                    throw new Error('xAxis \"' + zrUtil.retrieve(\n\t                        seriesModel.get('xAxisIndex'),\n\t                        seriesModel.get('xAxisId'),\n\t                        0\n\t                    ) + '\" not found');\n\t                }\n\t                if (!yAxisModel) {\n\t                    throw new Error('yAxis \"' + zrUtil.retrieve(\n\t                        seriesModel.get('xAxisIndex'),\n\t                        seriesModel.get('yAxisId'),\n\t                        0\n\t                    ) + '\" not found');\n\t                }\n\t            }\n\t\n\t            var xAxisType = xAxisModel.get('type');\n\t            var yAxisType = yAxisModel.get('type');\n\t\n\t            var dimensions = [\n\t                {\n\t                    name: 'x',\n\t                    type: getDimTypeByAxis(xAxisType),\n\t                    stackable: isStackable(xAxisType)\n\t                },\n\t                {\n\t                    name: 'y',\n\t                    // If two category axes\n\t                    type: getDimTypeByAxis(yAxisType),\n\t                    stackable: isStackable(yAxisType)\n\t                }\n\t            ];\n\t\n\t            var isXAxisCateogry = xAxisType === 'category';\n\t            var isYAxisCategory = yAxisType === 'category';\n\t\n\t            completeDimensions(dimensions, data, ['x', 'y', 'z']);\n\t\n\t            var categoryAxesModels = {};\n\t            if (isXAxisCateogry) {\n\t                categoryAxesModels.x = xAxisModel;\n\t            }\n\t            if (isYAxisCategory) {\n\t                categoryAxesModels.y = yAxisModel;\n\t            }\n\t            return {\n\t                dimensions: dimensions,\n\t                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n\t                categoryAxesModels: categoryAxesModels\n\t            };\n\t        },\n\t\n\t        polar: function (data, seriesModel, ecModel) {\n\t            var polarModel = ecModel.queryComponents({\n\t                mainType: 'polar',\n\t                index: seriesModel.get('polarIndex'),\n\t                id: seriesModel.get('polarId')\n\t            })[0];\n\t\n\t            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n\t            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\t\n\t            if (false) {\n\t                if (!angleAxisModel) {\n\t                    throw new Error('angleAxis option not found');\n\t                }\n\t                if (!radiusAxisModel) {\n\t                    throw new Error('radiusAxis option not found');\n\t                }\n\t            }\n\t\n\t            var radiusAxisType = radiusAxisModel.get('type');\n\t            var angleAxisType = angleAxisModel.get('type');\n\t\n\t            var dimensions = [\n\t                {\n\t                    name: 'radius',\n\t                    type: getDimTypeByAxis(radiusAxisType),\n\t                    stackable: isStackable(radiusAxisType)\n\t                },\n\t                {\n\t                    name: 'angle',\n\t                    type: getDimTypeByAxis(angleAxisType),\n\t                    stackable: isStackable(angleAxisType)\n\t                }\n\t            ];\n\t            var isAngleAxisCateogry = angleAxisType === 'category';\n\t            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\t\n\t            completeDimensions(dimensions, data, ['radius', 'angle', 'value']);\n\t\n\t            var categoryAxesModels = {};\n\t            if (isRadiusAxisCateogry) {\n\t                categoryAxesModels.radius = radiusAxisModel;\n\t            }\n\t            if (isAngleAxisCateogry) {\n\t                categoryAxesModels.angle = angleAxisModel;\n\t            }\n\t            return {\n\t                dimensions: dimensions,\n\t                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n\t                categoryAxesModels: categoryAxesModels\n\t            };\n\t        },\n\t\n\t        geo: function (data, seriesModel, ecModel) {\n\t            // TODO Region\n\t            // \n\t            return {\n\t                dimensions: completeDimensions([\n\t                    {name: 'lng'},\n\t                    {name: 'lat'}\n\t                ], data, ['lng', 'lat', 'value'])\n\t            };\n\t        }\n\t    };\n\t\n\t    function createNameList(result, data) {\n\t        var nameList = [];\n\t\n\t        var categoryDim = result && result.dimensions[result.categoryIndex];\n\t        var categoryAxisModel;\n\t        if (categoryDim) {\n\t            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n\t        }\n\t\n\t        if (categoryAxisModel) {\n\t            // FIXME Two category axis\n\t            var categories = categoryAxisModel.getCategories();\n\t            if (categories) {\n\t                var dataLen = data.length;\n\t                // Ordered data is given explicitly like\n\t                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n\t                // or given scatter data,\n\t                // pick the category\n\t                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n\t                    nameList = [];\n\t                    for (var i = 0; i < dataLen; i++) {\n\t                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n\t                    }\n\t                }\n\t                else {\n\t                    nameList = categories.slice(0);\n\t                }\n\t            }\n\t        }\n\t\n\t        return nameList;\n\t    }\n\t\n\t    module.exports = createListFromArray;\n\t\n\n\n/***/ },\n/* 36 */\n/*!*******************************!*\\\n  !*** ./lib/component/grid.js ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var graphic = __webpack_require__(/*! ../util/graphic */ 3);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var echarts = __webpack_require__(/*! ../echarts */ 2);\n\t\n\t    __webpack_require__(/*! ../coord/cartesian/Grid */ 54);\n\t\n\t    __webpack_require__(/*! ./axis */ 106);\n\t\n\t    // Grid view\n\t    echarts.extendComponentView({\n\t\n\t        type: 'grid',\n\t\n\t        render: function (gridModel, ecModel) {\n\t            this.group.removeAll();\n\t            if (gridModel.get('show')) {\n\t                this.group.add(new graphic.Rect({\n\t                    shape: gridModel.coordinateSystem.getRect(),\n\t                    style: zrUtil.defaults({\n\t                        fill: gridModel.get('backgroundColor')\n\t                    }, gridModel.getItemStyle()),\n\t                    silent: true,\n\t                    z2: -1\n\t                }));\n\t            }\n\t        }\n\t\n\t    });\n\t\n\t    echarts.registerPreprocessor(function (option) {\n\t        // Only create grid when need\n\t        if (option.xAxis && option.yAxis && !option.grid) {\n\t            option.grid = {};\n\t        }\n\t    });\n\n\n/***/ },\n/* 37 */\n/*!**********************************************!*\\\n  !*** ./~/zrender/lib/graphic/Displayable.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t\n\t    var Style = __webpack_require__(/*! ./Style */ 64);\n\t\n\t    var Element = __webpack_require__(/*! ../Element */ 58);\n\t    var RectText = __webpack_require__(/*! ./mixin/RectText */ 75);\n\t    // var Stateful = require('./mixin/Stateful');\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (\n\t                opts.hasOwnProperty(name) &&\n\t                name !== 'style'\n\t            ) {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style);\n\t\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];\n\t\n\t        // FIXME Stateful must be mixined after style is setted\n\t        // Stateful.call(this, opts);\n\t    }\n\t\n\t    Displayable.prototype = {\n\t\n\t        constructor: Displayable,\n\t\n\t        type: 'displayable',\n\t\n\t        /**\n\t         * Displayable Painter \n\t         * Dirty flag. From which painter will determine if this displayable object needs brush\n\t         * @name module:zrender/graphic/Displayable#__dirty\n\t         * @type {boolean}\n\t         */\n\t        __dirty: true,\n\t\n\t        /**\n\t         * true\n\t         * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t         * @name module:/zrender/graphic/Displayable#invisible\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        invisible: false,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z: 0,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z2: 0,\n\t\n\t        /**\n\t         * zlevelcanvas\n\t         * @name module:/zrender/graphic/Displayable#zlevel\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        zlevel: 0,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        draggable: false,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        dragging: false,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * If enable culling\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        culling: false,\n\t\n\t        /**\n\t         * Mouse cursor when hovered\n\t         * @name module:/zrender/graphic/Displayable#cursor\n\t         * @type {string}\n\t         */\n\t        cursor: 'pointer',\n\t\n\t        /**\n\t         * If hover area is bounding rect\n\t         * @name module:/zrender/graphic/Displayable#rectHover\n\t         * @type {string}\n\t         */\n\t        rectHover: false,\n\t\n\t        /**\n\t         * Render the element progressively when the value >= 0,\n\t         * usefull for large data.\n\t         * @type {number}\n\t         */\n\t        progressive: -1,\n\t\n\t        beforeBrush: function (ctx) {},\n\t\n\t        afterBrush: function (ctx) {},\n\t\n\t        /**\n\t         * \n\t         * @param {Canvas2DRenderingContext} ctx\n\t         */\n\t        // Interface\n\t        brush: function (ctx, prevEl) {},\n\t\n\t        /**\n\t         * \n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        // Interface\n\t        getBoundingRect: function () {},\n\t\n\t        /**\n\t         *  x, y \n\t         * If displayable element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t\n\t        /**\n\t         *  x, y \n\t         * If bounding rect of element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Mark displayable element dirty and refresh next frame\n\t         */\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t\n\t            this._rect = null;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * If displayable object binded any event\n\t         * @return {boolean}\n\t         */\n\t        // TODO,  bind \n\t        // isSilent: function () {\n\t        //     return !(\n\t        //         this.hoverable || this.draggable\n\t        //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t        //         || this.onmousedown || this.onmouseup || this.onclick\n\t        //         || this.ondragenter || this.ondragover || this.ondragleave\n\t        //         || this.ondrop\n\t        //     );\n\t        // },\n\t        /**\n\t         * Alias for animate('style')\n\t         * @param {boolean} loop\n\t         */\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            }\n\t            else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Use given style object\n\t         * @param  {Object} obj\n\t         */\n\t        useStyle: function (obj) {\n\t            this.style = new Style(obj);\n\t            this.dirty(false);\n\t            return this;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Displayable, Element);\n\t\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t\n\t    module.exports = Displayable;\n\n\n/***/ },\n/* 38 */\n/*!*******************************!*\\\n  !*** ./lib/scale/Interval.js ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Interval scale\n\t * @module echarts/scale/Interval\n\t */\n\t\n\t\n\t\n\t    var numberUtil = __webpack_require__(/*! ../util/number */ 4);\n\t    var formatUtil = __webpack_require__(/*! ../util/format */ 9);\n\t    var Scale = __webpack_require__(/*! ./Scale */ 32);\n\t\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t\n\t    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n\t    var roundingErrorFix = numberUtil.round;\n\t    /**\n\t     * @alias module:echarts/coord/scale/Interval\n\t     * @constructor\n\t     */\n\t    var IntervalScale = Scale.extend({\n\t\n\t        type: 'interval',\n\t\n\t        _interval: 0,\n\t\n\t        setExtent: function (start, end) {\n\t            var thisExtent = this._extent;\n\t            //start,end may be a Number like '25',so...\n\t            if (!isNaN(start)) {\n\t                thisExtent[0] = parseFloat(start);\n\t            }\n\t            if (!isNaN(end)) {\n\t                thisExtent[1] = parseFloat(end);\n\t            }\n\t        },\n\t\n\t        unionExtent: function (other) {\n\t            var extent = this._extent;\n\t            other[0] < extent[0] && (extent[0] = other[0]);\n\t            other[1] > extent[1] && (extent[1] = other[1]);\n\t\n\t            // unionExtent may called by it's sub classes\n\t            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n\t        },\n\t        /**\n\t         * Get interval\n\t         */\n\t        getInterval: function () {\n\t            if (!this._interval) {\n\t                this.niceTicks();\n\t            }\n\t            return this._interval;\n\t        },\n\t\n\t        /**\n\t         * Set interval\n\t         */\n\t        setInterval: function (interval) {\n\t            this._interval = interval;\n\t            // Dropped auto calculated niceExtent and use user setted extent\n\t            // We assume user wan't to set both interval, min, max to get a better result\n\t            this._niceExtent = this._extent.slice();\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getTicks: function () {\n\t            if (!this._interval) {\n\t                this.niceTicks();\n\t            }\n\t            var interval = this._interval;\n\t            var extent = this._extent;\n\t            var ticks = [];\n\t\n\t            // Consider this case: using dataZoom toolbox, zoom and zoom.\n\t            var safeLimit = 10000;\n\t\n\t            if (interval) {\n\t                var niceExtent = this._niceExtent;\n\t                var precision = getPrecisionSafe(interval) + 2;\n\t\n\t                if (extent[0] < niceExtent[0]) {\n\t                    ticks.push(extent[0]);\n\t                }\n\t                var tick = niceExtent[0];\n\t\n\t                while (tick <= niceExtent[1]) {\n\t                    ticks.push(tick);\n\t                    // Avoid rounding error\n\t                    tick = roundingErrorFix(tick + interval, precision);\n\t                    if (ticks.length > safeLimit) {\n\t                        return [];\n\t                    }\n\t                }\n\t                // Consider this case: the last item of ticks is smaller\n\t                // than niceExtent[1] and niceExtent[1] === extent[1].\n\t                if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceExtent[1])) {\n\t                    ticks.push(extent[1]);\n\t                }\n\t            }\n\t\n\t            return ticks;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<string>}\n\t         */\n\t        getTicksLabels: function () {\n\t            var labels = [];\n\t            var ticks = this.getTicks();\n\t            for (var i = 0; i < ticks.length; i++) {\n\t                labels.push(this.getLabel(ticks[i]));\n\t            }\n\t            return labels;\n\t        },\n\t\n\t        /**\n\t         * @param {number} n\n\t         * @return {number}\n\t         */\n\t        getLabel: function (data) {\n\t            return formatUtil.addCommas(data);\n\t        },\n\t\n\t        /**\n\t         * Update interval and extent of intervals for nice ticks\n\t         *\n\t         * @param {number} [splitNumber = 5] Desired number of ticks\n\t         */\n\t        niceTicks: function (splitNumber) {\n\t            splitNumber = splitNumber || 5;\n\t            var extent = this._extent;\n\t            var span = extent[1] - extent[0];\n\t            if (!isFinite(span)) {\n\t                return;\n\t            }\n\t            // User may set axis min 0 and data are all negative\n\t            // FIXME If it needs to reverse ?\n\t            if (span < 0) {\n\t                span = -span;\n\t                extent.reverse();\n\t            }\n\t\n\t            // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t            // var niceSpan = numberUtil.nice(span, false);\n\t            var step = roundingErrorFix(\n\t                numberUtil.nice(span / splitNumber, true),\n\t                Math.max(\n\t                    getPrecisionSafe(extent[0]),\n\t                    getPrecisionSafe(extent[1])\n\t                // extent may be [0, 1], and step should have 1 more digits.\n\t                // To make it safe we add 2 more digits\n\t                ) + 2\n\t            );\n\t\n\t            var precision = getPrecisionSafe(step) + 2;\n\t            // Niced extent inside original extent\n\t            var niceExtent = [\n\t                roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n\t                roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n\t            ];\n\t\n\t            this._interval = step;\n\t            this._niceExtent = niceExtent;\n\t        },\n\t\n\t        /**\n\t         * Nice extent.\n\t         * @param {number} [splitNumber = 5] Given approx tick number\n\t         * @param {boolean} [fixMin=false]\n\t         * @param {boolean} [fixMax=false]\n\t         */\n\t        niceExtent: function (splitNumber, fixMin, fixMax) {\n\t            var extent = this._extent;\n\t            // If extent start and end are same, expand them\n\t            if (extent[0] === extent[1]) {\n\t                if (extent[0] !== 0) {\n\t                    // Expand extent\n\t                    var expandSize = extent[0];\n\t                    // In the fowllowing case\n\t                    //      Axis has been fixed max 100\n\t                    //      Plus data are all 100 and axis extent are [100, 100].\n\t                    // Extend to the both side will cause expanded max is larger than fixed max.\n\t                    // So only expand to the smaller side.\n\t                    if (!fixMax) {\n\t                        extent[1] += expandSize / 2;\n\t                        extent[0] -= expandSize / 2;\n\t                    }\n\t                    else {\n\t                        extent[0] -= expandSize / 2;\n\t                    }\n\t                }\n\t                else {\n\t                    extent[1] = 1;\n\t                }\n\t            }\n\t            var span = extent[1] - extent[0];\n\t            // If there are no data and extent are [Infinity, -Infinity]\n\t            if (!isFinite(span)) {\n\t                extent[0] = 0;\n\t                extent[1] = 1;\n\t            }\n\t\n\t            this.niceTicks(splitNumber);\n\t\n\t            // var extent = this._extent;\n\t            var interval = this._interval;\n\t\n\t            if (!fixMin) {\n\t                extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n\t            }\n\t            if (!fixMax) {\n\t                extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n\t            }\n\t        }\n\t    });\n\t\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    IntervalScale.create = function () {\n\t        return new IntervalScale();\n\t    };\n\t\n\t    module.exports = IntervalScale;\n\t\n\n\n/***/ },\n/* 39 */\n/*!****************************************!*\\\n  !*** ./lib/chart/helper/SymbolDraw.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/chart/helper/SymbolDraw\n\t */\n\t\n\t\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var Symbol = __webpack_require__(/*! ./Symbol */ 49);\n\t\n\t    /**\n\t     * @constructor\n\t     * @alias module:echarts/chart/helper/SymbolDraw\n\t     * @param {module:zrender/graphic/Group} [symbolCtor]\n\t     */\n\t    function SymbolDraw(symbolCtor) {\n\t        this.group = new graphic.Group();\n\t\n\t        this._symbolCtor = symbolCtor || Symbol;\n\t    }\n\t\n\t    var symbolDrawProto = SymbolDraw.prototype;\n\t\n\t    function symbolNeedsDraw(data, idx, isIgnore) {\n\t        var point = data.getItemLayout(idx);\n\t        // Is an object\n\t        // if (point && point.hasOwnProperty('point')) {\n\t        //     point = point.point;\n\t        // }\n\t        return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx))\n\t                    && data.getItemVisual(idx, 'symbol') !== 'none';\n\t    }\n\t    /**\n\t     * Update symbols draw by new data\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Array.<boolean>} [isIgnore]\n\t     */\n\t    symbolDrawProto.updateData = function (data, isIgnore) {\n\t        var group = this.group;\n\t        var seriesModel = data.hostModel;\n\t        var oldData = this._data;\n\t\n\t        var SymbolCtor = this._symbolCtor;\n\t\n\t        var seriesScope = {\n\t            itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n\t            hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n\t            symbolRotate: seriesModel.get('symbolRotate'),\n\t            symbolOffset: seriesModel.get('symbolOffset'),\n\t            hoverAnimation: seriesModel.get('hoverAnimation'),\n\t\n\t            labelModel: seriesModel.getModel('label.normal'),\n\t            hoverLabelModel: seriesModel.getModel('label.emphasis')\n\t        };\n\t\n\t        data.diff(oldData)\n\t            .add(function (newIdx) {\n\t                var point = data.getItemLayout(newIdx);\n\t                if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n\t                    var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n\t                    symbolEl.attr('position', point);\n\t                    data.setItemGraphicEl(newIdx, symbolEl);\n\t                    group.add(symbolEl);\n\t                }\n\t            })\n\t            .update(function (newIdx, oldIdx) {\n\t                var symbolEl = oldData.getItemGraphicEl(oldIdx);\n\t                var point = data.getItemLayout(newIdx);\n\t                if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n\t                    group.remove(symbolEl);\n\t                    return;\n\t                }\n\t                if (!symbolEl) {\n\t                    symbolEl = new SymbolCtor(data, newIdx);\n\t                    symbolEl.attr('position', point);\n\t                }\n\t                else {\n\t                    symbolEl.updateData(data, newIdx, seriesScope);\n\t                    graphic.updateProps(symbolEl, {\n\t                        position: point\n\t                    }, seriesModel);\n\t                }\n\t\n\t                // Add back\n\t                group.add(symbolEl);\n\t\n\t                data.setItemGraphicEl(newIdx, symbolEl);\n\t            })\n\t            .remove(function (oldIdx) {\n\t                var el = oldData.getItemGraphicEl(oldIdx);\n\t                el && el.fadeOut(function () {\n\t                    group.remove(el);\n\t                });\n\t            })\n\t            .execute();\n\t\n\t        this._data = data;\n\t    };\n\t\n\t    symbolDrawProto.updateLayout = function () {\n\t        var data = this._data;\n\t        if (data) {\n\t            // Not use animation\n\t            data.eachItemGraphicEl(function (el, idx) {\n\t                var point = data.getItemLayout(idx);\n\t                el.attr('position', point);\n\t            });\n\t        }\n\t    };\n\t\n\t    symbolDrawProto.remove = function (enableAnimation) {\n\t        var group = this.group;\n\t        var data = this._data;\n\t        if (data) {\n\t            if (enableAnimation) {\n\t                data.eachItemGraphicEl(function (el) {\n\t                    el.fadeOut(function () {\n\t                        group.remove(el);\n\t                    });\n\t                });\n\t            }\n\t            else {\n\t                group.removeAll();\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = SymbolDraw;\n\n\n/***/ },\n/* 40 */,\n/* 41 */,\n/* 42 */\n/*!***************************!*\\\n  !*** ./lib/coord/Axis.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var numberUtil = __webpack_require__(/*! ../util/number */ 4);\n\t    var linearMap = numberUtil.linearMap;\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    function fixExtentWithBands(extent, nTick) {\n\t        var size = extent[1] - extent[0];\n\t        var len = nTick;\n\t        var margin = size / len / 2;\n\t        extent[0] += margin;\n\t        extent[1] -= margin;\n\t    }\n\t\n\t    var normalizedExtent = [0, 1];\n\t    /**\n\t     * @name module:echarts/coord/CartesianAxis\n\t     * @constructor\n\t     */\n\t    var Axis = function (dim, scale, extent) {\n\t\n\t        /**\n\t         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n\t         * @type {string}\n\t         */\n\t        this.dim = dim;\n\t\n\t        /**\n\t         * Axis scale\n\t         * @type {module:echarts/coord/scale/*}\n\t         */\n\t        this.scale = scale;\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        this._extent = extent || [0, 0];\n\t\n\t        /**\n\t         * @type {boolean}\n\t         */\n\t        this.inverse = false;\n\t\n\t        /**\n\t         * Usually true when axis has a ordinal scale\n\t         * @type {boolean}\n\t         */\n\t        this.onBand = false;\n\t    };\n\t\n\t    Axis.prototype = {\n\t\n\t        constructor: Axis,\n\t\n\t        /**\n\t         * If axis extent contain given coord\n\t         * @param {number} coord\n\t         * @return {boolean}\n\t         */\n\t        contain: function (coord) {\n\t            var extent = this._extent;\n\t            var min = Math.min(extent[0], extent[1]);\n\t            var max = Math.max(extent[0], extent[1]);\n\t            return coord >= min && coord <= max;\n\t        },\n\t\n\t        /**\n\t         * If axis extent contain given data\n\t         * @param {number} data\n\t         * @return {boolean}\n\t         */\n\t        containData: function (data) {\n\t            return this.contain(this.dataToCoord(data));\n\t        },\n\t\n\t        /**\n\t         * Get coord extent.\n\t         * @return {Array.<number>}\n\t         */\n\t        getExtent: function () {\n\t            var ret = this._extent.slice();\n\t            return ret;\n\t        },\n\t\n\t        /**\n\t         * Get precision used for formatting\n\t         * @param {Array.<number>} [dataExtent]\n\t         * @return {number}\n\t         */\n\t        getPixelPrecision: function (dataExtent) {\n\t            return numberUtil.getPixelPrecision(\n\t                dataExtent || this.scale.getExtent(),\n\t                this._extent\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Set coord extent\n\t         * @param {number} start\n\t         * @param {number} end\n\t         */\n\t        setExtent: function (start, end) {\n\t            var extent = this._extent;\n\t            extent[0] = start;\n\t            extent[1] = end;\n\t        },\n\t\n\t        /**\n\t         * Convert data to coord. Data is the rank if it has a ordinal scale\n\t         * @param {number} data\n\t         * @param  {boolean} clamp\n\t         * @return {number}\n\t         */\n\t        dataToCoord: function (data, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t            data = scale.normalize(data);\n\t\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t\n\t            return linearMap(data, normalizedExtent, extent, clamp);\n\t        },\n\t\n\t        /**\n\t         * Convert coord to data. Data is the rank if it has a ordinal scale\n\t         * @param {number} coord\n\t         * @param  {boolean} clamp\n\t         * @return {number}\n\t         */\n\t        coordToData: function (coord, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t\n\t            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\t\n\t            return this.scale.scale(t);\n\t        },\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getTicksCoords: function (alignWithLabel) {\n\t            if (this.onBand && !alignWithLabel) {\n\t                var bands = this.getBands();\n\t                var coords = [];\n\t                for (var i = 0; i < bands.length; i++) {\n\t                    coords.push(bands[i][0]);\n\t                }\n\t                if (bands[i - 1]) {\n\t                    coords.push(bands[i - 1][1]);\n\t                }\n\t                return coords;\n\t            }\n\t            else {\n\t                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Coords of labels are on the ticks or on the middle of bands\n\t         * @return {Array.<number>}\n\t         */\n\t        getLabelsCoords: function () {\n\t            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t        },\n\t\n\t        /**\n\t         * Get bands.\n\t         *\n\t         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n\t         * |---1---|---2---|---3---|---4---|.\n\t         *\n\t         * @return {Array}\n\t         */\n\t         // FIXME Situation when labels is on ticks\n\t        getBands: function () {\n\t            var extent = this.getExtent();\n\t            var bands = [];\n\t            var len = this.scale.count();\n\t            var start = extent[0];\n\t            var end = extent[1];\n\t            var span = end - start;\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                bands.push([\n\t                    span * i / len + start,\n\t                    span * (i + 1) / len + start\n\t                ]);\n\t            }\n\t            return bands;\n\t        },\n\t\n\t        /**\n\t         * Get width of band\n\t         * @return {number}\n\t         */\n\t        getBandWidth: function () {\n\t            var axisExtent = this._extent;\n\t            var dataExtent = this.scale.getExtent();\n\t\n\t            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n\t            // Fix #2728, avoid NaN when only one data.\n\t            len === 0 && (len = 1);\n\t\n\t            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\t\n\t            return Math.abs(size) / len;\n\t        }\n\t    };\n\t\n\t    module.exports = Axis;\n\n\n/***/ },\n/* 43 */\n/*!*******************************!*\\\n  !*** ./lib/util/component.js ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var clazz = __webpack_require__(/*! ./clazz */ 21);\n\t\n\t    var parseClassType = clazz.parseClassType;\n\t\n\t    var base = 0;\n\t\n\t    var componentUtil = {};\n\t\n\t    var DELIMITER = '_';\n\t\n\t    /**\n\t     * @public\n\t     * @param {string} type\n\t     * @return {string}\n\t     */\n\t    componentUtil.getUID = function (type) {\n\t        // Considering the case of crossing js context,\n\t        // use Math.random to make id as unique as possible.\n\t        return [(type || ''), base++, Math.random()].join(DELIMITER);\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    componentUtil.enableSubTypeDefaulter = function (entity) {\n\t\n\t        var subTypeDefaulters = {};\n\t\n\t        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n\t            componentType = parseClassType(componentType);\n\t            subTypeDefaulters[componentType.main] = defaulter;\n\t        };\n\t\n\t        entity.determineSubType = function (componentType, option) {\n\t            var type = option.type;\n\t            if (!type) {\n\t                var componentTypeMain = parseClassType(componentType).main;\n\t                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n\t                    type = subTypeDefaulters[componentTypeMain](option);\n\t                }\n\t            }\n\t            return type;\n\t        };\n\t\n\t        return entity;\n\t    };\n\t\n\t    /**\n\t     * Topological travel on Activity Network (Activity On Vertices).\n\t     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n\t     *\n\t     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n\t     *\n\t     * If there is circle dependencey, Error will be thrown.\n\t     *\n\t     */\n\t    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\t\n\t        /**\n\t         * @public\n\t         * @param {Array.<string>} targetNameList Target Component type list.\n\t         *                                           Can be ['aa', 'bb', 'aa.xx']\n\t         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n\t         * @param {Function} callback Params: componentType, dependencies.\n\t         * @param {Object} context Scope of callback.\n\t         */\n\t        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n\t            if (!targetNameList.length) {\n\t                return;\n\t            }\n\t\n\t            var result = makeDepndencyGraph(fullNameList);\n\t            var graph = result.graph;\n\t            var stack = result.noEntryList;\n\t\n\t            var targetNameSet = {};\n\t            zrUtil.each(targetNameList, function (name) {\n\t                targetNameSet[name] = true;\n\t            });\n\t\n\t            while (stack.length) {\n\t                var currComponentType = stack.pop();\n\t                var currVertex = graph[currComponentType];\n\t                var isInTargetNameSet = !!targetNameSet[currComponentType];\n\t                if (isInTargetNameSet) {\n\t                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n\t                    delete targetNameSet[currComponentType];\n\t                }\n\t                zrUtil.each(\n\t                    currVertex.successor,\n\t                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n\t                );\n\t            }\n\t\n\t            zrUtil.each(targetNameSet, function () {\n\t                throw new Error('Circle dependency may exists');\n\t            });\n\t\n\t            function removeEdge(succComponentType) {\n\t                graph[succComponentType].entryCount--;\n\t                if (graph[succComponentType].entryCount === 0) {\n\t                    stack.push(succComponentType);\n\t                }\n\t            }\n\t\n\t            // Consider this case: legend depends on series, and we call\n\t            // chart.setOption({series: [...]}), where only series is in option.\n\t            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n\t            // not be called, but only sereis.mergeOption is called. Thus legend\n\t            // have no chance to update its local record about series (like which\n\t            // name of series is available in legend).\n\t            function removeEdgeAndAdd(succComponentType) {\n\t                targetNameSet[succComponentType] = true;\n\t                removeEdge(succComponentType);\n\t            }\n\t        };\n\t\n\t        /**\n\t         * DepndencyGraph: {Object}\n\t         * key: conponentType,\n\t         * value: {\n\t         *     successor: [conponentTypes...],\n\t         *     originalDeps: [conponentTypes...],\n\t         *     entryCount: {number}\n\t         * }\n\t         */\n\t        function makeDepndencyGraph(fullNameList) {\n\t            var graph = {};\n\t            var noEntryList = [];\n\t\n\t            zrUtil.each(fullNameList, function (name) {\n\t\n\t                var thisItem = createDependencyGraphItem(graph, name);\n\t                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\t\n\t                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n\t                thisItem.entryCount = availableDeps.length;\n\t                if (thisItem.entryCount === 0) {\n\t                    noEntryList.push(name);\n\t                }\n\t\n\t                zrUtil.each(availableDeps, function (dependentName) {\n\t                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n\t                        thisItem.predecessor.push(dependentName);\n\t                    }\n\t                    var thatItem = createDependencyGraphItem(graph, dependentName);\n\t                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n\t                        thatItem.successor.push(name);\n\t                    }\n\t                });\n\t            });\n\t\n\t            return {graph: graph, noEntryList: noEntryList};\n\t        }\n\t\n\t        function createDependencyGraphItem(graph, name) {\n\t            if (!graph[name]) {\n\t                graph[name] = {predecessor: [], successor: []};\n\t            }\n\t            return graph[name];\n\t        }\n\t\n\t        function getAvailableDependencies(originalDeps, fullNameList) {\n\t            var availableDeps = [];\n\t            zrUtil.each(originalDeps, function (dep) {\n\t                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n\t            });\n\t            return availableDeps;\n\t        }\n\t    };\n\t\n\t    module.exports = componentUtil;\n\n\n/***/ },\n/* 44 */\n/*!***************************************!*\\\n  !*** ./~/zrender/lib/core/timsort.js ***!\n  \\***************************************/\n/***/ function(module, exports) {\n\n\t// https://github.com/mziccard/node-timsort\n\t\n\t    var DEFAULT_MIN_MERGE = 32;\n\t\n\t    var DEFAULT_MIN_GALLOPING = 7;\n\t\n\t    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t\n\t    function minRunLength(n) {\n\t        var r = 0;\n\t\n\t        while (n >= DEFAULT_MIN_MERGE) {\n\t            r |= n & 1;\n\t            n >>= 1;\n\t        }\n\t\n\t        return n + r;\n\t    }\n\t\n\t    function makeAscendingRun(array, lo, hi, compare) {\n\t        var runHi = lo + 1;\n\t\n\t        if (runHi === hi) {\n\t            return 1;\n\t        }\n\t\n\t        if (compare(array[runHi++], array[lo]) < 0) {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t                runHi++;\n\t            }\n\t\n\t            reverseRun(array, lo, runHi);\n\t        }\n\t        else {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t                runHi++;\n\t            }\n\t        }\n\t\n\t        return runHi - lo;\n\t    }\n\t\n\t    function reverseRun(array, lo, hi) {\n\t        hi--;\n\t\n\t        while (lo < hi) {\n\t            var t = array[lo];\n\t            array[lo++] = array[hi];\n\t            array[hi--] = t;\n\t        }\n\t    }\n\t\n\t    function binaryInsertionSort(array, lo, hi, start, compare) {\n\t        if (start === lo) {\n\t            start++;\n\t        }\n\t\n\t        for (; start < hi; start++) {\n\t            var pivot = array[start];\n\t\n\t            var left = lo;\n\t            var right = start;\n\t            var mid;\n\t\n\t            while (left < right) {\n\t                mid = left + right >>> 1;\n\t\n\t                if (compare(pivot, array[mid]) < 0) {\n\t                    right = mid;\n\t                }\n\t                else {\n\t                    left = mid + 1;\n\t                }\n\t            }\n\t\n\t            var n = start - left;\n\t\n\t            switch (n) {\n\t                case 3:\n\t                    array[left + 3] = array[left + 2];\n\t\n\t                case 2:\n\t                    array[left + 2] = array[left + 1];\n\t\n\t                case 1:\n\t                    array[left + 1] = array[left];\n\t                    break;\n\t                default:\n\t                    while (n > 0) {\n\t                        array[left + n] = array[left + n - 1];\n\t                        n--;\n\t                    }\n\t            }\n\t\n\t            array[left] = pivot;\n\t        }\n\t    }\n\t\n\t    function gallopLeft(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) > 0) {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t        else {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) > 0) {\n\t                lastOffset = m + 1;\n\t            }\n\t            else {\n\t                offset = m;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t\n\t    function gallopRight(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) < 0) {\n\t            maxOffset = hint + 1;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t        else {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t\n\t        lastOffset++;\n\t\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) < 0) {\n\t                offset = m;\n\t            }\n\t            else {\n\t                lastOffset = m + 1;\n\t            }\n\t        }\n\t\n\t        return offset;\n\t    }\n\t\n\t    function TimSort(array, compare) {\n\t        var minGallop = DEFAULT_MIN_GALLOPING;\n\t        var length = 0;\n\t        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t        var stackLength = 0;\n\t        var runStart;\n\t        var runLength;\n\t        var stackSize = 0;\n\t\n\t        length = array.length;\n\t\n\t        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t            tmpStorageLength = length >>> 1;\n\t        }\n\t\n\t        var tmp = [];\n\t\n\t        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t\n\t        runStart = [];\n\t        runLength = [];\n\t\n\t        function pushRun(_runStart, _runLength) {\n\t            runStart[stackSize] = _runStart;\n\t            runLength[stackSize] = _runLength;\n\t            stackSize += 1;\n\t        }\n\t\n\t        function mergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t                    if (runLength[n - 1] < runLength[n + 1]) {\n\t                        n--;\n\t                    }\n\t                }\n\t                else if (runLength[n] > runLength[n + 1]) {\n\t                    break;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function forceMergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t                    n--;\n\t                }\n\t\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function mergeAt(i) {\n\t            var start1 = runStart[i];\n\t            var length1 = runLength[i];\n\t            var start2 = runStart[i + 1];\n\t            var length2 = runLength[i + 1];\n\t\n\t            runLength[i] = length1 + length2;\n\t\n\t            if (i === stackSize - 3) {\n\t                runStart[i + 1] = runStart[i + 2];\n\t                runLength[i + 1] = runLength[i + 2];\n\t            }\n\t\n\t            stackSize--;\n\t\n\t            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t            start1 += k;\n\t            length1 -= k;\n\t\n\t            if (length1 === 0) {\n\t                return;\n\t            }\n\t\n\t            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t\n\t            if (length2 === 0) {\n\t                return;\n\t            }\n\t\n\t            if (length1 <= length2) {\n\t                mergeLow(start1, length1, start2, length2);\n\t            }\n\t            else {\n\t                mergeHigh(start1, length1, start2, length2);\n\t            }\n\t        }\n\t\n\t        function mergeLow(start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length1; i++) {\n\t                tmp[i] = array[start1 + i];\n\t            }\n\t\n\t            var cursor1 = 0;\n\t            var cursor2 = start2;\n\t            var dest = start1;\n\t\n\t            array[dest++] = array[cursor2++];\n\t\n\t            if (--length2 === 0) {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t                return;\n\t            }\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t            var count1, count2, exit;\n\t\n\t            while (1) {\n\t                count1 = 0;\n\t                count2 = 0;\n\t                exit = false;\n\t\n\t                do {\n\t                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t                        array[dest++] = array[cursor2++];\n\t                        count2++;\n\t                        count1 = 0;\n\t\n\t                        if (--length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest++] = tmp[cursor1++];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        for (i = 0; i < count1; i++) {\n\t                            array[dest + i] = tmp[cursor1 + i];\n\t                        }\n\t\n\t                        dest += count1;\n\t                        cursor1 += count1;\n\t                        length1 -= count1;\n\t                        if (length1 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest++] = array[cursor2++];\n\t\n\t                    if (--length2 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[dest + i] = array[cursor2 + i];\n\t                        }\n\t\n\t                        dest += count2;\n\t                        cursor2 += count2;\n\t                        length2 -= count2;\n\t\n\t                        if (length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = tmp[cursor1++];\n\t\n\t                    if (--length1 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            minGallop < 1 && (minGallop = 1);\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t            }\n\t            else if (length1 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeLow preconditions were not respected');\n\t            }\n\t            else {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t            }\n\t        }\n\t\n\t        function mergeHigh (start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length2; i++) {\n\t                tmp[i] = array[start2 + i];\n\t            }\n\t\n\t            var cursor1 = start1 + length1 - 1;\n\t            var cursor2 = length2 - 1;\n\t            var dest = start2 + length2 - 1;\n\t            var customCursor = 0;\n\t            var customDest = 0;\n\t\n\t            array[dest--] = array[cursor1--];\n\t\n\t            if (--length1 === 0) {\n\t                customCursor = dest - (length2 - 1);\n\t\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t\n\t            while (true) {\n\t                var count1 = 0;\n\t                var count2 = 0;\n\t                var exit = false;\n\t\n\t                do {\n\t                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t                        array[dest--] = array[cursor1--];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest--] = tmp[cursor2--];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        dest -= count1;\n\t                        cursor1 -= count1;\n\t                        length1 -= count1;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor1 + 1;\n\t\n\t                        for (i = count1 - 1; i >= 0; i--) {\n\t                            array[customDest + i] = array[customCursor + i];\n\t                        }\n\t\n\t                        if (length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = tmp[cursor2--];\n\t\n\t                    if (--length2 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        dest -= count2;\n\t                        cursor2 -= count2;\n\t                        length2 -= count2;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor2 + 1;\n\t\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[customDest + i] = tmp[customCursor + i];\n\t                        }\n\t\n\t                        if (length2 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = array[cursor1--];\n\t\n\t                    if (--length1 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            if (minGallop < 1) {\n\t                minGallop = 1;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t            }\n\t            else if (length2 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeHigh preconditions were not respected');\n\t            }\n\t            else {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t            }\n\t        }\n\t\n\t        this.mergeRuns = mergeRuns;\n\t        this.forceMergeRuns = forceMergeRuns;\n\t        this.pushRun = pushRun;\n\t    }\n\t\n\t    function sort(array, compare, lo, hi) {\n\t        if (!lo) {\n\t            lo = 0;\n\t        }\n\t        if (!hi) {\n\t            hi = array.length;\n\t        }\n\t\n\t        var remaining = hi - lo;\n\t\n\t        if (remaining < 2) {\n\t            return;\n\t        }\n\t\n\t        var runLength = 0;\n\t\n\t        if (remaining < DEFAULT_MIN_MERGE) {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t            return;\n\t        }\n\t\n\t        var ts = new TimSort(array, compare);\n\t\n\t        var minRun = minRunLength(remaining);\n\t\n\t        do {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            if (runLength < minRun) {\n\t                var force = remaining;\n\t                if (force > minRun) {\n\t                    force = minRun;\n\t                }\n\t\n\t                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t                runLength = force;\n\t            }\n\t\n\t            ts.pushRun(lo, runLength);\n\t            ts.mergeRuns();\n\t\n\t            remaining -= runLength;\n\t            lo += runLength;\n\t        } while (remaining !== 0);\n\t\n\t        ts.forceMergeRuns();\n\t    }\n\t\n\t    module.exports = sort;\n\n\n/***/ },\n/* 45 */\n/*!********************************!*\\\n  !*** ./lib/data/DataDiffer.js ***!\n  \\********************************/\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t\n\t    function defaultKeyGetter(item) {\n\t        return item;\n\t    }\n\t\n\t    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n\t        this._old = oldArr;\n\t        this._new = newArr;\n\t\n\t        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n\t        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n\t    }\n\t\n\t    DataDiffer.prototype = {\n\t\n\t        constructor: DataDiffer,\n\t\n\t        /**\n\t         * Callback function when add a data\n\t         */\n\t        add: function (func) {\n\t            this._add = func;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Callback function when update a data\n\t         */\n\t        update: function (func) {\n\t            this._update = func;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Callback function when remove a data\n\t         */\n\t        remove: function (func) {\n\t            this._remove = func;\n\t            return this;\n\t        },\n\t\n\t        execute: function () {\n\t            var oldArr = this._old;\n\t            var newArr = this._new;\n\t            var oldKeyGetter = this._oldKeyGetter;\n\t            var newKeyGetter = this._newKeyGetter;\n\t\n\t            var oldDataIndexMap = {};\n\t            var newDataIndexMap = {};\n\t            var oldDataKeyArr = [];\n\t            var newDataKeyArr = [];\n\t            var i;\n\t\n\t            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n\t            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\t\n\t            // Travel by inverted order to make sure order consistency\n\t            // when duplicate keys exists (consider newDataIndex.pop() below).\n\t            // For performance consideration, these code below do not look neat.\n\t            for (i = 0; i < oldArr.length; i++) {\n\t                var key = oldDataKeyArr[i];\n\t                var idx = newDataIndexMap[key];\n\t\n\t                // idx can never be empty array here. see 'set null' logic below.\n\t                if (idx != null) {\n\t                    // Consider there is duplicate key (for example, use dataItem.name as key).\n\t                    // We should make sure every item in newArr and oldArr can be visited.\n\t                    var len = idx.length;\n\t                    if (len) {\n\t                        len === 1 && (newDataIndexMap[key] = null);\n\t                        idx = idx.unshift();\n\t                    }\n\t                    else {\n\t                        newDataIndexMap[key] = null;\n\t                    }\n\t                    this._update && this._update(idx, i);\n\t                }\n\t                else {\n\t                    this._remove && this._remove(i);\n\t                }\n\t            }\n\t\n\t            for (var i = 0; i < newDataKeyArr.length; i++) {\n\t                var key = newDataKeyArr[i];\n\t                if (newDataIndexMap.hasOwnProperty(key)) {\n\t                    var idx = newDataIndexMap[key];\n\t                    if (idx == null) {\n\t                        continue;\n\t                    }\n\t                    // idx can never be empty array here. see 'set null' logic above.\n\t                    if (!idx.length) {\n\t                        this._add && this._add(idx);\n\t                    }\n\t                    else {\n\t                        for (var j = 0, len = idx.length; j < len; j++) {\n\t                            this._add && this._add(idx[j]);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function initIndexMap(arr, map, keyArr, keyGetter) {\n\t        for (var i = 0; i < arr.length; i++) {\n\t            var key = keyGetter(arr[i], i);\n\t            var existence = map[key];\n\t            if (existence == null) {\n\t                keyArr.push(key);\n\t                map[key] = i;\n\t            }\n\t            else {\n\t                if (!existence.length) {\n\t                    map[key] = existence = [existence];\n\t                }\n\t                existence.push(i);\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = DataDiffer;\n\n\n/***/ },\n/* 46 */\n/*!******************************!*\\\n  !*** ./lib/visual/symbol.js ***!\n  \\******************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\t\n\t        // Encoding visual for all series include which is filtered for legend drawing\n\t        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t\n\t            var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n\t            var symbolSize = seriesModel.get('symbolSize');\n\t\n\t            data.setVisual({\n\t                legendSymbol: legendSymbol || symbolType,\n\t                symbol: symbolType,\n\t                symbolSize: symbolSize\n\t            });\n\t\n\t            // Only visible series has each data be visual encoded\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                if (typeof symbolSize === 'function') {\n\t                    data.each(function (idx) {\n\t                        var rawValue = seriesModel.getRawValue(idx);\n\t                        // FIXME\n\t                        var params = seriesModel.getDataParams(idx);\n\t                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n\t                    });\n\t                }\n\t                data.each(function (idx) {\n\t                    var itemModel = data.getItemModel(idx);\n\t                    var itemSymbolType = itemModel.getShallow('symbol', true);\n\t                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n\t                    // If has item symbol\n\t                    if (itemSymbolType != null) {\n\t                        data.setItemVisual(idx, 'symbol', itemSymbolType);\n\t                    }\n\t                    if (itemSymbolSize != null) {\n\t                        // PENDING Transform symbolSize ?\n\t                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n\t                    }\n\t                });\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n/* 47 */\n/*!***********************************!*\\\n  !*** ./~/zrender/lib/core/log.js ***!\n  \\***********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t        var config = __webpack_require__(/*! ../config */ 33);\n\t\n\t        /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t         */\n\t        module.exports = function() {\n\t            if (config.debugMode === 0) {\n\t                return;\n\t            }\n\t            else if (config.debugMode == 1) {\n\t                for (var k in arguments) {\n\t                    throw new Error(arguments[k]);\n\t                }\n\t            }\n\t            else if (config.debugMode > 1) {\n\t                for (var k in arguments) {\n\t                    console.log(arguments[k]);\n\t                }\n\t            }\n\t        };\n\t\n\t        /* for debug\n\t        return function(mes) {\n\t            document.getElementById('wrong-message').innerHTML =\n\t                mes + ' ' + (new Date() - 0)\n\t                + '<br/>'\n\t                + document.getElementById('wrong-message').innerHTML;\n\t        };\n\t        */\n\t    \n\n\n/***/ },\n/* 48 */\n/*!****************************************!*\\\n  !*** ./~/zrender/lib/graphic/Image.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Image element\n\t * @module zrender/graphic/Image\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(/*! ./Displayable */ 37);\n\t    var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ 8);\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t\n\t    var LRU = __webpack_require__(/*! ../core/LRU */ 150);\n\t    var globalImageCache = new LRU(50);\n\t    /**\n\t     * @alias zrender/graphic/Image\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function ZImage(opts) {\n\t        Displayable.call(this, opts);\n\t    }\n\t\n\t    ZImage.prototype = {\n\t\n\t        constructor: ZImage,\n\t\n\t        type: 'image',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var src = style.image;\n\t            var image;\n\t\n\t            // Must bind each time\n\t            style.bind(ctx, this, prevEl);\n\t            // style.image is a url string\n\t            if (typeof src === 'string') {\n\t                image = this._image;\n\t            }\n\t            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t            else {\n\t                image = src;\n\t            }\n\t            // FIXME Case create many images with src\n\t            if (!image && src) {\n\t                // Try get from global image cache\n\t                var cachedImgObj = globalImageCache.get(src);\n\t                if (!cachedImgObj) {\n\t                    // Create a new image\n\t                    image = new Image();\n\t                    image.onload = function () {\n\t                        image.onload = null;\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t                            cachedImgObj.pending[i].dirty();\n\t                        }\n\t                    };\n\t                    cachedImgObj = {\n\t                        image: image,\n\t                        pending: [this]\n\t                    };\n\t                    image.src = src;\n\t                    globalImageCache.put(src, cachedImgObj);\n\t                    this._image = image;\n\t                    return;\n\t                }\n\t                else {\n\t                    image = cachedImgObj.image;\n\t                    this._image = image;\n\t                    // Image is not complete finish, add to pending list\n\t                    if (!image.width || !image.height) {\n\t                        cachedImgObj.pending.push(this);\n\t                        return;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (image) {\n\t                // \n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\n\t                //     if (!image.complete) {\n\t                //         return;\n\t                //     }\n\t                // }\n\t                // Else is canvas\n\t\n\t                var width = style.width || image.width;\n\t                var height = style.height || image.height;\n\t                var x = style.x || 0;\n\t                var y = style.y || 0;\n\t                // \n\t                if (!image.width || !image.height) {\n\t                    return;\n\t                }\n\t\n\t                // transform\n\t                this.setTransform(ctx);\n\t\n\t\n\t                if (style.sWidth && style.sHeight) {\n\t                    var sx = style.sx || 0;\n\t                    var sy = style.sy || 0;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, style.sWidth, style.sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else if (style.sx && style.sy) {\n\t                    var sx = style.sx;\n\t                    var sy = style.sy;\n\t                    var sWidth = width - sx;\n\t                    var sHeight = height - sy;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, sWidth, sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else {\n\t                    ctx.drawImage(image, x, y, width, height);\n\t                }\n\t\n\t                // \n\t                if (style.width == null) {\n\t                    style.width = width;\n\t                }\n\t                if (style.height == null) {\n\t                    style.height = height;\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t\n\t                // Draw rect text\n\t                if (style.text != null) {\n\t                    this.drawRectText(ctx, this.getBoundingRect());\n\t                }\n\t\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (! this._rect) {\n\t                this._rect = new BoundingRect(\n\t                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n\t                );\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(ZImage, Displayable);\n\t\n\t    module.exports = ZImage;\n\n\n/***/ },\n/* 49 */\n/*!************************************!*\\\n  !*** ./lib/chart/helper/Symbol.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/chart/helper/Symbol\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var symbolUtil = __webpack_require__(/*! ../../util/symbol */ 26);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var numberUtil = __webpack_require__(/*! ../../util/number */ 4);\n\t\n\t    function normalizeSymbolSize(symbolSize) {\n\t        symbolSize = symbolSize instanceof Array\n\t            ? symbolSize.slice()\n\t            : [+symbolSize, +symbolSize];\n\t        symbolSize[0] /= 2;\n\t        symbolSize[1] /= 2;\n\t        return symbolSize;\n\t    }\n\t\n\t    /**\n\t     * @constructor\n\t     * @alias {module:echarts/chart/helper/Symbol}\n\t     * @param {module:echarts/data/List} data\n\t     * @param {number} idx\n\t     * @extends {module:zrender/graphic/Group}\n\t     */\n\t    function Symbol(data, idx, seriesScope) {\n\t        graphic.Group.call(this);\n\t\n\t        this.updateData(data, idx, seriesScope);\n\t    }\n\t\n\t    var symbolProto = Symbol.prototype;\n\t\n\t    function driftSymbol(dx, dy) {\n\t        this.parent.drift(dx, dy);\n\t    }\n\t\n\t    symbolProto._createSymbol = function (symbolType, data, idx) {\n\t        // Remove paths created before\n\t        this.removeAll();\n\t\n\t        var seriesModel = data.hostModel;\n\t        var color = data.getItemVisual(idx, 'color');\n\t\n\t        // var symbolPath = symbolUtil.createSymbol(\n\t        //     symbolType, -0.5, -0.5, 1, 1, color\n\t        // );\n\t        // If width/height are set too small (e.g., set to 1) on ios10\n\t        // and macOS Sierra, a circle stroke become a rect, no matter what\n\t        // the scale is set. So we set width/height as 2. See #4150.\n\t        var symbolPath = symbolUtil.createSymbol(\n\t            symbolType, -1, -1, 2, 2, color\n\t        );\n\t\n\t        symbolPath.attr({\n\t            z2: 100,\n\t            culling: true,\n\t            scale: [0, 0]\n\t        });\n\t        // Rewrite drift method\n\t        symbolPath.drift = driftSymbol;\n\t\n\t        var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\t\n\t        graphic.initProps(symbolPath, {\n\t            scale: size\n\t        }, seriesModel, idx);\n\t        this._symbolType = symbolType;\n\t\n\t        this.add(symbolPath);\n\t    };\n\t\n\t    /**\n\t     * Stop animation\n\t     * @param {boolean} toLastFrame\n\t     */\n\t    symbolProto.stopSymbolAnimation = function (toLastFrame) {\n\t        this.childAt(0).stopAnimation(toLastFrame);\n\t    };\n\t\n\t    /**\n\t     * Get symbol path element\n\t     */\n\t    symbolProto.getSymbolPath = function () {\n\t        return this.childAt(0);\n\t    };\n\t\n\t    /**\n\t     * Get scale(aka, current symbol size).\n\t     * Including the change caused by animation\n\t     */\n\t    symbolProto.getScale = function () {\n\t        return this.childAt(0).scale;\n\t    };\n\t\n\t    /**\n\t     * Highlight symbol\n\t     */\n\t    symbolProto.highlight = function () {\n\t        this.childAt(0).trigger('emphasis');\n\t    };\n\t\n\t    /**\n\t     * Downplay symbol\n\t     */\n\t    symbolProto.downplay = function () {\n\t        this.childAt(0).trigger('normal');\n\t    };\n\t\n\t    /**\n\t     * @param {number} zlevel\n\t     * @param {number} z\n\t     */\n\t    symbolProto.setZ = function (zlevel, z) {\n\t        var symbolPath = this.childAt(0);\n\t        symbolPath.zlevel = zlevel;\n\t        symbolPath.z = z;\n\t    };\n\t\n\t    symbolProto.setDraggable = function (draggable) {\n\t        var symbolPath = this.childAt(0);\n\t        symbolPath.draggable = draggable;\n\t        symbolPath.cursor = draggable ? 'move' : 'pointer';\n\t    };\n\t\n\t    /**\n\t     * Update symbol properties\n\t     * @param  {module:echarts/data/List} data\n\t     * @param  {number} idx\n\t     */\n\t    symbolProto.updateData = function (data, idx, seriesScope) {\n\t        this.silent = false;\n\t\n\t        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n\t        var seriesModel = data.hostModel;\n\t        var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\t        if (symbolType !== this._symbolType) {\n\t            this._createSymbol(symbolType, data, idx);\n\t        }\n\t        else {\n\t            var symbolPath = this.childAt(0);\n\t            graphic.updateProps(symbolPath, {\n\t                scale: symbolSize\n\t            }, seriesModel, idx);\n\t        }\n\t        this._updateCommon(data, idx, symbolSize, seriesScope);\n\t        this._seriesModel = seriesModel;\n\t    };\n\t\n\t    // Update common properties\n\t    var normalStyleAccessPath = ['itemStyle', 'normal'];\n\t    var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\n\t    var normalLabelAccessPath = ['label', 'normal'];\n\t    var emphasisLabelAccessPath = ['label', 'emphasis'];\n\t\n\t    symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n\t        var symbolPath = this.childAt(0);\n\t        var seriesModel = data.hostModel;\n\t        var color = data.getItemVisual(idx, 'color');\n\t\n\t        // Reset style\n\t        if (symbolPath.type !== 'image') {\n\t            symbolPath.useStyle({\n\t                strokeNoScale: true\n\t            });\n\t        }\n\t\n\t        seriesScope = seriesScope || null;\n\t\n\t        var itemStyle = seriesScope && seriesScope.itemStyle;\n\t        var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n\t        var symbolRotate = seriesScope && seriesScope.symbolRotate;\n\t        var symbolOffset = seriesScope && seriesScope.symbolOffset;\n\t        var labelModel = seriesScope && seriesScope.labelModel;\n\t        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n\t        var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n\t\n\t        if (!seriesScope || data.hasItemOption) {\n\t            var itemModel = data.getItemModel(idx);\n\t\n\t            // Color must be excluded.\n\t            // Because symbol provide setColor individually to set fill and stroke\n\t            itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n\t            hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n\t\n\t            symbolRotate = itemModel.getShallow('symbolRotate');\n\t            symbolOffset = itemModel.getShallow('symbolOffset');\n\t\n\t            labelModel = itemModel.getModel(normalLabelAccessPath);\n\t            hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n\t            hoverAnimation = itemModel.getShallow('hoverAnimation');\n\t        }\n\t        else {\n\t            hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n\t        }\n\t\n\t        var elStyle = symbolPath.style;\n\t\n\t        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\t\n\t        if (symbolOffset) {\n\t            symbolPath.attr('position', [\n\t                numberUtil.parsePercent(symbolOffset[0], symbolSize[0]),\n\t                numberUtil.parsePercent(symbolOffset[1], symbolSize[1])\n\t            ]);\n\t        }\n\t\n\t        // PENDING setColor before setStyle!!!\n\t        symbolPath.setColor(color);\n\t\n\t        symbolPath.setStyle(itemStyle);\n\t\n\t        var opacity = data.getItemVisual(idx, 'opacity');\n\t        if (opacity != null) {\n\t            elStyle.opacity = opacity;\n\t        }\n\t\n\t        // Get last value dim\n\t        var dimensions = data.dimensions.slice();\n\t        var valueDim;\n\t        var dataType;\n\t        while (dimensions.length && (\n\t            valueDim = dimensions.pop(),\n\t            dataType = data.getDimensionInfo(valueDim).type,\n\t            dataType === 'ordinal' || dataType === 'time'\n\t        )) {} // jshint ignore:line\n\t\n\t        if (valueDim != null && labelModel.getShallow('show')) {\n\t            graphic.setText(elStyle, labelModel, color);\n\t            elStyle.text = zrUtil.retrieve(\n\t                seriesModel.getFormattedLabel(idx, 'normal'),\n\t                data.get(valueDim, idx)\n\t            );\n\t        }\n\t        else {\n\t            elStyle.text = '';\n\t        }\n\t\n\t        if (valueDim != null && hoverLabelModel.getShallow('show')) {\n\t            graphic.setText(hoverItemStyle, hoverLabelModel, color);\n\t            hoverItemStyle.text = zrUtil.retrieve(\n\t                seriesModel.getFormattedLabel(idx, 'emphasis'),\n\t                data.get(valueDim, idx)\n\t            );\n\t        }\n\t        else {\n\t            hoverItemStyle.text = '';\n\t        }\n\t\n\t        var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\t\n\t        symbolPath.off('mouseover')\n\t            .off('mouseout')\n\t            .off('emphasis')\n\t            .off('normal');\n\t\n\t        symbolPath.hoverStyle = hoverItemStyle;\n\t\n\t        graphic.setHoverStyle(symbolPath);\n\t\n\t        if (hoverAnimation && seriesModel.ifEnableAnimation()) {\n\t            var onEmphasis = function() {\n\t                var ratio = size[1] / size[0];\n\t                this.animateTo({\n\t                    scale: [\n\t                        Math.max(size[0] * 1.1, size[0] + 3),\n\t                        Math.max(size[1] * 1.1, size[1] + 3 * ratio)\n\t                    ]\n\t                }, 400, 'elasticOut');\n\t            };\n\t            var onNormal = function() {\n\t                this.animateTo({\n\t                    scale: size\n\t                }, 400, 'elasticOut');\n\t            };\n\t            symbolPath.on('mouseover', onEmphasis)\n\t                .on('mouseout', onNormal)\n\t                .on('emphasis', onEmphasis)\n\t                .on('normal', onNormal);\n\t        }\n\t    };\n\t\n\t    symbolProto.fadeOut = function (cb) {\n\t        var symbolPath = this.childAt(0);\n\t        // Avoid mistaken hover when fading out\n\t        this.silent = true;\n\t        // Not show text when animating\n\t        symbolPath.style.text = '';\n\t        graphic.updateProps(symbolPath, {\n\t            scale: [0, 0]\n\t        }, this._seriesModel, this.dataIndex, cb);\n\t    };\n\t\n\t    zrUtil.inherits(Symbol, graphic.Group);\n\t\n\t    module.exports = Symbol;\n\n\n/***/ },\n/* 50 */\n/*!*******************************************!*\\\n  !*** ./lib/component/axis/AxisBuilder.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var formatUtil = __webpack_require__(/*! ../../util/format */ 9);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var Model = __webpack_require__(/*! ../../model/Model */ 10);\n\t    var numberUtil = __webpack_require__(/*! ../../util/number */ 4);\n\t    var remRadian = numberUtil.remRadian;\n\t    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n\t    var vec2 = __webpack_require__(/*! zrender/lib/core/vector */ 5);\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var retrieve = zrUtil.retrieve;\n\t\n\t    var PI = Math.PI;\n\t\n\t    function makeAxisEventDataBase(axisModel) {\n\t        var eventData = {\n\t            componentType: axisModel.mainType\n\t        };\n\t        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n\t        return eventData;\n\t    }\n\t\n\t    /**\n\t     * A final axis is translated and rotated from a \"standard axis\".\n\t     * So opt.position and opt.rotation is required.\n\t     *\n\t     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n\t     * for example: (0, 0) ------------> (0, 50)\n\t     *\n\t     * nameDirection or tickDirection or labelDirection is 1 means tick\n\t     * or label is below the standard axis, whereas is -1 means above\n\t     * the standard axis. labelOffset means offset between label and axis,\n\t     * which is useful when 'onZero', where axisLabel is in the grid and\n\t     * label in outside grid.\n\t     *\n\t     * Tips: like always,\n\t     * positive rotation represents anticlockwise, and negative rotation\n\t     * represents clockwise.\n\t     * The direction of position coordinate is the same as the direction\n\t     * of screen coordinate.\n\t     *\n\t     * Do not need to consider axis 'inverse', which is auto processed by\n\t     * axis extent.\n\t     *\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {Object} axisModel\n\t     * @param {Object} opt Standard axis parameters.\n\t     * @param {Array.<number>} opt.position [x, y]\n\t     * @param {number} opt.rotation by radian\n\t     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n\t     * @param {number} [opt.tickDirection=1] 1 or -1\n\t     * @param {number} [opt.labelDirection=1] 1 or -1\n\t     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n\t     * @param {string} [opt.axisLabelShow] default get from axisModel.\n\t     * @param {string} [opt.axisName] default get from axisModel.\n\t     * @param {number} [opt.axisNameAvailableWidth]\n\t     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n\t     * @param {number} [opt.labelInterval] Default label interval when label\n\t     *                                     interval from model is null or 'auto'.\n\t     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n\t     */\n\t    var AxisBuilder = function (axisModel, opt) {\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.opt = opt;\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.axisModel = axisModel;\n\t\n\t        // Default value\n\t        zrUtil.defaults(\n\t            opt,\n\t            {\n\t                labelOffset: 0,\n\t                nameDirection: 1,\n\t                tickDirection: 1,\n\t                labelDirection: 1,\n\t                silent: true\n\t            }\n\t        );\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.group = new graphic.Group();\n\t\n\t        // FIXME Not use a seperate text group?\n\t        var dumbGroup = new graphic.Group({\n\t            position: opt.position.slice(),\n\t            rotation: opt.rotation\n\t        });\n\t\n\t        // this.group.add(dumbGroup);\n\t        // this._dumbGroup = dumbGroup;\n\t\n\t        dumbGroup.updateTransform();\n\t        this._transform = dumbGroup.transform;\n\t\n\t        this._dumbGroup = dumbGroup;\n\t    };\n\t\n\t    AxisBuilder.prototype = {\n\t\n\t        constructor: AxisBuilder,\n\t\n\t        hasBuilder: function (name) {\n\t            return !!builders[name];\n\t        },\n\t\n\t        add: function (name) {\n\t            builders[name].call(this);\n\t        },\n\t\n\t        getGroup: function () {\n\t            return this.group;\n\t        }\n\t\n\t    };\n\t\n\t    var builders = {\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        axisLine: function () {\n\t            var opt = this.opt;\n\t            var axisModel = this.axisModel;\n\t\n\t            if (!axisModel.get('axisLine.show')) {\n\t                return;\n\t            }\n\t\n\t            var extent = this.axisModel.axis.getExtent();\n\t\n\t            var matrix = this._transform;\n\t            var pt1 = [extent[0], 0];\n\t            var pt2 = [extent[1], 0];\n\t            if (matrix) {\n\t                v2ApplyTransform(pt1, pt1, matrix);\n\t                v2ApplyTransform(pt2, pt2, matrix);\n\t            }\n\t\n\t            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t\n\t                // Id for animation\n\t                anid: 'line',\n\t\n\t                shape: {\n\t                    x1: pt1[0],\n\t                    y1: pt1[1],\n\t                    x2: pt2[0],\n\t                    y2: pt2[1]\n\t                },\n\t                style: zrUtil.extend(\n\t                    {lineCap: 'round'},\n\t                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n\t                ),\n\t                strokeContainThreshold: opt.strokeContainThreshold || 5,\n\t                silent: true,\n\t                z2: 1\n\t            })));\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        axisTick: function () {\n\t            var axisModel = this.axisModel;\n\t\n\t            if (!axisModel.get('axisTick.show')) {\n\t                return;\n\t            }\n\t\n\t            var axis = axisModel.axis;\n\t            var tickModel = axisModel.getModel('axisTick');\n\t            var opt = this.opt;\n\t\n\t            var lineStyleModel = tickModel.getModel('lineStyle');\n\t            var tickLen = tickModel.get('length');\n\t\n\t            var tickInterval = getInterval(tickModel, opt.labelInterval);\n\t            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n\t            var ticks = axis.scale.getTicks();\n\t\n\t            var pt1 = [];\n\t            var pt2 = [];\n\t            var matrix = this._transform;\n\t\n\t            for (var i = 0; i < ticksCoords.length; i++) {\n\t                // Only ordinal scale support tick interval\n\t                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n\t                     continue;\n\t                }\n\t\n\t                var tickCoord = ticksCoords[i];\n\t\n\t                pt1[0] = tickCoord;\n\t                pt1[1] = 0;\n\t                pt2[0] = tickCoord;\n\t                pt2[1] = opt.tickDirection * tickLen;\n\t\n\t                if (matrix) {\n\t                    v2ApplyTransform(pt1, pt1, matrix);\n\t                    v2ApplyTransform(pt2, pt2, matrix);\n\t                }\n\t                // Tick line, Not use group transform to have better line draw\n\t                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t\n\t                    // Id for animation\n\t                    anid: 'tick_' + ticks[i],\n\t\n\t                    shape: {\n\t                        x1: pt1[0],\n\t                        y1: pt1[1],\n\t                        x2: pt2[0],\n\t                        y2: pt2[1]\n\t                    },\n\t                    style: zrUtil.defaults(\n\t                        lineStyleModel.getLineStyle(),\n\t                        {\n\t                            stroke: axisModel.get('axisLine.lineStyle.color')\n\t                        }\n\t                    ),\n\t                    z2: 2,\n\t                    silent: true\n\t                })));\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n\t         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t         * @private\n\t         */\n\t        axisLabel: function () {\n\t            var opt = this.opt;\n\t            var axisModel = this.axisModel;\n\t            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\t\n\t            if (!show) {\n\t                return;\n\t            }\n\t\n\t            var axis = axisModel.axis;\n\t            var labelModel = axisModel.getModel('axisLabel');\n\t            var textStyleModel = labelModel.getModel('textStyle');\n\t            var labelMargin = labelModel.get('margin');\n\t            var ticks = axis.scale.getTicks();\n\t            var labels = axisModel.getFormattedLabels();\n\t\n\t            // Special label rotate.\n\t            var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n\t            // To radian.\n\t            labelRotation = labelRotation * PI / 180;\n\t\n\t            var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n\t            var categoryData = axisModel.get('data');\n\t\n\t            var textEls = [];\n\t            var silent = isSilent(axisModel);\n\t            var triggerEvent = axisModel.get('triggerEvent');\n\t\n\t            for (var i = 0; i < ticks.length; i++) {\n\t                if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {\n\t                     continue;\n\t                }\n\t\n\t                var itemTextStyleModel = textStyleModel;\n\t                if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n\t                    itemTextStyleModel = new Model(\n\t                        categoryData[i].textStyle, textStyleModel, axisModel.ecModel\n\t                    );\n\t                }\n\t                var textColor = itemTextStyleModel.getTextColor()\n\t                    || axisModel.get('axisLine.lineStyle.color');\n\t\n\t                var tickCoord = axis.dataToCoord(ticks[i]);\n\t                var pos = [\n\t                    tickCoord,\n\t                    opt.labelOffset + opt.labelDirection * labelMargin\n\t                ];\n\t                var labelBeforeFormat = axis.scale.getLabel(ticks[i]);\n\t\n\t                var textEl = new graphic.Text({\n\t\n\t                    // Id for animation\n\t                    anid: 'label_' + ticks[i],\n\t\n\t                    style: {\n\t                        text: labels[i],\n\t                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n\t                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n\t                        textFont: itemTextStyleModel.getFont(),\n\t                        fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n\t                    },\n\t                    position: pos,\n\t                    rotation: labelLayout.rotation,\n\t                    silent: silent,\n\t                    z2: 10\n\t                });\n\t\n\t                // Pack data for mouse event\n\t                if (triggerEvent) {\n\t                    textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                    textEl.eventData.targetType = 'axisLabel';\n\t                    textEl.eventData.value = labelBeforeFormat;\n\t                }\n\t\n\t\n\t                // FIXME\n\t                this._dumbGroup.add(textEl);\n\t                textEl.updateTransform();\n\t\n\t                textEls.push(textEl);\n\t                this.group.add(textEl);\n\t\n\t                textEl.decomposeTransform();\n\t            }\n\t\n\t            function isTwoLabelOverlapped(current, next) {\n\t                var firstRect = current && current.getBoundingRect().clone();\n\t                var nextRect = next && next.getBoundingRect().clone();\n\t                if (firstRect && nextRect) {\n\t                    firstRect.applyTransform(current.getLocalTransform());\n\t                    nextRect.applyTransform(next.getLocalTransform());\n\t                    return firstRect.intersect(nextRect);\n\t                }\n\t            }\n\t            if (axis.type !== 'category') {\n\t                // If min or max are user set, we need to check\n\t                // If the tick on min(max) are overlap on their neighbour tick\n\t                // If they are overlapped, we need to hide the min(max) tick label\n\t                if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {\n\t                    var firstLabel = textEls[0];\n\t                    var nextLabel = textEls[1];\n\t                    if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n\t                        firstLabel.ignore = true;\n\t                    }\n\t                }\n\t                if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {\n\t                    var lastLabel = textEls[textEls.length - 1];\n\t                    var prevLabel = textEls[textEls.length - 2];\n\t                    if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n\t                        lastLabel.ignore = true;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        axisName: function () {\n\t            var opt = this.opt;\n\t            var axisModel = this.axisModel;\n\t            var name = retrieve(opt.axisName, axisModel.get('name'));\n\t\n\t            if (!name) {\n\t                return;\n\t            }\n\t\n\t            var nameLocation = axisModel.get('nameLocation');\n\t            var nameDirection = opt.nameDirection;\n\t            var textStyleModel = axisModel.getModel('nameTextStyle');\n\t            var gap = axisModel.get('nameGap') || 0;\n\t\n\t            var extent = this.axisModel.axis.getExtent();\n\t            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n\t            var pos = [\n\t                nameLocation === 'start'\n\t                    ? extent[0] - gapSignal * gap\n\t                    : nameLocation === 'end'\n\t                    ? extent[1] + gapSignal * gap\n\t                    : (extent[0] + extent[1]) / 2, // 'middle'\n\t                // Reuse labelOffset.\n\t                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n\t            ];\n\t\n\t            var labelLayout;\n\t\n\t            var nameRotation = axisModel.get('nameRotate');\n\t            if (nameRotation != null) {\n\t                nameRotation = nameRotation * PI / 180; // To radian.\n\t            }\n\t\n\t            var axisNameAvailableWidth;\n\t\n\t            if (nameLocation === 'middle') {\n\t                labelLayout = innerTextLayout(\n\t                    opt,\n\t                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n\t                    nameDirection\n\t                );\n\t            }\n\t            else {\n\t                labelLayout = endTextLayout(\n\t                    opt, nameLocation, nameRotation || 0, extent\n\t                );\n\t\n\t                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\t                if (axisNameAvailableWidth != null) {\n\t                    axisNameAvailableWidth = Math.abs(\n\t                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n\t                    );\n\t                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n\t                }\n\t            }\n\t\n\t            var textFont = textStyleModel.getFont();\n\t\n\t            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n\t            var ellipsis = truncateOpt.ellipsis;\n\t            var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n\t            var truncatedText = (ellipsis != null && maxWidth != null)\n\t                ? formatUtil.truncateText(\n\t                    name, maxWidth, textFont, ellipsis,\n\t                    {minChar: 2, placeholder: truncateOpt.placeholder}\n\t                )\n\t                : name;\n\t\n\t            var tooltipOpt = axisModel.get('tooltip', true);\n\t\n\t            var mainType = axisModel.mainType;\n\t            var formatterParams = {\n\t                componentType: mainType,\n\t                name: name,\n\t                $vars: ['name']\n\t            };\n\t            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\t\n\t            var textEl = new graphic.Text({\n\t\n\t                // Id for animation\n\t                anid: 'name',\n\t\n\t                __fullText: name,\n\t                __truncatedText: truncatedText,\n\t\n\t                style: {\n\t                    text: truncatedText,\n\t                    textFont: textFont,\n\t                    fill: textStyleModel.getTextColor()\n\t                        || axisModel.get('axisLine.lineStyle.color'),\n\t                    textAlign: labelLayout.textAlign,\n\t                    textVerticalAlign: labelLayout.verticalAlign\n\t                },\n\t                position: pos,\n\t                rotation: labelLayout.rotation,\n\t                silent: isSilent(axisModel),\n\t                z2: 1,\n\t                tooltip: (tooltipOpt && tooltipOpt.show)\n\t                    ? zrUtil.extend({\n\t                        content: name,\n\t                        formatter: function () {\n\t                            return name;\n\t                        },\n\t                        formatterParams: formatterParams\n\t                    }, tooltipOpt)\n\t                    : null\n\t            });\n\t\n\t            if (axisModel.get('triggerEvent')) {\n\t                textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                textEl.eventData.targetType = 'axisName';\n\t                textEl.eventData.name = name;\n\t            }\n\t\n\t            // FIXME\n\t            this._dumbGroup.add(textEl);\n\t            textEl.updateTransform();\n\t\n\t            this.group.add(textEl);\n\t\n\t            textEl.decomposeTransform();\n\t        }\n\t\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function innerTextLayout(opt, textRotation, direction) {\n\t        var rotationDiff = remRadian(textRotation - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t\n\t        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        }\n\t        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        }\n\t        else {\n\t            verticalAlign = 'middle';\n\t\n\t            if (rotationDiff > 0 && rotationDiff < PI) {\n\t                textAlign = direction > 0 ? 'right' : 'left';\n\t            }\n\t            else {\n\t                textAlign = direction > 0 ? 'left' : 'right';\n\t            }\n\t        }\n\t\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function endTextLayout(opt, textPosition, textRotate, extent) {\n\t        var rotationDiff = remRadian(textRotate - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t        var inverse = extent[0] > extent[1];\n\t        var onLeft = (textPosition === 'start' && !inverse)\n\t            || (textPosition !== 'start' && inverse);\n\t\n\t        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n\t            verticalAlign = onLeft ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        }\n\t        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n\t            verticalAlign = onLeft ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        }\n\t        else {\n\t            verticalAlign = 'middle';\n\t            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n\t                textAlign = onLeft ? 'left' : 'right';\n\t            }\n\t            else {\n\t                textAlign = onLeft ? 'right' : 'left';\n\t            }\n\t        }\n\t\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function isSilent(axisModel) {\n\t        var tooltipOpt = axisModel.get('tooltip');\n\t        return axisModel.get('silent')\n\t            // Consider mouse cursor, add these restrictions.\n\t            || !(\n\t                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n\t            );\n\t    }\n\t\n\t    /**\n\t     * @static\n\t     */\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n\t        var rawTick;\n\t        var scale = axis.scale;\n\t        return scale.type === 'ordinal'\n\t            && (\n\t                typeof interval === 'function'\n\t                    ? (\n\t                        rawTick = scale.getTicks()[i],\n\t                        !interval(rawTick, scale.getLabel(rawTick))\n\t                    )\n\t                    : i % (interval + 1)\n\t            );\n\t    };\n\t\n\t    /**\n\t     * @static\n\t     */\n\t    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n\t        var interval = model.get('interval');\n\t        if (interval == null || interval == 'auto') {\n\t            interval = labelInterval;\n\t        }\n\t        return interval;\n\t    };\n\t\n\t    module.exports = AxisBuilder;\n\t\n\n\n/***/ },\n/* 51 */\n/*!*******************************************!*\\\n  !*** ./lib/coord/axisModelCommonMixin.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var axisHelper = __webpack_require__(/*! ./axisHelper */ 22);\n\t\n\t    function getName(obj) {\n\t        if (zrUtil.isObject(obj) && obj.value != null) {\n\t            return obj.value;\n\t        }\n\t        else {\n\t            return obj;\n\t        }\n\t    }\n\t    /**\n\t     * Get categories\n\t     */\n\t    function getCategories() {\n\t        return this.get('type') === 'category'\n\t            && zrUtil.map(this.get('data'), getName);\n\t    }\n\t\n\t    /**\n\t     * Format labels\n\t     * @return {Array.<string>}\n\t     */\n\t    function getFormattedLabels() {\n\t        return axisHelper.getFormattedLabels(\n\t            this.axis,\n\t            this.get('axisLabel.formatter')\n\t        );\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        getFormattedLabels: getFormattedLabels,\n\t\n\t        getCategories: getCategories\n\t    };\n\n\n/***/ },\n/* 52 */\n/*!***************************************!*\\\n  !*** ./lib/coord/axisModelCreator.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var axisDefault = __webpack_require__(/*! ./axisDefault */ 81);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var ComponentModel = __webpack_require__(/*! ../model/Component */ 12);\n\t    var layout = __webpack_require__(/*! ../util/layout */ 13);\n\t\n\t    // FIXME axisType is fixed ?\n\t    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\t\n\t    /**\n\t     * Generate sub axis model class\n\t     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n\t     * @param {module:echarts/model/Component} BaseAxisModelClass\n\t     * @param {Function} axisTypeDefaulter\n\t     * @param {Object} [extraDefaultOption]\n\t     */\n\t    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\t\n\t        zrUtil.each(AXIS_TYPES, function (axisType) {\n\t\n\t            BaseAxisModelClass.extend({\n\t\n\t                type: axisName + 'Axis.' + axisType,\n\t\n\t                mergeDefaultAndTheme: function (option, ecModel) {\n\t                    var layoutMode = this.layoutMode;\n\t                    var inputPositionParams = layoutMode\n\t                        ? layout.getLayoutParams(option) : {};\n\t\n\t                    var themeModel = ecModel.getTheme();\n\t                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n\t                    zrUtil.merge(option, this.getDefaultOption());\n\t\n\t                    option.type = axisTypeDefaulter(axisName, option);\n\t\n\t                    if (layoutMode) {\n\t                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t                    }\n\t                },\n\t\n\t                defaultOption: zrUtil.mergeAll(\n\t                    [\n\t                        {},\n\t                        axisDefault[axisType + 'Axis'],\n\t                        extraDefaultOption\n\t                    ],\n\t                    true\n\t                )\n\t            });\n\t        });\n\t\n\t        ComponentModel.registerSubTypeDefaulter(\n\t            axisName + 'Axis',\n\t            zrUtil.curry(axisTypeDefaulter, axisName)\n\t        );\n\t    };\n\n\n/***/ },\n/* 53 */\n/*!******************************************!*\\\n  !*** ./lib/coord/cartesian/AxisModel.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var ComponentModel = __webpack_require__(/*! ../../model/Component */ 12);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var axisModelCreator = __webpack_require__(/*! ../axisModelCreator */ 52);\n\t\n\t    var AxisModel = ComponentModel.extend({\n\t\n\t        type: 'cartesian2dAxis',\n\t\n\t        /**\n\t         * @type {module:echarts/coord/cartesian/Axis2D}\n\t         */\n\t        axis: null,\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        init: function () {\n\t            AxisModel.superApply(this, 'init', arguments);\n\t            this.resetRange();\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        mergeOption: function () {\n\t            AxisModel.superApply(this, 'mergeOption', arguments);\n\t            this.resetRange();\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        restoreData: function () {\n\t            AxisModel.superApply(this, 'restoreData', arguments);\n\t            this.resetRange();\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/model/Model}\n\t         */\n\t        findGridModel: function () {\n\t            return this.ecModel.queryComponents({\n\t                mainType: 'grid',\n\t                index: this.get('gridIndex'),\n\t                id: this.get('gridId')\n\t            })[0];\n\t        }\n\t\n\t    });\n\t\n\t    function getAxisType(axisDim, option) {\n\t        // Default axis with data is category axis\n\t        return option.type || (option.data ? 'category' : 'value');\n\t    }\n\t\n\t    zrUtil.merge(AxisModel.prototype, __webpack_require__(/*! ../axisModelCommonMixin */ 51));\n\t    zrUtil.merge(AxisModel.prototype, __webpack_require__(/*! ../axisModelZoomMixin */ 82));\n\t\n\t    var extraOption = {\n\t        // gridIndex: 0,\n\t        // gridId: '',\n\t\n\t        // Offset is for multiple axis on the same position\n\t        offset: 0\n\t    };\n\t\n\t    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n\t    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\t\n\t    module.exports = AxisModel;\n\n\n/***/ },\n/* 54 */\n/*!*************************************!*\\\n  !*** ./lib/coord/cartesian/Grid.js ***!\n  \\*************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Grid is a region which contains at most 4 cartesian systems\n\t *\n\t * TODO Default cartesian\n\t */\n\tvar factory = exports;\n\t\n\t    var layout = __webpack_require__(/*! ../../util/layout */ 13);\n\t    var axisHelper = __webpack_require__(/*! ../../coord/axisHelper */ 22);\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var Cartesian2D = __webpack_require__(/*! ./Cartesian2D */ 119);\n\t    var Axis2D = __webpack_require__(/*! ./Axis2D */ 117);\n\t\n\t    var each = zrUtil.each;\n\t\n\t    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n\t    var niceScaleExtent = axisHelper.niceScaleExtent;\n\t\n\t    //  GridModel, AxisModel \n\t    __webpack_require__(/*! ./GridModel */ 120);\n\t\n\t    /**\n\t     * Check if the axis is used in the specified grid\n\t     * @inner\n\t     */\n\t    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n\t        return axisModel.findGridModel() === gridModel;\n\t    }\n\t\n\t    function getLabelUnionRect(axis) {\n\t        var axisModel = axis.model;\n\t        var labels = axisModel.getFormattedLabels();\n\t        var rect;\n\t        var step = 1;\n\t        var labelCount = labels.length;\n\t        if (labelCount > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.ceil(labelCount / 40);\n\t        }\n\t        for (var i = 0; i < labelCount; i += step) {\n\t            if (!axis.isLabelIgnored(i)) {\n\t                var singleRect = axisModel.getTextRect(labels[i]);\n\t                // FIXME consider label rotate\n\t                rect ? rect.union(singleRect) : (rect = singleRect);\n\t            }\n\t        }\n\t        return rect;\n\t    }\n\t\n\t    function Grid(gridModel, ecModel, api) {\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n\t         * @private\n\t         */\n\t        this._coordsMap = {};\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n\t         * @private\n\t         */\n\t        this._coordsList = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesMap = {};\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesList = [];\n\t\n\t        this._initCartesian(gridModel, ecModel, api);\n\t\n\t        this._model = gridModel;\n\t    }\n\t\n\t    var gridProto = Grid.prototype;\n\t\n\t    gridProto.type = 'grid';\n\t\n\t    gridProto.getRect = function () {\n\t        return this._rect;\n\t    };\n\t\n\t    gridProto.update = function (ecModel, api) {\n\t\n\t        var axesMap = this._axesMap;\n\t\n\t        this._updateScale(ecModel, this._model);\n\t\n\t        function ifAxisCanNotOnZero(otherAxisDim) {\n\t            var axes = axesMap[otherAxisDim];\n\t            for (var idx in axes) {\n\t                if (axes.hasOwnProperty(idx)) {\n\t                    var axis = axes[idx];\n\t                    if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n\t                        return true;\n\t                    }\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t\n\t        each(axesMap.x, function (xAxis) {\n\t            niceScaleExtent(xAxis, xAxis.model);\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            niceScaleExtent(yAxis, yAxis.model);\n\t        });\n\t        // Fix configuration\n\t        each(axesMap.x, function (xAxis) {\n\t            // onZero can not be enabled in these two situations\n\t            // 1. When any other axis is a category axis\n\t            // 2. When any other axis not across 0 point\n\t            if (ifAxisCanNotOnZero('y')) {\n\t                xAxis.onZero = false;\n\t            }\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            if (ifAxisCanNotOnZero('x')) {\n\t                yAxis.onZero = false;\n\t            }\n\t        });\n\t\n\t        // Resize again if containLabel is enabled\n\t        // FIXME It may cause getting wrong grid size in data processing stage\n\t        this.resize(this._model, api);\n\t    };\n\t\n\t    /**\n\t     * Resize the grid\n\t     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    gridProto.resize = function (gridModel, api) {\n\t\n\t        var gridRect = layout.getLayoutRect(\n\t            gridModel.getBoxLayoutParams(), {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t\n\t        this._rect = gridRect;\n\t\n\t        var axesList = this._axesList;\n\t\n\t        adjustAxes();\n\t\n\t        // Minus label size\n\t        if (gridModel.get('containLabel')) {\n\t            each(axesList, function (axis) {\n\t                if (!axis.model.get('axisLabel.inside')) {\n\t                    var labelUnionRect = getLabelUnionRect(axis);\n\t                    if (labelUnionRect) {\n\t                        var dim = axis.isHorizontal() ? 'height' : 'width';\n\t                        var margin = axis.model.get('axisLabel.margin');\n\t                        gridRect[dim] -= labelUnionRect[dim] + margin;\n\t                        if (axis.position === 'top') {\n\t                            gridRect.y += labelUnionRect.height + margin;\n\t                        }\n\t                        else if (axis.position === 'left')  {\n\t                            gridRect.x += labelUnionRect.width + margin;\n\t                        }\n\t                    }\n\t                }\n\t            });\n\t\n\t            adjustAxes();\n\t        }\n\t\n\t        function adjustAxes() {\n\t            each(axesList, function (axis) {\n\t                var isHorizontal = axis.isHorizontal();\n\t                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n\t                var idx = axis.inverse ? 1 : 0;\n\t                axis.setExtent(extent[idx], extent[1 - idx]);\n\t                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {string} axisType\n\t     * @param {ndumber} [axisIndex]\n\t     */\n\t    gridProto.getAxis = function (axisType, axisIndex) {\n\t        var axesMapOnDim = this._axesMap[axisType];\n\t        if (axesMapOnDim != null) {\n\t            if (axisIndex == null) {\n\t                // Find first axis\n\t                for (var name in axesMapOnDim) {\n\t                    if (axesMapOnDim.hasOwnProperty(name)) {\n\t                        return axesMapOnDim[name];\n\t                    }\n\t                }\n\t            }\n\t            return axesMapOnDim[axisIndex];\n\t        }\n\t    };\n\t\n\t    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n\t        if (xAxisIndex != null && yAxisIndex != null) {\n\t            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t            return this._coordsMap[key];\n\t        }\n\t        else {\n\t            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\t            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n\t                if (coordList[i].getAxis('x').index === xAxisIndex\n\t                    || coordList[i].getAxis('y').index === yAxisIndex\n\t                ) {\n\t                    return coordList[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @implements\n\t     * see {module:echarts/CoodinateSystem}\n\t     */\n\t    gridProto.convertToPixel = function (ecModel, finder, value) {\n\t        var target = this._findConvertTarget(ecModel, finder);\n\t\n\t        return target.cartesian\n\t            ? target.cartesian.dataToPoint(value)\n\t            : target.axis\n\t            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n\t            : null;\n\t    };\n\t\n\t    /**\n\t     * @implements\n\t     * see {module:echarts/CoodinateSystem}\n\t     */\n\t    gridProto.convertFromPixel = function (ecModel, finder, value) {\n\t        var target = this._findConvertTarget(ecModel, finder);\n\t\n\t        return target.cartesian\n\t            ? target.cartesian.pointToData(value)\n\t            : target.axis\n\t            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n\t            : null;\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    gridProto._findConvertTarget = function (ecModel, finder) {\n\t        var seriesModel = finder.seriesModel;\n\t        var xAxisModel = finder.xAxisModel\n\t            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n\t        var yAxisModel = finder.yAxisModel\n\t            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n\t        var gridModel = finder.gridModel;\n\t        var coordsList = this._coordsList;\n\t        var cartesian;\n\t        var axis;\n\t\n\t        if (seriesModel) {\n\t            cartesian = seriesModel.coordinateSystem;\n\t            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n\t        }\n\t        else if (xAxisModel && yAxisModel) {\n\t            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n\t        }\n\t        else if (xAxisModel) {\n\t            axis = this.getAxis('x', xAxisModel.componentIndex);\n\t        }\n\t        else if (yAxisModel) {\n\t            axis = this.getAxis('y', yAxisModel.componentIndex);\n\t        }\n\t        // Lowest priority.\n\t        else if (gridModel) {\n\t            var grid = gridModel.coordinateSystem;\n\t            if (grid === this) {\n\t                cartesian = this._coordsList[0];\n\t            }\n\t        }\n\t\n\t        return {cartesian: cartesian, axis: axis};\n\t    };\n\t\n\t    /**\n\t     * @implements\n\t     * see {module:echarts/CoodinateSystem}\n\t     */\n\t    gridProto.containPoint = function (point) {\n\t        var coord = this._coordsList[0];\n\t        if (coord) {\n\t            return coord.containPoint(point);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Initialize cartesian coordinate systems\n\t     * @private\n\t     */\n\t    gridProto._initCartesian = function (gridModel, ecModel, api) {\n\t        var axisPositionUsed = {\n\t            left: false,\n\t            right: false,\n\t            top: false,\n\t            bottom: false\n\t        };\n\t\n\t        var axesMap = {\n\t            x: {},\n\t            y: {}\n\t        };\n\t        var axesCount = {\n\t            x: 0,\n\t            y: 0\n\t        };\n\t\n\t        /// Create axis\n\t        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n\t        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\t\n\t        if (!axesCount.x || !axesCount.y) {\n\t            // Roll back when there no either x or y axis\n\t            this._axesMap = {};\n\t            this._axesList = [];\n\t            return;\n\t        }\n\t\n\t        this._axesMap = axesMap;\n\t\n\t        /// Create cartesian2d\n\t        each(axesMap.x, function (xAxis, xAxisIndex) {\n\t            each(axesMap.y, function (yAxis, yAxisIndex) {\n\t                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t                var cartesian = new Cartesian2D(key);\n\t\n\t                cartesian.grid = this;\n\t\n\t                this._coordsMap[key] = cartesian;\n\t                this._coordsList.push(cartesian);\n\t\n\t                cartesian.addAxis(xAxis);\n\t                cartesian.addAxis(yAxis);\n\t            }, this);\n\t        }, this);\n\t\n\t        function createAxisCreator(axisType) {\n\t            return function (axisModel, idx) {\n\t                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n\t                    return;\n\t                }\n\t\n\t                var axisPosition = axisModel.get('position');\n\t                if (axisType === 'x') {\n\t                    // Fix position\n\t                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n\t                        // Default bottom of X\n\t                        axisPosition = 'bottom';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    // Fix position\n\t                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n\t                        // Default left of Y\n\t                        axisPosition = 'left';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n\t                        }\n\t                    }\n\t                }\n\t                axisPositionUsed[axisPosition] = true;\n\t\n\t                var axis = new Axis2D(\n\t                    axisType, axisHelper.createScaleByModel(axisModel),\n\t                    [0, 0],\n\t                    axisModel.get('type'),\n\t                    axisPosition\n\t                );\n\t\n\t                var isCategory = axis.type === 'category';\n\t                axis.onBand = isCategory && axisModel.get('boundaryGap');\n\t                axis.inverse = axisModel.get('inverse');\n\t\n\t                axis.onZero = axisModel.get('axisLine.onZero');\n\t\n\t                // Inject axis into axisModel\n\t                axisModel.axis = axis;\n\t\n\t                // Inject axisModel into axis\n\t                axis.model = axisModel;\n\t\n\t                // Inject grid info axis\n\t                axis.grid = this;\n\t\n\t                // Index of axis, can be used as key\n\t                axis.index = idx;\n\t\n\t                this._axesList.push(axis);\n\t\n\t                axesMap[axisType][idx] = axis;\n\t                axesCount[axisType]++;\n\t            };\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Update cartesian properties from series\n\t     * @param  {module:echarts/model/Option} option\n\t     * @private\n\t     */\n\t    gridProto._updateScale = function (ecModel, gridModel) {\n\t        // Reset scale\n\t        zrUtil.each(this._axesList, function (axis) {\n\t            axis.scale.setExtent(Infinity, -Infinity);\n\t        });\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (isCartesian2D(seriesModel)) {\n\t                var axesModels = findAxesModels(seriesModel, ecModel);\n\t                var xAxisModel = axesModels[0];\n\t                var yAxisModel = axesModels[1];\n\t\n\t                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n\t                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n\t                 ) {\n\t                    return;\n\t                }\n\t\n\t                var cartesian = this.getCartesian(\n\t                    xAxisModel.componentIndex, yAxisModel.componentIndex\n\t                );\n\t                var data = seriesModel.getData();\n\t                var xAxis = cartesian.getAxis('x');\n\t                var yAxis = cartesian.getAxis('y');\n\t\n\t                if (data.type === 'list') {\n\t                    unionExtent(data, xAxis, seriesModel);\n\t                    unionExtent(data, yAxis, seriesModel);\n\t                }\n\t            }\n\t        }, this);\n\t\n\t        function unionExtent(data, axis, seriesModel) {\n\t            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n\t                axis.scale.unionExtent(data.getDataExtent(\n\t                    dim, axis.scale.type !== 'ordinal'\n\t                ));\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function updateAxisTransfrom(axis, coordBase) {\n\t        var axisExtent = axis.getExtent();\n\t        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\t\n\t        // Fast transform\n\t        axis.toGlobalCoord = axis.dim === 'x'\n\t            ? function (coord) {\n\t                return coord + coordBase;\n\t            }\n\t            : function (coord) {\n\t                return axisExtentSum - coord + coordBase;\n\t            };\n\t        axis.toLocalCoord = axis.dim === 'x'\n\t            ? function (coord) {\n\t                return coord - coordBase;\n\t            }\n\t            : function (coord) {\n\t                return axisExtentSum - coord + coordBase;\n\t            };\n\t    }\n\t\n\t    var axesTypes = ['xAxis', 'yAxis'];\n\t    /**\n\t     * @inner\n\t     */\n\t    function findAxesModels(seriesModel, ecModel) {\n\t        return zrUtil.map(axesTypes, function (axisType) {\n\t            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\t\n\t            if (false) {\n\t                if (!axisModel) {\n\t                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n\t                        seriesModel.get(axisType + 'Index'),\n\t                        seriesModel.get(axisType + 'Id'),\n\t                        0\n\t                    ) + '\" not found');\n\t                }\n\t            }\n\t            return axisModel;\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function isCartesian2D(seriesModel) {\n\t        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n\t    }\n\t\n\t    Grid.create = function (ecModel, api) {\n\t        var grids = [];\n\t        ecModel.eachComponent('grid', function (gridModel, idx) {\n\t            var grid = new Grid(gridModel, ecModel, api);\n\t            grid.name = 'grid_' + idx;\n\t            grid.resize(gridModel, api);\n\t\n\t            gridModel.coordinateSystem = grid;\n\t\n\t            grids.push(grid);\n\t        });\n\t\n\t        // Inject the coordinateSystems into seriesModel\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (!isCartesian2D(seriesModel)) {\n\t                return;\n\t            }\n\t\n\t            var axesModels = findAxesModels(seriesModel, ecModel);\n\t            var xAxisModel = axesModels[0];\n\t            var yAxisModel = axesModels[1];\n\t\n\t            var gridModel = xAxisModel.findGridModel();\n\t\n\t            if (false) {\n\t                if (!gridModel) {\n\t                    throw new Error(\n\t                        'Grid \"' + zrUtil.retrieve(\n\t                            xAxisModel.get('gridIndex'),\n\t                            xAxisModel.get('gridId'),\n\t                            0\n\t                        ) + '\" not found'\n\t                    );\n\t                }\n\t                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {\n\t                    throw new Error('xAxis and yAxis must use the same grid');\n\t                }\n\t            }\n\t\n\t            var grid = gridModel.coordinateSystem;\n\t\n\t            seriesModel.coordinateSystem = grid.getCartesian(\n\t                xAxisModel.componentIndex, yAxisModel.componentIndex\n\t            );\n\t        });\n\t\n\t        return grids;\n\t    };\n\t\n\t    // For deciding which dimensions to use when creating list data\n\t    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\t\n\t    __webpack_require__(/*! ../../CoordinateSystem */ 23).register('cartesian2d', Grid);\n\t\n\t    module.exports = Grid;\n\n\n/***/ },\n/* 55 */\n/*!******************************!*\\\n  !*** ./lib/layout/points.js ***!\n  \\******************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = function (seriesType, ecModel) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var coordSys = seriesModel.coordinateSystem;\n\t\n\t            if (coordSys) {\n\t                var dims = coordSys.dimensions;\n\t\n\t                if (coordSys.type === 'singleAxis') {\n\t                    data.each(dims[0], function (x, idx) {\n\t                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n\t                        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n\t                    });\n\t                }\n\t                else {\n\t                    data.each(dims, function (x, y, idx) {\n\t                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n\t                        data.setItemLayout(\n\t                            idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y])\n\t                        );\n\t                    }, true);\n\t                }\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n/* 56 */\n/*!*****************************************!*\\\n  !*** ./lib/model/mixin/colorPalette.js ***!\n  \\*****************************************/\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = {\n\t        clearColorPalette: function () {\n\t            this._colorIdx = 0;\n\t            this._colorNameMap = {};\n\t        },\n\t\n\t        getColorFromPalette: function (name, scope) {\n\t            scope = scope || this;\n\t            var colorIdx = scope._colorIdx || 0;\n\t            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});\n\t            if (colorNameMap[name]) {\n\t                return colorNameMap[name];\n\t            }\n\t            var colorPalette = this.get('color', true) || [];\n\t            if (!colorPalette.length) {\n\t                return;\n\t            }\n\t\n\t            var color = colorPalette[colorIdx];\n\t            if (name) {\n\t                colorNameMap[name] = color;\n\t            }\n\t            scope._colorIdx = (colorIdx + 1) % colorPalette.length;\n\t\n\t            return color;\n\t        }\n\t    };\n\n\n/***/ },\n/* 57 */\n/*!*******************************!*\\\n  !*** ./lib/view/Component.js ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Group = __webpack_require__(/*! zrender/lib/container/Group */ 34);\n\t    var componentUtil = __webpack_require__(/*! ../util/component */ 43);\n\t    var clazzUtil = __webpack_require__(/*! ../util/clazz */ 21);\n\t\n\t    var Component = function () {\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewComponent');\n\t    };\n\t\n\t    Component.prototype = {\n\t\n\t        constructor: Component,\n\t\n\t        init: function (ecModel, api) {},\n\t\n\t        render: function (componentModel, ecModel, api, payload) {},\n\t\n\t        dispose: function () {}\n\t\n\t    };\n\t\n\t    var componentProto = Component.prototype;\n\t    componentProto.updateView\n\t        = componentProto.updateLayout\n\t        = componentProto.updateVisual\n\t        = function (seriesModel, ecModel, api, payload) {\n\t            // Do nothing;\n\t        };\n\t    // Enable Component.extend.\n\t    clazzUtil.enableClassExtend(Component);\n\t\n\t    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\t\n\t    module.exports = Component;\n\n\n/***/ },\n/* 58 */\n/*!**********************************!*\\\n  !*** ./~/zrender/lib/Element.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/Element\n\t */\n\t\n\t\n\t    var guid = __webpack_require__(/*! ./core/guid */ 62);\n\t    var Eventful = __webpack_require__(/*! ./mixin/Eventful */ 20);\n\t    var Transformable = __webpack_require__(/*! ./mixin/Transformable */ 88);\n\t    var Animatable = __webpack_require__(/*! ./mixin/Animatable */ 166);\n\t    var zrUtil = __webpack_require__(/*! ./core/util */ 1);\n\t\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t\n\t        /**\n\t         * ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t\n\t    Element.prototype = {\n\t\n\t        /**\n\t         * \n\t         * Element type\n\t         * @type {string}\n\t         */\n\t        type: 'element',\n\t\n\t        /**\n\t         * \n\t         * Element name\n\t         * @type {string}\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * ZRender  element  zrender \n\t         * ZRender instance will be assigned when element is associated with zrender\n\t         * @name module:/zrender/Element#__zr\n\t         * @type {module:zrender/ZRender}\n\t         */\n\t        __zr: null,\n\t\n\t        /**\n\t         * true\n\t         * If ignore drawing and events of the element object\n\t         * @name module:/zrender/Element#ignore\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        ignore: false,\n\t\n\t        /**\n\t         * (shape) Group \n\t         * \n\t         * @type {module:zrender/graphic/Path}\n\t         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t         * @readOnly\n\t         */\n\t        clipPath: null,\n\t\n\t        /**\n\t         * Drift element\n\t         * @param  {number} dx dx on the global space\n\t         * @param  {number} dy dy on the global space\n\t         */\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t                case 'horizontal':\n\t                    dy = 0;\n\t                    break;\n\t                case 'vertical':\n\t                    dx = 0;\n\t                    break;\n\t            }\n\t\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [1, 0, 0, 1, 0, 0];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t\n\t            this.decomposeTransform();\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         * Hook before update\n\t         */\n\t        beforeUpdate: function () {},\n\t        /**\n\t         * Hook after update\n\t         */\n\t        afterUpdate: function () {},\n\t        /**\n\t         * Update each frame\n\t         */\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {},\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        attrKV: function (key, value) {\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            }\n\t            else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Hide the element\n\t         */\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * Show the element\n\t         */\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * @param {string|Object} key\n\t         * @param {*} value\n\t         */\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            }\n\t            else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.dirty(false);\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/graphic/Path} clipPath\n\t         */\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         */\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t\n\t                this.dirty(false);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // \n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Remove self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // \n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t\n\t    module.exports = Element;\n\n\n/***/ },\n/* 59 */\n/*!*********************************************!*\\\n  !*** ./~/zrender/lib/animation/Animator.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\t\n\t\n\t    var Clip = __webpack_require__(/*! ./Clip */ 144);\n\t    var color = __webpack_require__(/*! ../tool/color */ 18);\n\t    var util = __webpack_require__(/*! ../core/util */ 1);\n\t    var isArrayLike = util.isArrayLike;\n\t\n\t    var arraySlice = Array.prototype.slice;\n\t\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(\n\t                        p0[i][j], p1[i][j], percent\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    // arr0 is source array, arr1 is target array.\n\t    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len !== arr1Len) {\n\t            // FIXME Not work for TypedArray\n\t            var isPreviousLarger = arr0Len > arr1Len;\n\t            if (isPreviousLarger) {\n\t                // Cut the previous\n\t                arr0.length = arr1Len;\n\t            }\n\t            else {\n\t                // Fill the previous\n\t                for (var i = arr0Len; i < arr1Len; i++) {\n\t                    arr0.push(\n\t                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n\t                    );\n\t                }\n\t            }\n\t        }\n\t        // Handling NaN value\n\t        var len2 = arr0[0] && arr0[0].length;\n\t        for (var i = 0; i < arr0.length; i++) {\n\t            if (arrDim === 1) {\n\t                if (isNaN(arr0[i])) {\n\t                    arr0[i] = arr1[i];\n\t                }\n\t            }\n\t            else {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (isNaN(arr0[i][j])) {\n\t                        arr0[i][j] = arr1[i][j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(\n\t        p0, p1, p2, p3, t, t2, t3, out, arrDim\n\t    ) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(\n\t                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n\t                );\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(\n\t                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n\t                        t, t2, t3\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t\n\t            return arraySlice.call(value);\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t\n\t    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t\n\t        // For vertices morphing\n\t        var arrDim = (\n\t                isValueArray\n\t                && isArrayLike(firstVal[0])\n\t            )\n\t            ? 2 : 1;\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function(a, b) {\n\t            return a.time - b.time;\n\t        });\n\t\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t\n\t            // Check if value is equal, deep check if value is array\n\t            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n\t                || (!isValueArray && value === prevValue))) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                }\n\t                else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (isAllValueEqual) {\n\t            return;\n\t        }\n\t\n\t        var lastValue = kfValues[trackLen - 1];\n\t        // Polyfill array and NaN value\n\t        for (var i = 0; i < trackLen - 1; i++) {\n\t            if (isValueArray) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            }\n\t            else {\n\t                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t                    kfValues[i] = lastValue;\n\t                }\n\t            }\n\t        }\n\t        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t\n\t        if (isValueColor) {\n\t            var rgba = [0, 0, 0, 0];\n\t        }\n\t\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            // In the easing function like elasticOut, percent may less than 0\n\t            if (percent < 0) {\n\t                frame = 0;\n\t            }\n\t            else if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                // PENDING start from lastFrame ?\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                // PENDING really need to do this ?\n\t                frame = Math.min(frame, trackLen - 2);\n\t            }\n\t            else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t\n\t            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n\t            if (range === 0) {\n\t                return;\n\t            }\n\t            else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(\n\t                        p0, p1, p2, p3, w, w * w, w * w * w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    }\n\t                    else {\n\t                        value = catmullRomInterpolate(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w\n\t                        );\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t            else {\n\t                if (isValueArray) {\n\t                    interpolateArray(\n\t                        kfValues[frame], kfValues[frame + 1], w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(\n\t                            kfValues[frame], kfValues[frame + 1], w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t        };\n\t\n\t        var clip = new Clip({\n\t            target: animator._target,\n\t            life: trackMaxTime,\n\t            loop: animator._loop,\n\t            delay: animator._delay,\n\t            onframe: onframe,\n\t            ondestroy: oneTrackDone\n\t        });\n\t\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t\n\t        return clip;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function(target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t\n\t        this._loop = loop || false;\n\t\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t\n\t        this._clipCount = 0;\n\t\n\t        this._delay = 0;\n\t\n\t        this._doneList = [];\n\t\n\t        this._onframeList = [];\n\t\n\t        this._clipList = [];\n\t    };\n\t\n\t    Animator.prototype = {\n\t        /**\n\t         * \n\t         * @param  {number} time ms\n\t         * @param  {Object} props key-value\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        when: function(time /* ms */, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!props.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Function} callback\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t\n\t            var doneList = this._doneList;\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        /**\n\t         * \n\t         * @param  {string|Function} easing\n\t         *         {@link module:zrender/animation/easing}\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        start: function (easing) {\n\t\n\t            var self = this;\n\t            var clipCount = 0;\n\t\n\t            var oneTrackDone = function() {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\n\t\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                if (!this._tracks.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t                var clip = createTrackClip(\n\t                    this, easing, oneTrackDone,\n\t                    this._tracks[propName], propName\n\t                );\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {number} time ms\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        done: function(cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/animation/Clip>}\n\t         */\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t\n\t    module.exports = Animator;\n\n\n/***/ },\n/* 60 */\n/*!**********************************************************!*\\\n  !*** ./~/zrender/lib/animation/requestAnimationFrame.js ***!\n  \\**********************************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = (typeof window !== 'undefined' &&\n\t                                    (window.requestAnimationFrame\n\t                                    || window.msRequestAnimationFrame\n\t                                    || window.mozRequestAnimationFrame\n\t                                    || window.webkitRequestAnimationFrame))\n\t                                || function (func) {\n\t                                    setTimeout(func, 16);\n\t                                };\n\t\n\n\n/***/ },\n/* 61 */\n/*!***************************************!*\\\n  !*** ./~/zrender/lib/contain/util.js ***!\n  \\***************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var PI2 = Math.PI * 2;\n\t    module.exports = {\n\t        normalizeRadian: function(angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 62 */\n/*!************************************!*\\\n  !*** ./~/zrender/lib/core/guid.js ***!\n  \\************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * zrender: id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var idStart = 0x0907;\n\t\n\t    module.exports = function () {\n\t        return idStart++;\n\t    };\n\t\n\n\n/***/ },\n/* 63 */\n/*!******************************************!*\\\n  !*** ./~/zrender/lib/graphic/Pattern.js ***!\n  \\******************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var Pattern = function (image, repeat) {\n\t        this.image = image;\n\t        this.repeat = repeat;\n\t\n\t        // Can be cloned\n\t        this.type = 'pattern';\n\t    };\n\t\n\t    Pattern.prototype.getCanvasPattern = function (ctx) {\n\t\n\t        return this._canvasPattern\n\t            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n\t    };\n\t\n\t    module.exports = Pattern;\n\n\n/***/ },\n/* 64 */\n/*!****************************************!*\\\n  !*** ./~/zrender/lib/graphic/Style.js ***!\n  \\****************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/graphic/Style\n\t */\n\t\n\t\n\t    var STYLE_COMMON_PROPS = [\n\t        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n\t        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n\t    ];\n\t\n\t    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t\n\t    var Style = function (opts) {\n\t        this.extendFrom(opts);\n\t    };\n\t\n\t    function createLinearGradient(ctx, obj, rect) {\n\t        // var size =\n\t        var x = obj.x;\n\t        var x2 = obj.x2;\n\t        var y = obj.y;\n\t        var y2 = obj.y2;\n\t\n\t        if (!obj.global) {\n\t            x = x * rect.width + rect.x;\n\t            x2 = x2 * rect.width + rect.x;\n\t            y = y * rect.height + rect.y;\n\t            y2 = y2 * rect.height + rect.y;\n\t        }\n\t\n\t        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t    function createRadialGradient(ctx, obj, rect) {\n\t        var width = rect.width;\n\t        var height = rect.height;\n\t        var min = Math.min(width, height);\n\t\n\t        var x = obj.x;\n\t        var y = obj.y;\n\t        var r = obj.r;\n\t        if (!obj.global) {\n\t            x = x * width + rect.x;\n\t            y = y * height + rect.y;\n\t            r = r * min;\n\t        }\n\t\n\t        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t\n\t    Style.prototype = {\n\t\n\t        constructor: Style,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        fill: '#000000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        stroke: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        opacity: 1,\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         */\n\t        lineDash: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineDashOffset: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowBlur: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetX: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetY: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineWidth: 1,\n\t\n\t        /**\n\t         * If stroke ignore scale\n\t         * @type {Boolean}\n\t         */\n\t        strokeNoScale: false,\n\t\n\t        // Bounding rect text configuration\n\t        // Not affected by element transform\n\t        /**\n\t         * @type {string}\n\t         */\n\t        text: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textFill: '#000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textStroke: null,\n\t\n\t        /**\n\t         * 'inside', 'left', 'right', 'top', 'bottom'\n\t         * [x, y]\n\t         * @type {string|Array.<number>}\n\t         * @default 'inside'\n\t         */\n\t        textPosition: 'inside',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textBaseline: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textAlign: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textVerticalAlign: null,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textDistance: 5,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowBlur: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetX: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetY: 0,\n\t\n\t        /**\n\t         * If transform text\n\t         * Only useful in Path and Image element\n\t         * @type {boolean}\n\t         */\n\t        textTransform: false,\n\t\n\t        /**\n\t         * Text rotate around position of Path or Image\n\t         * Only useful in Path and Image element and textTransform is false.\n\t         */\n\t        textRotation: 0,\n\t\n\t        /**\n\t         * @type {string}\n\t         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t         */\n\t        blend: null,\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         */\n\t        bind: function (ctx, el, prevEl) {\n\t            var style = this;\n\t            var prevStyle = prevEl && prevEl.style;\n\t            var firstDraw = !prevStyle;\n\t\n\t            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t                var prop = STYLE_COMMON_PROPS[i];\n\t                var styleName = prop[0];\n\t\n\t                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t                    // FIXME Invalid property value will cause style leak from previous element.\n\t                    ctx[styleName] = style[styleName] || prop[1];\n\t                }\n\t            }\n\t\n\t            if ((firstDraw || style.fill !== prevStyle.fill)) {\n\t                ctx.fillStyle = style.fill;\n\t            }\n\t            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n\t                ctx.strokeStyle = style.stroke;\n\t            }\n\t            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n\t                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t            }\n\t\n\t            if ((firstDraw || style.blend !== prevStyle.blend)) {\n\t                ctx.globalCompositeOperation = style.blend || 'source-over';\n\t            }\n\t            if (this.hasStroke()) {\n\t                var lineWidth = style.lineWidth;\n\t                ctx.lineWidth = lineWidth / (\n\t                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n\t                );\n\t            }\n\t        },\n\t\n\t        hasFill: function () {\n\t            var fill = this.fill;\n\t            return fill != null && fill !== 'none';\n\t        },\n\t\n\t        hasStroke: function () {\n\t            var stroke = this.stroke;\n\t            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t        },\n\t\n\t        /**\n\t         * Extend from other style\n\t         * @param {zrender/graphic/Style} otherStyle\n\t         * @param {boolean} overwrite\n\t         */\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                var target = this;\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name)\n\t                        && (overwrite || ! target.hasOwnProperty(name))\n\t                    ) {\n\t                        target[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Batch setting style with a given object\n\t         * @param {Object|string} obj\n\t         * @param {*} [obj]\n\t         */\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            }\n\t            else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clone\n\t         * @return {zrender/graphic/Style} [description]\n\t         */\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        },\n\t\n\t        getGradient: function (ctx, obj, rect) {\n\t            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t            var canvasGradient = method(ctx, obj, rect);\n\t            var colorStops = obj.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(\n\t                    colorStops[i].offset, colorStops[i].color\n\t                );\n\t            }\n\t            return canvasGradient;\n\t        }\n\t    };\n\t\n\t    var styleProto = Style.prototype;\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t        var prop = STYLE_COMMON_PROPS[i];\n\t        if (!(prop[0] in styleProto)) {\n\t            styleProto[prop[0]] = prop[1];\n\t        }\n\t    }\n\t\n\t    // Provide for others\n\t    Style.getGradient = styleProto.getGradient;\n\t\n\t    module.exports = Style;\n\n\n/***/ },\n/* 65 */\n/*!**********************************************!*\\\n  !*** ./~/zrender/lib/graphic/helper/poly.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var smoothSpline = __webpack_require__(/*! ./smoothSpline */ 156);\n\t    var smoothBezier = __webpack_require__(/*! ./smoothBezier */ 155);\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(\n\t                        points, smooth, closePath, shape.smoothConstraint\n\t                    );\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(\n\t                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n\t                        );\n\t                    }\n\t                }\n\t                else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\n\n/***/ },\n/* 66 */\n/*!*************************************************!*\\\n  !*** ./lib/component/helper/selectableMixin.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Data selectable mixin for chart series.\n\t * To eanble data select, option of series must have `selectedMode`.\n\t * And each data item will use `selected` to toggle itself selected status\n\t *\n\t * @module echarts/chart/helper/DataSelectable\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    module.exports = {\n\t\n\t        updateSelectedMap: function (targetList) {\n\t            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n\t                targetMap[target.name] = target;\n\t                return targetMap;\n\t            }, {});\n\t        },\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        // PENGING If selectedMode is null ?\n\t        select: function (name) {\n\t            var targetMap = this._selectTargetMap;\n\t            var target = targetMap[name];\n\t            var selectedMode = this.get('selectedMode');\n\t            if (selectedMode === 'single') {\n\t                zrUtil.each(targetMap, function (target) {\n\t                    target.selected = false;\n\t                });\n\t            }\n\t            target && (target.selected = true);\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        unSelect: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            // var selectedMode = this.get('selectedMode');\n\t            // selectedMode !== 'single' && target && (target.selected = false);\n\t            target && (target.selected = false);\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        toggleSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            if (target != null) {\n\t                this[target.selected ? 'unSelect' : 'select'](name);\n\t                return target.selected;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        isSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            return target && target.selected;\n\t        }\n\t    };\n\n\n/***/ },\n/* 67 */,\n/* 68 */,\n/* 69 */,\n/* 70 */\n/*!*************************************!*\\\n  !*** ./lib/processor/dataFilter.js ***!\n  \\*************************************/\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function (seriesType, ecModel) {\n\t        var legendModels = ecModel.findComponents({\n\t            mainType: 'legend'\n\t        });\n\t        if (!legendModels || !legendModels.length) {\n\t            return;\n\t        }\n\t        ecModel.eachSeriesByType(seriesType, function (series) {\n\t            var data = series.getData();\n\t            data.filterSelf(function (idx) {\n\t                var name = data.getName(idx);\n\t                // If in any legend component the status is not selected.\n\t                for (var i = 0; i < legendModels.length; i++) {\n\t                    if (!legendModels[i].isSelected(name)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return true;\n\t            }, this);\n\t        }, this);\n\t    };\n\n\n/***/ },\n/* 71 */,\n/* 72 */\n/*!*********************************!*\\\n  !*** ./lib/visual/dataColor.js ***!\n  \\*********************************/\n/***/ function(module, exports) {\n\n\t// Pick color from palette for each data item\n\t\n\t\n\t    module.exports = function (seriesType, ecModel) {\n\t        // Pie and funnel may use diferrent scope\n\t        var paletteScope = {};\n\t        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n\t            var dataAll = seriesModel.getRawData();\n\t            var idxMap = {};\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                var data = seriesModel.getData();\n\t                data.each(function (idx) {\n\t                    var rawIdx = data.getRawIndex(idx);\n\t                    idxMap[rawIdx] = idx;\n\t                });\n\t                dataAll.each(function (rawIdx) {\n\t                    // FIXME Performance\n\t                    var itemModel = dataAll.getItemModel(rawIdx);\n\t                    var filteredIdx = idxMap[rawIdx];\n\t\n\t                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\t                    var singleDataColor = filteredIdx != null\n\t                        && data.getItemVisual(filteredIdx, 'color', true);\n\t\n\t                    if (!singleDataColor) {\n\t                        var color = itemModel.get('itemStyle.normal.color')\n\t                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n\t                        // Legend may use the visual info in data before processed\n\t                        dataAll.setItemVisual(rawIdx, 'color', color);\n\t\n\t                        // Data is not filtered\n\t                        if (filteredIdx != null) {\n\t                            data.setItemVisual(filteredIdx, 'color', color);\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Set data all color for legend\n\t                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n\t                    }\n\t                });\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n/* 73 */\n/*!************************************!*\\\n  !*** ./~/zrender/lib/core/bbox.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(/*! ./vector */ 5);\n\t    var curve = __webpack_require__(/*! ./curve */ 17);\n\t\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * `min``max`\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points \n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function(points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t\n\t    var xDim = [];\n\t    var yDim = [];\n\t    /**\n\t     * (p0, p1, p2, p3)`min``max`\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function(\n\t        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n\t    ) {\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t        min[0] = Infinity;\n\t        min[1] = Infinity;\n\t        max[0] = -Infinity;\n\t        max[1] = -Infinity;\n\t\n\t        for (i = 0; i < n; i++) {\n\t            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t            min[0] = mathMin(x, min[0]);\n\t            max[0] = mathMax(x, max[0]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t            min[1] = mathMin(y, min[1]);\n\t            max[1] = mathMax(y, max[1]);\n\t        }\n\t\n\t        min[0] = mathMin(x0, min[0]);\n\t        max[0] = mathMax(x0, max[0]);\n\t        min[0] = mathMin(x3, min[0]);\n\t        max[0] = mathMax(x3, max[0]);\n\t\n\t        min[1] = mathMin(y0, min[1]);\n\t        max[1] = mathMax(y0, max[1]);\n\t        min[1] = mathMin(y3, min[1]);\n\t        max[1] = mathMax(y3, max[1]);\n\t    };\n\t\n\t    /**\n\t     * (p0, p1, p2)`min``max`\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n\t            );\n\t        var ty =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n\t            );\n\t\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t\n\t    /**\n\t     * `min``max`\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (\n\t        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n\t    ) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t\n\t\n\t        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % (PI2);\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % (PI2);\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        }\n\t        else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = bbox;\n\t\n\n\n/***/ },\n/* 74 */\n/*!***************************************!*\\\n  !*** ./~/zrender/lib/graphic/Text.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Text element\n\t * @module zrender/graphic/Text\n\t *\n\t * TODO Wrapping\n\t *\n\t * Text not support gradient\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(/*! ./Displayable */ 37);\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t    var textContain = __webpack_require__(/*! ../contain/text */ 16);\n\t\n\t    /**\n\t     * @alias zrender/graphic/Text\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var Text = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t\n\t    Text.prototype = {\n\t\n\t        constructor: Text,\n\t\n\t        type: 'text',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var x = style.x || 0;\n\t            var y = style.y || 0;\n\t            // Convert to string\n\t            var text = style.text;\n\t\n\t            // Convert to string\n\t            text != null && (text += '');\n\t\n\t            // Always bind style\n\t            style.bind(ctx, this, prevEl);\n\t\n\t            if (text) {\n\t\n\t                this.setTransform(ctx);\n\t\n\t                var textBaseline;\n\t                var textAlign = style.textAlign;\n\t                var font = style.textFont || style.font;\n\t                if (style.textVerticalAlign) {\n\t                    var rect = textContain.getBoundingRect(\n\t                        text, font, style.textAlign, 'top'\n\t                    );\n\t                    // Ignore textBaseline\n\t                    textBaseline = 'middle';\n\t                    switch (style.textVerticalAlign) {\n\t                        case 'middle':\n\t                            y -= rect.height / 2 - rect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= rect.height - rect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += rect.lineHeight / 2;\n\t                    }\n\t                }\n\t                else {\n\t                    textBaseline = style.textBaseline;\n\t                }\n\t\n\t                // TODO Invalid font\n\t                ctx.font = font || '12px sans-serif';\n\t                ctx.textAlign = textAlign || 'left';\n\t                // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t                if (ctx.textAlign !== textAlign) {\n\t                    ctx.textAlign = 'left';\n\t                }\n\t                ctx.textBaseline = textBaseline || 'alphabetic';\n\t                // Use canvas default alphabetic baseline\n\t                if (ctx.textBaseline !== textBaseline) {\n\t                    ctx.textBaseline = 'alphabetic';\n\t                }\n\t\n\t                var lineHeight = textContain.measureText('', ctx.font).width;\n\t\n\t                var textLines = text.split('\\n');\n\t                for (var i = 0; i < textLines.length; i++) {\n\t                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n\t                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n\t                    y += lineHeight;\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            if (!this._rect) {\n\t                var style = this.style;\n\t                var textVerticalAlign = style.textVerticalAlign;\n\t                var rect = textContain.getBoundingRect(\n\t                    style.text + '', style.textFont || style.font, style.textAlign,\n\t                    textVerticalAlign ? 'top' : style.textBaseline\n\t                );\n\t                switch (textVerticalAlign) {\n\t                    case 'middle':\n\t                        rect.y -= rect.height / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        rect.y -= rect.height;\n\t                        break;\n\t                }\n\t                rect.x += style.x || 0;\n\t                rect.y += style.y || 0;\n\t                this._rect = rect;\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Text, Displayable);\n\t\n\t    module.exports = Text;\n\n\n/***/ },\n/* 75 */\n/*!*************************************************!*\\\n  !*** ./~/zrender/lib/graphic/mixin/RectText.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\t\n\t\n\t\n\t    var textContain = __webpack_require__(/*! ../../contain/text */ 16);\n\t    var BoundingRect = __webpack_require__(/*! ../../core/BoundingRect */ 8);\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var RectText = function () {};\n\t\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t\n\t    RectText.prototype = {\n\t\n\t        constructor: RectText,\n\t\n\t        /**\n\t         * Draw text in a rect with specified position.\n\t         * @param  {CanvasRenderingContext} ctx\n\t         * @param  {Object} rect Displayable rect\n\t         * @return {Object} textRect Alternative precalculated text bounding rect\n\t         */\n\t        drawRectText: function (ctx, rect, textRect) {\n\t            var style = this.style;\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            if (!text) {\n\t                return;\n\t            }\n\t\n\t            // FIXME\n\t            ctx.save();\n\t\n\t            var x;\n\t            var y;\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            var align = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            var baseline = style.textBaseline;\n\t            var verticalAlign = style.textVerticalAlign;\n\t\n\t            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t\n\t            // Transform rect to view space\n\t            var transform = this.transform;\n\t            if (!style.textTransform) {\n\t                if (transform) {\n\t                    tmpRect.copy(rect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = tmpRect;\n\t                }\n\t            }\n\t            else {\n\t                this.setTransform(ctx);\n\t            }\n\t\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t\n\t                if (verticalAlign) {\n\t                    switch (verticalAlign) {\n\t                        case 'middle':\n\t                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= textRect.height - textRect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += textRect.lineHeight / 2;\n\t                    }\n\t                    // Force bseline to be middle\n\t                    baseline = 'middle';\n\t                }\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t\n\t            // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t            ctx.textAlign = align || 'left';\n\t            // Use canvas default alphabetic baseline\n\t            ctx.textBaseline = baseline || 'alphabetic';\n\t\n\t            var textFill = style.textFill;\n\t            var textStroke = style.textStroke;\n\t            textFill && (ctx.fillStyle = textFill);\n\t            textStroke && (ctx.strokeStyle = textStroke);\n\t\n\t            // TODO Invalid font\n\t            ctx.font = font || '12px sans-serif';\n\t\n\t            // Text shadow\n\t            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n\t            ctx.shadowBlur = style.textShadowBlur;\n\t            ctx.shadowColor = style.textShadowColor || 'transparent';\n\t            ctx.shadowOffsetX = style.textShadowOffsetX;\n\t            ctx.shadowOffsetY = style.textShadowOffsetY;\n\t\n\t            var textLines = text.split('\\n');\n\t\n\t            if (style.textRotation) {\n\t                transform && ctx.translate(transform[4], transform[5]);\n\t                ctx.rotate(style.textRotation);\n\t                transform && ctx.translate(-transform[4], -transform[5]);\n\t            }\n\t\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                textFill && ctx.fillText(textLines[i], x, y);\n\t                textStroke && ctx.strokeText(textLines[i], x, y);\n\t                y += textRect.lineHeight;\n\t            }\n\t\n\t            ctx.restore();\n\t        }\n\t    };\n\t\n\t    module.exports = RectText;\n\n\n/***/ },\n/* 76 */\n/*!**********************************!*\\\n  !*** ./~/zrender/lib/zrender.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * ZRender, a high performance 2d drawing library.\n\t *\n\t * Copyright (c) 2013, Baidu Inc.\n\t * All rights reserved.\n\t *\n\t * LICENSE\n\t * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n\t */\n\t// Global defines\n\t\n\t    var guid = __webpack_require__(/*! ./core/guid */ 62);\n\t    var env = __webpack_require__(/*! ./core/env */ 11);\n\t    var zrUtil = __webpack_require__(/*! ./core/util */ 1);\n\t\n\t    var Handler = __webpack_require__(/*! ./Handler */ 139);\n\t    var Storage = __webpack_require__(/*! ./Storage */ 142);\n\t    var Animation = __webpack_require__(/*! ./animation/Animation */ 143);\n\t    var HandlerProxy = __webpack_require__(/*! ./dom/HandlerProxy */ 151);\n\t\n\t    var useVML = !env.canvasSupported;\n\t\n\t    var painterCtors = {\n\t        canvas: __webpack_require__(/*! ./Painter */ 141)\n\t    };\n\t\n\t    var instances = {};    // ZRendermap\n\t\n\t    var zrender = {};\n\t\n\t    /**\n\t     * @type {string}\n\t     */\n\t    zrender.version = '3.2.2';\n\t\n\t    /**\n\t     * Initializing a zrender instance\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.init = function(dom, opts) {\n\t        var zr = new ZRender(guid(), dom, opts);\n\t        instances[zr.id] = zr;\n\t        return zr;\n\t    };\n\t\n\t    /**\n\t     * Dispose zrender instance\n\t     * @param {module:zrender/ZRender} zr\n\t     */\n\t    zrender.dispose = function (zr) {\n\t        if (zr) {\n\t            zr.dispose();\n\t        }\n\t        else {\n\t            for (var key in instances) {\n\t                if (instances.hasOwnProperty(key)) {\n\t                    instances[key].dispose();\n\t                }\n\t            }\n\t            instances = {};\n\t        }\n\t\n\t        return zrender;\n\t    };\n\t\n\t    /**\n\t     * Get zrender instance by id\n\t     * @param {string} id zrender instance id\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.getInstance = function (id) {\n\t        return instances[id];\n\t    };\n\t\n\t    zrender.registerPainter = function (name, Ctor) {\n\t        painterCtors[name] = Ctor;\n\t    };\n\t\n\t    function delInstance(id) {\n\t        delete instances[id];\n\t    }\n\t\n\t    /**\n\t     * @module zrender/ZRender\n\t     */\n\t    /**\n\t     * @constructor\n\t     * @alias module:zrender/ZRender\n\t     * @param {string} id\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     */\n\t    var ZRender = function(id, dom, opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         */\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id = id;\n\t\n\t        var self = this;\n\t        var storage = new Storage();\n\t\n\t        var rendererType = opts.renderer;\n\t        if (useVML) {\n\t            if (!painterCtors.vml) {\n\t                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t            }\n\t            rendererType = 'vml';\n\t        }\n\t        else if (!rendererType || !painterCtors[rendererType]) {\n\t            rendererType = 'canvas';\n\t        }\n\t        var painter = new painterCtors[rendererType](dom, storage, opts);\n\t\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t\n\t        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\t\n\t        /**\n\t         * @type {module:zrender/animation/Animation}\n\t         */\n\t        this.animation = new Animation({\n\t            stage: {\n\t                update: zrUtil.bind(this.flush, this)\n\t            }\n\t        });\n\t        this.animation.start();\n\t\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._needsRefresh;\n\t\n\t        //  storage.delFromMap, \n\t        // FIXME ugly\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t\n\t            oldDelFromMap.call(storage, elId);\n\t\n\t            el && el.removeSelfFromZr(self);\n\t        };\n\t\n\t        storage.addToMap = function (el) {\n\t            oldAddToMap.call(storage, el);\n\t\n\t            el.addSelfToZr(self);\n\t        };\n\t    };\n\t\n\t    ZRender.prototype = {\n\t\n\t        constructor: ZRender,\n\t        /**\n\t         * \n\t         * @return {string}\n\t         */\n\t        getId: function () {\n\t            return this.id;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        add: function (el) {\n\t            this.storage.addRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        remove: function (el) {\n\t            this.storage.delRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Change configuration of layer\n\t         * @param {string} zLevel\n\t         * @param {Object} config\n\t         * @param {string} [config.clearColor=0] Clear color\n\t         * @param {string} [config.motionBlur=false] If enable motion blur\n\t         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n\t        */\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Repaint the canvas immediately\n\t         */\n\t        refreshImmediately: function () {\n\t            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t            // Or it will cause zrender refreshes again and again.\n\t            this._needsRefresh = false;\n\t            this.painter.refresh();\n\t            /**\n\t             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t             */\n\t            this._needsRefresh = false;\n\t        },\n\t\n\t        /**\n\t         * Mark and repaint the canvas in the next frame of browser\n\t         */\n\t        refresh: function() {\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Perform all refresh\n\t         */\n\t        flush: function () {\n\t            if (this._needsRefresh) {\n\t                this.refreshImmediately();\n\t            }\n\t            if (this._needsRefreshHover) {\n\t                this.refreshHoverImmediately();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element to hover layer\n\t         * @param  {module:zrender/Element} el\n\t         * @param {Object} style\n\t         */\n\t        addHover: function (el, style) {\n\t            if (this.painter.addHover) {\n\t                this.painter.addHover(el, style);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element from hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        removeHover: function (el) {\n\t            if (this.painter.removeHover) {\n\t                this.painter.removeHover(el);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clear all hover elements in hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        clearHover: function () {\n\t            if (this.painter.clearHover) {\n\t                this.painter.clearHover();\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Refresh hover in next frame\n\t         */\n\t        refreshHover: function () {\n\t            this._needsRefreshHover = true;\n\t        },\n\t\n\t        /**\n\t         * Refresh hover immediately\n\t         */\n\t        refreshHoverImmediately: function () {\n\t            this._needsRefreshHover = false;\n\t            this.painter.refreshHover && this.painter.refreshHover();\n\t        },\n\t\n\t        /**\n\t         * Resize the canvas.\n\t         * Should be invoked when container size is changed\n\t         * @param {Object} [opts]\n\t         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t         */\n\t        resize: function(opts) {\n\t            opts = opts || {};\n\t            this.painter.resize(opts.width, opts.height);\n\t            this.handler.resize();\n\t        },\n\t\n\t        /**\n\t         * Stop and clear all animation immediately\n\t         */\n\t        clearAnimation: function () {\n\t            this.animation.clear();\n\t        },\n\t\n\t        /**\n\t         * Get container width\n\t         */\n\t        getWidth: function() {\n\t            return this.painter.getWidth();\n\t        },\n\t\n\t        /**\n\t         * Get container height\n\t         */\n\t        getHeight: function() {\n\t            return this.painter.getHeight();\n\t        },\n\t\n\t        /**\n\t         * Export the canvas as Base64 URL\n\t         * @param {string} type\n\t         * @param {string} [backgroundColor='#fff']\n\t         * @return {string} Base64 URL\n\t         */\n\t        // toDataURL: function(type, backgroundColor) {\n\t        //     return this.painter.getRenderedCanvas({\n\t        //         backgroundColor: backgroundColor\n\t        //     }).toDataURL(type);\n\t        // },\n\t\n\t        /**\n\t         * Converting a path to image.\n\t         * It has much better performance of drawing image rather than drawing a vector path.\n\t         * @param {module:zrender/graphic/Path} e\n\t         * @param {number} width\n\t         * @param {number} height\n\t         */\n\t        pathToImage: function(e, width, height) {\n\t            var id = guid();\n\t            return this.painter.pathToImage(id, e, width, height);\n\t        },\n\t\n\t        /**\n\t         * Set default cursor\n\t         * @param {string} [cursorStyle='default']  crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            this.handler.setCursorStyle(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * Bind event\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {Function} eventHandler Handler function\n\t         * @param {Object} [context] Context object\n\t         */\n\t        on: function(eventName, eventHandler, context) {\n\t            this.handler.on(eventName, eventHandler, context);\n\t        },\n\t\n\t        /**\n\t         * Unbind event\n\t         * @param {string} eventName Event name\n\t         * @param {Function} [eventHandler] Handler function\n\t         */\n\t        off: function(eventName, eventHandler) {\n\t            this.handler.off(eventName, eventHandler);\n\t        },\n\t\n\t        /**\n\t         * Trigger event manually\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {event=} event Event object\n\t         */\n\t        trigger: function (eventName, event) {\n\t            this.handler.trigger(eventName, event);\n\t        },\n\t\n\t\n\t        /**\n\t         * Clear all objects and the canvas.\n\t         */\n\t        clear: function () {\n\t            this.storage.delRoot();\n\t            this.painter.clear();\n\t        },\n\t\n\t        /**\n\t         * Dispose self.\n\t         */\n\t        dispose: function () {\n\t            this.animation.stop();\n\t\n\t            this.clear();\n\t            this.storage.dispose();\n\t            this.painter.dispose();\n\t            this.handler.dispose();\n\t\n\t            this.animation =\n\t            this.storage =\n\t            this.painter =\n\t            this.handler = null;\n\t\n\t            delInstance(this.id);\n\t        }\n\t    };\n\t\n\t    module.exports = zrender;\n\t\n\n\n/***/ },\n/* 77 */\n/*!**********************************************!*\\\n  !*** ./lib/action/createDataSelectAction.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var echarts = __webpack_require__(/*! ../echarts */ 2);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    module.exports = function (seriesType, actionInfos) {\n\t        zrUtil.each(actionInfos, function (actionInfo) {\n\t            actionInfo.update = 'updateView';\n\t            /**\n\t             * @payload\n\t             * @property {string} seriesName\n\t             * @property {string} name\n\t             */\n\t            echarts.registerAction(actionInfo, function (payload, ecModel) {\n\t                var selected = {};\n\t                ecModel.eachComponent(\n\t                    {mainType: 'series', subType: seriesType, query: payload},\n\t                    function (seriesModel) {\n\t                        if (seriesModel[actionInfo.method]) {\n\t                            seriesModel[actionInfo.method](payload.name);\n\t                        }\n\t                        var data = seriesModel.getData();\n\t                        // Create selected map\n\t                        data.each(function (idx) {\n\t                            var name = data.getName(idx);\n\t                            selected[name] = seriesModel.isSelected(name) || false;\n\t                        });\n\t                    }\n\t                );\n\t                return {\n\t                    name: payload.name,\n\t                    selected: selected\n\t                };\n\t            });\n\t        });\n\t    };\n\n\n/***/ },\n/* 78 */,\n/* 79 */,\n/* 80 */,\n/* 81 */\n/*!**********************************!*\\\n  !*** ./lib/coord/axisDefault.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var defaultOption = {\n\t        show: true,\n\t        zlevel: 0,                  // \n\t        z: 0,                       // \n\t        // \n\t        inverse: false,\n\t\n\t        // \n\t        name: '',\n\t        // 'start' | 'middle' | 'end'\n\t        nameLocation: 'end',\n\t        // degree\n\t        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n\t        nameTruncate: {\n\t            maxWidth: null,\n\t            ellipsis: '...',\n\t            placeholder: '.'\n\t        },\n\t        // \n\t        nameTextStyle: {},\n\t        // \n\t        nameGap: 15,\n\t\n\t        silent: false, // Default false to support tooltip.\n\t        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\t\n\t        tooltip: {\n\t            show: false\n\t        },\n\t\n\t        // \n\t        axisLine: {\n\t            // show\n\t            show: true,\n\t            onZero: true,\n\t            // lineStyle\n\t            lineStyle: {\n\t                color: '#333',\n\t                width: 1,\n\t                type: 'solid'\n\t            }\n\t        },\n\t        // \n\t        axisTick: {\n\t            // show\n\t            show: true,\n\t            // grid\n\t            inside: false,\n\t            // length\n\t            length: 5,\n\t            // lineStyle\n\t            lineStyle: {\n\t                width: 1\n\t            }\n\t        },\n\t        // axis.axisLabel\n\t        axisLabel: {\n\t            show: true,\n\t            // grid\n\t            inside: false,\n\t            rotate: 0,\n\t            margin: 8,\n\t            // formatter: null,\n\t            // TEXTSTYLE\n\t            textStyle: {\n\t                fontSize: 12\n\t            }\n\t        },\n\t        // \n\t        splitLine: {\n\t            // show\n\t            show: true,\n\t            // lineStylelineStyle\n\t            lineStyle: {\n\t                color: ['#ccc'],\n\t                width: 1,\n\t                type: 'solid'\n\t            }\n\t        },\n\t        // \n\t        splitArea: {\n\t            // show\n\t            show: false,\n\t            // areaStyleareaStyle\n\t            areaStyle: {\n\t                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n\t            }\n\t        }\n\t    };\n\t\n\t    var categoryAxis = zrUtil.merge({\n\t        // \n\t        boundaryGap: true,\n\t        // splitArea: {\n\t            // show: false\n\t        // },\n\t        splitLine: {\n\t            show: false\n\t        },\n\t        // \n\t        axisTick: {\n\t            // If tick is align with label when boundaryGap is true\n\t            // Default with axisTick\n\t            alignWithLabel: false,\n\t            interval: 'auto'\n\t        },\n\t        // axis.axisLabel\n\t        axisLabel: {\n\t            interval: 'auto'\n\t        }\n\t    }, defaultOption);\n\t\n\t    var valueAxis = zrUtil.merge({\n\t        // \n\t        boundaryGap: [0, 0],\n\t        // ,  'dataMin' \n\t        // min: null,\n\t        //  'dataMax' \n\t        // max: null,\n\t        // Readonly prop, specifies start value of the range when using data zoom.\n\t        // rangeStart: null\n\t        // Readonly prop, specifies end value of the range when using data zoom.\n\t        // rangeEnd: null\n\t        // 0_min_max\n\t        // scale: false,\n\t        // 5\n\t        splitNumber: 5\n\t        // Minimum interval\n\t        // minInterval: null\n\t    }, defaultOption);\n\t\n\t    // FIXME\n\t    var timeAxis = zrUtil.defaults({\n\t        scale: true,\n\t        min: 'dataMin',\n\t        max: 'dataMax'\n\t    }, valueAxis);\n\t    var logAxis = zrUtil.defaults({\n\t        logBase: 10\n\t    }, valueAxis);\n\t    logAxis.scale = true;\n\t\n\t    module.exports = {\n\t        categoryAxis: categoryAxis,\n\t        valueAxis: valueAxis,\n\t        timeAxis: timeAxis,\n\t        logAxis: logAxis\n\t    };\n\n\n/***/ },\n/* 82 */\n/*!*****************************************!*\\\n  !*** ./lib/coord/axisModelZoomMixin.js ***!\n  \\*****************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t\n\t        /**\n\t         * @public\n\t         * @return {Array.<number|string|Date>}\n\t         */\n\t        getMin: function () {\n\t            var option = this.option;\n\t            var min = option.rangeStart != null ? option.rangeStart : option.min;\n\t            // In case of axis.type === 'time', Date should be converted to timestamp.\n\t            // In other cases, min/max should be a number or null/undefined or 'dataMin/Max'.\n\t            if (min instanceof Date) {\n\t                min = +min;\n\t            }\n\t            return min;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @return {Array.<number|string|Date>}\n\t         */\n\t        getMax: function () {\n\t            var option = this.option;\n\t            var max = option.rangeEnd != null ? option.rangeEnd : option.max;\n\t            // In case of axis.type === 'time', Date should be converted to timestamp.\n\t            // In other cases, min/max should be a number or null/undefined or 'dataMin/Max'.\n\t            if (max instanceof Date) {\n\t                max = +max;\n\t            }\n\t            return max;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @return {boolean}\n\t         */\n\t        getNeedCrossZero: function () {\n\t            var option = this.option;\n\t            return (option.rangeStart != null || option.rangeEnd != null)\n\t                ? false : !option.scale;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @param {number} rangeStart\n\t         * @param {number} rangeEnd\n\t         */\n\t        setRange: function (rangeStart, rangeEnd) {\n\t            this.option.rangeStart = rangeStart;\n\t            this.option.rangeEnd = rangeEnd;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         */\n\t        resetRange: function () {\n\t            // rangeStart and rangeEnd is readonly.\n\t            this.option.rangeStart = this.option.rangeEnd = null;\n\t        }\n\t    };\n\t\n\n\n/***/ },\n/* 83 */,\n/* 84 */\n/*!***************************************!*\\\n  !*** ./~/zrender/lib/contain/line.js ***!\n  \\***************************************/\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l)\n\t                || (y < y0 - _l && y < y1 - _l)\n\t                || (x > x0 + _l && x > x1 + _l)\n\t                || (x < x0 - _l && x < x1 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n\t            }\n\t            else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 85 */\n/*!********************************************!*\\\n  !*** ./~/zrender/lib/contain/quadratic.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(/*! ../core/curve */ 17);\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(\n\t                x0, y0, x1, y1, x2, y2,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 86 */\n/*!**********************************************!*\\\n  !*** ./~/zrender/lib/contain/windingLine.js ***!\n  \\**********************************************/\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n\t        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n\t            return 0;\n\t        }\n\t        // Ignore horizontal line\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t\n\t        // Avoid winding error when intersection point is the connect point of two line of polygon\n\t        if (t === 1 || t === 0) {\n\t            dir = y1 < y0 ? 0.5 : -0.5;\n\t        }\n\t\n\t        var x_ = t * (x1 - x0) + x0;\n\t\n\t        return x_ > x ? dir : 0;\n\t    };\n\n\n/***/ },\n/* 87 */\n/*!*************************************************!*\\\n  !*** ./~/zrender/lib/graphic/LinearGradient.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t\n\t    var Gradient = __webpack_require__(/*! ./Gradient */ 29);\n\t\n\t    /**\n\t     * x, y, x2, y2 are all percent from 0 to 1\n\t     * @param {number} [x=0]\n\t     * @param {number} [y=0]\n\t     * @param {number} [x2=1]\n\t     * @param {number} [y2=0]\n\t     * @param {Array.<Object>} colorStops\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t        this.x = x == null ? 0 : x;\n\t\n\t        this.y = y == null ? 0 : y;\n\t\n\t        this.x2 = x2 == null ? 1 : x2;\n\t\n\t        this.y2 = y2 == null ? 0 : y2;\n\t\n\t        // Can be cloned\n\t        this.type = 'linear';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    LinearGradient.prototype = {\n\t\n\t        constructor: LinearGradient\n\t    };\n\t\n\t    zrUtil.inherits(LinearGradient, Gradient);\n\t\n\t    module.exports = LinearGradient;\n\n\n/***/ },\n/* 88 */\n/*!**********************************************!*\\\n  !*** ./~/zrender/lib/mixin/Transformable.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var matrix = __webpack_require__(/*! ../core/matrix */ 19);\n\t    var vector = __webpack_require__(/*! ../core/vector */ 5);\n\t    var mIdentity = matrix.identity;\n\t\n\t    var EPSILON = 5e-5;\n\t\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [0, 0];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [1, 1];\n\t        }\n\t        /**\n\t         * \n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t\n\t    /**\n\t     * \n\t     * , position, rotation, scaletransformtransform\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation)\n\t            || isNotAroundZero(this.position[0])\n\t            || isNotAroundZero(this.position[1])\n\t            || isNotAroundZero(this.scale[0] - 1)\n\t            || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t\n\t        m = m || matrix.create();\n\t\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        }\n\t        else {\n\t            mIdentity(m);\n\t        }\n\t\n\t        // \n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            }\n\t            else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // \n\t        this.transform = m;\n\t\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t\n\t    transformableProto.getLocalTransform = function (m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t\n\t        var origin = this.origin;\n\t\n\t        var scale = this.scale;\n\t        var rotation = this.rotation;\n\t        var position = this.position;\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t\n\t        return m;\n\t    };\n\t    /**\n\t     * transformcontext\n\t     * @param {Context2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        if (m) {\n\t            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t        }\n\t        else {\n\t            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t        }\n\t    };\n\t\n\t    transformableProto.restoreTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t    }\n\t\n\t    var tmpTransform = [];\n\t\n\t    /**\n\t     * `transform``position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t\n\t    /**\n\t     * Get global scale\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.getGlobalScale = function () {\n\t        var m = this.transform;\n\t        if (!m) {\n\t            return [1, 1];\n\t        }\n\t        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        return [sx, sy];\n\t    };\n\t    /**\n\t     *  shape \n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    /**\n\t     * \n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    module.exports = Transformable;\n\t\n\n\n/***/ },\n/* 89 */\n/*!*****************************!*\\\n  !*** ./lib/ExtensionAPI.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var echartsAPIList = [\n\t        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction', 'isDisposed',\n\t        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\n\t    ];\n\t\n\t    function ExtensionAPI(chartInstance) {\n\t        zrUtil.each(echartsAPIList, function (name) {\n\t            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n\t        }, this);\n\t    }\n\t\n\t    module.exports = ExtensionAPI;\n\n\n/***/ },\n/* 90 */\n/*!**************************!*\\\n  !*** ./lib/chart/bar.js ***!\n  \\**************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    __webpack_require__(/*! ../coord/cartesian/Grid */ 54);\n\t\n\t    __webpack_require__(/*! ./bar/BarSeries */ 91);\n\t    __webpack_require__(/*! ./bar/BarView */ 92);\n\t\n\t    var barLayoutGrid = __webpack_require__(/*! ../layout/barGrid */ 122);\n\t    var echarts = __webpack_require__(/*! ../echarts */ 2);\n\t\n\t    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n\t    // Visual coding for legend\n\t    echarts.registerVisual(function (ecModel) {\n\t        ecModel.eachSeriesByType('bar', function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            data.setVisual('legendSymbol', 'roundRect');\n\t        });\n\t    });\n\t\n\t    // In case developer forget to include grid component\n\t    __webpack_require__(/*! ../component/grid */ 36);\n\n\n/***/ },\n/* 91 */\n/*!************************************!*\\\n  !*** ./lib/chart/bar/BarSeries.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var SeriesModel = __webpack_require__(/*! ../../model/Series */ 15);\n\t    var createListFromArray = __webpack_require__(/*! ../helper/createListFromArray */ 35);\n\t\n\t    module.exports = SeriesModel.extend({\n\t\n\t        type: 'series.bar',\n\t\n\t        dependencies: ['grid', 'polar'],\n\t\n\t        getInitialData: function (option, ecModel) {\n\t            if (false) {\n\t                var coordSys = option.coordinateSystem;\n\t                if (coordSys !== 'cartesian2d') {\n\t                    throw new Error('Bar only support cartesian2d coordinateSystem');\n\t                }\n\t            }\n\t            return createListFromArray(option.data, this, ecModel);\n\t        },\n\t\n\t        getMarkerPosition: function (value) {\n\t            var coordSys = this.coordinateSystem;\n\t            if (coordSys) {\n\t                // PENDING if clamp ?\n\t                var pt = coordSys.dataToPoint(value, true);\n\t                var data = this.getData();\n\t                var offset = data.getLayout('offset');\n\t                var size = data.getLayout('size');\n\t                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n\t                pt[offsetIndex] += offset + size / 2;\n\t                return pt;\n\t            }\n\t            return [NaN, NaN];\n\t        },\n\t\n\t        brushSelector: 'rect',\n\t\n\t        defaultOption: {\n\t            zlevel: 0,                  // \n\t            z: 2,                       // \n\t            coordinateSystem: 'cartesian2d',\n\t            legendHoverLink: true,\n\t            // stack: null\n\t\n\t            // Cartesian coordinate system\n\t            // xAxisIndex: 0,\n\t            // yAxisIndex: 0,\n\t\n\t            // 0\n\t            barMinHeight: 0,\n\t\n\t            // barMaxWidth: null,\n\t            // \n\t            // barWidth: null,\n\t            // 30%\n\t            // barGap: '30%',\n\t            // 20%\n\t            // barCategoryGap: '20%',\n\t            // label: {\n\t            //     normal: {\n\t            //         show: false\n\t            //     }\n\t            // },\n\t            itemStyle: {\n\t                normal: {\n\t                    // color: ''\n\t                },\n\t                emphasis: {}\n\t            }\n\t        }\n\t    });\n\n\n/***/ },\n/* 92 */\n/*!**********************************!*\\\n  !*** ./lib/chart/bar/BarView.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t\n\t    zrUtil.extend(__webpack_require__(/*! ../../model/Model */ 10).prototype, __webpack_require__(/*! ./barItemStyle */ 93));\n\t\n\t    function fixLayoutWithLineWidth(layout, lineWidth) {\n\t        var signX = layout.width > 0 ? 1 : -1;\n\t        var signY = layout.height > 0 ? 1 : -1;\n\t        // In case width or height are too small.\n\t        lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));\n\t        layout.x += signX * lineWidth / 2;\n\t        layout.y += signY * lineWidth / 2;\n\t        layout.width -= signX * lineWidth;\n\t        layout.height -= signY * lineWidth;\n\t    }\n\t\n\t    module.exports = __webpack_require__(/*! ../../echarts */ 2).extendChartView({\n\t\n\t        type: 'bar',\n\t\n\t        render: function (seriesModel, ecModel, api) {\n\t            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\t\n\t            if (coordinateSystemType === 'cartesian2d') {\n\t                this._renderOnCartesian(seriesModel, ecModel, api);\n\t            }\n\t\n\t            return this.group;\n\t        },\n\t\n\t        dispose: zrUtil.noop,\n\t\n\t        _renderOnCartesian: function (seriesModel, ecModel, api) {\n\t            var group = this.group;\n\t            var data = seriesModel.getData();\n\t            var oldData = this._data;\n\t\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var isHorizontal = baseAxis.isHorizontal();\n\t\n\t            var enableAnimation = seriesModel.get('animation');\n\t\n\t            var barBorderWidthQuery = ['itemStyle', 'normal', 'barBorderWidth'];\n\t\n\t            function createRect(dataIndex, isUpdate) {\n\t                var layout = data.getItemLayout(dataIndex);\n\t                var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;\n\t                fixLayoutWithLineWidth(layout, lineWidth);\n\t\n\t                var rect = new graphic.Rect({\n\t                    shape: zrUtil.extend({}, layout)\n\t                });\n\t                // Animation\n\t                if (enableAnimation) {\n\t                    var rectShape = rect.shape;\n\t                    var animateProperty = isHorizontal ? 'height' : 'width';\n\t                    var animateTarget = {};\n\t                    rectShape[animateProperty] = 0;\n\t                    animateTarget[animateProperty] = layout[animateProperty];\n\t                    graphic[isUpdate? 'updateProps' : 'initProps'](rect, {\n\t                        shape: animateTarget\n\t                    }, seriesModel, dataIndex);\n\t                }\n\t                return rect;\n\t            }\n\t            data.diff(oldData)\n\t                .add(function (dataIndex) {\n\t                    // \n\t                    if (!data.hasValue(dataIndex)) {\n\t                        return;\n\t                    }\n\t\n\t                    var rect = createRect(dataIndex);\n\t\n\t                    data.setItemGraphicEl(dataIndex, rect);\n\t\n\t                    group.add(rect);\n\t\n\t                })\n\t                .update(function (newIndex, oldIndex) {\n\t                    var rect = oldData.getItemGraphicEl(oldIndex);\n\t                    // \n\t                    if (!data.hasValue(newIndex)) {\n\t                        group.remove(rect);\n\t                        return;\n\t                    }\n\t                    if (!rect) {\n\t                        rect = createRect(newIndex, true);\n\t                    }\n\t\n\t                    var layout = data.getItemLayout(newIndex);\n\t                    var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;\n\t                    fixLayoutWithLineWidth(layout, lineWidth);\n\t\n\t                    graphic.updateProps(rect, {\n\t                        shape: layout\n\t                    }, seriesModel, newIndex);\n\t\n\t                    data.setItemGraphicEl(newIndex, rect);\n\t\n\t                    // Add back\n\t                    group.add(rect);\n\t                })\n\t                .remove(function (idx) {\n\t                    var rect = oldData.getItemGraphicEl(idx);\n\t                    if (rect) {\n\t                        // Not show text when animating\n\t                        rect.style.text = '';\n\t                        graphic.updateProps(rect, {\n\t                            shape: {\n\t                                width: 0\n\t                            }\n\t                        }, seriesModel, idx, function () {\n\t                            group.remove(rect);\n\t                        });\n\t                    }\n\t                })\n\t                .execute();\n\t\n\t            this._updateStyle(seriesModel, data, isHorizontal);\n\t\n\t            this._data = data;\n\t        },\n\t\n\t        _updateStyle: function (seriesModel, data, isHorizontal) {\n\t            function setLabel(style, model, color, labelText, labelPositionOutside) {\n\t                graphic.setText(style, model, color);\n\t                style.text = labelText;\n\t                if (style.textPosition === 'outside') {\n\t                    style.textPosition = labelPositionOutside;\n\t                }\n\t            }\n\t\n\t            data.eachItemGraphicEl(function (rect, idx) {\n\t                var itemModel = data.getItemModel(idx);\n\t                var color = data.getItemVisual(idx, 'color');\n\t                var opacity = data.getItemVisual(idx, 'opacity');\n\t                var layout = data.getItemLayout(idx);\n\t                var itemStyleModel = itemModel.getModel('itemStyle.normal');\n\t\n\t                var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\t\n\t                rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n\t\n\t                rect.useStyle(zrUtil.defaults(\n\t                    {\n\t                        fill: color,\n\t                        opacity: opacity\n\t                    },\n\t                    itemStyleModel.getBarItemStyle()\n\t                ));\n\t\n\t                var labelPositionOutside = isHorizontal\n\t                    ? (layout.height > 0 ? 'bottom' : 'top')\n\t                    : (layout.width > 0 ? 'left' : 'right');\n\t\n\t                var labelModel = itemModel.getModel('label.normal');\n\t                var hoverLabelModel = itemModel.getModel('label.emphasis');\n\t                var rectStyle = rect.style;\n\t                if (labelModel.get('show')) {\n\t                    setLabel(\n\t                        rectStyle, labelModel, color,\n\t                        zrUtil.retrieve(\n\t                            seriesModel.getFormattedLabel(idx, 'normal'),\n\t                            seriesModel.getRawValue(idx)\n\t                        ),\n\t                        labelPositionOutside\n\t                    );\n\t                }\n\t                else {\n\t                    rectStyle.text = '';\n\t                }\n\t                if (hoverLabelModel.get('show')) {\n\t                    setLabel(\n\t                        hoverStyle, hoverLabelModel, color,\n\t                        zrUtil.retrieve(\n\t                            seriesModel.getFormattedLabel(idx, 'emphasis'),\n\t                            seriesModel.getRawValue(idx)\n\t                        ),\n\t                        labelPositionOutside\n\t                    );\n\t                }\n\t                else {\n\t                    hoverStyle.text = '';\n\t                }\n\t                graphic.setHoverStyle(rect, hoverStyle);\n\t            });\n\t        },\n\t\n\t        remove: function (ecModel, api) {\n\t            var group = this.group;\n\t            if (ecModel.get('animation')) {\n\t                if (this._data) {\n\t                    this._data.eachItemGraphicEl(function (el) {\n\t                        // Not show text when animating\n\t                        el.style.text = '';\n\t                        graphic.updateProps(el, {\n\t                            shape: {\n\t                                width: 0\n\t                            }\n\t                        }, ecModel, el.dataIndex, function () {\n\t                            group.remove(el);\n\t                        });\n\t                    });\n\t                }\n\t            }\n\t            else {\n\t                group.removeAll();\n\t            }\n\t        }\n\t    });\n\n\n/***/ },\n/* 93 */\n/*!***************************************!*\\\n  !*** ./lib/chart/bar/barItemStyle.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t\n\t    var getBarItemStyle = __webpack_require__(/*! ../../model/mixin/makeStyleMapper */ 31)(\n\t        [\n\t            ['fill', 'color'],\n\t            ['stroke', 'borderColor'],\n\t            ['lineWidth', 'borderWidth'],\n\t            // Compatitable with 2\n\t            ['stroke', 'barBorderColor'],\n\t            ['lineWidth', 'barBorderWidth'],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]\n\t    );\n\t    module.exports = {\n\t        getBarItemStyle: function (excludes) {\n\t            var style = getBarItemStyle.call(this, excludes);\n\t            if (this.getBorderLineDash) {\n\t                var lineDash = this.getBorderLineDash();\n\t                lineDash && (style.lineDash = lineDash);\n\t            }\n\t            return style;\n\t        }\n\t    };\n\n\n/***/ },\n/* 94 */,\n/* 95 */,\n/* 96 */\n/*!***************************!*\\\n  !*** ./lib/chart/line.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var echarts = __webpack_require__(/*! ../echarts */ 2);\n\t    var PRIORITY = echarts.PRIORITY;\n\t\n\t    __webpack_require__(/*! ./line/LineSeries */ 97);\n\t    __webpack_require__(/*! ./line/LineView */ 98);\n\t\n\t    echarts.registerVisual(zrUtil.curry(\n\t        __webpack_require__(/*! ../visual/symbol */ 46), 'line', 'circle', 'line'\n\t    ));\n\t    echarts.registerLayout(zrUtil.curry(\n\t        __webpack_require__(/*! ../layout/points */ 55), 'line'\n\t    ));\n\t\n\t    // Down sample after filter\n\t    echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(\n\t        __webpack_require__(/*! ../processor/dataSample */ 134), 'line'\n\t    ));\n\t\n\t    // In case developer forget to include grid component\n\t    __webpack_require__(/*! ../component/grid */ 36);\n\n\n/***/ },\n/* 97 */\n/*!**************************************!*\\\n  !*** ./lib/chart/line/LineSeries.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var createListFromArray = __webpack_require__(/*! ../helper/createListFromArray */ 35);\n\t    var SeriesModel = __webpack_require__(/*! ../../model/Series */ 15);\n\t\n\t    module.exports = SeriesModel.extend({\n\t\n\t        type: 'series.line',\n\t\n\t        dependencies: ['grid', 'polar'],\n\t\n\t        getInitialData: function (option, ecModel) {\n\t            if (false) {\n\t                var coordSys = option.coordinateSystem;\n\t                if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {\n\t                    throw new Error('Line not support coordinateSystem besides cartesian and polar');\n\t                }\n\t            }\n\t            return createListFromArray(option.data, this, ecModel);\n\t        },\n\t\n\t        defaultOption: {\n\t            zlevel: 0,                  // \n\t            z: 2,                       // \n\t            coordinateSystem: 'cartesian2d',\n\t            legendHoverLink: true,\n\t\n\t            hoverAnimation: true,\n\t            // stack: null\n\t            // xAxisIndex: 0,\n\t            // yAxisIndex: 0,\n\t\n\t            // polarIndex: 0,\n\t\n\t            // If clip the overflow value\n\t            clipOverflow: true,\n\t\n\t            label: {\n\t                normal: {\n\t                    position: 'top'\n\t                }\n\t            },\n\t            // itemStyle: {\n\t            //     normal: {},\n\t            //     emphasis: {}\n\t            // },\n\t            lineStyle: {\n\t                normal: {\n\t                    width: 2,\n\t                    type: 'solid'\n\t                }\n\t            },\n\t            // areaStyle: {},\n\t            // false, 'start', 'end', 'middle'\n\t            step: false,\n\t\n\t            // Disabled if step is true\n\t            smooth: false,\n\t            smoothMonotone: null,\n\t            // \n\t            symbol: 'emptyCircle',\n\t            // \n\t            symbolSize: 4,\n\t            // \n\t            symbolRotate: null,\n\t\n\t            //  symbol,  tooltip hover \n\t            showSymbol: true,\n\t            // \n\t            showAllSymbol: false,\n\t\n\t            // \n\t            connectNulls: false,\n\t\n\t            // 'average', 'max', 'min', 'sum'\n\t            sampling: 'none',\n\t\n\t            animationEasing: 'linear',\n\t\n\t            // Disable progressive\n\t            progressive: 0,\n\t            hoverLayerThreshold: Infinity\n\t        }\n\t    });\n\n\n/***/ },\n/* 98 */\n/*!************************************!*\\\n  !*** ./lib/chart/line/LineView.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// FIXME step not support polar\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var SymbolDraw = __webpack_require__(/*! ../helper/SymbolDraw */ 39);\n\t    var Symbol = __webpack_require__(/*! ../helper/Symbol */ 49);\n\t    var lineAnimationDiff = __webpack_require__(/*! ./lineAnimationDiff */ 99);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var modelUtil = __webpack_require__(/*! ../../util/model */ 7);\n\t\n\t    var polyHelper = __webpack_require__(/*! ./poly */ 100);\n\t\n\t    var ChartView = __webpack_require__(/*! ../../view/Chart */ 27);\n\t\n\t    function isPointsSame(points1, points2) {\n\t        if (points1.length !== points2.length) {\n\t            return;\n\t        }\n\t        for (var i = 0; i < points1.length; i++) {\n\t            var p1 = points1[i];\n\t            var p2 = points2[i];\n\t            if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n\t                return;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    function getSmooth(smooth) {\n\t        return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);\n\t    }\n\t\n\t    function getAxisExtentWithGap(axis) {\n\t        var extent = axis.getGlobalExtent();\n\t        if (axis.onBand) {\n\t            // Remove extra 1px to avoid line miter in clipped edge\n\t            var halfBandWidth = axis.getBandWidth() / 2 - 1;\n\t            var dir = extent[1] > extent[0] ? 1 : -1;\n\t            extent[0] += dir * halfBandWidth;\n\t            extent[1] -= dir * halfBandWidth;\n\t        }\n\t        return extent;\n\t    }\n\t\n\t    function sign(val) {\n\t        return val >= 0 ? 1 : -1;\n\t    }\n\t    /**\n\t     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Array.<Array.<number>>} points\n\t     * @private\n\t     */\n\t    function getStackedOnPoints(coordSys, data) {\n\t        var baseAxis = coordSys.getBaseAxis();\n\t        var valueAxis = coordSys.getOtherAxis(baseAxis);\n\t        var valueStart = baseAxis.onZero\n\t            ? 0 : valueAxis.scale.getExtent()[0];\n\t\n\t        var valueDim = valueAxis.dim;\n\t\n\t        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\t\n\t        return data.mapArray([valueDim], function (val, idx) {\n\t            var stackedOnSameSign;\n\t            var stackedOn = data.stackedOn;\n\t            // Find first stacked value with same sign\n\t            while (stackedOn &&\n\t                sign(stackedOn.get(valueDim, idx)) === sign(val)\n\t            ) {\n\t                stackedOnSameSign = stackedOn;\n\t                break;\n\t            }\n\t            var stackedData = [];\n\t            stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n\t            stackedData[1 - baseDataOffset] = stackedOnSameSign\n\t                ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\t\n\t            return coordSys.dataToPoint(stackedData);\n\t        }, true);\n\t    }\n\t\n\t    function createGridClipShape(cartesian, hasAnimation, seriesModel) {\n\t        var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n\t        var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n\t        var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n\t\n\t        var x = Math.min(xExtent[0], xExtent[1]);\n\t        var y = Math.min(yExtent[0], yExtent[1]);\n\t        var width = Math.max(xExtent[0], xExtent[1]) - x;\n\t        var height = Math.max(yExtent[0], yExtent[1]) - y;\n\t        var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;\n\t        // Expand clip shape to avoid clipping when line value exceeds axis\n\t        var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\t        if (isHorizontal) {\n\t            y -= expandSize;\n\t            height += expandSize * 2;\n\t        }\n\t        else {\n\t            x -= expandSize;\n\t            width += expandSize * 2;\n\t        }\n\t\n\t        var clipPath = new graphic.Rect({\n\t            shape: {\n\t                x: x,\n\t                y: y,\n\t                width: width,\n\t                height: height\n\t            }\n\t        });\n\t\n\t        if (hasAnimation) {\n\t            clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n\t            graphic.initProps(clipPath, {\n\t                shape: {\n\t                    width: width,\n\t                    height: height\n\t                }\n\t            }, seriesModel);\n\t        }\n\t\n\t        return clipPath;\n\t    }\n\t\n\t    function createPolarClipShape(polar, hasAnimation, seriesModel) {\n\t        var angleAxis = polar.getAngleAxis();\n\t        var radiusAxis = polar.getRadiusAxis();\n\t\n\t        var radiusExtent = radiusAxis.getExtent();\n\t        var angleExtent = angleAxis.getExtent();\n\t\n\t        var RADIAN = Math.PI / 180;\n\t\n\t        var clipPath = new graphic.Sector({\n\t            shape: {\n\t                cx: polar.cx,\n\t                cy: polar.cy,\n\t                r0: radiusExtent[0],\n\t                r: radiusExtent[1],\n\t                startAngle: -angleExtent[0] * RADIAN,\n\t                endAngle: -angleExtent[1] * RADIAN,\n\t                clockwise: angleAxis.inverse\n\t            }\n\t        });\n\t\n\t        if (hasAnimation) {\n\t            clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n\t            graphic.initProps(clipPath, {\n\t                shape: {\n\t                    endAngle: -angleExtent[1] * RADIAN\n\t                }\n\t            }, seriesModel);\n\t        }\n\t\n\t        return clipPath;\n\t    }\n\t\n\t    function createClipShape(coordSys, hasAnimation, seriesModel) {\n\t        return coordSys.type === 'polar'\n\t            ? createPolarClipShape(coordSys, hasAnimation, seriesModel)\n\t            : createGridClipShape(coordSys, hasAnimation, seriesModel);\n\t    }\n\t\n\t    function turnPointsIntoStep(points, coordSys, stepTurnAt) {\n\t        var baseAxis = coordSys.getBaseAxis();\n\t        var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\t\n\t        var stepPoints = [];\n\t        for (var i = 0; i < points.length - 1; i++) {\n\t            var nextPt = points[i + 1];\n\t            var pt = points[i];\n\t            stepPoints.push(pt);\n\t\n\t            var stepPt = [];\n\t            switch (stepTurnAt) {\n\t                case 'end':\n\t                    stepPt[baseIndex] = nextPt[baseIndex];\n\t                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n\t                    // default is start\n\t                    stepPoints.push(stepPt);\n\t                    break;\n\t                case 'middle':\n\t                    // default is start\n\t                    var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n\t                    var stepPt2 = [];\n\t                    stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n\t                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n\t                    stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n\t                    stepPoints.push(stepPt);\n\t                    stepPoints.push(stepPt2);\n\t                    break;\n\t                default:\n\t                    stepPt[baseIndex] = pt[baseIndex];\n\t                    stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n\t                    // default is start\n\t                    stepPoints.push(stepPt);\n\t            }\n\t        }\n\t        // Last points\n\t        points[i] && stepPoints.push(points[i]);\n\t        return stepPoints;\n\t    }\n\t\n\t    function clamp(number, extent) {\n\t        return Math.max(Math.min(number, extent[1]), extent[0]);\n\t    }\n\t\n\t    function getVisualGradient(data, coordSys) {\n\t        var visualMetaList = data.getVisual('visualMeta');\n\t        if (!visualMetaList || !visualMetaList.length || !data.count()) {\n\t            // When data.count() is 0, gradient range can not be calculated.\n\t            return;\n\t        }\n\t\n\t        var visualMeta;\n\t        for (var i = visualMetaList.length - 1; i >= 0; i--) {\n\t            // Can only be x or y\n\t            if (visualMetaList[i].dimension < 2) {\n\t                visualMeta = visualMetaList[i];\n\t                break;\n\t            }\n\t        }\n\t        if (!visualMeta || coordSys.type !== 'cartesian2d') {\n\t            if (false) {\n\t                console.warn('Visual map on line style only support x or y dimension.');\n\t            }\n\t            return;\n\t        }\n\t\n\t        var dimension = visualMeta.dimension;\n\t        var dimName = data.dimensions[dimension];\n\t        var dataExtent = data.getDataExtent(dimName);\n\t\n\t        var stops = visualMeta.stops;\n\t\n\t        var colorStops = [];\n\t        if (stops[0].interval) {\n\t            stops.sort(function (a, b) {\n\t                return a.interval[0] - b.interval[0];\n\t            });\n\t        }\n\t\n\t        var firstStop = stops[0];\n\t        var lastStop = stops[stops.length - 1];\n\t        // Interval can be infinity in piecewise case\n\t        var min = firstStop.interval ? clamp(firstStop.interval[0], dataExtent) : firstStop.value;\n\t        var max = lastStop.interval ? clamp(lastStop.interval[1], dataExtent) : lastStop.value;\n\t        var stopsSpan = max - min;\n\t\n\t        // In the piecewise case data out of visual range\n\t        // ----dataMin----dataMax-----visualMin----visualMax\n\t        if (stopsSpan === 0) {\n\t            return data.getItemVisual(0, 'color');\n\t        }\n\t        for (var i = 0; i < stops.length; i++) {\n\t            // Piecewise\n\t            if (stops[i].interval) {\n\t                if (stops[i].interval[1] === stops[i].interval[0]) {\n\t                    continue;\n\t                }\n\t                colorStops.push({\n\t                    // Make sure offset is between 0 and 1\n\t                    offset: (clamp(stops[i].interval[0], dataExtent) - min) / stopsSpan,\n\t                    color: stops[i].color\n\t                }, {\n\t                    offset: (clamp(stops[i].interval[1], dataExtent) - min) / stopsSpan,\n\t                    color: stops[i].color\n\t                });\n\t            }\n\t            // Continous\n\t            else {\n\t                // if (i > 0 && stops[i].value === stops[i - 1].value) {\n\t                //     continue;\n\t                // }\n\t                colorStops.push({\n\t                    offset: (stops[i].value - min) / stopsSpan,\n\t                    color: stops[i].color\n\t                });\n\t            }\n\t        }\n\t\n\t        var gradient = new graphic.LinearGradient(\n\t            0, 0, 0, 0, colorStops, true\n\t        );\n\t        var axis = coordSys.getAxis(dimName);\n\t\n\t        var start = axis.toGlobalCoord(axis.dataToCoord(min));\n\t        var end = axis.toGlobalCoord(axis.dataToCoord(max));\n\t        // zrUtil.each(colorStops, function (colorStop) {\n\t        //     // Make sure each offset has rounded px to avoid not sharp edge\n\t        //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n\t        // });\n\t\n\t        gradient[dimName] = start;\n\t        gradient[dimName + '2'] = end;\n\t\n\t        return gradient;\n\t    }\n\t\n\t    module.exports = ChartView.extend({\n\t\n\t        type: 'line',\n\t\n\t        init: function () {\n\t            var lineGroup = new graphic.Group();\n\t\n\t            var symbolDraw = new SymbolDraw();\n\t            this.group.add(symbolDraw.group);\n\t\n\t            this._symbolDraw = symbolDraw;\n\t            this._lineGroup = lineGroup;\n\t        },\n\t\n\t        render: function (seriesModel, ecModel, api) {\n\t            var coordSys = seriesModel.coordinateSystem;\n\t            var group = this.group;\n\t            var data = seriesModel.getData();\n\t            var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n\t            var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n\t\n\t            var points = data.mapArray(data.getItemLayout, true);\n\t\n\t            var isCoordSysPolar = coordSys.type === 'polar';\n\t            var prevCoordSys = this._coordSys;\n\t\n\t            var symbolDraw = this._symbolDraw;\n\t            var polyline = this._polyline;\n\t            var polygon = this._polygon;\n\t\n\t            var lineGroup = this._lineGroup;\n\t\n\t            var hasAnimation = seriesModel.get('animation');\n\t\n\t            var isAreaChart = !areaStyleModel.isEmpty();\n\t            var stackedOnPoints = getStackedOnPoints(coordSys, data);\n\t\n\t            var showSymbol = seriesModel.get('showSymbol');\n\t\n\t            var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol')\n\t                && this._getSymbolIgnoreFunc(data, coordSys);\n\t\n\t            // Remove temporary symbols\n\t            var oldData = this._data;\n\t            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n\t                if (el.__temp) {\n\t                    group.remove(el);\n\t                    oldData.setItemGraphicEl(idx, null);\n\t                }\n\t            });\n\t\n\t            // Remove previous created symbols if showSymbol changed to false\n\t            if (!showSymbol) {\n\t                symbolDraw.remove();\n\t            }\n\t\n\t            group.add(lineGroup);\n\t\n\t            // FIXME step not support polar\n\t            var step = !isCoordSysPolar && seriesModel.get('step');\n\t            // Initialization animation or coordinate system changed\n\t            if (\n\t                !(polyline && prevCoordSys.type === coordSys.type && step === this._step)\n\t            ) {\n\t                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\t\n\t                if (step) {\n\t                    // TODO If stacked series is not step\n\t                    points = turnPointsIntoStep(points, coordSys, step);\n\t                    stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n\t                }\n\t\n\t                polyline = this._newPolyline(points, coordSys, hasAnimation);\n\t                if (isAreaChart) {\n\t                    polygon = this._newPolygon(\n\t                        points, stackedOnPoints,\n\t                        coordSys, hasAnimation\n\t                    );\n\t                }\n\t                lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n\t            }\n\t            else {\n\t                if (isAreaChart && !polygon) {\n\t                    // If areaStyle is added\n\t                    polygon = this._newPolygon(\n\t                        points, stackedOnPoints,\n\t                        coordSys, hasAnimation\n\t                    );\n\t                }\n\t                else if (polygon && !isAreaChart) {\n\t                    // If areaStyle is removed\n\t                    lineGroup.remove(polygon);\n\t                    polygon = this._polygon = null;\n\t                }\n\t\n\t                // Update clipPath\n\t                lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));\n\t\n\t                // Always update, or it is wrong in the case turning on legend\n\t                // because points are not changed\n\t                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\t\n\t                // Stop symbol animation and sync with line points\n\t                // FIXME performance?\n\t                data.eachItemGraphicEl(function (el) {\n\t                    el.stopAnimation(true);\n\t                });\n\t\n\t                // In the case data zoom triggerred refreshing frequently\n\t                // Data may not change if line has a category axis. So it should animate nothing\n\t                if (!isPointsSame(this._stackedOnPoints, stackedOnPoints)\n\t                    || !isPointsSame(this._points, points)\n\t                ) {\n\t                    if (hasAnimation) {\n\t                        this._updateAnimation(\n\t                            data, stackedOnPoints, coordSys, api, step\n\t                        );\n\t                    }\n\t                    else {\n\t                        // Not do it in update with animation\n\t                        if (step) {\n\t                            // TODO If stacked series is not step\n\t                            points = turnPointsIntoStep(points, coordSys, step);\n\t                            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n\t                        }\n\t\n\t                        polyline.setShape({\n\t                            points: points\n\t                        });\n\t                        polygon && polygon.setShape({\n\t                            points: points,\n\t                            stackedOnPoints: stackedOnPoints\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t\n\t            var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n\t\n\t            polyline.useStyle(zrUtil.defaults(\n\t                // Use color in lineStyle first\n\t                lineStyleModel.getLineStyle(),\n\t                {\n\t                    fill: 'none',\n\t                    stroke: visualColor,\n\t                    lineJoin: 'bevel'\n\t                }\n\t            ));\n\t\n\t            var smooth = seriesModel.get('smooth');\n\t            smooth = getSmooth(seriesModel.get('smooth'));\n\t            polyline.setShape({\n\t                smooth: smooth,\n\t                smoothMonotone: seriesModel.get('smoothMonotone'),\n\t                connectNulls: seriesModel.get('connectNulls')\n\t            });\n\t\n\t            if (polygon) {\n\t                var stackedOn = data.stackedOn;\n\t                var stackedOnSmooth = 0;\n\t\n\t                polygon.useStyle(zrUtil.defaults(\n\t                    areaStyleModel.getAreaStyle(),\n\t                    {\n\t                        fill: visualColor,\n\t                        opacity: 0.7,\n\t                        lineJoin: 'bevel'\n\t                    }\n\t                ));\n\t\n\t                if (stackedOn) {\n\t                    var stackedOnSeries = stackedOn.hostModel;\n\t                    stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n\t                }\n\t\n\t                polygon.setShape({\n\t                    smooth: smooth,\n\t                    stackedOnSmooth: stackedOnSmooth,\n\t                    smoothMonotone: seriesModel.get('smoothMonotone'),\n\t                    connectNulls: seriesModel.get('connectNulls')\n\t                });\n\t            }\n\t\n\t            this._data = data;\n\t            // Save the coordinate system for transition animation when data changed\n\t            this._coordSys = coordSys;\n\t            this._stackedOnPoints = stackedOnPoints;\n\t            this._points = points;\n\t            this._step = step;\n\t        },\n\t\n\t        dispose: function () {},\n\t\n\t        highlight: function (seriesModel, ecModel, api, payload) {\n\t            var data = seriesModel.getData();\n\t            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\t\n\t            if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n\t                var symbol = data.getItemGraphicEl(dataIndex);\n\t                if (!symbol) {\n\t                    // Create a temporary symbol if it is not exists\n\t                    var pt = data.getItemLayout(dataIndex);\n\t                    symbol = new Symbol(data, dataIndex);\n\t                    symbol.position = pt;\n\t                    symbol.setZ(\n\t                        seriesModel.get('zlevel'),\n\t                        seriesModel.get('z')\n\t                    );\n\t                    symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n\t                    symbol.__temp = true;\n\t                    data.setItemGraphicEl(dataIndex, symbol);\n\t\n\t                    // Stop scale animation\n\t                    symbol.stopSymbolAnimation(true);\n\t\n\t                    this.group.add(symbol);\n\t                }\n\t                symbol.highlight();\n\t            }\n\t            else {\n\t                // Highlight whole series\n\t                ChartView.prototype.highlight.call(\n\t                    this, seriesModel, ecModel, api, payload\n\t                );\n\t            }\n\t        },\n\t\n\t        downplay: function (seriesModel, ecModel, api, payload) {\n\t            var data = seriesModel.getData();\n\t            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\t            if (dataIndex != null && dataIndex >= 0) {\n\t                var symbol = data.getItemGraphicEl(dataIndex);\n\t                if (symbol) {\n\t                    if (symbol.__temp) {\n\t                        data.setItemGraphicEl(dataIndex, null);\n\t                        this.group.remove(symbol);\n\t                    }\n\t                    else {\n\t                        symbol.downplay();\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                // Downplay whole series\n\t                ChartView.prototype.downplay.call(\n\t                    this, seriesModel, ecModel, api, payload\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/container/Group} group\n\t         * @param {Array.<Array.<number>>} points\n\t         * @private\n\t         */\n\t        _newPolyline: function (points) {\n\t            var polyline = this._polyline;\n\t            // Remove previous created polyline\n\t            if (polyline) {\n\t                this._lineGroup.remove(polyline);\n\t            }\n\t\n\t            polyline = new polyHelper.Polyline({\n\t                shape: {\n\t                    points: points\n\t                },\n\t                silent: true,\n\t                z2: 10\n\t            });\n\t\n\t            this._lineGroup.add(polyline);\n\t\n\t            this._polyline = polyline;\n\t\n\t            return polyline;\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/container/Group} group\n\t         * @param {Array.<Array.<number>>} stackedOnPoints\n\t         * @param {Array.<Array.<number>>} points\n\t         * @private\n\t         */\n\t        _newPolygon: function (points, stackedOnPoints) {\n\t            var polygon = this._polygon;\n\t            // Remove previous created polygon\n\t            if (polygon) {\n\t                this._lineGroup.remove(polygon);\n\t            }\n\t\n\t            polygon = new polyHelper.Polygon({\n\t                shape: {\n\t                    points: points,\n\t                    stackedOnPoints: stackedOnPoints\n\t                },\n\t                silent: true\n\t            });\n\t\n\t            this._lineGroup.add(polygon);\n\t\n\t            this._polygon = polygon;\n\t            return polygon;\n\t        },\n\t        /**\n\t         * @private\n\t         */\n\t        _getSymbolIgnoreFunc: function (data, coordSys) {\n\t            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\t            // `getLabelInterval` is provided by echarts/component/axis\n\t            if (categoryAxis && categoryAxis.isLabelIgnored) {\n\t                return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        // FIXME Two value axis\n\t        _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n\t            var polyline = this._polyline;\n\t            var polygon = this._polygon;\n\t            var seriesModel = data.hostModel;\n\t\n\t            var diff = lineAnimationDiff(\n\t                this._data, data,\n\t                this._stackedOnPoints, stackedOnPoints,\n\t                this._coordSys, coordSys\n\t            );\n\t\n\t            var current = diff.current;\n\t            var stackedOnCurrent = diff.stackedOnCurrent;\n\t            var next = diff.next;\n\t            var stackedOnNext = diff.stackedOnNext;\n\t            if (step) {\n\t                // TODO If stacked series is not step\n\t                current = turnPointsIntoStep(diff.current, coordSys, step);\n\t                stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n\t                next = turnPointsIntoStep(diff.next, coordSys, step);\n\t                stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n\t            }\n\t            // `diff.current` is subset of `current` (which should be ensured by\n\t            // turnPointsIntoStep), so points in `__points` can be updated when\n\t            // points in `current` are update during animation.\n\t            polyline.shape.__points = diff.current;\n\t            polyline.shape.points = current;\n\t\n\t            graphic.updateProps(polyline, {\n\t                shape: {\n\t                    points: next\n\t                }\n\t            }, seriesModel);\n\t\n\t            if (polygon) {\n\t                polygon.setShape({\n\t                    points: current,\n\t                    stackedOnPoints: stackedOnCurrent\n\t                });\n\t                graphic.updateProps(polygon, {\n\t                    shape: {\n\t                        points: next,\n\t                        stackedOnPoints: stackedOnNext\n\t                    }\n\t                }, seriesModel);\n\t            }\n\t\n\t            var updatedDataInfo = [];\n\t            var diffStatus = diff.status;\n\t\n\t            for (var i = 0; i < diffStatus.length; i++) {\n\t                var cmd = diffStatus[i].cmd;\n\t                if (cmd === '=') {\n\t                    var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\t                    if (el) {\n\t                        updatedDataInfo.push({\n\t                            el: el,\n\t                            ptIdx: i    // Index of points\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (polyline.animators && polyline.animators.length) {\n\t                polyline.animators[0].during(function () {\n\t                    for (var i = 0; i < updatedDataInfo.length; i++) {\n\t                        var el = updatedDataInfo[i].el;\n\t                        el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        remove: function (ecModel) {\n\t            var group = this.group;\n\t            var oldData = this._data;\n\t            this._lineGroup.removeAll();\n\t            this._symbolDraw.remove(true);\n\t            // Remove temporary created elements when highlighting\n\t            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n\t                if (el.__temp) {\n\t                    group.remove(el);\n\t                    oldData.setItemGraphicEl(idx, null);\n\t                }\n\t            });\n\t\n\t            this._polyline =\n\t            this._polygon =\n\t            this._coordSys =\n\t            this._points =\n\t            this._stackedOnPoints =\n\t            this._data = null;\n\t        }\n\t    });\n\n\n/***/ },\n/* 99 */\n/*!*********************************************!*\\\n  !*** ./lib/chart/line/lineAnimationDiff.js ***!\n  \\*********************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    // var arrayDiff = require('zrender/lib/core/arrayDiff');\n\t    // 'zrender/core/arrayDiff' has been used before, but it did\n\t    // not do well in performance when roam with fixed dataZoom window.\n\t\n\t    function sign(val) {\n\t        return val >= 0 ? 1 : -1;\n\t    }\n\t\n\t    function getStackedOnPoint(coordSys, data, idx) {\n\t        var baseAxis = coordSys.getBaseAxis();\n\t        var valueAxis = coordSys.getOtherAxis(baseAxis);\n\t        var valueStart = baseAxis.onZero\n\t            ? 0 : valueAxis.scale.getExtent()[0];\n\t\n\t        var valueDim = valueAxis.dim;\n\t        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\t\n\t        var stackedOnSameSign;\n\t        var stackedOn = data.stackedOn;\n\t        var val = data.get(valueDim, idx);\n\t        // Find first stacked value with same sign\n\t        while (stackedOn &&\n\t            sign(stackedOn.get(valueDim, idx)) === sign(val)\n\t        ) {\n\t            stackedOnSameSign = stackedOn;\n\t            break;\n\t        }\n\t        var stackedData = [];\n\t        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n\t        stackedData[1 - baseDataOffset] = stackedOnSameSign\n\t            ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\t\n\t        return coordSys.dataToPoint(stackedData);\n\t    }\n\t\n\t    // function convertToIntId(newIdList, oldIdList) {\n\t    //     // Generate int id instead of string id.\n\t    //     // Compare string maybe slow in score function of arrDiff\n\t\n\t    //     // Assume id in idList are all unique\n\t    //     var idIndicesMap = {};\n\t    //     var idx = 0;\n\t    //     for (var i = 0; i < newIdList.length; i++) {\n\t    //         idIndicesMap[newIdList[i]] = idx;\n\t    //         newIdList[i] = idx++;\n\t    //     }\n\t    //     for (var i = 0; i < oldIdList.length; i++) {\n\t    //         var oldId = oldIdList[i];\n\t    //         // Same with newIdList\n\t    //         if (idIndicesMap[oldId]) {\n\t    //             oldIdList[i] = idIndicesMap[oldId];\n\t    //         }\n\t    //         else {\n\t    //             oldIdList[i] = idx++;\n\t    //         }\n\t    //     }\n\t    // }\n\t\n\t    function diffData(oldData, newData) {\n\t        var diffResult = [];\n\t\n\t        newData.diff(oldData)\n\t            .add(function (idx) {\n\t                diffResult.push({cmd: '+', idx: idx});\n\t            })\n\t            .update(function (newIdx, oldIdx) {\n\t                diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx});\n\t            })\n\t            .remove(function (idx) {\n\t                diffResult.push({cmd: '-', idx: idx});\n\t            })\n\t            .execute();\n\t\n\t        return diffResult;\n\t    }\n\t\n\t    module.exports = function (\n\t        oldData, newData,\n\t        oldStackedOnPoints, newStackedOnPoints,\n\t        oldCoordSys, newCoordSys\n\t    ) {\n\t        var diff = diffData(oldData, newData);\n\t\n\t        // var newIdList = newData.mapArray(newData.getId);\n\t        // var oldIdList = oldData.mapArray(oldData.getId);\n\t\n\t        // convertToIntId(newIdList, oldIdList);\n\t\n\t        // // FIXME One data ?\n\t        // diff = arrayDiff(oldIdList, newIdList);\n\t\n\t        var currPoints = [];\n\t        var nextPoints = [];\n\t        // Points for stacking base line\n\t        var currStackedPoints = [];\n\t        var nextStackedPoints = [];\n\t\n\t        var status = [];\n\t        var sortedIndices = [];\n\t        var rawIndices = [];\n\t        var dims = newCoordSys.dimensions;\n\t        for (var i = 0; i < diff.length; i++) {\n\t            var diffItem = diff[i];\n\t            var pointAdded = true;\n\t\n\t            // FIXME, animation is not so perfect when dataZoom window moves fast\n\t            // Which is in case remvoing or add more than one data in the tail or head\n\t            switch (diffItem.cmd) {\n\t                case '=':\n\t                    var currentPt = oldData.getItemLayout(diffItem.idx);\n\t                    var nextPt = newData.getItemLayout(diffItem.idx1);\n\t                    // If previous data is NaN, use next point directly\n\t                    if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n\t                        currentPt = nextPt.slice();\n\t                    }\n\t                    currPoints.push(currentPt);\n\t                    nextPoints.push(nextPt);\n\t\n\t                    currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n\t                    nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n\t\n\t                    rawIndices.push(newData.getRawIndex(diffItem.idx1));\n\t                    break;\n\t                case '+':\n\t                    var idx = diffItem.idx;\n\t                    currPoints.push(\n\t                        oldCoordSys.dataToPoint([\n\t                            newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)\n\t                        ])\n\t                    );\n\t\n\t                    nextPoints.push(newData.getItemLayout(idx).slice());\n\t\n\t                    currStackedPoints.push(\n\t                        getStackedOnPoint(oldCoordSys, newData, idx)\n\t                    );\n\t                    nextStackedPoints.push(newStackedOnPoints[idx]);\n\t\n\t                    rawIndices.push(newData.getRawIndex(idx));\n\t                    break;\n\t                case '-':\n\t                    var idx = diffItem.idx;\n\t                    var rawIndex = oldData.getRawIndex(idx);\n\t                    // Data is replaced. In the case of dynamic data queue\n\t                    // FIXME FIXME FIXME\n\t                    if (rawIndex !== idx) {\n\t                        currPoints.push(oldData.getItemLayout(idx));\n\t                        nextPoints.push(newCoordSys.dataToPoint([\n\t                            oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)\n\t                        ]));\n\t\n\t                        currStackedPoints.push(oldStackedOnPoints[idx]);\n\t                        nextStackedPoints.push(\n\t                            getStackedOnPoint(\n\t                                newCoordSys, oldData, idx\n\t                            )\n\t                        );\n\t\n\t                        rawIndices.push(rawIndex);\n\t                    }\n\t                    else {\n\t                        pointAdded = false;\n\t                    }\n\t            }\n\t\n\t            // Original indices\n\t            if (pointAdded) {\n\t                status.push(diffItem);\n\t                sortedIndices.push(sortedIndices.length);\n\t            }\n\t        }\n\t\n\t        // Diff result may be crossed if all items are changed\n\t        // Sort by data index\n\t        sortedIndices.sort(function (a, b) {\n\t            return rawIndices[a] - rawIndices[b];\n\t        });\n\t\n\t        var sortedCurrPoints = [];\n\t        var sortedNextPoints = [];\n\t\n\t        var sortedCurrStackedPoints = [];\n\t        var sortedNextStackedPoints = [];\n\t\n\t        var sortedStatus = [];\n\t        for (var i = 0; i < sortedIndices.length; i++) {\n\t            var idx = sortedIndices[i];\n\t            sortedCurrPoints[i] = currPoints[idx];\n\t            sortedNextPoints[i] = nextPoints[idx];\n\t\n\t            sortedCurrStackedPoints[i] = currStackedPoints[idx];\n\t            sortedNextStackedPoints[i] = nextStackedPoints[idx];\n\t\n\t            sortedStatus[i] = status[idx];\n\t        }\n\t\n\t        return {\n\t            current: sortedCurrPoints,\n\t            next: sortedNextPoints,\n\t\n\t            stackedOnCurrent: sortedCurrStackedPoints,\n\t            stackedOnNext: sortedNextStackedPoints,\n\t\n\t            status: sortedStatus\n\t        };\n\t    };\n\n\n/***/ },\n/* 100 */\n/*!********************************!*\\\n  !*** ./lib/chart/line/poly.js ***!\n  \\********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Poly path support NaN point\n\t\n\t\n\t    var Path = __webpack_require__(/*! zrender/lib/graphic/Path */ 6);\n\t    var vec2 = __webpack_require__(/*! zrender/lib/core/vector */ 5);\n\t\n\t    var vec2Min = vec2.min;\n\t    var vec2Max = vec2.max;\n\t\n\t    var scaleAndAdd = vec2.scaleAndAdd;\n\t    var v2Copy = vec2.copy;\n\t\n\t    // Temporary variable\n\t    var v = [];\n\t    var cp0 = [];\n\t    var cp1 = [];\n\t\n\t    function isPointNull(p) {\n\t        return isNaN(p[0]) || isNaN(p[1]);\n\t    }\n\t\n\t    function drawSegment(\n\t        ctx, points, start, segLen, allLen,\n\t        dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls\n\t    ) {\n\t        var prevIdx = 0;\n\t        var idx = start;\n\t        for (var k = 0; k < segLen; k++) {\n\t            var p = points[idx];\n\t            if (idx >= allLen || idx < 0) {\n\t                break;\n\t            }\n\t            if (isPointNull(p)) {\n\t                if (connectNulls) {\n\t                    idx += dir;\n\t                    continue;\n\t                }\n\t                break;\n\t            }\n\t\n\t            if (idx === start) {\n\t                ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n\t                v2Copy(cp0, p);\n\t            }\n\t            else {\n\t                if (smooth > 0) {\n\t                    var nextIdx = idx + dir;\n\t                    var nextP = points[nextIdx];\n\t                    if (connectNulls) {\n\t                        // Find next point not null\n\t                        while (nextP && isPointNull(points[nextIdx])) {\n\t                            nextIdx += dir;\n\t                            nextP = points[nextIdx];\n\t                        }\n\t                    }\n\t\n\t                    var ratioNextSeg = 0.5;\n\t                    var prevP = points[prevIdx];\n\t                    var nextP = points[nextIdx];\n\t                    // Last point\n\t                    if (!nextP || isPointNull(nextP)) {\n\t                        v2Copy(cp1, p);\n\t                    }\n\t                    else {\n\t                        // If next data is null in not connect case\n\t                        if (isPointNull(nextP) && !connectNulls) {\n\t                            nextP = p;\n\t                        }\n\t\n\t                        vec2.sub(v, nextP, prevP);\n\t\n\t                        var lenPrevSeg;\n\t                        var lenNextSeg;\n\t                        if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n\t                            var dim = smoothMonotone === 'x' ? 0 : 1;\n\t                            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n\t                            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n\t                        }\n\t                        else {\n\t                            lenPrevSeg = vec2.dist(p, prevP);\n\t                            lenNextSeg = vec2.dist(p, nextP);\n\t                        }\n\t\n\t                        // Use ratio of seg length\n\t                        ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n\t\n\t                        scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n\t                    }\n\t                    // Smooth constraint\n\t                    vec2Min(cp0, cp0, smoothMax);\n\t                    vec2Max(cp0, cp0, smoothMin);\n\t                    vec2Min(cp1, cp1, smoothMax);\n\t                    vec2Max(cp1, cp1, smoothMin);\n\t\n\t                    ctx.bezierCurveTo(\n\t                        cp0[0], cp0[1],\n\t                        cp1[0], cp1[1],\n\t                        p[0], p[1]\n\t                    );\n\t                    // cp0 of next segment\n\t                    scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n\t                }\n\t                else {\n\t                    ctx.lineTo(p[0], p[1]);\n\t                }\n\t            }\n\t\n\t            prevIdx = idx;\n\t            idx += dir;\n\t        }\n\t\n\t        return k;\n\t    }\n\t\n\t    function getBoundingBox(points, smoothConstraint) {\n\t        var ptMin = [Infinity, Infinity];\n\t        var ptMax = [-Infinity, -Infinity];\n\t        if (smoothConstraint) {\n\t            for (var i = 0; i < points.length; i++) {\n\t                var pt = points[i];\n\t                if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; }\n\t                if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; }\n\t                if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; }\n\t                if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; }\n\t            }\n\t        }\n\t        return {\n\t            min: smoothConstraint ? ptMin : ptMax,\n\t            max: smoothConstraint ? ptMax : ptMin\n\t        };\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        Polyline: Path.extend({\n\t\n\t            type: 'ec-polyline',\n\t\n\t            shape: {\n\t                points: [],\n\t\n\t                smooth: 0,\n\t\n\t                smoothConstraint: true,\n\t\n\t                smoothMonotone: null,\n\t\n\t                connectNulls: false\n\t            },\n\t\n\t            style: {\n\t                fill: null,\n\t\n\t                stroke: '#000'\n\t            },\n\t\n\t            buildPath: function (ctx, shape) {\n\t                var points = shape.points;\n\t\n\t                var i = 0;\n\t                var len = points.length;\n\t\n\t                var result = getBoundingBox(points, shape.smoothConstraint);\n\t\n\t                if (shape.connectNulls) {\n\t                    // Must remove first and last null values avoid draw error in polygon\n\t                    for (; len > 0; len--) {\n\t                        if (!isPointNull(points[len - 1])) {\n\t                            break;\n\t                        }\n\t                    }\n\t                    for (; i < len; i++) {\n\t                        if (!isPointNull(points[i])) {\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t                while (i < len) {\n\t                    i += drawSegment(\n\t                        ctx, points, i, len, len,\n\t                        1, result.min, result.max, shape.smooth,\n\t                        shape.smoothMonotone, shape.connectNulls\n\t                    ) + 1;\n\t                }\n\t            }\n\t        }),\n\t\n\t        Polygon: Path.extend({\n\t\n\t            type: 'ec-polygon',\n\t\n\t            shape: {\n\t                points: [],\n\t\n\t                // Offset between stacked base points and points\n\t                stackedOnPoints: [],\n\t\n\t                smooth: 0,\n\t\n\t                stackedOnSmooth: 0,\n\t\n\t                smoothConstraint: true,\n\t\n\t                smoothMonotone: null,\n\t\n\t                connectNulls: false\n\t            },\n\t\n\t            buildPath: function (ctx, shape) {\n\t                var points = shape.points;\n\t                var stackedOnPoints = shape.stackedOnPoints;\n\t\n\t                var i = 0;\n\t                var len = points.length;\n\t                var smoothMonotone = shape.smoothMonotone;\n\t                var bbox = getBoundingBox(points, shape.smoothConstraint);\n\t                var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\t\n\t                if (shape.connectNulls) {\n\t                    // Must remove first and last null values avoid draw error in polygon\n\t                    for (; len > 0; len--) {\n\t                        if (!isPointNull(points[len - 1])) {\n\t                            break;\n\t                        }\n\t                    }\n\t                    for (; i < len; i++) {\n\t                        if (!isPointNull(points[i])) {\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t                while (i < len) {\n\t                    var k = drawSegment(\n\t                        ctx, points, i, len, len,\n\t                        1, bbox.min, bbox.max, shape.smooth,\n\t                        smoothMonotone, shape.connectNulls\n\t                    );\n\t                    drawSegment(\n\t                        ctx, stackedOnPoints, i + k - 1, k, len,\n\t                        -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth,\n\t                        smoothMonotone, shape.connectNulls\n\t                    );\n\t                    i += k + 1;\n\t\n\t                    ctx.closePath();\n\t                }\n\t            }\n\t        })\n\t    };\n\n\n/***/ },\n/* 101 */\n/*!**************************!*\\\n  !*** ./lib/chart/pie.js ***!\n  \\**************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var echarts = __webpack_require__(/*! ../echarts */ 2);\n\t\n\t    __webpack_require__(/*! ./pie/PieSeries */ 102);\n\t    __webpack_require__(/*! ./pie/PieView */ 103);\n\t\n\t    __webpack_require__(/*! ../action/createDataSelectAction */ 77)('pie', [{\n\t        type: 'pieToggleSelect',\n\t        event: 'pieselectchanged',\n\t        method: 'toggleSelected'\n\t    }, {\n\t        type: 'pieSelect',\n\t        event: 'pieselected',\n\t        method: 'select'\n\t    }, {\n\t        type: 'pieUnSelect',\n\t        event: 'pieunselected',\n\t        method: 'unSelect'\n\t    }]);\n\t\n\t    echarts.registerVisual(zrUtil.curry(__webpack_require__(/*! ../visual/dataColor */ 72), 'pie'));\n\t\n\t    echarts.registerLayout(zrUtil.curry(\n\t        __webpack_require__(/*! ./pie/pieLayout */ 105), 'pie'\n\t    ));\n\t\n\t    echarts.registerProcessor(zrUtil.curry(__webpack_require__(/*! ../processor/dataFilter */ 70), 'pie'));\n\n\n/***/ },\n/* 102 */\n/*!************************************!*\\\n  !*** ./lib/chart/pie/PieSeries.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var List = __webpack_require__(/*! ../../data/List */ 14);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var modelUtil = __webpack_require__(/*! ../../util/model */ 7);\n\t    var completeDimensions = __webpack_require__(/*! ../../data/helper/completeDimensions */ 30);\n\t\n\t    var dataSelectableMixin = __webpack_require__(/*! ../../component/helper/selectableMixin */ 66);\n\t\n\t    var PieSeries = __webpack_require__(/*! ../../echarts */ 2).extendSeriesModel({\n\t\n\t        type: 'series.pie',\n\t\n\t        // Overwrite\n\t        init: function (option) {\n\t            PieSeries.superApply(this, 'init', arguments);\n\t\n\t            // Enable legend selection for each data item\n\t            // Use a function instead of direct access because data reference may changed\n\t            this.legendDataProvider = function () {\n\t                return this._dataBeforeProcessed;\n\t            };\n\t\n\t            this.updateSelectedMap(option.data);\n\t\n\t            this._defaultLabelLine(option);\n\t        },\n\t\n\t        // Overwrite\n\t        mergeOption: function (newOption) {\n\t            PieSeries.superCall(this, 'mergeOption', newOption);\n\t            this.updateSelectedMap(this.option.data);\n\t        },\n\t\n\t        getInitialData: function (option, ecModel) {\n\t            var dimensions = completeDimensions(['value'], option.data);\n\t            var list = new List(dimensions, this);\n\t            list.initData(option.data);\n\t            return list;\n\t        },\n\t\n\t        // Overwrite\n\t        getDataParams: function (dataIndex) {\n\t            var data = this._data;\n\t            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n\t            var sum = data.getSum('value');\n\t            // FIXME toFixed?\n\t            //\n\t            // Percent is 0 if sum is 0\n\t            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\t\n\t            params.$vars.push('percent');\n\t            return params;\n\t        },\n\t\n\t        _defaultLabelLine: function (option) {\n\t            // Extend labelLine emphasis\n\t            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\t\n\t            var labelLineNormalOpt = option.labelLine.normal;\n\t            var labelLineEmphasisOpt = option.labelLine.emphasis;\n\t            // Not show label line if `label.normal.show = false`\n\t            labelLineNormalOpt.show = labelLineNormalOpt.show\n\t                && option.label.normal.show;\n\t            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n\t                && option.label.emphasis.show;\n\t        },\n\t\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 2,\n\t            legendHoverLink: true,\n\t\n\t            hoverAnimation: true,\n\t            // \n\t            center: ['50%', '50%'],\n\t            radius: [0, '75%'],\n\t            // \n\t            clockwise: true,\n\t            startAngle: 90,\n\t            // 0\n\t            minAngle: 0,\n\t            // \n\t            selectedOffset: 10,\n\t\n\t            // If use strategy to avoid label overlapping\n\t            avoidLabelOverlap: true,\n\t            // singlemultiple\n\t            // selectedMode: false,\n\t            // 'radius' | 'area'\n\t            // roseType: null,\n\t\n\t            label: {\n\t                normal: {\n\t                    // If rotate around circle\n\t                    rotate: false,\n\t                    show: true,\n\t                    // 'outer', 'inside', 'center'\n\t                    position: 'outer'\n\t                    // formatter: Tooltip.formatter\n\t                    // textStyle: null      // TEXTSTYLE\n\t                    // distance: positioninnerlabel()\n\t                },\n\t                emphasis: {}\n\t            },\n\t            // Enabled when label.normal.position is 'outer'\n\t            labelLine: {\n\t                normal: {\n\t                    show: true,\n\t                    // \n\t                    length: 15,\n\t                    // \n\t                    length2: 15,\n\t                    smooth: false,\n\t                    lineStyle: {\n\t                        // color: ,\n\t                        width: 1,\n\t                        type: 'solid'\n\t                    }\n\t                }\n\t            },\n\t            itemStyle: {\n\t                normal: {\n\t                    borderWidth: 1\n\t                },\n\t                emphasis: {}\n\t            },\n\t\n\t            animationEasing: 'cubicOut',\n\t\n\t            data: []\n\t        }\n\t    });\n\t\n\t    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\t\n\t    module.exports = PieSeries;\n\n\n/***/ },\n/* 103 */\n/*!**********************************!*\\\n  !*** ./lib/chart/pie/PieView.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    /**\n\t     * @param {module:echarts/model/Series} seriesModel\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n\t        var data = seriesModel.getData();\n\t        var dataIndex = this.dataIndex;\n\t        var name = data.getName(dataIndex);\n\t        var selectedOffset = seriesModel.get('selectedOffset');\n\t\n\t        api.dispatchAction({\n\t            type: 'pieToggleSelect',\n\t            from: uid,\n\t            name: name,\n\t            seriesId: seriesModel.id\n\t        });\n\t\n\t        data.each(function (idx) {\n\t            toggleItemSelected(\n\t                data.getItemGraphicEl(idx),\n\t                data.getItemLayout(idx),\n\t                seriesModel.isSelected(data.getName(idx)),\n\t                selectedOffset,\n\t                hasAnimation\n\t            );\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @param {module:zrender/graphic/Sector} el\n\t     * @param {Object} layout\n\t     * @param {boolean} isSelected\n\t     * @param {number} selectedOffset\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n\t        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t\n\t        var dx = Math.cos(midAngle);\n\t        var dy = Math.sin(midAngle);\n\t\n\t        var offset = isSelected ? selectedOffset : 0;\n\t        var position = [dx * offset, dy * offset];\n\t\n\t        hasAnimation\n\t            // animateTo will stop revious animation like update transition\n\t            ? el.animate()\n\t                .when(200, {\n\t                    position: position\n\t                })\n\t                .start('bounceOut')\n\t            : el.attr('position', position);\n\t    }\n\t\n\t    /**\n\t     * Piece of pie including Sector, Label, LabelLine\n\t     * @constructor\n\t     * @extends {module:zrender/graphic/Group}\n\t     */\n\t    function PiePiece(data, idx) {\n\t\n\t        graphic.Group.call(this);\n\t\n\t        var sector = new graphic.Sector({\n\t            z2: 2\n\t        });\n\t        var polyline = new graphic.Polyline();\n\t        var text = new graphic.Text();\n\t        this.add(sector);\n\t        this.add(polyline);\n\t        this.add(text);\n\t\n\t        this.updateData(data, idx, true);\n\t\n\t        // Hover to change label and labelLine\n\t        function onEmphasis() {\n\t            polyline.ignore = polyline.hoverIgnore;\n\t            text.ignore = text.hoverIgnore;\n\t        }\n\t        function onNormal() {\n\t            polyline.ignore = polyline.normalIgnore;\n\t            text.ignore = text.normalIgnore;\n\t        }\n\t        this.on('emphasis', onEmphasis)\n\t            .on('normal', onNormal)\n\t            .on('mouseover', onEmphasis)\n\t            .on('mouseout', onNormal);\n\t    }\n\t\n\t    var piePieceProto = PiePiece.prototype;\n\t\n\t    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t        return {\n\t            fill: textStyleModel.getTextColor()\n\t                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n\t            opacity: data.getItemVisual(idx, 'opacity'),\n\t            textFont: textStyleModel.getFont(),\n\t            text: zrUtil.retrieve(\n\t                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n\t            )\n\t        };\n\t    }\n\t\n\t    piePieceProto.updateData = function (data, idx, firstCreate) {\n\t\n\t        var sector = this.childAt(0);\n\t\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var sectorShape = zrUtil.extend({}, layout);\n\t        sectorShape.label = null;\n\t        if (firstCreate) {\n\t            sector.setShape(sectorShape);\n\t            sector.shape.endAngle = layout.startAngle;\n\t            graphic.updateProps(sector, {\n\t                shape: {\n\t                    endAngle: layout.endAngle\n\t                }\n\t            }, seriesModel, idx);\n\t        }\n\t        else {\n\t            graphic.updateProps(sector, {\n\t                shape: sectorShape\n\t            }, seriesModel, idx);\n\t        }\n\t\n\t        // Update common style\n\t        var itemStyleModel = itemModel.getModel('itemStyle');\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t\n\t        sector.useStyle(\n\t            zrUtil.defaults(\n\t                {\n\t                    lineJoin: 'bevel',\n\t                    fill: visualColor\n\t                },\n\t                itemStyleModel.getModel('normal').getItemStyle()\n\t            )\n\t        );\n\t        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\t\n\t        // Toggle selected\n\t        toggleItemSelected(\n\t            this,\n\t            data.getItemLayout(idx),\n\t            itemModel.get('selected'),\n\t            seriesModel.get('selectedOffset'),\n\t            seriesModel.get('animation')\n\t        );\n\t\n\t        function onEmphasis() {\n\t            // Sector may has animation of updating data. Force to move to the last frame\n\t            // Or it may stopped on the wrong shape\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({\n\t                shape: {\n\t                    r: layout.r + 10\n\t                }\n\t            }, 300, 'elasticOut');\n\t        }\n\t        function onNormal() {\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({\n\t                shape: {\n\t                    r: layout.r\n\t                }\n\t            }, 300, 'elasticOut');\n\t        }\n\t        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\t        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n\t            sector\n\t                .on('mouseover', onEmphasis)\n\t                .on('mouseout', onNormal)\n\t                .on('emphasis', onEmphasis)\n\t                .on('normal', onNormal);\n\t        }\n\t\n\t        this._updateLabel(data, idx);\n\t\n\t        graphic.setHoverStyle(this);\n\t    };\n\t\n\t    piePieceProto._updateLabel = function (data, idx) {\n\t\n\t        var labelLine = this.childAt(1);\n\t        var labelText = this.childAt(2);\n\t\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var labelLayout = layout.label;\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t\n\t        graphic.updateProps(labelLine, {\n\t            shape: {\n\t                points: labelLayout.linePoints || [\n\t                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n\t                ]\n\t            }\n\t        }, seriesModel, idx);\n\t\n\t        graphic.updateProps(labelText, {\n\t            style: {\n\t                x: labelLayout.x,\n\t                y: labelLayout.y\n\t            }\n\t        }, seriesModel, idx);\n\t        labelText.attr({\n\t            style: {\n\t                textVerticalAlign: labelLayout.verticalAlign,\n\t                textAlign: labelLayout.textAlign,\n\t                textFont: labelLayout.font\n\t            },\n\t            rotation: labelLayout.rotation,\n\t            origin: [labelLayout.x, labelLayout.y],\n\t            z2: 10\n\t        });\n\t\n\t        var labelModel = itemModel.getModel('label.normal');\n\t        var labelHoverModel = itemModel.getModel('label.emphasis');\n\t        var labelLineModel = itemModel.getModel('labelLine.normal');\n\t        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n\t        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\t\n\t        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\t\n\t        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n\t        labelText.hoverIgnore = !labelHoverModel.get('show');\n\t\n\t        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n\t        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\t\n\t        // Default use item visual color\n\t        labelLine.setStyle({\n\t            stroke: visualColor,\n\t            opacity: data.getItemVisual(idx, 'opacity')\n\t        });\n\t        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\t\n\t        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n\t        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\t\n\t        var smooth = labelLineModel.get('smooth');\n\t        if (smooth && smooth === true) {\n\t            smooth = 0.4;\n\t        }\n\t        labelLine.setShape({\n\t            smooth: smooth\n\t        });\n\t    };\n\t\n\t    zrUtil.inherits(PiePiece, graphic.Group);\n\t\n\t\n\t    // Pie view\n\t    var Pie = __webpack_require__(/*! ../../view/Chart */ 27).extend({\n\t\n\t        type: 'pie',\n\t\n\t        init: function () {\n\t            var sectorGroup = new graphic.Group();\n\t            this._sectorGroup = sectorGroup;\n\t        },\n\t\n\t        render: function (seriesModel, ecModel, api, payload) {\n\t            if (payload && (payload.from === this.uid)) {\n\t                return;\n\t            }\n\t\n\t            var data = seriesModel.getData();\n\t            var oldData = this._data;\n\t            var group = this.group;\n\t\n\t            var hasAnimation = ecModel.get('animation');\n\t            var isFirstRender = !oldData;\n\t\n\t            var onSectorClick = zrUtil.curry(\n\t                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n\t            );\n\t\n\t            var selectedMode = seriesModel.get('selectedMode');\n\t\n\t            data.diff(oldData)\n\t                .add(function (idx) {\n\t                    var piePiece = new PiePiece(data, idx);\n\t                    if (isFirstRender) {\n\t                        piePiece.eachChild(function (child) {\n\t                            child.stopAnimation(true);\n\t                        });\n\t                    }\n\t\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t\n\t                    data.setItemGraphicEl(idx, piePiece);\n\t\n\t                    group.add(piePiece);\n\t                })\n\t                .update(function (newIdx, oldIdx) {\n\t                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\t\n\t                    piePiece.updateData(data, newIdx);\n\t\n\t                    piePiece.off('click');\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t                    group.add(piePiece);\n\t                    data.setItemGraphicEl(newIdx, piePiece);\n\t                })\n\t                .remove(function (idx) {\n\t                    var piePiece = oldData.getItemGraphicEl(idx);\n\t                    group.remove(piePiece);\n\t                })\n\t                .execute();\n\t\n\t            if (hasAnimation && isFirstRender && data.count() > 0) {\n\t                var shape = data.getItemLayout(0);\n\t                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\t\n\t                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n\t                group.setClipPath(this._createClipPath(\n\t                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n\t                ));\n\t            }\n\t\n\t            this._data = data;\n\t        },\n\t\n\t        dispose: function () {},\n\t\n\t        _createClipPath: function (\n\t            cx, cy, r, startAngle, clockwise, cb, seriesModel\n\t        ) {\n\t            var clipPath = new graphic.Sector({\n\t                shape: {\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r0: 0,\n\t                    r: r,\n\t                    startAngle: startAngle,\n\t                    endAngle: startAngle,\n\t                    clockwise: clockwise\n\t                }\n\t            });\n\t\n\t            graphic.initProps(clipPath, {\n\t                shape: {\n\t                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n\t                }\n\t            }, seriesModel, cb);\n\t\n\t            return clipPath;\n\t        },\n\t\n\t        /**\n\t         * @implement\n\t         */\n\t        containPoint: function (point, seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var itemLayout = data.getItemLayout(0);\n\t            if (itemLayout) {\n\t                var dx = point[0] - itemLayout.cx;\n\t                var dy = point[1] - itemLayout.cy;\n\t                var radius = Math.sqrt(dx * dx + dy * dy);\n\t                return radius <= itemLayout.r && radius >= itemLayout.r0;\n\t            }\n\t        }\n\t\n\t    });\n\t\n\t    module.exports = Pie;\n\n\n/***/ },\n/* 104 */\n/*!**************************************!*\\\n  !*** ./lib/chart/pie/labelLayout.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// FIXME emphasis label position is not same with normal label position\n\t\n\t\n\t    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 16);\n\t\n\t    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n\t        list.sort(function (a, b) {\n\t            return a.y - b.y;\n\t        });\n\t\n\t        // \n\t        function shiftDown(start, end, delta, dir) {\n\t            for (var j = start; j < end; j++) {\n\t                list[j].y += delta;\n\t                if (j > start\n\t                    && j + 1 < end\n\t                    && list[j + 1].y > list[j].y + list[j].height\n\t                ) {\n\t                    shiftUp(j, delta / 2);\n\t                    return;\n\t                }\n\t            }\n\t\n\t            shiftUp(end - 1, delta / 2);\n\t        }\n\t\n\t        // \n\t        function shiftUp(end, delta) {\n\t            for (var j = end; j >= 0; j--) {\n\t                list[j].y -= delta;\n\t                if (j > 0\n\t                    && list[j].y > list[j - 1].y + list[j - 1].height\n\t                ) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t\n\t        function changeX(list, isDownList, cx, cy, r, dir) {\n\t            var lastDeltaX = dir > 0\n\t                ? isDownList                // \n\t                    ? Number.MAX_VALUE      // \n\t                    : 0                     // \n\t                : isDownList                // \n\t                    ? Number.MAX_VALUE      // \n\t                    : 0;                    // \n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                // Not change x for center label\n\t                if (list[i].position === 'center') {\n\t                    continue;\n\t                }\n\t                var deltaY = Math.abs(list[i].y - cy);\n\t                var length = list[i].len;\n\t                var length2 = list[i].len2;\n\t                var deltaX = (deltaY < r + length)\n\t                    ? Math.sqrt(\n\t                          (r + length + length2) * (r + length + length2)\n\t                          - deltaY * deltaY\n\t                      )\n\t                    : Math.abs(list[i].x - cx);\n\t                if (isDownList && deltaX >= lastDeltaX) {\n\t                    // \n\t                    deltaX = lastDeltaX - 10;\n\t                }\n\t                if (!isDownList && deltaX <= lastDeltaX) {\n\t                    // \n\t                    deltaX = lastDeltaX + 10;\n\t                }\n\t\n\t                list[i].x = cx + deltaX * dir;\n\t                lastDeltaX = deltaX;\n\t            }\n\t        }\n\t\n\t        var lastY = 0;\n\t        var delta;\n\t        var len = list.length;\n\t        var upList = [];\n\t        var downList = [];\n\t        for (var i = 0; i < len; i++) {\n\t            delta = list[i].y - lastY;\n\t            if (delta < 0) {\n\t                shiftDown(i, len, -delta, dir);\n\t            }\n\t            lastY = list[i].y + list[i].height;\n\t        }\n\t        if (viewHeight - lastY < 0) {\n\t            shiftUp(len - 1, lastY - viewHeight);\n\t        }\n\t        for (var i = 0; i < len; i++) {\n\t            if (list[i].y >= cy) {\n\t                downList.push(list[i]);\n\t            }\n\t            else {\n\t                upList.push(list[i]);\n\t            }\n\t        }\n\t        changeX(upList, false, cx, cy, r, dir);\n\t        changeX(downList, true, cx, cy, r, dir);\n\t    }\n\t\n\t    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n\t        var leftList = [];\n\t        var rightList = [];\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            if (labelLayoutList[i].x < cx) {\n\t                leftList.push(labelLayoutList[i]);\n\t            }\n\t            else {\n\t                rightList.push(labelLayoutList[i]);\n\t            }\n\t        }\n\t\n\t        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n\t        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\t\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            var linePoints = labelLayoutList[i].linePoints;\n\t            if (linePoints) {\n\t                var dist = linePoints[1][0] - linePoints[2][0];\n\t                if (labelLayoutList[i].x < cx) {\n\t                    linePoints[2][0] = labelLayoutList[i].x + 3;\n\t                }\n\t                else {\n\t                    linePoints[2][0] = labelLayoutList[i].x - 3;\n\t                }\n\t                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n\t                linePoints[1][0] = linePoints[2][0] + dist;\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n\t        var data = seriesModel.getData();\n\t        var labelLayoutList = [];\n\t        var cx;\n\t        var cy;\n\t        var hasLabelRotate = false;\n\t\n\t        data.each(function (idx) {\n\t            var layout = data.getItemLayout(idx);\n\t\n\t            var itemModel = data.getItemModel(idx);\n\t            var labelModel = itemModel.getModel('label.normal');\n\t            // Use position in normal or emphasis\n\t            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\t\n\t            var labelLineModel = itemModel.getModel('labelLine.normal');\n\t            var labelLineLen = labelLineModel.get('length');\n\t            var labelLineLen2 = labelLineModel.get('length2');\n\t\n\t            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t            var dx = Math.cos(midAngle);\n\t            var dy = Math.sin(midAngle);\n\t\n\t            var textX;\n\t            var textY;\n\t            var linePoints;\n\t            var textAlign;\n\t\n\t            cx = layout.cx;\n\t            cy = layout.cy;\n\t\n\t            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t            if (labelPosition === 'center') {\n\t                textX = layout.cx;\n\t                textY = layout.cy;\n\t                textAlign = 'center';\n\t            }\n\t            else {\n\t                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n\t                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\t\n\t                textX = x1 + dx * 3;\n\t                textY = y1 + dy * 3;\n\t\n\t                if (!isLabelInside) {\n\t                    // For roseType\n\t                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n\t                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n\t                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n\t                    var y3 = y2;\n\t\n\t                    textX = x3 + (dx < 0 ? -5 : 5);\n\t                    textY = y3;\n\t                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n\t                }\n\t\n\t                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n\t            }\n\t            var font = labelModel.getModel('textStyle').getFont();\n\t\n\t            var labelRotate = labelModel.get('rotate')\n\t                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n\t            var text = seriesModel.getFormattedLabel(idx, 'normal')\n\t                        || data.getName(idx);\n\t            var textRect = textContain.getBoundingRect(\n\t                text, font, textAlign, 'top'\n\t            );\n\t            hasLabelRotate = !!labelRotate;\n\t            layout.label = {\n\t                x: textX,\n\t                y: textY,\n\t                position: labelPosition,\n\t                height: textRect.height,\n\t                len: labelLineLen,\n\t                len2: labelLineLen2,\n\t                linePoints: linePoints,\n\t                textAlign: textAlign,\n\t                verticalAlign: 'middle',\n\t                font: font,\n\t                rotation: labelRotate\n\t            };\n\t\n\t            // Not layout the inside label\n\t            if (!isLabelInside) {\n\t                labelLayoutList.push(layout.label);\n\t            }\n\t        });\n\t        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n\t            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n\t        }\n\t    };\n\n\n/***/ },\n/* 105 */\n/*!************************************!*\\\n  !*** ./lib/chart/pie/pieLayout.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// TODO minAngle\n\t\n\t\n\t\n\t    var numberUtil = __webpack_require__(/*! ../../util/number */ 4);\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var labelLayout = __webpack_require__(/*! ./labelLayout */ 104);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var PI2 = Math.PI * 2;\n\t    var RADIAN = Math.PI / 180;\n\t\n\t    module.exports = function (seriesType, ecModel, api, payload) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var center = seriesModel.get('center');\n\t            var radius = seriesModel.get('radius');\n\t\n\t            if (!zrUtil.isArray(radius)) {\n\t                radius = [0, radius];\n\t            }\n\t            if (!zrUtil.isArray(center)) {\n\t                center = [center, center];\n\t            }\n\t\n\t            var width = api.getWidth();\n\t            var height = api.getHeight();\n\t            var size = Math.min(width, height);\n\t            var cx = parsePercent(center[0], width);\n\t            var cy = parsePercent(center[1], height);\n\t            var r0 = parsePercent(radius[0], size / 2);\n\t            var r = parsePercent(radius[1], size / 2);\n\t\n\t            var data = seriesModel.getData();\n\t\n\t            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\t\n\t            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\t\n\t            var sum = data.getSum('value');\n\t            // Sum may be 0\n\t            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\t\n\t            var clockwise = seriesModel.get('clockwise');\n\t\n\t            var roseType = seriesModel.get('roseType');\n\t\n\t            // [0...max]\n\t            var extent = data.getDataExtent('value');\n\t            extent[0] = 0;\n\t\n\t            // In the case some sector angle is smaller than minAngle\n\t            var restAngle = PI2;\n\t            var valueSumLargerThanMinAngle = 0;\n\t\n\t            var currentAngle = startAngle;\n\t\n\t            var dir = clockwise ? 1 : -1;\n\t            data.each('value', function (value, idx) {\n\t                var angle;\n\t                // FIXME  2.0  roseType  area \n\t                if (roseType !== 'area') {\n\t                    angle = sum === 0 ? unitRadian : (value * unitRadian);\n\t                }\n\t                else {\n\t                    angle = PI2 / (data.count() || 1);\n\t                }\n\t\n\t                if (angle < minAngle) {\n\t                    angle = minAngle;\n\t                    restAngle -= minAngle;\n\t                }\n\t                else {\n\t                    valueSumLargerThanMinAngle += value;\n\t                }\n\t\n\t                var endAngle = currentAngle + dir * angle;\n\t                data.setItemLayout(idx, {\n\t                    angle: angle,\n\t                    startAngle: currentAngle,\n\t                    endAngle: endAngle,\n\t                    clockwise: clockwise,\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r0: r0,\n\t                    r: roseType\n\t                        ? numberUtil.linearMap(value, extent, [r0, r])\n\t                        : r\n\t                });\n\t\n\t                currentAngle = endAngle;\n\t            }, true);\n\t\n\t            // Some sector is constrained by minAngle\n\t            // Rest sectors needs recalculate angle\n\t            if (restAngle < PI2) {\n\t                // Average the angle if rest angle is not enough after all angles is\n\t                // Constrained by minAngle\n\t                if (restAngle <= 1e-3) {\n\t                    var angle = PI2 / data.count();\n\t                    data.each(function (idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        layout.startAngle = startAngle + dir * idx * angle;\n\t                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n\t                    });\n\t                }\n\t                else {\n\t                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n\t                    currentAngle = startAngle;\n\t                    data.each('value', function (value, idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        var angle = layout.angle === minAngle\n\t                            ? minAngle : value * unitRadian;\n\t                        layout.startAngle = currentAngle;\n\t                        layout.endAngle = currentAngle + dir * angle;\n\t                        currentAngle += angle;\n\t                    });\n\t                }\n\t            }\n\t\n\t            labelLayout(seriesModel, r, width, height);\n\t        });\n\t    };\n\n\n/***/ },\n/* 106 */\n/*!*******************************!*\\\n  !*** ./lib/component/axis.js ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// TODO boundaryGap\n\t\n\t\n\t    __webpack_require__(/*! ../coord/cartesian/AxisModel */ 53);\n\t\n\t    __webpack_require__(/*! ./axis/AxisView */ 107);\n\n\n/***/ },\n/* 107 */\n/*!****************************************!*\\\n  !*** ./lib/component/axis/AxisView.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var graphic = __webpack_require__(/*! ../../util/graphic */ 3);\n\t    var AxisBuilder = __webpack_require__(/*! ./AxisBuilder */ 50);\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n\t    var getInterval = AxisBuilder.getInterval;\n\t\n\t    var axisBuilderAttrs = [\n\t        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n\t    ];\n\t    var selfBuilderAttrs = [\n\t        'splitArea', 'splitLine'\n\t    ];\n\t\n\t    // function getAlignWithLabel(model, axisModel) {\n\t    //     var alignWithLabel = model.get('alignWithLabel');\n\t    //     if (alignWithLabel === 'auto') {\n\t    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n\t    //     }\n\t    //     return alignWithLabel;\n\t    // }\n\t\n\t    var AxisView = __webpack_require__(/*! ../../echarts */ 2).extendComponentView({\n\t\n\t        type: 'axis',\n\t\n\t        render: function (axisModel, ecModel) {\n\t\n\t            this.group.removeAll();\n\t\n\t            var oldAxisGroup = this._axisGroup;\n\t            this._axisGroup = new graphic.Group();\n\t\n\t            this.group.add(this._axisGroup);\n\t\n\t            if (!axisModel.get('show')) {\n\t                return;\n\t            }\n\t\n\t            var gridModel = axisModel.findGridModel();\n\t\n\t            var layout = layoutAxis(gridModel, axisModel);\n\t\n\t            var axisBuilder = new AxisBuilder(axisModel, layout);\n\t\n\t            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\t\n\t            this._axisGroup.add(axisBuilder.getGroup());\n\t\n\t            zrUtil.each(selfBuilderAttrs, function (name) {\n\t                if (axisModel.get(name + '.show')) {\n\t                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n\t                }\n\t            }, this);\n\t\n\t            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n\t         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t         * @param {number|Function} labelInterval\n\t         * @private\n\t         */\n\t        _splitLine: function (axisModel, gridModel, labelInterval) {\n\t            var axis = axisModel.axis;\n\t\n\t            var splitLineModel = axisModel.getModel('splitLine');\n\t            var lineStyleModel = splitLineModel.getModel('lineStyle');\n\t            var lineColors = lineStyleModel.get('color');\n\t\n\t            var lineInterval = getInterval(splitLineModel, labelInterval);\n\t\n\t            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\t\n\t            var gridRect = gridModel.coordinateSystem.getRect();\n\t            var isHorizontal = axis.isHorizontal();\n\t\n\t            var lineCount = 0;\n\t\n\t            var ticksCoords = axis.getTicksCoords(\n\t                // splitLineModel.get('alignWithLabel')\n\t            );\n\t            var ticks = axis.scale.getTicks();\n\t\n\t            var p1 = [];\n\t            var p2 = [];\n\t            // Simple optimization\n\t            // Batching the lines if color are the same\n\t            var lineStyle = lineStyleModel.getLineStyle();\n\t            for (var i = 0; i < ticksCoords.length; i++) {\n\t                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n\t                    continue;\n\t                }\n\t\n\t                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t\n\t                if (isHorizontal) {\n\t                    p1[0] = tickCoord;\n\t                    p1[1] = gridRect.y;\n\t                    p2[0] = tickCoord;\n\t                    p2[1] = gridRect.y + gridRect.height;\n\t                }\n\t                else {\n\t                    p1[0] = gridRect.x;\n\t                    p1[1] = tickCoord;\n\t                    p2[0] = gridRect.x + gridRect.width;\n\t                    p2[1] = tickCoord;\n\t                }\n\t\n\t                var colorIndex = (lineCount++) % lineColors.length;\n\t                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                    anid: 'line_' + ticks[i],\n\t\n\t                    shape: {\n\t                        x1: p1[0],\n\t                        y1: p1[1],\n\t                        x2: p2[0],\n\t                        y2: p2[1]\n\t                    },\n\t                    style: zrUtil.defaults({\n\t                        stroke: lineColors[colorIndex]\n\t                    }, lineStyle),\n\t                    silent: true\n\t                })));\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n\t         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t         * @param {number|Function} labelInterval\n\t         * @private\n\t         */\n\t        _splitArea: function (axisModel, gridModel, labelInterval) {\n\t            var axis = axisModel.axis;\n\t\n\t            var splitAreaModel = axisModel.getModel('splitArea');\n\t            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\t            var areaColors = areaStyleModel.get('color');\n\t\n\t            var gridRect = gridModel.coordinateSystem.getRect();\n\t\n\t            var ticksCoords = axis.getTicksCoords(\n\t                // splitAreaModel.get('alignWithLabel')\n\t            );\n\t            var ticks = axis.scale.getTicks();\n\t\n\t            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n\t            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\t\n\t            var count = 0;\n\t\n\t            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\t\n\t            var areaStyle = areaStyleModel.getAreaStyle();\n\t            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\t\n\t            for (var i = 1; i < ticksCoords.length; i++) {\n\t                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n\t                    continue;\n\t                }\n\t\n\t                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t\n\t                var x;\n\t                var y;\n\t                var width;\n\t                var height;\n\t                if (axis.isHorizontal()) {\n\t                    x = prevX;\n\t                    y = gridRect.y;\n\t                    width = tickCoord - x;\n\t                    height = gridRect.height;\n\t                }\n\t                else {\n\t                    x = gridRect.x;\n\t                    y = prevY;\n\t                    width = gridRect.width;\n\t                    height = tickCoord - y;\n\t                }\n\t\n\t                var colorIndex = (count++) % areaColors.length;\n\t                this._axisGroup.add(new graphic.Rect({\n\t                    anid: 'area_' + ticks[i],\n\t\n\t                    shape: {\n\t                        x: x,\n\t                        y: y,\n\t                        width: width,\n\t                        height: height\n\t                    },\n\t                    style: zrUtil.defaults({\n\t                        fill: areaColors[colorIndex]\n\t                    }, areaStyle),\n\t                    silent: true\n\t                }));\n\t\n\t                prevX = x + width;\n\t                prevY = y + height;\n\t            }\n\t        }\n\t    });\n\t\n\t    AxisView.extend({\n\t        type: 'xAxis'\n\t    });\n\t    AxisView.extend({\n\t        type: 'yAxis'\n\t    });\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function layoutAxis(gridModel, axisModel) {\n\t        var grid = gridModel.coordinateSystem;\n\t        var axis = axisModel.axis;\n\t        var layout = {};\n\t\n\t        var rawAxisPosition = axis.position;\n\t        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n\t        var axisDim = axis.dim;\n\t\n\t        // [left, right, top, bottom]\n\t        var rect = grid.getRect();\n\t        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\t\n\t        var axisOffset = axisModel.get('offset') || 0;\n\t\n\t        var posMap = {\n\t            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n\t            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n\t        };\n\t\n\t        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n\t        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\t\n\t        function getZero(dim, val) {\n\t            var theAxis = grid.getAxis(dim);\n\t            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n\t        }\n\t\n\t        // Axis position\n\t        layout.position = [\n\t            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n\t            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n\t        ];\n\t\n\t        // Axis rotation\n\t        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\t\n\t        // Tick and label direction, x y is axisDim\n\t        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\t\n\t        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n\t        if (axis.onZero) {\n\t            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n\t        }\n\t\n\t        if (axisModel.getModel('axisTick').get('inside')) {\n\t            layout.tickDirection = -layout.tickDirection;\n\t        }\n\t        if (axisModel.getModel('axisLabel').get('inside')) {\n\t            layout.labelDirection = -layout.labelDirection;\n\t        }\n\t\n\t        // Special label rotation\n\t        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n\t        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\t\n\t        // label interval when auto mode.\n\t        layout.labelInterval = axis.getLabelInterval();\n\t\n\t        // Over splitLine and splitArea\n\t        layout.z2 = 1;\n\t\n\t        return layout;\n\t    }\n\n\n/***/ },\n/* 108 */,\n/* 109 */,\n/* 110 */,\n/* 111 */,\n/* 112 */,\n/* 113 */,\n/* 114 */,\n/* 115 */,\n/* 116 */,\n/* 117 */\n/*!***************************************!*\\\n  !*** ./lib/coord/cartesian/Axis2D.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var Axis = __webpack_require__(/*! ../Axis */ 42);\n\t    var axisLabelInterval = __webpack_require__(/*! ./axisLabelInterval */ 121);\n\t\n\t    /**\n\t     * Extend axis 2d\n\t     * @constructor module:echarts/coord/cartesian/Axis2D\n\t     * @extends {module:echarts/coord/cartesian/Axis}\n\t     * @param {string} dim\n\t     * @param {*} scale\n\t     * @param {Array.<number>} coordExtent\n\t     * @param {string} axisType\n\t     * @param {string} position\n\t     */\n\t    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n\t        Axis.call(this, dim, scale, coordExtent);\n\t        /**\n\t         * Axis type\n\t         *  - 'category'\n\t         *  - 'value'\n\t         *  - 'time'\n\t         *  - 'log'\n\t         * @type {string}\n\t         */\n\t        this.type = axisType || 'value';\n\t\n\t        /**\n\t         * Axis position\n\t         *  - 'top'\n\t         *  - 'bottom'\n\t         *  - 'left'\n\t         *  - 'right'\n\t         */\n\t        this.position = position || 'bottom';\n\t    };\n\t\n\t    Axis2D.prototype = {\n\t\n\t        constructor: Axis2D,\n\t\n\t        /**\n\t         * Index of axis, can be used as key\n\t         */\n\t        index: 0,\n\t        /**\n\t         * If axis is on the zero position of the other axis\n\t         * @type {boolean}\n\t         */\n\t        onZero: false,\n\t\n\t        /**\n\t         * Axis model\n\t         * @param {module:echarts/coord/cartesian/AxisModel}\n\t         */\n\t        model: null,\n\t\n\t        isHorizontal: function () {\n\t            var position = this.position;\n\t            return position === 'top' || position === 'bottom';\n\t        },\n\t\n\t        getGlobalExtent: function () {\n\t            var ret = this.getExtent();\n\t            ret[0] = this.toGlobalCoord(ret[0]);\n\t            ret[1] = this.toGlobalCoord(ret[1]);\n\t            return ret;\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        getLabelInterval: function () {\n\t            var labelInterval = this._labelInterval;\n\t            if (!labelInterval) {\n\t                labelInterval = this._labelInterval = axisLabelInterval(this);\n\t            }\n\t            return labelInterval;\n\t        },\n\t\n\t        /**\n\t         * If label is ignored.\n\t         * Automatically used when axis is category and label can not be all shown\n\t         * @param  {number}  idx\n\t         * @return {boolean}\n\t         */\n\t        isLabelIgnored: function (idx) {\n\t            if (this.type === 'category') {\n\t                var labelInterval = this.getLabelInterval();\n\t                return ((typeof labelInterval === 'function')\n\t                    && !labelInterval(idx, this.scale.getLabel(idx)))\n\t                    || idx % (labelInterval + 1);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Transform global coord to local coord,\n\t         * i.e. var localCoord = axis.toLocalCoord(80);\n\t         * designate by module:echarts/coord/cartesian/Grid.\n\t         * @type {Function}\n\t         */\n\t        toLocalCoord: null,\n\t\n\t        /**\n\t         * Transform global coord to local coord,\n\t         * i.e. var globalCoord = axis.toLocalCoord(40);\n\t         * designate by module:echarts/coord/cartesian/Grid.\n\t         * @type {Function}\n\t         */\n\t        toGlobalCoord: null\n\t\n\t    };\n\t    zrUtil.inherits(Axis2D, Axis);\n\t\n\t    module.exports = Axis2D;\n\n\n/***/ },\n/* 118 */\n/*!******************************************!*\\\n  !*** ./lib/coord/cartesian/Cartesian.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Cartesian coordinate system\n\t * @module  echarts/coord/Cartesian\n\t *\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    function dimAxisMapper(dim) {\n\t        return this._axes[dim];\n\t    }\n\t\n\t    /**\n\t     * @alias module:echarts/coord/Cartesian\n\t     * @constructor\n\t     */\n\t    var Cartesian = function (name) {\n\t        this._axes = {};\n\t\n\t        this._dimList = [];\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.name = name || '';\n\t    };\n\t\n\t    Cartesian.prototype = {\n\t\n\t        constructor: Cartesian,\n\t\n\t        type: 'cartesian',\n\t\n\t        /**\n\t         * Get axis\n\t         * @param  {number|string} dim\n\t         * @return {module:echarts/coord/Cartesian~Axis}\n\t         */\n\t        getAxis: function (dim) {\n\t            return this._axes[dim];\n\t        },\n\t\n\t        /**\n\t         * Get axes list\n\t         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n\t         */\n\t        getAxes: function () {\n\t            return zrUtil.map(this._dimList, dimAxisMapper, this);\n\t        },\n\t\n\t        /**\n\t         * Get axes list by given scale type\n\t         */\n\t        getAxesByScale: function (scaleType) {\n\t            scaleType = scaleType.toLowerCase();\n\t            return zrUtil.filter(\n\t                this.getAxes(),\n\t                function (axis) {\n\t                    return axis.scale.type === scaleType;\n\t                }\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Add axis\n\t         * @param {module:echarts/coord/Cartesian.Axis}\n\t         */\n\t        addAxis: function (axis) {\n\t            var dim = axis.dim;\n\t\n\t            this._axes[dim] = axis;\n\t\n\t            this._dimList.push(dim);\n\t        },\n\t\n\t        /**\n\t         * Convert data to coord in nd space\n\t         * @param {Array.<number>|Object.<string, number>} val\n\t         * @return {Array.<number>|Object.<string, number>}\n\t         */\n\t        dataToCoord: function (val) {\n\t            return this._dataCoordConvert(val, 'dataToCoord');\n\t        },\n\t\n\t        /**\n\t         * Convert coord in nd space to data\n\t         * @param  {Array.<number>|Object.<string, number>} val\n\t         * @return {Array.<number>|Object.<string, number>}\n\t         */\n\t        coordToData: function (val) {\n\t            return this._dataCoordConvert(val, 'coordToData');\n\t        },\n\t\n\t        _dataCoordConvert: function (input, method) {\n\t            var dimList = this._dimList;\n\t\n\t            var output = input instanceof Array ? [] : {};\n\t\n\t            for (var i = 0; i < dimList.length; i++) {\n\t                var dim = dimList[i];\n\t                var axis = this._axes[dim];\n\t\n\t                output[dim] = axis[method](input[dim]);\n\t            }\n\t\n\t            return output;\n\t        }\n\t    };\n\t\n\t    module.exports = Cartesian;\n\n\n/***/ },\n/* 119 */\n/*!********************************************!*\\\n  !*** ./lib/coord/cartesian/Cartesian2D.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var Cartesian = __webpack_require__(/*! ./Cartesian */ 118);\n\t\n\t    function Cartesian2D(name) {\n\t\n\t        Cartesian.call(this, name);\n\t    }\n\t\n\t    Cartesian2D.prototype = {\n\t\n\t        constructor: Cartesian2D,\n\t\n\t        type: 'cartesian2d',\n\t\n\t        /**\n\t         * @type {Array.<string>}\n\t         * @readOnly\n\t         */\n\t        dimensions: ['x', 'y'],\n\t\n\t        /**\n\t         * Base axis will be used on stacking.\n\t         *\n\t         * @return {module:echarts/coord/cartesian/Axis2D}\n\t         */\n\t        getBaseAxis: function () {\n\t            return this.getAxesByScale('ordinal')[0]\n\t                || this.getAxesByScale('time')[0]\n\t                || this.getAxis('x');\n\t        },\n\t\n\t        /**\n\t         * If contain point\n\t         * @param {Array.<number>} point\n\t         * @return {boolean}\n\t         */\n\t        containPoint: function (point) {\n\t            var axisX = this.getAxis('x');\n\t            var axisY = this.getAxis('y');\n\t            return axisX.contain(axisX.toLocalCoord(point[0]))\n\t                && axisY.contain(axisY.toLocalCoord(point[1]));\n\t        },\n\t\n\t        /**\n\t         * If contain data\n\t         * @param {Array.<number>} data\n\t         * @return {boolean}\n\t         */\n\t        containData: function (data) {\n\t            return this.getAxis('x').containData(data[0])\n\t                && this.getAxis('y').containData(data[1]);\n\t        },\n\t\n\t        /**\n\t         * Convert series data to an array of points\n\t         * @param {module:echarts/data/List} data\n\t         * @param {boolean} stack\n\t         * @return {Array}\n\t         *  Return array of points. For example:\n\t         *  `[[10, 10], [20, 20], [30, 30]]`\n\t         */\n\t        dataToPoints: function (data, stack) {\n\t            return data.mapArray(['x', 'y'], function (x, y) {\n\t                return this.dataToPoint([x, y]);\n\t            }, stack, this);\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} data\n\t         * @param {boolean} [clamp=false]\n\t         * @return {Array.<number>}\n\t         */\n\t        dataToPoint: function (data, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n\t                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n\t            ];\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} point\n\t         * @param {boolean} [clamp=false]\n\t         * @return {Array.<number>}\n\t         */\n\t        pointToData: function (point, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n\t                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n\t            ];\n\t        },\n\t\n\t        /**\n\t         * Get other axis\n\t         * @param {module:echarts/coord/cartesian/Axis2D} axis\n\t         */\n\t        getOtherAxis: function (axis) {\n\t            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Cartesian2D, Cartesian);\n\t\n\t    module.exports = Cartesian2D;\n\n\n/***/ },\n/* 120 */\n/*!******************************************!*\\\n  !*** ./lib/coord/cartesian/GridModel.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Grid \n\t//  Cartesian2D \n\t\n\t\n\t    __webpack_require__(/*! ./AxisModel */ 53);\n\t    var ComponentModel = __webpack_require__(/*! ../../model/Component */ 12);\n\t\n\t    module.exports = ComponentModel.extend({\n\t\n\t        type: 'grid',\n\t\n\t        dependencies: ['xAxis', 'yAxis'],\n\t\n\t        layoutMode: 'box',\n\t\n\t        /**\n\t         * @type {module:echarts/coord/cartesian/Grid}\n\t         */\n\t        coordinateSystem: null,\n\t\n\t        defaultOption: {\n\t            show: false,\n\t            zlevel: 0,\n\t            z: 0,\n\t            left: '10%',\n\t            top: 60,\n\t            right: '10%',\n\t            bottom: 60,\n\t            // If grid size contain label\n\t            containLabel: false,\n\t            // width: {totalWidth} - left - right,\n\t            // height: {totalHeight} - top - bottom,\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            borderWidth: 1,\n\t            borderColor: '#ccc'\n\t        }\n\t    });\n\n\n/***/ },\n/* 121 */\n/*!**************************************************!*\\\n  !*** ./lib/coord/cartesian/axisLabelInterval.js ***!\n  \\**************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Helper function for axisLabelInterval calculation\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var axisHelper = __webpack_require__(/*! ../axisHelper */ 22);\n\t\n\t    module.exports = function (axis) {\n\t        var axisModel = axis.model;\n\t        var labelModel = axisModel.getModel('axisLabel');\n\t        var labelInterval = labelModel.get('interval');\n\t        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n\t            return labelInterval === 'auto' ? 0 : labelInterval;\n\t        }\n\t\n\t        return axisHelper.getAxisLabelInterval(\n\t            zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis),\n\t            axisModel.getFormattedLabels(),\n\t            labelModel.getModel('textStyle').getFont(),\n\t            axis.isHorizontal()\n\t        );\n\t    };\n\n\n/***/ },\n/* 122 */\n/*!*******************************!*\\\n  !*** ./lib/layout/barGrid.js ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var numberUtil = __webpack_require__(/*! ../util/number */ 4);\n\t    var parsePercent = numberUtil.parsePercent;\n\t\n\t    function getSeriesStackId(seriesModel) {\n\t        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n\t    }\n\t\n\t    function getAxisKey(axis) {\n\t        return axis.dim + axis.index;\n\t    }\n\t\n\t    function calBarWidthAndOffset(barSeries, api) {\n\t        // Columns info on each category axis. Key is cartesian name\n\t        var columnsMap = {};\n\t\n\t        zrUtil.each(barSeries, function (seriesModel, idx) {\n\t            var data = seriesModel.getData();\n\t            var cartesian = seriesModel.coordinateSystem;\n\t\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var axisExtent = baseAxis.getExtent();\n\t            var bandWidth = baseAxis.type === 'category'\n\t                ? baseAxis.getBandWidth()\n\t                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\t\n\t            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n\t                bandWidth: bandWidth,\n\t                remainedWidth: bandWidth,\n\t                autoWidthCount: 0,\n\t                categoryGap: '20%',\n\t                gap: '30%',\n\t                stacks: {}\n\t            };\n\t            var stacks = columnsOnAxis.stacks;\n\t            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n\t\n\t            var stackId = getSeriesStackId(seriesModel);\n\t\n\t            if (!stacks[stackId]) {\n\t                columnsOnAxis.autoWidthCount++;\n\t            }\n\t            stacks[stackId] = stacks[stackId] || {\n\t                width: 0,\n\t                maxWidth: 0\n\t            };\n\t\n\t            var barWidth = parsePercent(\n\t                seriesModel.get('barWidth'), bandWidth\n\t            );\n\t            var barMaxWidth = parsePercent(\n\t                seriesModel.get('barMaxWidth'), bandWidth\n\t            );\n\t            var barGap = seriesModel.get('barGap');\n\t            var barCategoryGap = seriesModel.get('barCategoryGap');\n\t            // TODO\n\t            if (barWidth && !stacks[stackId].width) {\n\t                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n\t                stacks[stackId].width = barWidth;\n\t                columnsOnAxis.remainedWidth -= barWidth;\n\t            }\n\t\n\t            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n\t            (barGap != null) && (columnsOnAxis.gap = barGap);\n\t            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n\t        });\n\t\n\t        var result = {};\n\t\n\t        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\t\n\t            result[coordSysName] = {};\n\t\n\t            var stacks = columnsOnAxis.stacks;\n\t            var bandWidth = columnsOnAxis.bandWidth;\n\t            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n\t            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\t\n\t            var remainedWidth = columnsOnAxis.remainedWidth;\n\t            var autoWidthCount = columnsOnAxis.autoWidthCount;\n\t            var autoWidth = (remainedWidth - categoryGap)\n\t                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n\t            autoWidth = Math.max(autoWidth, 0);\n\t\n\t            // Find if any auto calculated bar exceeded maxBarWidth\n\t            zrUtil.each(stacks, function (column, stack) {\n\t                var maxWidth = column.maxWidth;\n\t                if (!column.width && maxWidth && maxWidth < autoWidth) {\n\t                    maxWidth = Math.min(maxWidth, remainedWidth);\n\t                    remainedWidth -= maxWidth;\n\t                    column.width = maxWidth;\n\t                    autoWidthCount--;\n\t                }\n\t            });\n\t\n\t            // Recalculate width again\n\t            autoWidth = (remainedWidth - categoryGap)\n\t                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n\t            autoWidth = Math.max(autoWidth, 0);\n\t\n\t            var widthSum = 0;\n\t            var lastColumn;\n\t            zrUtil.each(stacks, function (column, idx) {\n\t                if (!column.width) {\n\t                    column.width = autoWidth;\n\t                }\n\t                lastColumn = column;\n\t                widthSum += column.width * (1 + barGapPercent);\n\t            });\n\t            if (lastColumn) {\n\t                widthSum -= lastColumn.width * barGapPercent;\n\t            }\n\t\n\t            var offset = -widthSum / 2;\n\t            zrUtil.each(stacks, function (column, stackId) {\n\t                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n\t                    offset: offset,\n\t                    width: column.width\n\t                };\n\t\n\t                offset += column.width * (1 + barGapPercent);\n\t            });\n\t        });\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {string} seriesType\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function barLayoutGrid(seriesType, ecModel, api) {\n\t\n\t        var barWidthAndOffset = calBarWidthAndOffset(\n\t            zrUtil.filter(\n\t                ecModel.getSeriesByType(seriesType),\n\t                function (seriesModel) {\n\t                    return !ecModel.isSeriesFiltered(seriesModel)\n\t                        && seriesModel.coordinateSystem\n\t                        && seriesModel.coordinateSystem.type === 'cartesian2d';\n\t                }\n\t            )\n\t        );\n\t\n\t        var lastStackCoords = {};\n\t        var lastStackCoordsOrigin = {};\n\t\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t\n\t            var data = seriesModel.getData();\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t\n\t            var stackId = getSeriesStackId(seriesModel);\n\t            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n\t            var columnOffset = columnLayoutInfo.offset;\n\t            var columnWidth = columnLayoutInfo.width;\n\t            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\t\n\t            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\t\n\t            var valueAxisStart = baseAxis.onZero\n\t                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n\t                : valueAxis.getGlobalExtent()[0];\n\t\n\t            var coords = cartesian.dataToPoints(data, true);\n\t            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n\t            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\t\n\t            data.setLayout({\n\t                offset: columnOffset,\n\t                size: columnWidth\n\t            });\n\t\n\t            data.each(valueAxis.dim, function (value, idx) {\n\t                // \n\t                if (isNaN(value)) {\n\t                    return;\n\t                }\n\t                if (!lastStackCoords[stackId][idx]) {\n\t                    lastStackCoords[stackId][idx] = {\n\t                        p: valueAxisStart, // Positive stack\n\t                        n: valueAxisStart  // Negative stack\n\t                    };\n\t                    lastStackCoordsOrigin[stackId][idx] = {\n\t                        p: valueAxisStart, // Positive stack\n\t                        n: valueAxisStart  // Negative stack\n\t                    };\n\t                }\n\t                var sign = value >= 0 ? 'p' : 'n';\n\t                var coord = coords[idx];\n\t                var lastCoord = lastStackCoords[stackId][idx][sign];\n\t                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n\t                var x;\n\t                var y;\n\t                var width;\n\t                var height;\n\t\n\t                if (valueAxis.isHorizontal()) {\n\t                    x = lastCoord;\n\t                    y = coord[1] + columnOffset;\n\t                    width = coord[0] - lastCoordOrigin;\n\t                    height = columnWidth;\n\t\n\t                    lastStackCoordsOrigin[stackId][idx][sign] += width;\n\t                    if (Math.abs(width) < barMinHeight) {\n\t                        width = (width < 0 ? -1 : 1) * barMinHeight;\n\t                    }\n\t                    lastStackCoords[stackId][idx][sign] += width;\n\t                }\n\t                else {\n\t                    x = coord[0] + columnOffset;\n\t                    y = lastCoord;\n\t                    width = columnWidth;\n\t                    height = coord[1] - lastCoordOrigin;\n\t\n\t                    lastStackCoordsOrigin[stackId][idx][sign] += height;\n\t                    if (Math.abs(height) < barMinHeight) {\n\t                        // Include zero to has a positive bar\n\t                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n\t                    }\n\t                    lastStackCoords[stackId][idx][sign] += height;\n\t                }\n\t\n\t                data.setItemLayout(idx, {\n\t                    x: x,\n\t                    y: y,\n\t                    width: width,\n\t                    height: height\n\t                });\n\t            }, true);\n\t\n\t        }, this);\n\t    }\n\t\n\t    module.exports = barLayoutGrid;\n\n\n/***/ },\n/* 123 */\n/*!********************************!*\\\n  !*** ./lib/loading/default.js ***!\n  \\********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var graphic = __webpack_require__(/*! ../util/graphic */ 3);\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var PI = Math.PI;\n\t    /**\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     * @param {Object} [opts]\n\t     * @param {string} [opts.text]\n\t     * @param {string} [opts.color]\n\t     * @param {string} [opts.textColor]\n\t     * @return {module:zrender/Element}\n\t     */\n\t    module.exports = function (api, opts) {\n\t        opts = opts || {};\n\t        zrUtil.defaults(opts, {\n\t            text: 'loading',\n\t            color: '#c23531',\n\t            textColor: '#000',\n\t            maskColor: 'rgba(255, 255, 255, 0.8)',\n\t            zlevel: 0\n\t        });\n\t        var mask = new graphic.Rect({\n\t            style: {\n\t                fill: opts.maskColor\n\t            },\n\t            zlevel: opts.zlevel,\n\t            z: 10000\n\t        });\n\t        var arc = new graphic.Arc({\n\t            shape: {\n\t                startAngle: -PI / 2,\n\t                endAngle: -PI / 2 + 0.1,\n\t                r: 10\n\t            },\n\t            style: {\n\t                stroke: opts.color,\n\t                lineCap: 'round',\n\t                lineWidth: 5\n\t            },\n\t            zlevel: opts.zlevel,\n\t            z: 10001\n\t        });\n\t        var labelRect = new graphic.Rect({\n\t            style: {\n\t                fill: 'none',\n\t                text: opts.text,\n\t                textPosition: 'right',\n\t                textDistance: 10,\n\t                textFill: opts.textColor\n\t            },\n\t            zlevel: opts.zlevel,\n\t            z: 10001\n\t        });\n\t\n\t        arc.animateShape(true)\n\t            .when(1000, {\n\t                endAngle: PI * 3 / 2\n\t            })\n\t            .start('circularInOut');\n\t        arc.animateShape(true)\n\t            .when(1000, {\n\t                startAngle: PI * 3 / 2\n\t            })\n\t            .delay(300)\n\t            .start('circularInOut');\n\t\n\t        var group = new graphic.Group();\n\t        group.add(arc);\n\t        group.add(labelRect);\n\t        group.add(mask);\n\t        // Inject resize\n\t        group.resize = function () {\n\t            var cx = api.getWidth() / 2;\n\t            var cy = api.getHeight() / 2;\n\t            arc.setShape({\n\t                cx: cx,\n\t                cy: cy\n\t            });\n\t            var r = arc.shape.r;\n\t            labelRect.setShape({\n\t                x: cx - r,\n\t                y: cy - r,\n\t                width: r * 2,\n\t                height: r * 2\n\t            });\n\t\n\t            mask.setShape({\n\t                x: 0,\n\t                y: 0,\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t        };\n\t        group.resize();\n\t        return group;\n\t    };\n\n\n/***/ },\n/* 124 */\n/*!*****************************!*\\\n  !*** ./lib/model/Global.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * ECharts global model\n\t *\n\t * @module {echarts/model/Global}\n\t */\n\t\n\t\n\t\n\t    /**\n\t     * Caution: If the mechanism should be changed some day, these cases\n\t     * should be considered:\n\t     *\n\t     * (1) In `merge option` mode, if using the same option to call `setOption`\n\t     * many times, the result should be the same (try our best to ensure that).\n\t     * (2) In `merge option` mode, if a component has no id/name specified, it\n\t     * will be merged by index, and the result sequence of the components is\n\t     * consistent to the original sequence.\n\t     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n\t     * `mergeOption` in module:echarts/model/OptionManager.\n\t     */\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var modelUtil = __webpack_require__(/*! ../util/model */ 7);\n\t    var Model = __webpack_require__(/*! ./Model */ 10);\n\t    var each = zrUtil.each;\n\t    var filter = zrUtil.filter;\n\t    var map = zrUtil.map;\n\t    var isArray = zrUtil.isArray;\n\t    var indexOf = zrUtil.indexOf;\n\t    var isObject = zrUtil.isObject;\n\t\n\t    var ComponentModel = __webpack_require__(/*! ./Component */ 12);\n\t\n\t    var globalDefault = __webpack_require__(/*! ./globalDefault */ 126);\n\t\n\t    var OPTION_INNER_KEY = '\\0_ec_inner';\n\t\n\t    /**\n\t     * @alias module:echarts/model/Global\n\t     *\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {Object} theme\n\t     */\n\t    var GlobalModel = Model.extend({\n\t\n\t        constructor: GlobalModel,\n\t\n\t        init: function (option, parentModel, theme, optionManager) {\n\t            theme = theme || {};\n\t\n\t            this.option = null; // Mark as not initialized.\n\t\n\t            /**\n\t             * @type {module:echarts/model/Model}\n\t             * @private\n\t             */\n\t            this._theme = new Model(theme);\n\t\n\t            /**\n\t             * @type {module:echarts/model/OptionManager}\n\t             */\n\t            this._optionManager = optionManager;\n\t        },\n\t\n\t        setOption: function (option, optionPreprocessorFuncs) {\n\t            zrUtil.assert(\n\t                !(OPTION_INNER_KEY in option),\n\t                'please use chart.getOption()'\n\t            );\n\t\n\t            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\t\n\t            this.resetOption();\n\t        },\n\t\n\t        /**\n\t         * @param {string} type null/undefined: reset all.\n\t         *                      'recreate': force recreate all.\n\t         *                      'timeline': only reset timeline option\n\t         *                      'media': only reset media query option\n\t         * @return {boolean} Whether option changed.\n\t         */\n\t        resetOption: function (type) {\n\t            var optionChanged = false;\n\t            var optionManager = this._optionManager;\n\t\n\t            if (!type || type === 'recreate') {\n\t                var baseOption = optionManager.mountOption(type === 'recreate');\n\t\n\t                if (!this.option || type === 'recreate') {\n\t                    initBase.call(this, baseOption);\n\t                }\n\t                else {\n\t                    this.restoreData();\n\t                    this.mergeOption(baseOption);\n\t                }\n\t                optionChanged = true;\n\t            }\n\t\n\t            if (type === 'timeline' || type === 'media') {\n\t                this.restoreData();\n\t            }\n\t\n\t            if (!type || type === 'recreate' || type === 'timeline') {\n\t                var timelineOption = optionManager.getTimelineOption(this);\n\t                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n\t            }\n\t\n\t            if (!type || type === 'recreate' || type === 'media') {\n\t                var mediaOptions = optionManager.getMediaOption(this, this._api);\n\t                if (mediaOptions.length) {\n\t                    each(mediaOptions, function (mediaOption) {\n\t                        this.mergeOption(mediaOption, optionChanged = true);\n\t                    }, this);\n\t                }\n\t            }\n\t\n\t            return optionChanged;\n\t        },\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        mergeOption: function (newOption) {\n\t            var option = this.option;\n\t            var componentsMap = this._componentsMap;\n\t            var newCptTypes = [];\n\t\n\t            //  component model  merge\n\t            each(newOption, function (componentOption, mainType) {\n\t                if (componentOption == null) {\n\t                    return;\n\t                }\n\t\n\t                if (!ComponentModel.hasClass(mainType)) {\n\t                    option[mainType] = option[mainType] == null\n\t                        ? zrUtil.clone(componentOption)\n\t                        : zrUtil.merge(option[mainType], componentOption, true);\n\t                }\n\t                else {\n\t                    newCptTypes.push(mainType);\n\t                }\n\t            });\n\t\n\t            // FIXME OPTION \n\t            ComponentModel.topologicalTravel(\n\t                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n\t            );\n\t\n\t            this._seriesIndices = this._seriesIndices || [];\n\t\n\t            function visitComponent(mainType, dependencies) {\n\t                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\t\n\t                var mapResult = modelUtil.mappingToExists(\n\t                    componentsMap[mainType], newCptOptionList\n\t                );\n\t\n\t                makeKeyInfo(mainType, mapResult);\n\t\n\t                var dependentModels = getComponentsByTypes(\n\t                    componentsMap, dependencies\n\t                );\n\t\n\t                option[mainType] = [];\n\t                componentsMap[mainType] = [];\n\t\n\t                each(mapResult, function (resultItem, index) {\n\t                    var componentModel = resultItem.exist;\n\t                    var newCptOption = resultItem.option;\n\t\n\t                    zrUtil.assert(\n\t                        isObject(newCptOption) || componentModel,\n\t                        'Empty component definition'\n\t                    );\n\t\n\t                    // Consider where is no new option and should be merged using {},\n\t                    // see removeEdgeAndAdd in topologicalTravel and\n\t                    // ComponentModel.getAllClassMainTypes.\n\t                    if (!newCptOption) {\n\t                        componentModel.mergeOption({}, this);\n\t                        componentModel.optionUpdated({}, false);\n\t                    }\n\t                    else {\n\t                        var ComponentModelClass = ComponentModel.getClass(\n\t                            mainType, resultItem.keyInfo.subType, true\n\t                        );\n\t\n\t                        if (componentModel && componentModel instanceof ComponentModelClass) {\n\t                            componentModel.name = resultItem.keyInfo.name;\n\t                            componentModel.mergeOption(newCptOption, this);\n\t                            componentModel.optionUpdated(newCptOption, false);\n\t                        }\n\t                        else {\n\t                            // PENDING Global as parent ?\n\t                            var extraOpt = zrUtil.extend(\n\t                                {\n\t                                    dependentModels: dependentModels,\n\t                                    componentIndex: index\n\t                                },\n\t                                resultItem.keyInfo\n\t                            );\n\t                            componentModel = new ComponentModelClass(\n\t                                newCptOption, this, this, extraOpt\n\t                            );\n\t                            zrUtil.extend(componentModel, extraOpt);\n\t                            componentModel.init(newCptOption, this, this, extraOpt);\n\t                            // Call optionUpdated after init.\n\t                            // newCptOption has been used as componentModel.option\n\t                            // and may be merged with theme and default, so pass null\n\t                            // to avoid confusion.\n\t                            componentModel.optionUpdated(null, true);\n\t                        }\n\t                    }\n\t\n\t                    componentsMap[mainType][index] = componentModel;\n\t                    option[mainType][index] = componentModel.option;\n\t                }, this);\n\t\n\t                // Backup series for filtering.\n\t                if (mainType === 'series') {\n\t                    this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get option for output (cloned option and inner info removed)\n\t         * @public\n\t         * @return {Object}\n\t         */\n\t        getOption: function () {\n\t            var option = zrUtil.clone(this.option);\n\t\n\t            each(option, function (opts, mainType) {\n\t                if (ComponentModel.hasClass(mainType)) {\n\t                    var opts = modelUtil.normalizeToArray(opts);\n\t                    for (var i = opts.length - 1; i >= 0; i--) {\n\t                        // Remove options with inner id.\n\t                        if (modelUtil.isIdInner(opts[i])) {\n\t                            opts.splice(i, 1);\n\t                        }\n\t                    }\n\t                    option[mainType] = opts;\n\t                }\n\t            });\n\t\n\t            delete option[OPTION_INNER_KEY];\n\t\n\t            return option;\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/model/Model}\n\t         */\n\t        getTheme: function () {\n\t            return this._theme;\n\t        },\n\t\n\t        /**\n\t         * @param {string} mainType\n\t         * @param {number} [idx=0]\n\t         * @return {module:echarts/model/Component}\n\t         */\n\t        getComponent: function (mainType, idx) {\n\t            var list = this._componentsMap[mainType];\n\t            if (list) {\n\t                return list[idx || 0];\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object} condition\n\t         * @param {string} condition.mainType\n\t         * @param {string} [condition.subType] If ignore, only query by mainType\n\t         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n\t         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n\t         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n\t         * @return {Array.<module:echarts/model/Component>}\n\t         */\n\t        queryComponents: function (condition) {\n\t            var mainType = condition.mainType;\n\t            if (!mainType) {\n\t                return [];\n\t            }\n\t\n\t            var index = condition.index;\n\t            var id = condition.id;\n\t            var name = condition.name;\n\t\n\t            var cpts = this._componentsMap[mainType];\n\t\n\t            if (!cpts || !cpts.length) {\n\t                return [];\n\t            }\n\t\n\t            var result;\n\t\n\t            if (index != null) {\n\t                if (!isArray(index)) {\n\t                    index = [index];\n\t                }\n\t                result = filter(map(index, function (idx) {\n\t                    return cpts[idx];\n\t                }), function (val) {\n\t                    return !!val;\n\t                });\n\t            }\n\t            else if (id != null) {\n\t                var isIdArray = isArray(id);\n\t                result = filter(cpts, function (cpt) {\n\t                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n\t                        || (!isIdArray && cpt.id === id);\n\t                });\n\t            }\n\t            else if (name != null) {\n\t                var isNameArray = isArray(name);\n\t                result = filter(cpts, function (cpt) {\n\t                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n\t                        || (!isNameArray && cpt.name === name);\n\t                });\n\t            }\n\t            else {\n\t                // Return all components with mainType\n\t                result = cpts;\n\t            }\n\t\n\t            return filterBySubType(result, condition);\n\t        },\n\t\n\t        /**\n\t         * The interface is different from queryComponents,\n\t         * which is convenient for inner usage.\n\t         *\n\t         * @usage\n\t         * var result = findComponents(\n\t         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n\t         * );\n\t         * var result = findComponents(\n\t         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n\t         * );\n\t         * var result = findComponents(\n\t         *     {mainType: 'series'},\n\t         *     function (model, index) {...}\n\t         * );\n\t         * // result like [component0, componnet1, ...]\n\t         *\n\t         * @param {Object} condition\n\t         * @param {string} condition.mainType Mandatory.\n\t         * @param {string} [condition.subType] Optional.\n\t         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n\t         *        where xxx is mainType.\n\t         *        If query attribute is null/undefined or has no index/id/name,\n\t         *        do not filtering by query conditions, which is convenient for\n\t         *        no-payload situations or when target of action is global.\n\t         * @param {Function} [condition.filter] parameter: component, return boolean.\n\t         * @return {Array.<module:echarts/model/Component>}\n\t         */\n\t        findComponents: function (condition) {\n\t            var query = condition.query;\n\t            var mainType = condition.mainType;\n\t\n\t            var queryCond = getQueryCond(query);\n\t            var result = queryCond\n\t                ? this.queryComponents(queryCond)\n\t                : this._componentsMap[mainType];\n\t\n\t            return doFilter(filterBySubType(result, condition));\n\t\n\t            function getQueryCond(q) {\n\t                var indexAttr = mainType + 'Index';\n\t                var idAttr = mainType + 'Id';\n\t                var nameAttr = mainType + 'Name';\n\t                return q && (\n\t                        q.hasOwnProperty(indexAttr)\n\t                        || q.hasOwnProperty(idAttr)\n\t                        || q.hasOwnProperty(nameAttr)\n\t                    )\n\t                    ? {\n\t                        mainType: mainType,\n\t                        // subType will be filtered finally.\n\t                        index: q[indexAttr],\n\t                        id: q[idAttr],\n\t                        name: q[nameAttr]\n\t                    }\n\t                    : null;\n\t            }\n\t\n\t            function doFilter(res) {\n\t                return condition.filter\n\t                     ? filter(res, condition.filter)\n\t                     : res;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @usage\n\t         * eachComponent('legend', function (legendModel, index) {\n\t         *     ...\n\t         * });\n\t         * eachComponent(function (componentType, model, index) {\n\t         *     // componentType does not include subType\n\t         *     // (componentType is 'xxx' but not 'xxx.aa')\n\t         * });\n\t         * eachComponent(\n\t         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n\t         *     function (model, index) {...}\n\t         * );\n\t         * eachComponent(\n\t         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n\t         *     function (model, index) {...}\n\t         * );\n\t         *\n\t         * @param {string|Object=} mainType When mainType is object, the definition\n\t         *                                  is the same as the method 'findComponents'.\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachComponent: function (mainType, cb, context) {\n\t            var componentsMap = this._componentsMap;\n\t\n\t            if (typeof mainType === 'function') {\n\t                context = cb;\n\t                cb = mainType;\n\t                each(componentsMap, function (components, componentType) {\n\t                    each(components, function (component, index) {\n\t                        cb.call(context, componentType, component, index);\n\t                    });\n\t                });\n\t            }\n\t            else if (zrUtil.isString(mainType)) {\n\t                each(componentsMap[mainType], cb, context);\n\t            }\n\t            else if (isObject(mainType)) {\n\t                var queryResult = this.findComponents(mainType);\n\t                each(queryResult, cb, context);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         * @return {Array.<module:echarts/model/Series>}\n\t         */\n\t        getSeriesByName: function (name) {\n\t            var series = this._componentsMap.series;\n\t            return filter(series, function (oneSeries) {\n\t                return oneSeries.name === name;\n\t            });\n\t        },\n\t\n\t        /**\n\t         * @param {number} seriesIndex\n\t         * @return {module:echarts/model/Series}\n\t         */\n\t        getSeriesByIndex: function (seriesIndex) {\n\t            return this._componentsMap.series[seriesIndex];\n\t        },\n\t\n\t        /**\n\t         * @param {string} subType\n\t         * @return {Array.<module:echarts/model/Series>}\n\t         */\n\t        getSeriesByType: function (subType) {\n\t            var series = this._componentsMap.series;\n\t            return filter(series, function (oneSeries) {\n\t                return oneSeries.subType === subType;\n\t            });\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:echarts/model/Series>}\n\t         */\n\t        getSeries: function () {\n\t            return this._componentsMap.series.slice();\n\t        },\n\t\n\t        /**\n\t         * After filtering, series may be different\n\t         * frome raw series.\n\t         *\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachSeries: function (cb, context) {\n\t            assertSeriesInitialized(this);\n\t            each(this._seriesIndices, function (rawSeriesIndex) {\n\t                var series = this._componentsMap.series[rawSeriesIndex];\n\t                cb.call(context, series, rawSeriesIndex);\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * Iterate raw series before filtered.\n\t         *\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachRawSeries: function (cb, context) {\n\t            each(this._componentsMap.series, cb, context);\n\t        },\n\t\n\t        /**\n\t         * After filtering, series may be different.\n\t         * frome raw series.\n\t         *\n\t         * @parma {string} subType\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachSeriesByType: function (subType, cb, context) {\n\t            assertSeriesInitialized(this);\n\t            each(this._seriesIndices, function (rawSeriesIndex) {\n\t                var series = this._componentsMap.series[rawSeriesIndex];\n\t                if (series.subType === subType) {\n\t                    cb.call(context, series, rawSeriesIndex);\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * Iterate raw series before filtered of given type.\n\t         *\n\t         * @parma {string} subType\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachRawSeriesByType: function (subType, cb, context) {\n\t            return each(this.getSeriesByType(subType), cb, context);\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/model/Series} seriesModel\n\t         */\n\t        isSeriesFiltered: function (seriesModel) {\n\t            assertSeriesInitialized(this);\n\t            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n\t        },\n\t\n\t        /**\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        filterSeries: function (cb, context) {\n\t            assertSeriesInitialized(this);\n\t            var filteredSeries = filter(\n\t                this._componentsMap.series, cb, context\n\t            );\n\t            this._seriesIndices = createSeriesIndices(filteredSeries);\n\t        },\n\t\n\t        restoreData: function () {\n\t            var componentsMap = this._componentsMap;\n\t\n\t            this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t\n\t            var componentTypes = [];\n\t            each(componentsMap, function (components, componentType) {\n\t                componentTypes.push(componentType);\n\t            });\n\t\n\t            ComponentModel.topologicalTravel(\n\t                componentTypes,\n\t                ComponentModel.getAllClassMainTypes(),\n\t                function (componentType, dependencies) {\n\t                    each(componentsMap[componentType], function (component) {\n\t                        component.restoreData();\n\t                    });\n\t                }\n\t            );\n\t        }\n\t\n\t    });\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function mergeTheme(option, theme) {\n\t        zrUtil.each(theme, function (themeItem, name) {\n\t            //  component model  merge  model \n\t            if (!ComponentModel.hasClass(name)) {\n\t                if (typeof themeItem === 'object') {\n\t                    option[name] = !option[name]\n\t                        ? zrUtil.clone(themeItem)\n\t                        : zrUtil.merge(option[name], themeItem, false);\n\t                }\n\t                else {\n\t                    if (option[name] == null) {\n\t                        option[name] = themeItem;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    }\n\t\n\t    function initBase(baseOption) {\n\t        baseOption = baseOption;\n\t\n\t        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n\t        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\t        this.option = {};\n\t        this.option[OPTION_INNER_KEY] = 1;\n\t\n\t        /**\n\t         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t\n\t        /**\n\t         * Mapping between filtered series list and raw series list.\n\t         * key: filtered series indices, value: raw series indices.\n\t         * @type {Array.<nubmer>}\n\t         * @private\n\t         */\n\t        this._seriesIndices = null;\n\t\n\t        mergeTheme(baseOption, this._theme.option);\n\t\n\t        // TODO Needs clone when merging to the unexisted property\n\t        zrUtil.merge(baseOption, globalDefault, false);\n\t\n\t        this.mergeOption(baseOption);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     * @param {Array.<string>|string} types model types\n\t     * @return {Object} key: {string} type, value: {Array.<Object>} models\n\t     */\n\t    function getComponentsByTypes(componentsMap, types) {\n\t        if (!zrUtil.isArray(types)) {\n\t            types = types ? [types] : [];\n\t        }\n\t\n\t        var ret = {};\n\t        each(types, function (type) {\n\t            ret[type] = (componentsMap[type] || []).slice();\n\t        });\n\t\n\t        return ret;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeKeyInfo(mainType, mapResult) {\n\t        // We use this id to hash component models and view instances\n\t        // in echarts. id can be specified by user, or auto generated.\n\t\n\t        // The id generation rule ensures new view instance are able\n\t        // to mapped to old instance when setOption are called in\n\t        // no-merge mode. So we generate model id by name and plus\n\t        // type in view id.\n\t\n\t        // name can be duplicated among components, which is convenient\n\t        // to specify multi components (like series) by one name.\n\t\n\t        // Ensure that each id is distinct.\n\t        var idMap = {};\n\t\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            existCpt && (idMap[existCpt.id] = item);\n\t        });\n\t\n\t        each(mapResult, function (item, index) {\n\t            var opt = item.option;\n\t\n\t            zrUtil.assert(\n\t                !opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item,\n\t                'id duplicates: ' + (opt && opt.id)\n\t            );\n\t\n\t            opt && opt.id != null && (idMap[opt.id] = item);\n\t\n\t            // Complete subType\n\t            if (isObject(opt)) {\n\t                var subType = determineSubType(mainType, opt, item.exist);\n\t                item.keyInfo = {mainType: mainType, subType: subType};\n\t            }\n\t        });\n\t\n\t        // Make name and id.\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            var opt = item.option;\n\t            var keyInfo = item.keyInfo;\n\t\n\t            if (!isObject(opt)) {\n\t                return;\n\t            }\n\t\n\t            // name can be overwitten. Consider case: axis.name = '20km'.\n\t            // But id generated by name will not be changed, which affect\n\t            // only in that case: setOption with 'not merge mode' and view\n\t            // instance will be recreated, which can be accepted.\n\t            keyInfo.name = opt.name != null\n\t                ? opt.name + ''\n\t                : existCpt\n\t                ? existCpt.name\n\t                : '\\0-';\n\t\n\t            if (existCpt) {\n\t                keyInfo.id = existCpt.id;\n\t            }\n\t            else if (opt.id != null) {\n\t                keyInfo.id = opt.id + '';\n\t            }\n\t            else {\n\t                // Consider this situatoin:\n\t                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n\t                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n\t                // Series with the same name between optionA and optionB\n\t                // should be mapped.\n\t                var idNum = 0;\n\t                do {\n\t                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n\t                }\n\t                while (idMap[keyInfo.id]);\n\t            }\n\t\n\t            idMap[keyInfo.id] = item;\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function determineSubType(mainType, newCptOption, existComponent) {\n\t        var subType = newCptOption.type\n\t            ? newCptOption.type\n\t            : existComponent\n\t            ? existComponent.subType\n\t            // Use determineSubType only when there is no existComponent.\n\t            : ComponentModel.determineSubType(mainType, newCptOption);\n\t\n\t        // tooltip, markline, markpoint may always has no subType\n\t        return subType;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function createSeriesIndices(seriesModels) {\n\t        return map(seriesModels, function (series) {\n\t            return series.componentIndex;\n\t        }) || [];\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function filterBySubType(components, condition) {\n\t        // Using hasOwnProperty for restrict. Consider\n\t        // subType is undefined in user payload.\n\t        return condition.hasOwnProperty('subType')\n\t            ? filter(components, function (cpt) {\n\t                return cpt.subType === condition.subType;\n\t            })\n\t            : components;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function assertSeriesInitialized(ecModel) {\n\t        // Components that use _seriesIndices should depends on series component,\n\t        // which make sure that their initialization is after series.\n\t        if (false) {\n\t            if (!ecModel._seriesIndices) {\n\t                throw new Error('Series has not been initialized yet.');\n\t            }\n\t        }\n\t    }\n\t\n\t    zrUtil.mixin(GlobalModel, __webpack_require__(/*! ./mixin/colorPalette */ 56));\n\t\n\t    module.exports = GlobalModel;\n\n\n/***/ },\n/* 125 */\n/*!************************************!*\\\n  !*** ./lib/model/OptionManager.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * ECharts option manager\n\t *\n\t * @module {echarts/model/OptionManager}\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var modelUtil = __webpack_require__(/*! ../util/model */ 7);\n\t    var ComponentModel = __webpack_require__(/*! ./Component */ 12);\n\t    var each = zrUtil.each;\n\t    var clone = zrUtil.clone;\n\t    var map = zrUtil.map;\n\t    var merge = zrUtil.merge;\n\t\n\t    var QUERY_REG = /^(min|max)?(.+)$/;\n\t\n\t    /**\n\t     * TERM EXPLANATIONS:\n\t     *\n\t     * [option]:\n\t     *\n\t     *     An object that contains definitions of components. For example:\n\t     *     var option = {\n\t     *         title: {...},\n\t     *         legend: {...},\n\t     *         visualMap: {...},\n\t     *         series: [\n\t     *             {data: [...]},\n\t     *             {data: [...]},\n\t     *             ...\n\t     *         ]\n\t     *     };\n\t     *\n\t     * [rawOption]:\n\t     *\n\t     *     An object input to echarts.setOption. 'rawOption' may be an\n\t     *     'option', or may be an object contains multi-options. For example:\n\t     *     var option = {\n\t     *         baseOption: {\n\t     *             title: {...},\n\t     *             legend: {...},\n\t     *             series: [\n\t     *                 {data: [...]},\n\t     *                 {data: [...]},\n\t     *                 ...\n\t     *             ]\n\t     *         },\n\t     *         timeline: {...},\n\t     *         options: [\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             ...\n\t     *         ],\n\t     *         media: [\n\t     *             {\n\t     *                 query: {maxWidth: 320},\n\t     *                 option: {series: {x: 20}, visualMap: {show: false}}\n\t     *             },\n\t     *             {\n\t     *                 query: {minWidth: 320, maxWidth: 720},\n\t     *                 option: {series: {x: 500}, visualMap: {show: true}}\n\t     *             },\n\t     *             {\n\t     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n\t     *             }\n\t     *         ]\n\t     *     };\n\t     *\n\t     * @alias module:echarts/model/OptionManager\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function OptionManager(api) {\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:echarts/ExtensionAPI}\n\t         */\n\t        this._api = api;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._timelineOptions = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._mediaList = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._mediaDefault;\n\t\n\t        /**\n\t         * -1, means default.\n\t         * empty means no media.\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._currentMediaIndices = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._optionBackup;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._newBaseOption;\n\t    }\n\t\n\t    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n\t    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n\t    // rawOption cloned and backuped when timeline changed, which does no\n\t    // good to performance. What's more, that both timeline and setOption\n\t    // method supply 'notMerge' brings complex and some problems.\n\t    // Consider this case:\n\t    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n\t    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\t\n\t    OptionManager.prototype = {\n\t\n\t        constructor: OptionManager,\n\t\n\t        /**\n\t         * @public\n\t         * @param {Object} rawOption Raw option.\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @param {Array.<Function>} optionPreprocessorFuncs\n\t         * @return {Object} Init option\n\t         */\n\t        setOption: function (rawOption, optionPreprocessorFuncs) {\n\t            rawOption = clone(rawOption, true);\n\t\n\t            // FIXME\n\t            //  timeline options  media baseOption\n\t\n\t            var oldOptionBackup = this._optionBackup;\n\t            var newParsedOption = parseRawOption.call(\n\t                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n\t            );\n\t            this._newBaseOption = newParsedOption.baseOption;\n\t\n\t            // For setOption at second time (using merge mode);\n\t            if (oldOptionBackup) {\n\t                // Only baseOption can be merged.\n\t                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\t\n\t                // For simplicity, timeline options and media options do not support merge,\n\t                // that is, if you `setOption` twice and both has timeline options, the latter\n\t                // timeline opitons will not be merged to the formers, but just substitude them.\n\t                if (newParsedOption.timelineOptions.length) {\n\t                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n\t                }\n\t                if (newParsedOption.mediaList.length) {\n\t                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n\t                }\n\t                if (newParsedOption.mediaDefault) {\n\t                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n\t                }\n\t            }\n\t            else {\n\t                this._optionBackup = newParsedOption;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {boolean} isRecreate\n\t         * @return {Object}\n\t         */\n\t        mountOption: function (isRecreate) {\n\t            var optionBackup = this._optionBackup;\n\t\n\t            // TODO\n\t            // resetclone\n\t\n\t            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n\t            this._mediaList = map(optionBackup.mediaList, clone);\n\t            this._mediaDefault = clone(optionBackup.mediaDefault);\n\t            this._currentMediaIndices = [];\n\t\n\t            return clone(isRecreate\n\t                // this._optionBackup.baseOption, which is created at the first `setOption`\n\t                // called, and is merged into every new option by inner method `mergeOption`\n\t                // each time `setOption` called, can be only used in `isRecreate`, because\n\t                // its reliability is under suspicion. In other cases option merge is\n\t                // proformed by `model.mergeOption`.\n\t                ? optionBackup.baseOption : this._newBaseOption\n\t            );\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @return {Object}\n\t         */\n\t        getTimelineOption: function (ecModel) {\n\t            var option;\n\t            var timelineOptions = this._timelineOptions;\n\t\n\t            if (timelineOptions.length) {\n\t                // getTimelineOption can only be called after ecModel inited,\n\t                // so we can get currentIndex from timelineModel.\n\t                var timelineModel = ecModel.getComponent('timeline');\n\t                if (timelineModel) {\n\t                    option = clone(\n\t                        timelineOptions[timelineModel.getCurrentIndex()],\n\t                        true\n\t                    );\n\t                }\n\t            }\n\t\n\t            return option;\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @return {Array.<Object>}\n\t         */\n\t        getMediaOption: function (ecModel) {\n\t            var ecWidth = this._api.getWidth();\n\t            var ecHeight = this._api.getHeight();\n\t            var mediaList = this._mediaList;\n\t            var mediaDefault = this._mediaDefault;\n\t            var indices = [];\n\t            var result = [];\n\t\n\t            // No media defined.\n\t            if (!mediaList.length && !mediaDefault) {\n\t                return result;\n\t            }\n\t\n\t            // Multi media may be applied, the latter defined media has higher priority.\n\t            for (var i = 0, len = mediaList.length; i < len; i++) {\n\t                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n\t                    indices.push(i);\n\t                }\n\t            }\n\t\n\t            // FIXME\n\t            // mediaDefault\n\t            if (!indices.length && mediaDefault) {\n\t                indices = [-1];\n\t            }\n\t\n\t            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n\t                result = map(indices, function (index) {\n\t                    return clone(\n\t                        index === -1 ? mediaDefault.option : mediaList[index].option\n\t                    );\n\t                });\n\t            }\n\t            // Otherwise return nothing.\n\t\n\t            this._currentMediaIndices = indices;\n\t\n\t            return result;\n\t        }\n\t    };\n\t\n\t    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n\t        var timelineOptions = [];\n\t        var mediaList = [];\n\t        var mediaDefault;\n\t        var baseOption;\n\t\n\t        // Compatible with ec2.\n\t        var timelineOpt = rawOption.timeline;\n\t\n\t        if (rawOption.baseOption) {\n\t            baseOption = rawOption.baseOption;\n\t        }\n\t\n\t        // For timeline\n\t        if (timelineOpt || rawOption.options) {\n\t            baseOption = baseOption || {};\n\t            timelineOptions = (rawOption.options || []).slice();\n\t        }\n\t\n\t        // For media query\n\t        if (rawOption.media) {\n\t            baseOption = baseOption || {};\n\t            var media = rawOption.media;\n\t            each(media, function (singleMedia) {\n\t                if (singleMedia && singleMedia.option) {\n\t                    if (singleMedia.query) {\n\t                        mediaList.push(singleMedia);\n\t                    }\n\t                    else if (!mediaDefault) {\n\t                        // Use the first media default.\n\t                        mediaDefault = singleMedia;\n\t                    }\n\t                }\n\t            });\n\t        }\n\t\n\t        // For normal option\n\t        if (!baseOption) {\n\t            baseOption = rawOption;\n\t        }\n\t\n\t        // Set timelineOpt to baseOption in ec3,\n\t        // which is convenient for merge option.\n\t        if (!baseOption.timeline) {\n\t            baseOption.timeline = timelineOpt;\n\t        }\n\t\n\t        // Preprocess.\n\t        each([baseOption].concat(timelineOptions)\n\t            .concat(zrUtil.map(mediaList, function (media) {\n\t                return media.option;\n\t            })),\n\t            function (option) {\n\t                each(optionPreprocessorFuncs, function (preProcess) {\n\t                    preProcess(option, isNew);\n\t                });\n\t            }\n\t        );\n\t\n\t        return {\n\t            baseOption: baseOption,\n\t            timelineOptions: timelineOptions,\n\t            mediaDefault: mediaDefault,\n\t            mediaList: mediaList\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n\t     * Support: width, height, aspectRatio\n\t     * Can use max or min as prefix.\n\t     */\n\t    function applyMediaQuery(query, ecWidth, ecHeight) {\n\t        var realMap = {\n\t            width: ecWidth,\n\t            height: ecHeight,\n\t            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n\t        };\n\t\n\t        var applicatable = true;\n\t\n\t        zrUtil.each(query, function (value, attr) {\n\t            var matched = attr.match(QUERY_REG);\n\t\n\t            if (!matched || !matched[1] || !matched[2]) {\n\t                return;\n\t            }\n\t\n\t            var operator = matched[1];\n\t            var realAttr = matched[2].toLowerCase();\n\t\n\t            if (!compare(realMap[realAttr], value, operator)) {\n\t                applicatable = false;\n\t            }\n\t        });\n\t\n\t        return applicatable;\n\t    }\n\t\n\t    function compare(real, expect, operator) {\n\t        if (operator === 'min') {\n\t            return real >= expect;\n\t        }\n\t        else if (operator === 'max') {\n\t            return real <= expect;\n\t        }\n\t        else { // Equals\n\t            return real === expect;\n\t        }\n\t    }\n\t\n\t    function indicesEquals(indices1, indices2) {\n\t        // indices is always order by asc and has only finite number.\n\t        return indices1.join(',') === indices2.join(',');\n\t    }\n\t\n\t    /**\n\t     * Consider case:\n\t     * `chart.setOption(opt1);`\n\t     * Then user do some interaction like dataZoom, dataView changing.\n\t     * `chart.setOption(opt2);`\n\t     * Then user press 'reset button' in toolbox.\n\t     *\n\t     * After doing that all of the interaction effects should be reset, the\n\t     * chart should be the same as the result of invoke\n\t     * `chart.setOption(opt1); chart.setOption(opt2);`.\n\t     *\n\t     * Although it is not able ensure that\n\t     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n\t     * `chart.setOption(merge(opt1, opt2));` exactly,\n\t     * this might be the only simple way to implement that feature.\n\t     *\n\t     * MEMO: We've considered some other approaches:\n\t     * 1. Each model handle its self restoration but not uniform treatment.\n\t     *     (Too complex in logic and error-prone)\n\t     * 2. Use a shadow ecModel. (Performace expensive)\n\t     */\n\t    function mergeOption(oldOption, newOption) {\n\t        newOption = newOption || {};\n\t\n\t        each(newOption, function (newCptOpt, mainType) {\n\t            if (newCptOpt == null) {\n\t                return;\n\t            }\n\t\n\t            var oldCptOpt = oldOption[mainType];\n\t\n\t            if (!ComponentModel.hasClass(mainType)) {\n\t                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n\t            }\n\t            else {\n\t                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n\t                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\t\n\t                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\t\n\t                oldOption[mainType] = map(mapResult, function (item) {\n\t                    return (item.option && item.exist)\n\t                        ? merge(item.exist, item.option, true)\n\t                        : (item.exist || item.option);\n\t                });\n\t            }\n\t        });\n\t    }\n\t\n\t    module.exports = OptionManager;\n\n\n/***/ },\n/* 126 */\n/*!************************************!*\\\n  !*** ./lib/model/globalDefault.js ***!\n  \\************************************/\n/***/ function(module, exports) {\n\n\t\n\t    var platform = '';\n\t    // Navigator not exists in node\n\t    if (typeof navigator !== 'undefined') {\n\t        platform = navigator.platform || '';\n\t    }\n\t    module.exports = {\n\t        // \n\t        // backgroundColor: 'rgba(0,0,0,0)',\n\t\n\t        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n\t        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n\t        // \n\t        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n\t        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n\t        // \n\t        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\t\n\t        //  Grid \n\t        // grid: {},\n\t        // \n\t        textStyle: {\n\t            // color: '#000',\n\t            // decoration: 'none',\n\t            // PENDING\n\t            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n\t            // fontFamily: 'Arial, Verdana, sans-serif',\n\t            fontSize: 12,\n\t            fontStyle: 'normal',\n\t            fontWeight: 'normal'\n\t        },\n\t\n\t        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n\t        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t        // Default is source-over\n\t        blendMode: null,\n\t\n\t        animation: true,\n\t        animationDuration: 1000,\n\t        animationDurationUpdate: 300,\n\t        animationEasing: 'exponentialOut',\n\t        animationEasingUpdate: 'cubicOut',\n\t\n\t        animationThreshold: 2000,\n\t        // Configuration for progressive/incremental rendering\n\t        progressiveThreshold: 3000,\n\t        progressive: 400,\n\t\n\t        // Threshold of if use single hover layer to optimize.\n\t        hoverLayerThreshold: 3000\n\t    };\n\n\n/***/ },\n/* 127 */\n/*!**************************************!*\\\n  !*** ./lib/model/mixin/areaStyle.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    module.exports = {\n\t        getAreaStyle: __webpack_require__(/*! ./makeStyleMapper */ 31)(\n\t            [\n\t                ['fill', 'color'],\n\t                ['shadowBlur'],\n\t                ['shadowOffsetX'],\n\t                ['shadowOffsetY'],\n\t                ['opacity'],\n\t                ['shadowColor']\n\t            ]\n\t        )\n\t    };\n\n\n/***/ },\n/* 128 */\n/*!**************************************!*\\\n  !*** ./lib/model/mixin/boxLayout.js ***!\n  \\**************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        getBoxLayoutParams: function () {\n\t            return {\n\t                left: this.get('left'),\n\t                top: this.get('top'),\n\t                right: this.get('right'),\n\t                bottom: this.get('bottom'),\n\t                width: this.get('width'),\n\t                height: this.get('height')\n\t            };\n\t        }\n\t    };\n\n\n/***/ },\n/* 129 */\n/*!**************************************!*\\\n  !*** ./lib/model/mixin/itemStyle.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var getItemStyle = __webpack_require__(/*! ./makeStyleMapper */ 31)(\n\t        [\n\t            ['fill', 'color'],\n\t            ['stroke', 'borderColor'],\n\t            ['lineWidth', 'borderWidth'],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor'],\n\t            ['textPosition'],\n\t            ['textAlign']\n\t        ]\n\t    );\n\t    module.exports = {\n\t        getItemStyle: function (excludes) {\n\t            var style = getItemStyle.call(this, excludes);\n\t            var lineDash = this.getBorderLineDash();\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t\n\t        getBorderLineDash: function () {\n\t            var lineType = this.get('borderType');\n\t            return (lineType === 'solid' || lineType == null) ? null\n\t                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n\t        }\n\t    };\n\n\n/***/ },\n/* 130 */\n/*!**************************************!*\\\n  !*** ./lib/model/mixin/lineStyle.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var getLineStyle = __webpack_require__(/*! ./makeStyleMapper */ 31)(\n\t        [\n\t            ['lineWidth', 'width'],\n\t            ['stroke', 'color'],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]\n\t    );\n\t    module.exports = {\n\t        getLineStyle: function (excludes) {\n\t            var style = getLineStyle.call(this, excludes);\n\t            var lineDash = this.getLineDash(style.lineWidth);\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t\n\t        getLineDash: function (lineWidth) {\n\t            if (lineWidth == null) {\n\t                lineWidth = 1;\n\t            }\n\t            var lineType = this.get('type');\n\t            var dotSize = Math.max(lineWidth, 2);\n\t            var dashSize = lineWidth * 4;\n\t            return (lineType === 'solid' || lineType == null) ? null\n\t                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n\t        }\n\t    };\n\n\n/***/ },\n/* 131 */\n/*!**************************************!*\\\n  !*** ./lib/model/mixin/textStyle.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textContain = __webpack_require__(/*! zrender/lib/contain/text */ 16);\n\t\n\t    function getShallow(model, path) {\n\t        return model && model.getShallow(path);\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Get color property or get color from option.textStyle.color\n\t         * @return {string}\n\t         */\n\t        getTextColor: function () {\n\t            var ecModel = this.ecModel;\n\t            return this.getShallow('color')\n\t                || (ecModel && ecModel.get('textStyle.color'));\n\t        },\n\t\n\t        /**\n\t         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n\t         * @return {string}\n\t         */\n\t        getFont: function () {\n\t            var ecModel = this.ecModel;\n\t            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n\t            return [\n\t                // FIXME in node-canvas fontWeight is before fontStyle\n\t                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n\t                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n\t                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n\t                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n\t            ].join(' ');\n\t        },\n\t\n\t        getTextRect: function (text) {\n\t            var textStyle = this.get('textStyle') || {};\n\t            return textContain.getBoundingRect(\n\t                text,\n\t                this.getFont(),\n\t                textStyle.align,\n\t                textStyle.baseline\n\t            );\n\t        },\n\t\n\t        truncateText: function (text, containerWidth, ellipsis, options) {\n\t            return textContain.truncateText(\n\t                text, containerWidth, this.getFont(), ellipsis, options\n\t            );\n\t        }\n\t    };\n\n\n/***/ },\n/* 132 */\n/*!********************************************!*\\\n  !*** ./lib/preprocessor/backwardCompat.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Compatitable with 2.0\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var compatStyle = __webpack_require__(/*! ./helper/compatStyle */ 133);\n\t\n\t    function get(opt, path) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        for (var i = 0; i < path.length; i++) {\n\t            obj = obj && obj[path[i]];\n\t            if (obj == null) {\n\t                break;\n\t            }\n\t        }\n\t        return obj;\n\t    }\n\t\n\t    function set(opt, path, val, overwrite) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        var key;\n\t        for (var i = 0; i < path.length - 1; i++) {\n\t            key = path[i];\n\t            if (obj[key] == null) {\n\t                obj[key] = {};\n\t            }\n\t            obj = obj[key];\n\t        }\n\t        if (overwrite || obj[path[i]] == null) {\n\t            obj[path[i]] = val;\n\t        }\n\t    }\n\t\n\t    function compatLayoutProperties(option) {\n\t        each(LAYOUT_PROPERTIES, function (prop) {\n\t            if (prop[0] in option && !(prop[1] in option)) {\n\t                option[prop[1]] = option[prop[0]];\n\t            }\n\t        });\n\t    }\n\t\n\t    var LAYOUT_PROPERTIES = [\n\t        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n\t    ];\n\t\n\t    var COMPATITABLE_COMPONENTS = [\n\t        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n\t    ];\n\t\n\t    var COMPATITABLE_SERIES = [\n\t        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n\t        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n\t        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n\t    ];\n\t\n\t    var each = zrUtil.each;\n\t\n\t    module.exports = function (option) {\n\t        each(option.series, function (seriesOpt) {\n\t            if (!zrUtil.isObject(seriesOpt)) {\n\t                return;\n\t            }\n\t\n\t            var seriesType = seriesOpt.type;\n\t\n\t            compatStyle(seriesOpt);\n\t\n\t            if (seriesType === 'pie' || seriesType === 'gauge') {\n\t                if (seriesOpt.clockWise != null) {\n\t                    seriesOpt.clockwise = seriesOpt.clockWise;\n\t                }\n\t            }\n\t            if (seriesType === 'gauge') {\n\t                var pointerColor = get(seriesOpt, 'pointer.color');\n\t                pointerColor != null\n\t                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n\t            }\n\t\n\t            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n\t                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n\t                    compatLayoutProperties(seriesOpt);\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t\n\t        // dataRange has changed to visualMap\n\t        if (option.dataRange) {\n\t            option.visualMap = option.dataRange;\n\t        }\n\t\n\t        each(COMPATITABLE_COMPONENTS, function (componentName) {\n\t            var options = option[componentName];\n\t            if (options) {\n\t                if (!zrUtil.isArray(options)) {\n\t                    options = [options];\n\t                }\n\t                each(options, function (option) {\n\t                    compatLayoutProperties(option);\n\t                });\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n/* 133 */\n/*!************************************************!*\\\n  !*** ./lib/preprocessor/helper/compatStyle.js ***!\n  \\************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t\n\t    var POSSIBLE_STYLES = [\n\t        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n\t        'chordStyle', 'label', 'labelLine'\n\t    ];\n\t\n\t    function compatItemStyle(opt) {\n\t        var itemStyleOpt = opt && opt.itemStyle;\n\t        if (itemStyleOpt) {\n\t            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n\t                var normalItemStyleOpt = itemStyleOpt.normal;\n\t                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n\t                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].normal) {\n\t                        opt[styleName].normal = normalItemStyleOpt[styleName];\n\t                    }\n\t                    else {\n\t                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n\t                    }\n\t                    normalItemStyleOpt[styleName] = null;\n\t                }\n\t                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].emphasis) {\n\t                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n\t                    }\n\t                    else {\n\t                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n\t                    }\n\t                    emphasisItemStyleOpt[styleName] = null;\n\t                }\n\t            });\n\t        }\n\t    }\n\t\n\t    module.exports = function (seriesOpt) {\n\t        if (!seriesOpt) {\n\t            return;\n\t        }\n\t        compatItemStyle(seriesOpt);\n\t        compatItemStyle(seriesOpt.markPoint);\n\t        compatItemStyle(seriesOpt.markLine);\n\t        var data = seriesOpt.data;\n\t        if (data) {\n\t            for (var i = 0; i < data.length; i++) {\n\t                compatItemStyle(data[i]);\n\t            }\n\t            // mark point data\n\t            var markPoint = seriesOpt.markPoint;\n\t            if (markPoint && markPoint.data) {\n\t                var mpData = markPoint.data;\n\t                for (var i = 0; i < mpData.length; i++) {\n\t                    compatItemStyle(mpData[i]);\n\t                }\n\t            }\n\t            // mark line data\n\t            var markLine = seriesOpt.markLine;\n\t            if (markLine && markLine.data) {\n\t                var mlData = markLine.data;\n\t                for (var i = 0; i < mlData.length; i++) {\n\t                    if (zrUtil.isArray(mlData[i])) {\n\t                        compatItemStyle(mlData[i][0]);\n\t                        compatItemStyle(mlData[i][1]);\n\t                    }\n\t                    else {\n\t                        compatItemStyle(mlData[i]);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\n\n/***/ },\n/* 134 */\n/*!*************************************!*\\\n  !*** ./lib/processor/dataSample.js ***!\n  \\*************************************/\n/***/ function(module, exports) {\n\n\t\n\t    var samplers = {\n\t        average: function (frame) {\n\t            var sum = 0;\n\t            var count = 0;\n\t            for (var i = 0; i < frame.length; i++) {\n\t                if (!isNaN(frame[i])) {\n\t                    sum += frame[i];\n\t                    count++;\n\t                }\n\t            }\n\t            // Return NaN if count is 0\n\t            return count === 0 ? NaN : sum / count;\n\t        },\n\t        sum: function (frame) {\n\t            var sum = 0;\n\t            for (var i = 0; i < frame.length; i++) {\n\t                // Ignore NaN\n\t                sum += frame[i] || 0;\n\t            }\n\t            return sum;\n\t        },\n\t        max: function (frame) {\n\t            var max = -Infinity;\n\t            for (var i = 0; i < frame.length; i++) {\n\t                frame[i] > max && (max = frame[i]);\n\t            }\n\t            return max;\n\t        },\n\t        min: function (frame) {\n\t            var min = Infinity;\n\t            for (var i = 0; i < frame.length; i++) {\n\t                frame[i] < min && (min = frame[i]);\n\t            }\n\t            return min;\n\t        },\n\t        // TODO\n\t        // Median\n\t        nearest: function (frame) {\n\t            return frame[0];\n\t        }\n\t    };\n\t\n\t    var indexSampler = function (frame, value) {\n\t        return Math.round(frame.length / 2);\n\t    };\n\t    module.exports = function (seriesType, ecModel, api) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var sampling = seriesModel.get('sampling');\n\t            var coordSys = seriesModel.coordinateSystem;\n\t            // Only cartesian2d support down sampling\n\t            if (coordSys.type === 'cartesian2d' && sampling) {\n\t                var baseAxis = coordSys.getBaseAxis();\n\t                var valueAxis = coordSys.getOtherAxis(baseAxis);\n\t                var extent = baseAxis.getExtent();\n\t                // Coordinste system has been resized\n\t                var size = extent[1] - extent[0];\n\t                var rate = Math.round(data.count() / size);\n\t                if (rate > 1) {\n\t                    var sampler;\n\t                    if (typeof sampling === 'string') {\n\t                        sampler = samplers[sampling];\n\t                    }\n\t                    else if (typeof sampling === 'function') {\n\t                        sampler = sampling;\n\t                    }\n\t                    if (sampler) {\n\t                        data = data.downSample(\n\t                            valueAxis.dim, 1 / rate, sampler, indexSampler\n\t                        );\n\t                        seriesModel.setData(data);\n\t                    }\n\t                }\n\t            }\n\t        }, this);\n\t    };\n\n\n/***/ },\n/* 135 */\n/*!**************************!*\\\n  !*** ./lib/scale/Log.js ***!\n  \\**************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Log scale\n\t * @module echarts/scale/Log\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var Scale = __webpack_require__(/*! ./Scale */ 32);\n\t    var numberUtil = __webpack_require__(/*! ../util/number */ 4);\n\t\n\t    // Use some method of IntervalScale\n\t    var IntervalScale = __webpack_require__(/*! ./Interval */ 38);\n\t\n\t    var scaleProto = Scale.prototype;\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t\n\t    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n\t    var roundingErrorFix = numberUtil.round;\n\t\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t    var mathPow = Math.pow;\n\t\n\t    var mathLog = Math.log;\n\t\n\t    var LogScale = Scale.extend({\n\t\n\t        type: 'log',\n\t\n\t        base: 10,\n\t\n\t        $constructor: function () {\n\t            Scale.apply(this, arguments);\n\t            this._originalScale = new IntervalScale();\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getTicks: function () {\n\t            var originalScale = this._originalScale;\n\t            var extent = this._extent;\n\t            var originalExtent = originalScale.getExtent();\n\t\n\t            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n\t                var powVal = numberUtil.round(mathPow(this.base, val));\n\t\n\t                // Fix #4158\n\t                powVal = (val === extent[0] && originalScale.__fixMin)\n\t                    ? fixRoundingError(powVal, originalExtent[0])\n\t                    : powVal;\n\t                powVal = (val === extent[1] && originalScale.__fixMax)\n\t                    ? fixRoundingError(powVal, originalExtent[1])\n\t                    : powVal;\n\t\n\t                return powVal;\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * @param {number} val\n\t         * @return {string}\n\t         */\n\t        getLabel: intervalScaleProto.getLabel,\n\t\n\t        /**\n\t         * @param  {number} val\n\t         * @return {number}\n\t         */\n\t        scale: function (val) {\n\t            val = scaleProto.scale.call(this, val);\n\t            return mathPow(this.base, val);\n\t        },\n\t\n\t        /**\n\t         * @param {number} start\n\t         * @param {number} end\n\t         */\n\t        setExtent: function (start, end) {\n\t            var base = this.base;\n\t            start = mathLog(start) / mathLog(base);\n\t            end = mathLog(end) / mathLog(base);\n\t            intervalScaleProto.setExtent.call(this, start, end);\n\t        },\n\t\n\t        /**\n\t         * @return {number} end\n\t         */\n\t        getExtent: function () {\n\t            var base = this.base;\n\t            var extent = scaleProto.getExtent.call(this);\n\t            extent[0] = mathPow(base, extent[0]);\n\t            extent[1] = mathPow(base, extent[1]);\n\t\n\t            // Fix #4158\n\t            var originalScale = this._originalScale;\n\t            var originalExtent = originalScale.getExtent();\n\t            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n\t            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\t\n\t            return extent;\n\t        },\n\t\n\t        /**\n\t         * @param  {Array.<number>} extent\n\t         */\n\t        unionExtent: function (extent) {\n\t            this._originalScale.unionExtent(extent);\n\t\n\t            var base = this.base;\n\t            extent[0] = mathLog(extent[0]) / mathLog(base);\n\t            extent[1] = mathLog(extent[1]) / mathLog(base);\n\t            scaleProto.unionExtent.call(this, extent);\n\t        },\n\t\n\t        /**\n\t         * Update interval and extent of intervals for nice ticks\n\t         * @param  {number} [approxTickNum = 10] Given approx tick number\n\t         */\n\t        niceTicks: function (approxTickNum) {\n\t            approxTickNum = approxTickNum || 10;\n\t            var extent = this._extent;\n\t            var span = extent[1] - extent[0];\n\t            if (span === Infinity || span <= 0) {\n\t                return;\n\t            }\n\t\n\t            var interval = numberUtil.quantity(span);\n\t            var err = approxTickNum / span * interval;\n\t\n\t            // Filter ticks to get closer to the desired count.\n\t            if (err <= 0.5) {\n\t                interval *= 10;\n\t            }\n\t\n\t            // Interval should be integer\n\t            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n\t                interval *= 10;\n\t            }\n\t\n\t            var niceExtent = [\n\t                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n\t                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n\t            ];\n\t\n\t            this._interval = interval;\n\t            this._niceExtent = niceExtent;\n\t        },\n\t\n\t        /**\n\t         * Nice extent.\n\t         * @param {number} [approxTickNum = 10] Given approx tick number\n\t         * @param {boolean} [fixMin=false]\n\t         * @param {boolean} [fixMax=false]\n\t         */\n\t        niceExtent: function (splitNumber, fixMin, fixMax) {\n\t            intervalScaleProto.niceExtent.call(this, splitNumber, fixMin, fixMax);\n\t\n\t            var originalScale = this._originalScale;\n\t            originalScale.__fixMin = fixMin;\n\t            originalScale.__fixMax = fixMax;\n\t        }\n\t\n\t    });\n\t\n\t    zrUtil.each(['contain', 'normalize'], function (methodName) {\n\t        LogScale.prototype[methodName] = function (val) {\n\t            val = mathLog(val) / mathLog(this.base);\n\t            return scaleProto[methodName].call(this, val);\n\t        };\n\t    });\n\t\n\t    LogScale.create = function () {\n\t        return new LogScale();\n\t    };\n\t\n\t    function fixRoundingError(val, originalVal) {\n\t        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n\t    }\n\t\n\t    module.exports = LogScale;\n\n\n/***/ },\n/* 136 */\n/*!******************************!*\\\n  !*** ./lib/scale/Ordinal.js ***!\n  \\******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Linear continuous scale\n\t * @module echarts/coord/scale/Ordinal\n\t *\n\t * http://en.wikipedia.org/wiki/Level_of_measurement\n\t */\n\t\n\t// FIXME only one data\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var Scale = __webpack_require__(/*! ./Scale */ 32);\n\t\n\t    var scaleProto = Scale.prototype;\n\t\n\t    var OrdinalScale = Scale.extend({\n\t\n\t        type: 'ordinal',\n\t\n\t        init: function (data, extent) {\n\t            this._data = data;\n\t            this._extent = extent || [0, data.length - 1];\n\t        },\n\t\n\t        parse: function (val) {\n\t            return typeof val === 'string'\n\t                ? zrUtil.indexOf(this._data, val)\n\t                // val might be float.\n\t                : Math.round(val);\n\t        },\n\t\n\t        contain: function (rank) {\n\t            rank = this.parse(rank);\n\t            return scaleProto.contain.call(this, rank)\n\t                && this._data[rank] != null;\n\t        },\n\t\n\t        /**\n\t         * Normalize given rank or name to linear [0, 1]\n\t         * @param {number|string} [val]\n\t         * @return {number}\n\t         */\n\t        normalize: function (val) {\n\t            return scaleProto.normalize.call(this, this.parse(val));\n\t        },\n\t\n\t        scale: function (val) {\n\t            return Math.round(scaleProto.scale.call(this, val));\n\t        },\n\t\n\t        /**\n\t         * @return {Array}\n\t         */\n\t        getTicks: function () {\n\t            var ticks = [];\n\t            var extent = this._extent;\n\t            var rank = extent[0];\n\t\n\t            while (rank <= extent[1]) {\n\t                ticks.push(rank);\n\t                rank++;\n\t            }\n\t\n\t            return ticks;\n\t        },\n\t\n\t        /**\n\t         * Get item on rank n\n\t         * @param {number} n\n\t         * @return {string}\n\t         */\n\t        getLabel: function (n) {\n\t            return this._data[n];\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        count: function () {\n\t            return this._extent[1] - this._extent[0] + 1;\n\t        },\n\t\n\t        niceTicks: zrUtil.noop,\n\t        niceExtent: zrUtil.noop\n\t    });\n\t\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    OrdinalScale.create = function () {\n\t        return new OrdinalScale();\n\t    };\n\t\n\t    module.exports = OrdinalScale;\n\n\n/***/ },\n/* 137 */\n/*!***************************!*\\\n  !*** ./lib/scale/Time.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Interval scale\n\t * @module echarts/coord/scale/Time\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! zrender/lib/core/util */ 1);\n\t    var numberUtil = __webpack_require__(/*! ../util/number */ 4);\n\t    var formatUtil = __webpack_require__(/*! ../util/format */ 9);\n\t\n\t    var IntervalScale = __webpack_require__(/*! ./Interval */ 38);\n\t\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t\n\t    var mathCeil = Math.ceil;\n\t    var mathFloor = Math.floor;\n\t    var ONE_SECOND = 1000;\n\t    var ONE_MINUTE = ONE_SECOND * 60;\n\t    var ONE_HOUR = ONE_MINUTE * 60;\n\t    var ONE_DAY = ONE_HOUR * 24;\n\t\n\t    // FIXME \n\t    var bisect = function (a, x, lo, hi) {\n\t        while (lo < hi) {\n\t            var mid = lo + hi >>> 1;\n\t            if (a[mid][2] < x) {\n\t                lo = mid + 1;\n\t            }\n\t            else {\n\t                hi  = mid;\n\t            }\n\t        }\n\t        return lo;\n\t    };\n\t\n\t    /**\n\t     * @alias module:echarts/coord/scale/Time\n\t     * @constructor\n\t     */\n\t    var TimeScale = IntervalScale.extend({\n\t        type: 'time',\n\t\n\t        // Overwrite\n\t        getLabel: function (val) {\n\t            var stepLvl = this._stepLvl;\n\t\n\t            var date = new Date(val);\n\t\n\t            return formatUtil.formatTime(stepLvl[0], date);\n\t        },\n\t\n\t        // Overwrite\n\t        niceExtent: function (approxTickNum, fixMin, fixMax) {\n\t            var extent = this._extent;\n\t            // If extent start and end are same, expand them\n\t            if (extent[0] === extent[1]) {\n\t                // Expand extent\n\t                extent[0] -= ONE_DAY;\n\t                extent[1] += ONE_DAY;\n\t            }\n\t            // If there are no data and extent are [Infinity, -Infinity]\n\t            if (extent[1] === -Infinity && extent[0] === Infinity) {\n\t                var d = new Date();\n\t                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n\t                extent[0] = extent[1] - ONE_DAY;\n\t            }\n\t\n\t            this.niceTicks(approxTickNum);\n\t\n\t            // var extent = this._extent;\n\t            var interval = this._interval;\n\t\n\t            if (!fixMin) {\n\t                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n\t            }\n\t            if (!fixMax) {\n\t                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n\t            }\n\t        },\n\t\n\t        // Overwrite\n\t        niceTicks: function (approxTickNum) {\n\t            approxTickNum = approxTickNum || 10;\n\t\n\t            var extent = this._extent;\n\t            var span = extent[1] - extent[0];\n\t            var approxInterval = span / approxTickNum;\n\t            var scaleLevelsLen = scaleLevels.length;\n\t            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\t\n\t            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n\t            var interval = level[2];\n\t            // Same with interval scale if span is much larger than 1 year\n\t            if (level[0] === 'year') {\n\t                var yearSpan = span / interval;\n\t\n\t                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n\t                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\t\n\t                interval *= yearStep;\n\t            }\n\t\n\t            var niceExtent = [\n\t                mathCeil(extent[0] / interval) * interval,\n\t                mathFloor(extent[1] / interval) * interval\n\t            ];\n\t\n\t            this._stepLvl = level;\n\t            // Interval will be used in getTicks\n\t            this._interval = interval;\n\t            this._niceExtent = niceExtent;\n\t        },\n\t\n\t        parse: function (val) {\n\t            // val might be float.\n\t            return +numberUtil.parseDate(val);\n\t        }\n\t    });\n\t\n\t    zrUtil.each(['contain', 'normalize'], function (methodName) {\n\t        TimeScale.prototype[methodName] = function (val) {\n\t            return intervalScaleProto[methodName].call(this, this.parse(val));\n\t        };\n\t    });\n\t\n\t    // Steps from d3\n\t    var scaleLevels = [\n\t        // Format       step    interval\n\t        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n\t        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n\t        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n\t        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n\t        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n\t        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n\t        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n\t        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n\t        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n\t        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n\t        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n\t        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n\t        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n\t        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n\t        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n\t        ['week',        7,      ONE_DAY * 7],        // 7d\n\t        ['month',       1,      ONE_DAY * 31],       // 1M\n\t        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n\t        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n\t        ['year',        1,      ONE_DAY * 380]       // 1Y\n\t    ];\n\t\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    TimeScale.create = function () {\n\t        return new TimeScale();\n\t    };\n\t\n\t    module.exports = TimeScale;\n\n\n/***/ },\n/* 138 */\n/*!***********************************!*\\\n  !*** ./lib/visual/seriesColor.js ***!\n  \\***********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var Gradient = __webpack_require__(/*! zrender/lib/graphic/Gradient */ 29);\n\t    module.exports = function (ecModel) {\n\t        function encodeColor(seriesModel) {\n\t            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n\t            var data = seriesModel.getData();\n\t            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n\t                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\t\n\t            // FIXME Set color function or use the platte color\n\t            data.setVisual('color', color);\n\t\n\t            // Only visible series has each data be visual encoded\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                if (typeof color === 'function' && !(color instanceof Gradient)) {\n\t                    data.each(function (idx) {\n\t                        data.setItemVisual(\n\t                            idx, 'color', color(seriesModel.getDataParams(idx))\n\t                        );\n\t                    });\n\t                }\n\t\n\t                // itemStyle in each data item\n\t                data.each(function (idx) {\n\t                    var itemModel = data.getItemModel(idx);\n\t                    var color = itemModel.get(colorAccessPath, true);\n\t                    if (color != null) {\n\t                        data.setItemVisual(idx, 'color', color);\n\t                    }\n\t                });\n\t            }\n\t        }\n\t        ecModel.eachRawSeries(encodeColor);\n\t    };\n\n\n/***/ },\n/* 139 */\n/*!**********************************!*\\\n  !*** ./~/zrender/lib/Handler.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Handler\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(/*! ./core/util */ 1);\n\t    var Draggable = __webpack_require__(/*! ./mixin/Draggable */ 167);\n\t\n\t    var Eventful = __webpack_require__(/*! ./mixin/Eventful */ 20);\n\t\n\t    function makeEventPacket(eveType, target, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            target: target,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta,\n\t            zrByTouch: event.zrByTouch\n\t        };\n\t    }\n\t\n\t    function EmptyProxy () {}\n\t    EmptyProxy.prototype.dispose = function () {};\n\t\n\t    var handlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n\t     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n\t     */\n\t    var Handler = function(storage, painter, proxy, painterRoot) {\n\t        Eventful.call(this);\n\t\n\t        this.storage = storage;\n\t\n\t        this.painter = painter;\n\t\n\t        this.painterRoot = painterRoot;\n\t\n\t        proxy = proxy || new EmptyProxy();\n\t\n\t        /**\n\t         * Proxy of event. can be Dom, WebGLSurface, etc.\n\t         */\n\t        this.proxy = proxy;\n\t\n\t        // Attach handler\n\t        proxy.handler = this;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._hovered;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t\n\t\n\t        Draggable.call(this);\n\t\n\t        util.each(handlerNames, function (name) {\n\t            proxy.on && proxy.on(name, this[name], this);\n\t        }, this);\n\t    };\n\t\n\t    Handler.prototype = {\n\t\n\t        constructor: Handler,\n\t\n\t        mousemove: function (event) {\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t\n\t            var hovered = this.findHover(x, y, null);\n\t            var lastHovered = this._hovered;\n\t            var proxy = this.proxy;\n\t\n\t            this._hovered = hovered;\n\t\n\t            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\t\n\t            // Mouse out on previous hovered element\n\t            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n\t                this.dispatchToElement(lastHovered, 'mouseout', event);\n\t            }\n\t\n\t            // Mouse moving on one element\n\t            this.dispatchToElement(hovered, 'mousemove', event);\n\t\n\t            // Mouse over on a new element\n\t            if (hovered && hovered !== lastHovered) {\n\t                this.dispatchToElement(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t\n\t        mouseout: function (event) {\n\t            this.dispatchToElement(this._hovered, 'mouseout', event);\n\t\n\t            // There might be some doms created by upper layer application\n\t            // at the same level of painter.getViewportRoot() (e.g., tooltip\n\t            // dom created by echarts), where 'globalout' event should not\n\t            // be triggered when mouse enters these doms. (But 'mouseout'\n\t            // should be triggered at the original hovered element as usual).\n\t            var element = event.toElement || event.relatedTarget;\n\t            var innerDom;\n\t            do {\n\t                element = element && element.parentNode;\n\t            }\n\t            while (element && element.nodeType != 9 && !(\n\t                innerDom = element === this.painterRoot\n\t            ));\n\t\n\t            !innerDom && this.trigger('globalout', {event: event});\n\t        },\n\t\n\t        /**\n\t         * Resize\n\t         */\n\t        resize: function (event) {\n\t            this._hovered = null;\n\t        },\n\t\n\t        /**\n\t         * Dispatch event\n\t         * @param {string} eventName\n\t         * @param {event=} eventArgs\n\t         */\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t\n\t        /**\n\t         * Dispose\n\t         */\n\t        dispose: function () {\n\t\n\t            this.proxy.dispose();\n\t\n\t            this.storage =\n\t            this.proxy =\n\t            this.painter = null;\n\t        },\n\t\n\t        /**\n\t         * cursor style\n\t         * @param {string} [cursorStyle='default']  crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            var proxy = this.proxy;\n\t            proxy.setCursor && proxy.setCursor(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * \n\t         *\n\t         * @private\n\t         * @param {Object} targetEl \n\t         * @param {string} eventName \n\t         * @param {Object} event \n\t         */\n\t        dispatchToElement: function (targetEl, eventName, event) {\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\t\n\t            var el = targetEl;\n\t\n\t            while (el) {\n\t                el[eventHandler]\n\t                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t\n\t                el.trigger(eventName, eventPacket);\n\t\n\t                el = el.parent;\n\t\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (!eventPacket.cancelBubble) {\n\t                //  zrender \n\t                this.trigger(eventName, eventPacket);\n\t                // \n\t                //  click  dispose painter \n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof(layer[eventHandler]) == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {module:zrender/graphic/Displayable} exclude\n\t         * @method\n\t         */\n\t        findHover: function(x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            for (var i = list.length - 1; i >= 0 ; i--) {\n\t                if (!list[i].silent\n\t                 && list[i] !== exclude\n\t                 // getDisplayList may include ignored item in VML mode\n\t                 && !list[i].ignore\n\t                 && isHover(list[i], x, y)) {\n\t                    return list[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        Handler.prototype[name] = function (event) {\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY, null);\n\t\n\t            if (name === 'mousedown') {\n\t                this._downel = hovered;\n\t                // In case click triggered before mouseup\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'mosueup') {\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'click') {\n\t                if (this._downel !== this._upel) {\n\t                    return;\n\t                }\n\t            }\n\t\n\t            this.dispatchToElement(hovered, name, event);\n\t        };\n\t    });\n\t\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var el = displayable;\n\t            while (el) {\n\t                // If ancestor is silent or clipped by ancestor\n\t                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n\t                    return false;\n\t                }\n\t                el = el.parent;\n\t            }\n\t            return true;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t\n\t    module.exports = Handler;\n\n\n/***/ },\n/* 140 */\n/*!********************************!*\\\n  !*** ./~/zrender/lib/Layer.js ***!\n  \\********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/Layer\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(/*! ./core/util */ 1);\n\t    var config = __webpack_require__(/*! ./config */ 33);\n\t    var Style = __webpack_require__(/*! ./graphic/Style */ 64);\n\t    var Pattern = __webpack_require__(/*! ./graphic/Pattern */ 63);\n\t\n\t    function returnFalse() {\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * dom\n\t     *\n\t     * @inner\n\t     * @param {string} id dom id \n\t     * @param {string} type dom typesuch as canvas, div etc.\n\t     * @param {Painter} painter painter instance\n\t     * @param {number} number\n\t     */\n\t    function createDom(id, type, painter, dpr) {\n\t        var newDom = document.createElement(type);\n\t        var width = painter.getWidth();\n\t        var height = painter.getHeight();\n\t\n\t        var newDomStyle = newDom.style;\n\t        // append~\n\t        newDomStyle.position = 'absolute';\n\t        newDomStyle.left = 0;\n\t        newDomStyle.top = 0;\n\t        newDomStyle.width = width + 'px';\n\t        newDomStyle.height = height + 'px';\n\t        newDom.width = width * dpr;\n\t        newDom.height = height * dpr;\n\t\n\t        // id\n\t        newDom.setAttribute('data-zr-dom-id', id);\n\t        return newDom;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Layer\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @param {string} id\n\t     * @param {module:zrender/Painter} painter\n\t     * @param {number} [dpr]\n\t     */\n\t    var Layer = function(id, painter, dpr) {\n\t        var dom;\n\t        dpr = dpr || config.devicePixelRatio;\n\t        if (typeof id === 'string') {\n\t            dom = createDom(id, 'canvas', painter, dpr);\n\t        }\n\t        // Not using isDom because in node it will return false\n\t        else if (util.isObject(id)) {\n\t            dom = id;\n\t            id = dom.id;\n\t        }\n\t        this.id = id;\n\t        this.dom = dom;\n\t\n\t        var domStyle = dom.style;\n\t        if (domStyle) { // Not in node\n\t            dom.onselectstart = returnFalse; // \n\t            domStyle['-webkit-user-select'] = 'none';\n\t            domStyle['user-select'] = 'none';\n\t            domStyle['-webkit-touch-callout'] = 'none';\n\t            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t            domStyle['padding'] = 0;\n\t            domStyle['margin'] = 0;\n\t            domStyle['border-width'] = 0;\n\t        }\n\t\n\t        this.domBack = null;\n\t        this.ctxBack = null;\n\t\n\t        this.painter = painter;\n\t\n\t        this.config = null;\n\t\n\t        // Configs\n\t        /**\n\t         * \n\t         * @type {string}\n\t         * @default 0\n\t         */\n\t        this.clearColor = 0;\n\t        /**\n\t         * \n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        this.motionBlur = false;\n\t        /**\n\t         * alpha\n\t         * @type {number}\n\t         * @default 0.7\n\t         */\n\t        this.lastFrameAlpha = 0.7;\n\t\n\t        /**\n\t         * Layer dpr\n\t         * @type {number}\n\t         */\n\t        this.dpr = dpr;\n\t    };\n\t\n\t    Layer.prototype = {\n\t\n\t        constructor: Layer,\n\t\n\t        elCount: 0,\n\t\n\t        __dirty: true,\n\t\n\t        initContext: function () {\n\t            this.ctx = this.dom.getContext('2d');\n\t\n\t            this.ctx.dpr = this.dpr;\n\t        },\n\t\n\t        createBackBuffer: function () {\n\t            var dpr = this.dpr;\n\t\n\t            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n\t            this.ctxBack = this.domBack.getContext('2d');\n\t\n\t            if (dpr != 1) {\n\t                this.ctxBack.scale(dpr, dpr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param  {number} width\n\t         * @param  {number} height\n\t         */\n\t        resize: function (width, height) {\n\t            var dpr = this.dpr;\n\t\n\t            var dom = this.dom;\n\t            var domStyle = dom.style;\n\t            var domBack = this.domBack;\n\t\n\t            domStyle.width = width + 'px';\n\t            domStyle.height = height + 'px';\n\t\n\t            dom.width = width * dpr;\n\t            dom.height = height * dpr;\n\t\n\t            if (domBack) {\n\t                domBack.width = width * dpr;\n\t                domBack.height = height * dpr;\n\t\n\t                if (dpr != 1) {\n\t                    this.ctxBack.scale(dpr, dpr);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} clearAll Clear all with out motion blur\n\t         */\n\t        clear: function (clearAll) {\n\t            var dom = this.dom;\n\t            var ctx = this.ctx;\n\t            var width = dom.width;\n\t            var height = dom.height;\n\t\n\t            var clearColor = this.clearColor;\n\t            var haveMotionBLur = this.motionBlur && !clearAll;\n\t            var lastFrameAlpha = this.lastFrameAlpha;\n\t\n\t            var dpr = this.dpr;\n\t\n\t            if (haveMotionBLur) {\n\t                if (!this.domBack) {\n\t                    this.createBackBuffer();\n\t                }\n\t\n\t                this.ctxBack.globalCompositeOperation = 'copy';\n\t                this.ctxBack.drawImage(\n\t                    dom, 0, 0,\n\t                    width / dpr,\n\t                    height / dpr\n\t                );\n\t            }\n\t\n\t            ctx.clearRect(0, 0, width, height);\n\t            if (clearColor) {\n\t                var clearColorGradientOrPattern;\n\t                // Gradient\n\t                if (clearColor.colorStops) {\n\t                    // Cache canvas gradient\n\t                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t                        x: 0,\n\t                        y: 0,\n\t                        width: width,\n\t                        height: height\n\t                    });\n\t\n\t                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t                }\n\t                // Pattern\n\t                else if (clearColor.image) {\n\t                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t                }\n\t                ctx.save();\n\t                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t                ctx.fillRect(0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t\n\t            if (haveMotionBLur) {\n\t                var domBack = this.domBack;\n\t                ctx.save();\n\t                ctx.globalAlpha = lastFrameAlpha;\n\t                ctx.drawImage(domBack, 0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Layer;\n\n\n/***/ },\n/* 141 */\n/*!**********************************!*\\\n  !*** ./~/zrender/lib/Painter.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Default canvas painter\n\t * @module zrender/Painter\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t \n\t\n\t    var config = __webpack_require__(/*! ./config */ 33);\n\t    var util = __webpack_require__(/*! ./core/util */ 1);\n\t    var log = __webpack_require__(/*! ./core/log */ 47);\n\t    var BoundingRect = __webpack_require__(/*! ./core/BoundingRect */ 8);\n\t    var timsort = __webpack_require__(/*! ./core/timsort */ 44);\n\t\n\t    var Layer = __webpack_require__(/*! ./Layer */ 140);\n\t\n\t    var requestAnimationFrame = __webpack_require__(/*! ./animation/requestAnimationFrame */ 60);\n\t\n\t    // PENDIGN\n\t    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t    //\n\t    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\t    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    function isLayerValid(layer) {\n\t        if (!layer) {\n\t            return false;\n\t        }\n\t\n\t        if (layer.isBuildin) {\n\t            return true;\n\t        }\n\t\n\t        if (typeof(layer.resize) !== 'function'\n\t            || typeof(layer.refresh) !== 'function'\n\t        ) {\n\t            return false;\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    function preProcessLayer(layer) {\n\t        layer.__unusedCount++;\n\t    }\n\t\n\t    function postProcessLayer(layer) {\n\t        if (layer.__unusedCount == 1) {\n\t            layer.clear();\n\t        }\n\t    }\n\t\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var viewRect = new BoundingRect(0, 0, 0, 0);\n\t    function isDisplayableCulled(el, width, height) {\n\t        tmpRect.copy(el.getBoundingRect());\n\t        if (el.transform) {\n\t            tmpRect.applyTransform(el.transform);\n\t        }\n\t        viewRect.width = width;\n\t        viewRect.height = height;\n\t        return !tmpRect.intersect(viewRect);\n\t    }\n\t\n\t    function isClipPathChanged(clipPaths, prevClipPaths) {\n\t        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n\t            return false;\n\t        }\n\t\n\t        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n\t            return true;\n\t        }\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            if (clipPaths[i] !== prevClipPaths[i]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t\n\t    function doClip(clipPaths, ctx) {\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            var clipPath = clipPaths[i];\n\t            var path = clipPath.path;\n\t\n\t            clipPath.setTransform(ctx);\n\t            path.beginPath(ctx);\n\t            clipPath.buildPath(path, clipPath.shape);\n\t            ctx.clip();\n\t            // Transform back\n\t            clipPath.restoreTransform(ctx);\n\t        }\n\t    }\n\t\n\t    function createRoot(width, height) {\n\t        var domRoot = document.createElement('div');\n\t\n\t        // domRoot.onselectstart = returnFalse; // \n\t        domRoot.style.cssText = [\n\t            'position:relative',\n\t            'overflow:hidden',\n\t            'width:' + width + 'px',\n\t            'height:' + height + 'px',\n\t            'padding:0',\n\t            'margin:0',\n\t            'border-width:0'\n\t        ].join(';') + ';';\n\t\n\t        return domRoot;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Painter\n\t     * @constructor\n\t     * @param {HTMLElement} root \n\t     * @param {module:zrender/Storage} storage\n\t     * @param {Ojbect} opts\n\t     */\n\t    var Painter = function (root, storage, opts) {\n\t        // In node environment using node-canvas\n\t        var singleCanvas = !root.nodeName // In node ?\n\t            || root.nodeName.toUpperCase() === 'CANVAS';\n\t\n\t        this._opts = opts = util.extend({}, opts || {});\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._singleCanvas = singleCanvas;\n\t        /**\n\t         * \n\t         * @type {HTMLElement}\n\t         */\n\t        this.root = root;\n\t\n\t        var rootStyle = root.style;\n\t\n\t        if (rootStyle) {\n\t            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t            rootStyle['-webkit-user-select'] =\n\t            rootStyle['user-select'] =\n\t            rootStyle['-webkit-touch-callout'] = 'none';\n\t\n\t            root.innerHTML = '';\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/Storage}\n\t         */\n\t        this.storage = storage;\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        var zlevelList = this._zlevelList = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:zrender/Layer>}\n\t         * @private\n\t         */\n\t        var layers = this._layers = {};\n\t\n\t        /**\n\t         * @type {Object.<string, Object>}\n\t         * @type {private}\n\t         */\n\t        this._layerConfig = {};\n\t\n\t        if (!singleCanvas) {\n\t            this._width = this._getSize(0);\n\t            this._height = this._getSize(1);\n\t\n\t            var domRoot = this._domRoot = createRoot(\n\t                this._width, this._height\n\t            );\n\t            root.appendChild(domRoot);\n\t        }\n\t        else {\n\t            // Use canvas width and height directly\n\t            var width = root.width;\n\t            var height = root.height;\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            // Create layer if only one given canvas\n\t            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t            var mainLayer = new Layer(root, this, 1);\n\t            mainLayer.initContext();\n\t            // FIXME Use canvas width and height\n\t            // mainLayer.resize(width, height);\n\t            layers[0] = mainLayer;\n\t            zlevelList.push(0);\n\t        }\n\t\n\t        this.pathToImage = this._createPathToImage();\n\t\n\t        // Layers for progressive rendering\n\t        this._progressiveLayers = [];\n\t\n\t        /**\n\t         * @type {module:zrender/Layer}\n\t         * @private\n\t         */\n\t        this._hoverlayer;\n\t\n\t        this._hoverElements = [];\n\t    };\n\t\n\t    Painter.prototype = {\n\t\n\t        constructor: Painter,\n\t\n\t        /**\n\t         * If painter use a single canvas\n\t         * @return {boolean}\n\t         */\n\t        isSingleCanvas: function () {\n\t            return this._singleCanvas;\n\t        },\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} [paintAll=false] displayable\n\t         */\n\t        refresh: function (paintAll) {\n\t\n\t            var list = this.storage.getDisplayList(true);\n\t\n\t            var zlevelList = this._zlevelList;\n\t\n\t            this._paintList(list, paintAll);\n\t\n\t            // Paint custum layers\n\t            for (var i = 0; i < zlevelList.length; i++) {\n\t                var z = zlevelList[i];\n\t                var layer = this._layers[z];\n\t                if (!layer.isBuildin && layer.refresh) {\n\t                    layer.refresh();\n\t                }\n\t            }\n\t\n\t            this.refreshHover();\n\t\n\t            if (this._progressiveLayers.length) {\n\t                this._startProgessive();\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        addHover: function (el, hoverStyle) {\n\t            if (el.__hoverMir) {\n\t                return;\n\t            }\n\t            var elMirror = new el.constructor({\n\t                style: el.style,\n\t                shape: el.shape\n\t            });\n\t            elMirror.__from = el;\n\t            el.__hoverMir = elMirror;\n\t            elMirror.setStyle(hoverStyle);\n\t            this._hoverElements.push(elMirror);\n\t        },\n\t\n\t        removeHover: function (el) {\n\t            var elMirror = el.__hoverMir;\n\t            var hoverElements = this._hoverElements;\n\t            var idx = util.indexOf(hoverElements, elMirror);\n\t            if (idx >= 0) {\n\t                hoverElements.splice(idx, 1);\n\t            }\n\t            el.__hoverMir = null;\n\t        },\n\t\n\t        clearHover: function (el) {\n\t            var hoverElements = this._hoverElements;\n\t            for (var i = 0; i < hoverElements.length; i++) {\n\t                var from = hoverElements[i].__from;\n\t                if (from) {\n\t                    from.__hoverMir = null;\n\t                }\n\t            }\n\t            hoverElements.length = 0;\n\t        },\n\t\n\t        refreshHover: function () {\n\t            var hoverElements = this._hoverElements;\n\t            var len = hoverElements.length;\n\t            var hoverLayer = this._hoverlayer;\n\t            hoverLayer && hoverLayer.clear();\n\t\n\t            if (!len) {\n\t                return;\n\t            }\n\t            timsort(hoverElements, this.storage.displayableSortFunc);\n\t\n\t            // Use a extream large zlevel\n\t            // FIXME?\n\t            if (!hoverLayer) {\n\t                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n\t            }\n\t\n\t            var scope = {};\n\t            hoverLayer.ctx.save();\n\t            for (var i = 0; i < len;) {\n\t                var el = hoverElements[i];\n\t                var originalEl = el.__from;\n\t                // Original el is removed\n\t                // PENDING\n\t                if (!(originalEl && originalEl.__zr)) {\n\t                    hoverElements.splice(i, 1);\n\t                    originalEl.__hoverMir = null;\n\t                    len--;\n\t                    continue;\n\t                }\n\t                i++;\n\t\n\t                // Use transform\n\t                // FIXME style and shape ?\n\t                if (!originalEl.invisible) {\n\t                    el.transform = originalEl.transform;\n\t                    el.invTransform = originalEl.invTransform;\n\t                    el.__clipPaths = originalEl.__clipPaths;\n\t                    // el.\n\t                    this._doPaintEl(el, hoverLayer, true, scope);\n\t                }\n\t            }\n\t            hoverLayer.ctx.restore();\n\t        },\n\t\n\t        _startProgessive: function () {\n\t            var self = this;\n\t\n\t            if (!self._furtherProgressive) {\n\t                return;\n\t            }\n\t\n\t            // Use a token to stop progress steps triggered by\n\t            // previous zr.refresh calling.\n\t            var token = self._progressiveToken = +new Date();\n\t\n\t            self._progress++;\n\t            requestAnimationFrame(step);\n\t\n\t            function step() {\n\t                // In case refreshed or disposed\n\t                if (token === self._progressiveToken && self.storage) {\n\t\n\t                    self._doPaintList(self.storage.getDisplayList());\n\t\n\t                    if (self._furtherProgressive) {\n\t                        self._progress++;\n\t                        requestAnimationFrame(step);\n\t                    }\n\t                    else {\n\t                        self._progressiveToken = -1;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _clearProgressive: function () {\n\t            this._progressiveToken = -1;\n\t            this._progress = 0;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                layer.__dirty && layer.clear();\n\t            });\n\t        },\n\t\n\t        _paintList: function (list, paintAll) {\n\t\n\t            if (paintAll == null) {\n\t                paintAll = false;\n\t            }\n\t\n\t            this._updateLayerStatus(list);\n\t\n\t            this._clearProgressive();\n\t\n\t            this.eachBuildinLayer(preProcessLayer);\n\t\n\t            this._doPaintList(list, paintAll);\n\t\n\t            this.eachBuildinLayer(postProcessLayer);\n\t        },\n\t\n\t        _doPaintList: function (list, paintAll) {\n\t            var currentLayer;\n\t            var currentZLevel;\n\t            var ctx;\n\t\n\t            // var invTransform = [];\n\t            var scope;\n\t\n\t            var progressiveLayerIdx = 0;\n\t            var currentProgressiveLayer;\n\t\n\t            var width = this._width;\n\t            var height = this._height;\n\t            var layerProgress;\n\t            var frame = this._progress;\n\t            function flushProgressiveLayer(layer) {\n\t                var dpr = ctx.dpr || 1;\n\t                ctx.save();\n\t                ctx.globalAlpha = 1;\n\t                ctx.shadowBlur = 0;\n\t                // Avoid layer don't clear in next progressive frame\n\t                currentLayer.__dirty = true;\n\t                ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t                ctx.restore();\n\t            }\n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t\n\t                var elFrame = el.__frame;\n\t\n\t                // Flush at current context\n\t                // PENDING\n\t                if (elFrame < 0 && currentProgressiveLayer) {\n\t                    flushProgressiveLayer(currentProgressiveLayer);\n\t                    currentProgressiveLayer = null;\n\t                }\n\t\n\t                // Change draw layer\n\t                if (currentZLevel !== elZLevel) {\n\t                    if (ctx) {\n\t                        ctx.restore();\n\t                    }\n\t\n\t                    // Reset scope\n\t                    scope = {};\n\t\n\t                    // Only 0 zlevel if only has one canvas\n\t                    currentZLevel = elZLevel;\n\t                    currentLayer = this.getLayer(currentZLevel);\n\t\n\t                    if (!currentLayer.isBuildin) {\n\t                        log(\n\t                            'ZLevel ' + currentZLevel\n\t                            + ' has been used by unkown layer ' + currentLayer.id\n\t                        );\n\t                    }\n\t\n\t                    ctx = currentLayer.ctx;\n\t                    ctx.save();\n\t\n\t                    // Reset the count\n\t                    currentLayer.__unusedCount = 0;\n\t\n\t                    if (currentLayer.__dirty || paintAll) {\n\t                        currentLayer.clear();\n\t                    }\n\t                }\n\t\n\t                if (!(currentLayer.__dirty || paintAll)) {\n\t                    continue;\n\t                }\n\t\n\t                if (elFrame >= 0) {\n\t                    // Progressive layer changed\n\t                    if (!currentProgressiveLayer) {\n\t                        currentProgressiveLayer = this._progressiveLayers[\n\t                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n\t                        ];\n\t\n\t                        currentProgressiveLayer.ctx.save();\n\t                        currentProgressiveLayer.renderScope = {};\n\t\n\t                        if (currentProgressiveLayer\n\t                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n\t                        ) {\n\t                            // flushProgressiveLayer(currentProgressiveLayer);\n\t                            // Quick jump all progressive elements\n\t                            // All progressive element are not dirty, jump over and flush directly\n\t                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n\t                            // currentProgressiveLayer = null;\n\t                            continue;\n\t                        }\n\t\n\t                        layerProgress = currentProgressiveLayer.__progress;\n\t\n\t                        if (!currentProgressiveLayer.__dirty) {\n\t                            // Keep rendering\n\t                            frame = layerProgress;\n\t                        }\n\t\n\t                        currentProgressiveLayer.__progress = frame + 1;\n\t                    }\n\t\n\t                    if (elFrame === frame) {\n\t                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t                    }\n\t                }\n\t                else {\n\t                    this._doPaintEl(el, currentLayer, paintAll, scope);\n\t                }\n\t\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                flushProgressiveLayer(currentProgressiveLayer);\n\t            }\n\t\n\t            // Restore the lastLayer ctx\n\t            ctx && ctx.restore();\n\t            // If still has clipping state\n\t            // if (scope.prevElClipPaths) {\n\t            //     ctx.restore();\n\t            // }\n\t\n\t            this._furtherProgressive = false;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                if (layer.__maxProgress >= layer.__progress) {\n\t                    this._furtherProgressive = true;\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t            var ctx = currentLayer.ctx;\n\t            var m = el.transform;\n\t            if (\n\t                (currentLayer.__dirty || forcePaint)\n\t                // Ignore invisible element\n\t                && !el.invisible\n\t                // Ignore transparent element\n\t                && el.style.opacity !== 0\n\t                // Ignore scale 0 element, in some environment like node-canvas\n\t                // Draw a scale 0 element can cause all following draw wrong\n\t                // And setTransform with scale 0 will cause set back transform failed.\n\t                && !(m && !m[0] && !m[3])\n\t                // Ignore culled element\n\t                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n\t            ) {\n\t\n\t                var clipPaths = el.__clipPaths;\n\t\n\t                // Optimize when clipping on group with several elements\n\t                if (scope.prevClipLayer !== currentLayer\n\t                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n\t                ) {\n\t                    // If has previous clipping state, restore from it\n\t                    if (scope.prevElClipPaths) {\n\t                        scope.prevClipLayer.ctx.restore();\n\t                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\t\n\t                        // Reset prevEl since context has been restored\n\t                        scope.prevEl = null;\n\t                    }\n\t                    // New clipping state\n\t                    if (clipPaths) {\n\t                        ctx.save();\n\t                        doClip(clipPaths, ctx);\n\t                        scope.prevClipLayer = currentLayer;\n\t                        scope.prevElClipPaths = clipPaths;\n\t                    }\n\t                }\n\t                el.beforeBrush && el.beforeBrush(ctx);\n\t\n\t                el.brush(ctx, scope.prevEl || null);\n\t                scope.prevEl = el;\n\t\n\t                el.afterBrush && el.afterBrush(ctx);\n\t            }\n\t        },\n\t\n\t        /**\n\t         *  zlevel \n\t         * @param {number} zlevel\n\t         * @return {module:zrender/Layer}\n\t         */\n\t        getLayer: function (zlevel) {\n\t            if (this._singleCanvas) {\n\t                return this._layers[0];\n\t            }\n\t\n\t            var layer = this._layers[zlevel];\n\t            if (!layer) {\n\t                // Create a new layer\n\t                layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t                layer.isBuildin = true;\n\t\n\t                if (this._layerConfig[zlevel]) {\n\t                    util.merge(layer, this._layerConfig[zlevel], true);\n\t                }\n\t\n\t                this.insertLayer(zlevel, layer);\n\t\n\t                // Context is created after dom inserted to document\n\t                // Or excanvas will get 0px clientWidth and clientHeight\n\t                layer.initContext();\n\t            }\n\t\n\t            return layer;\n\t        },\n\t\n\t        insertLayer: function (zlevel, layer) {\n\t\n\t            var layersMap = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var len = zlevelList.length;\n\t            var prevLayer = null;\n\t            var i = -1;\n\t            var domRoot = this._domRoot;\n\t\n\t            if (layersMap[zlevel]) {\n\t                log('ZLevel ' + zlevel + ' has been used already');\n\t                return;\n\t            }\n\t            // Check if is a valid layer\n\t            if (!isLayerValid(layer)) {\n\t                log('Layer of zlevel ' + zlevel + ' is not valid');\n\t                return;\n\t            }\n\t\n\t            if (len > 0 && zlevel > zlevelList[0]) {\n\t                for (i = 0; i < len - 1; i++) {\n\t                    if (\n\t                        zlevelList[i] < zlevel\n\t                        && zlevelList[i + 1] > zlevel\n\t                    ) {\n\t                        break;\n\t                    }\n\t                }\n\t                prevLayer = layersMap[zlevelList[i]];\n\t            }\n\t            zlevelList.splice(i + 1, 0, zlevel);\n\t\n\t            if (prevLayer) {\n\t                var prevDom = prevLayer.dom;\n\t                if (prevDom.nextSibling) {\n\t                    domRoot.insertBefore(\n\t                        layer.dom,\n\t                        prevDom.nextSibling\n\t                    );\n\t                }\n\t                else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t            else {\n\t                if (domRoot.firstChild) {\n\t                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t                }\n\t                else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t\n\t            layersMap[zlevel] = layer;\n\t        },\n\t\n\t        // Iterate each layer\n\t        eachLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                cb.call(context, this._layers[z], z);\n\t            }\n\t        },\n\t\n\t        // Iterate each buildin layer\n\t        eachBuildinLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        // Iterate each other layer except buildin layer\n\t        eachOtherLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (! layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t         */\n\t        getLayers: function () {\n\t            return this._layers;\n\t        },\n\t\n\t        _updateLayerStatus: function (list) {\n\t\n\t            var layers = this._layers;\n\t            var progressiveLayers = this._progressiveLayers;\n\t\n\t            var elCountsLastFrame = {};\n\t            var progressiveElCountsLastFrame = {};\n\t\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                elCountsLastFrame[z] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                progressiveElCountsLastFrame[idx] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            var progressiveLayerCount = 0;\n\t            var currentProgressiveLayer;\n\t            var lastProgressiveKey;\n\t            var frameCount = 0;\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var layer = layers[zlevel];\n\t                var elProgress = el.progressive;\n\t                if (layer) {\n\t                    layer.elCount++;\n\t                    layer.__dirty = layer.__dirty || el.__dirty;\n\t                }\n\t\n\t                /////// Update progressive\n\t                if (elProgress >= 0) {\n\t                    // Fix wrong progressive sequence problem.\n\t                    if (lastProgressiveKey !== elProgress) {\n\t                        lastProgressiveKey = elProgress;\n\t                        frameCount++;\n\t                    }\n\t                    var elFrame = el.__frame = frameCount - 1;\n\t                    if (!currentProgressiveLayer) {\n\t                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t                        currentProgressiveLayer = progressiveLayers[idx];\n\t                        if (!currentProgressiveLayer) {\n\t                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n\t                                'progressive', this, this.dpr\n\t                            );\n\t                            currentProgressiveLayer.initContext();\n\t                        }\n\t                        currentProgressiveLayer.__maxProgress = 0;\n\t                    }\n\t                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t                    currentProgressiveLayer.elCount++;\n\t\n\t                    currentProgressiveLayer.__maxProgress = Math.max(\n\t                        currentProgressiveLayer.__maxProgress, elFrame\n\t                    );\n\t\n\t                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t                        // Should keep rendering this  layer because progressive rendering is not finished yet\n\t                        layer.__dirty = true;\n\t                    }\n\t                }\n\t                else {\n\t                    el.__frame = -1;\n\t\n\t                    if (currentProgressiveLayer) {\n\t                        currentProgressiveLayer.__nextIdxNotProg = i;\n\t                        progressiveLayerCount++;\n\t                        currentProgressiveLayer = null;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                progressiveLayerCount++;\n\t                currentProgressiveLayer.__nextIdxNotProg = i;\n\t            }\n\t\n\t            // \n\t            this.eachBuildinLayer(function (layer, z) {\n\t                if (elCountsLastFrame[z] !== layer.elCount) {\n\t                    layer.__dirty = true;\n\t                }\n\t            });\n\t\n\t            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t                    el.__dirty = true;\n\t                }\n\t                if (layer.__dirty) {\n\t                    layer.__progress = 0;\n\t                }\n\t            });\n\t        },\n\t\n\t        /**\n\t         * hover\n\t         */\n\t        clear: function () {\n\t            this.eachBuildinLayer(this._clearLayer);\n\t            return this;\n\t        },\n\t\n\t        _clearLayer: function (layer) {\n\t            layer.clear();\n\t        },\n\t\n\t        /**\n\t         * zlevel\n\t         *\n\t         * @param {string} zlevel\n\t         * @param {Object} config \n\t         * @param {string} [config.clearColor=0] \n\t         * @param {string} [config.motionBlur=false] \n\t         * @param {number} [config.lastFrameAlpha=0.7]\n\t         *                 alpha\n\t         */\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                }\n\t                else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t\n\t                var layer = this._layers[zlevel];\n\t\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {number} zlevel zlevel\n\t         */\n\t        delLayer: function (zlevel) {\n\t            var layers = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var layer = layers[zlevel];\n\t            if (!layer) {\n\t                return;\n\t            }\n\t            layer.dom.parentNode.removeChild(layer.dom);\n\t            delete layers[zlevel];\n\t\n\t            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        resize: function (width, height) {\n\t            var domRoot = this._domRoot;\n\t            // FIXME Why ?\n\t            domRoot.style.display = 'none';\n\t\n\t            // Save input w/h\n\t            var opts = this._opts;\n\t            width != null && (opts.width = width);\n\t            height != null && (opts.height = height);\n\t\n\t            width = this._getSize(0);\n\t            height = this._getSize(1);\n\t\n\t            domRoot.style.display = '';\n\t\n\t            // resize\n\t            if (this._width != width || height != this._height) {\n\t                domRoot.style.width = width + 'px';\n\t                domRoot.style.height = height + 'px';\n\t\n\t                for (var id in this._layers) {\n\t                    if (this._layers.hasOwnProperty(id)) {\n\t                        this._layers[id].resize(width, height);\n\t                    }\n\t                }\n\t                util.each(this._progressiveLayers, function (layer) {\n\t                    layer.resize(width, height);\n\t                });\n\t\n\t                this.refresh(true);\n\t            }\n\t\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {number} zlevel\n\t         */\n\t        clearLayer: function (zlevel) {\n\t            var layer = this._layers[zlevel];\n\t            if (layer) {\n\t                layer.clear();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this.root =\n\t            this.storage =\n\t\n\t            this._domRoot =\n\t            this._layers = null;\n\t        },\n\t\n\t        /**\n\t         * Get canvas which has all thing rendered\n\t         * @param {Object} opts\n\t         * @param {string} [opts.backgroundColor]\n\t         */\n\t        getRenderedCanvas: function (opts) {\n\t            opts = opts || {};\n\t            if (this._singleCanvas) {\n\t                return this._layers[0].dom;\n\t            }\n\t\n\t            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t            imageLayer.initContext();\n\t\n\t            imageLayer.clearColor = opts.backgroundColor;\n\t            imageLayer.clear();\n\t\n\t            var displayList = this.storage.getDisplayList(true);\n\t\n\t            var scope = {};\n\t            for (var i = 0; i < displayList.length; i++) {\n\t                var el = displayList[i];\n\t                this._doPaintEl(el, imageLayer, true, scope);\n\t            }\n\t\n\t            return imageLayer.dom;\n\t        },\n\t        /**\n\t         * \n\t         */\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        _getSize: function (whIdx) {\n\t            var opts = this._opts;\n\t            var wh = ['width', 'height'][whIdx];\n\t            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n\t            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n\t            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\t\n\t            if (opts[wh] != null && opts[wh] !== 'auto') {\n\t                return parseFloat(opts[wh]);\n\t            }\n\t\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t\n\t            return (\n\t                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n\t                - (parseInt10(stl[plt]) || 0)\n\t                - (parseInt10(stl[prb]) || 0)\n\t            ) | 0;\n\t        },\n\t\n\t        _pathToImage: function (id, path, width, height, dpr) {\n\t            var canvas = document.createElement('canvas');\n\t            var ctx = canvas.getContext('2d');\n\t\n\t            canvas.width = width * dpr;\n\t            canvas.height = height * dpr;\n\t\n\t            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\t\n\t            var pathTransform = {\n\t                position: path.position,\n\t                rotation: path.rotation,\n\t                scale: path.scale\n\t            };\n\t            path.position = [0, 0, 0];\n\t            path.rotation = 0;\n\t            path.scale = [1, 1];\n\t            if (path) {\n\t                path.brush(ctx);\n\t            }\n\t\n\t            var ImageShape = __webpack_require__(/*! ./graphic/Image */ 48);\n\t            var imgShape = new ImageShape({\n\t                id: id,\n\t                style: {\n\t                    x: 0,\n\t                    y: 0,\n\t                    image: canvas\n\t                }\n\t            });\n\t\n\t            if (pathTransform.position != null) {\n\t                imgShape.position = path.position = pathTransform.position;\n\t            }\n\t\n\t            if (pathTransform.rotation != null) {\n\t                imgShape.rotation = path.rotation = pathTransform.rotation;\n\t            }\n\t\n\t            if (pathTransform.scale != null) {\n\t                imgShape.scale = path.scale = pathTransform.scale;\n\t            }\n\t\n\t            return imgShape;\n\t        },\n\t\n\t        _createPathToImage: function () {\n\t            var me = this;\n\t\n\t            return function (id, e, width, height) {\n\t                return me._pathToImage(\n\t                    id, e, width, height, me.dpr\n\t                );\n\t            };\n\t        }\n\t    };\n\t\n\t    module.exports = Painter;\n\t\n\n\n/***/ },\n/* 142 */\n/*!**********************************!*\\\n  !*** ./~/zrender/lib/Storage.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Storage\n\t * @module zrender/Storage\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t * @author errorrik (errorrik@gmail.com)\n\t * @author pissang (https://github.com/pissang/)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(/*! ./core/util */ 1);\n\t    var env = __webpack_require__(/*! ./core/env */ 11);\n\t\n\t    var Group = __webpack_require__(/*! ./container/Group */ 34);\n\t\n\t    // Use timsort because in most case elements are partially sorted\n\t    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n\t    var timsort = __webpack_require__(/*! ./core/timsort */ 44);\n\t\n\t    function shapeCompareFunc(a, b) {\n\t        if (a.zlevel === b.zlevel) {\n\t            if (a.z === b.z) {\n\t                // if (a.z2 === b.z2) {\n\t                //     // FIXME Slow has renderidx compare\n\t                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t                //     return a.__renderidx - b.__renderidx;\n\t                // }\n\t                return a.z2 - b.z2;\n\t            }\n\t            return a.z - b.z;\n\t        }\n\t        return a.zlevel - b.zlevel;\n\t    }\n\t    /**\n\t     *  (M)\n\t     * @alias module:zrender/Storage\n\t     * @constructor\n\t     */\n\t    var Storage = function () {\n\t        // idmap\n\t        this._elements = {};\n\t\n\t        this._roots = [];\n\t\n\t        this._displayList = [];\n\t\n\t        this._displayListLen = 0;\n\t    };\n\t\n\t    Storage.prototype = {\n\t\n\t        constructor: Storage,\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         *\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._roots.length; i++) {\n\t                this._roots[i].traverse(cb, context);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} [update=false] \n\t         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n\t         *\n\t         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t         * @return {Array.<module:zrender/graphic/Displayable>}\n\t         */\n\t        getDisplayList: function (update, includeIgnore) {\n\t            includeIgnore = includeIgnore || false;\n\t            if (update) {\n\t                this.updateDisplayList(includeIgnore);\n\t            }\n\t            return this._displayList;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * GroupShapeShape\n\t         * zlevel > z > \n\t         * @param {boolean} [includeIgnore=false]  ignore \n\t         */\n\t        updateDisplayList: function (includeIgnore) {\n\t            this._displayListLen = 0;\n\t            var roots = this._roots;\n\t            var displayList = this._displayList;\n\t            for (var i = 0, len = roots.length; i < len; i++) {\n\t                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t            }\n\t            displayList.length = this._displayListLen;\n\t\n\t            // for (var i = 0, len = displayList.length; i < len; i++) {\n\t            //     displayList[i].__renderidx = i;\n\t            // }\n\t\n\t            // displayList.sort(shapeCompareFunc);\n\t            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t        },\n\t\n\t        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t\n\t            if (el.ignore && !includeIgnore) {\n\t                return;\n\t            }\n\t\n\t            el.beforeUpdate();\n\t\n\t            if (el.__dirty) {\n\t\n\t                el.update();\n\t\n\t            }\n\t\n\t            el.afterUpdate();\n\t\n\t            var clipPath = el.clipPath;\n\t            if (clipPath) {\n\t                // clipPath  group \n\t                clipPath.parent = el;\n\t                clipPath.updateTransform();\n\t\n\t                // FIXME \n\t                if (clipPaths) {\n\t                    clipPaths = clipPaths.slice();\n\t                    clipPaths.push(clipPath);\n\t                }\n\t                else {\n\t                    clipPaths = [clipPath];\n\t                }\n\t            }\n\t\n\t            if (el.isGroup) {\n\t                var children = el._children;\n\t\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var child = children[i];\n\t\n\t                    // Force to mark as dirty if group is dirty\n\t                    // FIXME __dirtyPath ?\n\t                    if (el.__dirty) {\n\t                        child.__dirty = true;\n\t                    }\n\t\n\t                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t                }\n\t\n\t                // Mark group clean here\n\t                el.__dirty = false;\n\t\n\t            }\n\t            else {\n\t                el.__clipPaths = clipPaths;\n\t\n\t                this._displayList[this._displayListLen++] = el;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * (Shape)(Group)\n\t         * @param {module:zrender/Element} el\n\t         */\n\t        addRoot: function (el) {\n\t            // Element has been added\n\t            if (this._elements[el.id]) {\n\t                return;\n\t            }\n\t\n\t            if (el instanceof Group) {\n\t                el.addChildrenToStorage(this);\n\t            }\n\t\n\t            this.addToMap(el);\n\t            this._roots.push(el);\n\t        },\n\t\n\t        /**\n\t         * (Shape)(Group)\n\t         * @param {string|Array.<string>} [elId] Storage\n\t         */\n\t        delRoot: function (elId) {\n\t            if (elId == null) {\n\t                // elId\n\t                for (var i = 0; i < this._roots.length; i++) {\n\t                    var root = this._roots[i];\n\t                    if (root instanceof Group) {\n\t                        root.delChildrenFromStorage(this);\n\t                    }\n\t                }\n\t\n\t                this._elements = {};\n\t                this._roots = [];\n\t                this._displayList = [];\n\t                this._displayListLen = 0;\n\t\n\t                return;\n\t            }\n\t\n\t            if (elId instanceof Array) {\n\t                for (var i = 0, l = elId.length; i < l; i++) {\n\t                    this.delRoot(elId[i]);\n\t                }\n\t                return;\n\t            }\n\t\n\t            var el;\n\t            if (typeof(elId) == 'string') {\n\t                el = this._elements[elId];\n\t            }\n\t            else {\n\t                el = elId;\n\t            }\n\t\n\t            var idx = util.indexOf(this._roots, el);\n\t            if (idx >= 0) {\n\t                this.delFromMap(el.id);\n\t                this._roots.splice(idx, 1);\n\t                if (el instanceof Group) {\n\t                    el.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t        },\n\t\n\t        addToMap: function (el) {\n\t            if (el instanceof Group) {\n\t                el.__storage = this;\n\t            }\n\t            el.dirty(false);\n\t\n\t            this._elements[el.id] = el;\n\t\n\t            return this;\n\t        },\n\t\n\t        get: function (elId) {\n\t            return this._elements[elId];\n\t        },\n\t\n\t        delFromMap: function (elId) {\n\t            var elements = this._elements;\n\t            var el = elements[elId];\n\t            if (el) {\n\t                delete elements[elId];\n\t                if (el instanceof Group) {\n\t                    el.__storage = null;\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Storage\n\t         */\n\t        dispose: function () {\n\t            this._elements =\n\t            this._renderList =\n\t            this._roots = null;\n\t        },\n\t\n\t        displayableSortFunc: shapeCompareFunc\n\t    };\n\t\n\t    module.exports = Storage;\n\t\n\n\n/***/ },\n/* 143 */\n/*!**********************************************!*\\\n  !*** ./~/zrender/lib/animation/Animation.js ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * , \n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t\n\t    var util = __webpack_require__(/*! ../core/util */ 1);\n\t    var Dispatcher = __webpack_require__(/*! ../core/event */ 24).Dispatcher;\n\t\n\t    var requestAnimationFrame = __webpack_require__(/*! ./requestAnimationFrame */ 60);\n\t\n\t    var Animator = __webpack_require__(/*! ./Animator */ 59);\n\t    /**\n\t     * @typedef {Object} IZRenderStage\n\t     * @property {Function} update\n\t     */\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animation\n\t     * @constructor\n\t     * @param {Object} [options]\n\t     * @param {Function} [options.onframe]\n\t     * @param {IZRenderStage} [options.stage]\n\t     * @example\n\t     *     var animation = new Animation();\n\t     *     var obj = {\n\t     *         x: 100,\n\t     *         y: 100\n\t     *     };\n\t     *     animation.animate(node.position)\n\t     *         .when(1000, {\n\t     *             x: 500,\n\t     *             y: 500\n\t     *         })\n\t     *         .when(2000, {\n\t     *             x: 100,\n\t     *             y: 100\n\t     *         })\n\t     *         .start('spline');\n\t     */\n\t    var Animation = function (options) {\n\t\n\t        options = options || {};\n\t\n\t        this.stage = options.stage || {};\n\t\n\t        this.onframe = options.onframe || function() {};\n\t\n\t        // private properties\n\t        this._clips = [];\n\t\n\t        this._running = false;\n\t\n\t        this._time;\n\t\n\t        this._pausedTime;\n\t\n\t        this._pauseStart;\n\t\n\t        this._paused = false;\n\t\n\t        Dispatcher.call(this);\n\t    };\n\t\n\t    Animation.prototype = {\n\t\n\t        constructor: Animation,\n\t        /**\n\t         *  clip\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        addClip: function (clip) {\n\t            this._clips.push(clip);\n\t        },\n\t        /**\n\t         *  animator\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        addAnimator: function (animator) {\n\t            animator.animation = this;\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.addClip(clips[i]);\n\t            }\n\t        },\n\t        /**\n\t         * \n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        removeClip: function(clip) {\n\t            var idx = util.indexOf(this._clips, clip);\n\t            if (idx >= 0) {\n\t                this._clips.splice(idx, 1);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        removeAnimator: function (animator) {\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.removeClip(clips[i]);\n\t            }\n\t            animator.animation = null;\n\t        },\n\t\n\t        _update: function() {\n\t\n\t            var time = new Date().getTime() - this._pausedTime;\n\t            var delta = time - this._time;\n\t            var clips = this._clips;\n\t            var len = clips.length;\n\t\n\t            var deferredEvents = [];\n\t            var deferredClips = [];\n\t            for (var i = 0; i < len; i++) {\n\t                var clip = clips[i];\n\t                var e = clip.step(time);\n\t                // Throw out the events need to be called after\n\t                // stage.update, like destroy\n\t                if (e) {\n\t                    deferredEvents.push(e);\n\t                    deferredClips.push(clip);\n\t                }\n\t            }\n\t\n\t            // Remove the finished clip\n\t            for (var i = 0; i < len;) {\n\t                if (clips[i]._needsRemove) {\n\t                    clips[i] = clips[len - 1];\n\t                    clips.pop();\n\t                    len--;\n\t                }\n\t                else {\n\t                    i++;\n\t                }\n\t            }\n\t\n\t            len = deferredEvents.length;\n\t            for (var i = 0; i < len; i++) {\n\t                deferredClips[i].fire(deferredEvents[i]);\n\t            }\n\t\n\t            this._time = time;\n\t\n\t            this.onframe(delta);\n\t\n\t            this.trigger('frame', delta);\n\t\n\t            if (this.stage.update) {\n\t                this.stage.update();\n\t            }\n\t        },\n\t\n\t        _startLoop: function () {\n\t            var self = this;\n\t\n\t            this._running = true;\n\t\n\t            function step() {\n\t                if (self._running) {\n\t\n\t                    requestAnimationFrame(step);\n\t\n\t                    !self._paused && self._update();\n\t                }\n\t            }\n\t\n\t            requestAnimationFrame(step);\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        start: function () {\n\t\n\t            this._time = new Date().getTime();\n\t            this._pausedTime = 0;\n\t\n\t            this._startLoop();\n\t        },\n\t        /**\n\t         * \n\t         */\n\t        stop: function () {\n\t            this._running = false;\n\t        },\n\t\n\t        /**\n\t         * Pause\n\t         */\n\t        pause: function () {\n\t            if (!this._paused) {\n\t                this._pauseStart = new Date().getTime();\n\t                this._paused = true;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Resume\n\t         */\n\t        resume: function () {\n\t            if (this._paused) {\n\t                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n\t                this._paused = false;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        clear: function () {\n\t            this._clips = [];\n\t        },\n\t        /**\n\t         * animator\n\t         * @param  {Object} target\n\t         * @param  {Object} options\n\t         * @param  {boolean} [options.loop=false] \n\t         * @param  {Function} [options.getter=null]\n\t         *         gettergetter\n\t         * @param  {Function} [options.setter=null]\n\t         *         settersetter\n\t         * @return {module:zrender/animation/Animation~Animator}\n\t         */\n\t        // TODO Gap\n\t        animate: function (target, options) {\n\t            options = options || {};\n\t            var animator = new Animator(\n\t                target,\n\t                options.loop,\n\t                options.getter,\n\t                options.setter\n\t            );\n\t\n\t            return animator;\n\t        }\n\t    };\n\t\n\t    util.mixin(Animation, Dispatcher);\n\t\n\t    module.exports = Animation;\n\t\n\n\n/***/ },\n/* 144 */\n/*!*****************************************!*\\\n  !*** ./~/zrender/lib/animation/Clip.js ***!\n  \\*****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @config target onframe\n\t * @config life(1000) \n\t * @config delay(0) \n\t * @config loop(true)\n\t * @config gap(0) \n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\t\n\t\n\t    var easingFuncs = __webpack_require__(/*! ./easing */ 145);\n\t\n\t    function Clip(options) {\n\t\n\t        this._target = options.target;\n\t\n\t        // \n\t        this._life = options.life || 1000;\n\t        // \n\t        this._delay = options.delay || 0;\n\t        // \n\t        // this._startTime = new Date().getTime() + this._delay;// \n\t        this._initialized = false;\n\t\n\t        // \n\t        this.loop = options.loop == null ? false : options.loop;\n\t\n\t        this.gap = options.gap || 0;\n\t\n\t        this.easing = options.easing || 'Linear';\n\t\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t    }\n\t\n\t    Clip.prototype = {\n\t\n\t        constructor: Clip,\n\t\n\t        step: function (globalTime) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = globalTime + this._delay;\n\t                this._initialized = true;\n\t            }\n\t\n\t            var percent = (globalTime - this._startTime) / this._life;\n\t\n\t            // \n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t\n\t            percent = Math.min(percent, 1);\n\t\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t            var schedule = typeof easingFunc === 'function'\n\t                ? easingFunc(percent)\n\t                : percent;\n\t\n\t            this.fire('frame', schedule);\n\t\n\t            // \n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart (globalTime);\n\t                    // \n\t                    //  stage.update \n\t                    return 'restart';\n\t                }\n\t\n\t                // \n\t                // Animation.update\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t\n\t            return null;\n\t        },\n\t\n\t        restart: function (globalTime) {\n\t            var remainder = (globalTime - this._startTime) % this._life;\n\t            this._startTime = globalTime - remainder + this.gap;\n\t\n\t            this._needsRemove = false;\n\t        },\n\t\n\t        fire: function(eventType, arg) {\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\n\t                this[eventType](this._target, arg);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Clip;\n\t\n\n\n/***/ },\n/* 145 */\n/*!*******************************************!*\\\n  !*** ./~/zrender/lib/animation/easing.js ***!\n  \\*******************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\t\n\t    var easing = {\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        linear: function (k) {\n\t            return k;\n\t        },\n\t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticIn: function (k) {\n\t            return k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticOut: function (k) {\n\t            return k * (2 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k;\n\t            }\n\t            return -0.5 * (--k * (k - 2) - 1);\n\t        },\n\t\n\t        // t^3\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicIn: function (k) {\n\t            return k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicOut: function (k) {\n\t            return --k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k + 2);\n\t        },\n\t\n\t        // t^4\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticIn: function (k) {\n\t            return k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticOut: function (k) {\n\t            return 1 - (--k * k * k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k;\n\t            }\n\t            return -0.5 * ((k -= 2) * k * k * k - 2);\n\t        },\n\t\n\t        // t^5\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticIn: function (k) {\n\t            return k * k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticOut: function (k) {\n\t            return --k * k * k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t        },\n\t\n\t        // sin(t)\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalIn: function (k) {\n\t            return 1 - Math.cos(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalOut: function (k) {\n\t            return Math.sin(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalInOut: function (k) {\n\t            return 0.5 * (1 - Math.cos(Math.PI * k));\n\t        },\n\t\n\t        // 2^t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialIn: function (k) {\n\t            return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialOut: function (k) {\n\t            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialInOut: function (k) {\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * Math.pow(1024, k - 1);\n\t            }\n\t            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t        },\n\t\n\t        // sqrt(1-t^2)\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularIn: function (k) {\n\t            return 1 - Math.sqrt(1 - k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularOut: function (k) {\n\t            return Math.sqrt(1 - (--k * k));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t            }\n\t            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticIn: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return -(a * Math.pow(2, 10 * (k -= 1)) *\n\t                        Math.sin((k - s) * (2 * Math.PI) / p));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return (a * Math.pow(2, -10 * k) *\n\t                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticInOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            }\n\t            return a * Math.pow(2, -10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backIn: function (k) {\n\t            var s = 1.70158;\n\t            return k * k * ((s + 1) * k - s);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backOut: function (k) {\n\t            var s = 1.70158;\n\t            return --k * k * ((s + 1) * k + s) + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backInOut: function (k) {\n\t            var s = 1.70158 * 1.525;\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * (k * k * ((s + 1) * k - s));\n\t            }\n\t            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceIn: function (k) {\n\t            return 1 - easing.bounceOut(1 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceOut: function (k) {\n\t            if (k < (1 / 2.75)) {\n\t                return 7.5625 * k * k;\n\t            }\n\t            else if (k < (2 / 2.75)) {\n\t                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t            }\n\t            else if (k < (2.5 / 2.75)) {\n\t                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t            }\n\t            else {\n\t                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t            }\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceInOut: function (k) {\n\t            if (k < 0.5) {\n\t                return easing.bounceIn(k * 2) * 0.5;\n\t            }\n\t            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t        }\n\t    };\n\t\n\t    module.exports = easing;\n\t\n\t\n\n\n/***/ },\n/* 146 */\n/*!**************************************!*\\\n  !*** ./~/zrender/lib/contain/arc.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var normalizeRadian = __webpack_require__(/*! ./util */ 61).normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  cx\n\t         * @param  {number}  cy\n\t         * @param  {number}  r\n\t         * @param  {number}  startAngle\n\t         * @param  {number}  endAngle\n\t         * @param  {boolean}  anticlockwise\n\t         * @param  {number} lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {Boolean}\n\t         */\n\t        containStroke: function (\n\t            cx, cy, r, startAngle, endAngle, anticlockwise,\n\t            lineWidth, x, y\n\t        ) {\n\t\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t\n\t            if ((d - _l > r) || (d + _l < r)) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return (angle >= startAngle && angle <= endAngle)\n\t                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n\t        }\n\t    };\n\n\n/***/ },\n/* 147 */\n/*!****************************************!*\\\n  !*** ./~/zrender/lib/contain/cubic.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(/*! ../core/curve */ 17);\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  x3\n\t         * @param  {number}  y3\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(\n\t                x0, y0, x1, y1, x2, y2, x3, y3,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 148 */\n/*!***************************************!*\\\n  !*** ./~/zrender/lib/contain/path.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var CMD = __webpack_require__(/*! ../core/PathProxy */ 28).CMD;\n\t    var line = __webpack_require__(/*! ./line */ 84);\n\t    var cubic = __webpack_require__(/*! ./cubic */ 147);\n\t    var quadratic = __webpack_require__(/*! ./quadratic */ 85);\n\t    var arc = __webpack_require__(/*! ./arc */ 146);\n\t    var normalizeRadian = __webpack_require__(/*! ./util */ 61).normalizeRadian;\n\t    var curve = __webpack_require__(/*! ../core/curve */ 17);\n\t\n\t    var windingLine = __webpack_require__(/*! ./windingLine */ 86);\n\t\n\t    var containStroke = line.containStroke;\n\t\n\t    var PI2 = Math.PI * 2;\n\t\n\t    var EPSILON = 1e-4;\n\t\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t\n\t    // \n\t    var roots = [-1, -1, -1];\n\t    var extrema = [-1, -1];\n\t\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2 && y > y3)\n\t            || (y < y0 && y < y1 && y < y2 && y < y3)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t\n\t                // Avoid winding error when intersection point is the connect point of two line of polygon\n\t                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) { // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // \n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y1_ ? unit : -unit;\n\t                    }\n\t                }\n\t                else {\n\t                    // \n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y0_ ? unit : -unit;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2)\n\t            || (y < y0 && y < y1 && y < y2)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >= 0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    // Remove one endpoint.\n\t                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\t\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ < x) {   // Quick reject\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y2 < y_ ? unit : -unit;\n\t                    }\n\t                }\n\t                return w;\n\t            }\n\t            else {\n\t                // Remove one endpoint.\n\t                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ < x) {   // Quick reject\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? unit : -unit;\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO\n\t    // Arc \n\t    function windingArc(\n\t        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n\t    ) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 1e-4) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 1e-4) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        }\n\t        else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (\n\t                    (angle >= startAngle && angle <= endAngle)\n\t                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n\t                ) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }\n\t                //  subpath \n\t                // if (w !== 0) {\n\t                //     return true;\n\t                // }\n\t            }\n\t\n\t            if (i == 1) {\n\t                //  L, C, Q\n\t                //  previous point  point\n\t                //\n\t                //  Arc \n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t\n\t            switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo  subpath, \n\t                    //  closePath \n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    if (isStroke) {\n\t                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // NOTE  L, C, Q  NaN\n\t                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    if (isStroke) {\n\t                        if (cubic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingCubic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    if (isStroke) {\n\t                        if (quadratic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingQuadratic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc \n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var theta = data[i++];\n\t                    var dTheta = data[i++];\n\t                    // TODO Arc \n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    var x1 = Math.cos(theta) * rx + cx;\n\t                    var y1 = Math.sin(theta) * ry + cy;\n\t                    //  arc \n\t                    if (i > 1) {\n\t                        w += windingLine(xi, yi, x1, y1, x, y);\n\t                    }\n\t                    else {\n\t                        // \n\t                        x0 = x1;\n\t                        y0 = y1;\n\t                    }\n\t                    // zr scale, x\n\t                    var _x = (x - cx) * ry / rx + cx;\n\t                    if (isStroke) {\n\t                        if (arc.containStroke(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            lineWidth, _x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingArc(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            _x, y\n\t                        );\n\t                    }\n\t                    xi = Math.cos(theta + dTheta) * rx + cx;\n\t                    yi = Math.sin(theta + dTheta) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    var x1 = x0 + width;\n\t                    var y1 = y0 + height;\n\t                    if (isStroke) {\n\t                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n\t                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n\t                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n\t                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n\t                        ) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // FIXME Clockwise ?\n\t                        w += windingLine(x1, y0, x1, y1, x, y);\n\t                        w += windingLine(x0, y1, x0, y0, x, y);\n\t                    }\n\t                    break;\n\t                case CMD.Z:\n\t                    if (isStroke) {\n\t                        if (containStroke(\n\t                            xi, yi, x0, y0, lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Close a subpath\n\t                        w += windingLine(xi, yi, x0, y0, x, y);\n\t                        //  subpath \n\t                        // FIXME subpaths may overlap\n\t                        // if (w !== 0) {\n\t                        //     return true;\n\t                        // }\n\t                    }\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t\n\t    module.exports = {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 149 */\n/*!******************************************!*\\\n  !*** ./~/zrender/lib/core/GestureMgr.js ***!\n  \\******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Only implements needed gestures for mobile.\n\t */\n\t\n\t\n\t    var eventUtil = __webpack_require__(/*! ./event */ 24);\n\t\n\t    var GestureMgr = function () {\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._track = [];\n\t    };\n\t\n\t    GestureMgr.prototype = {\n\t\n\t        constructor: GestureMgr,\n\t\n\t        recognize: function (event, target, root) {\n\t            this._doTrack(event, target, root);\n\t            return this._recognize(event);\n\t        },\n\t\n\t        clear: function () {\n\t            this._track.length = 0;\n\t            return this;\n\t        },\n\t\n\t        _doTrack: function (event, target, root) {\n\t            var touches = event.touches;\n\t\n\t            if (!touches) {\n\t                return;\n\t            }\n\t\n\t            var trackItem = {\n\t                points: [],\n\t                touches: [],\n\t                target: target,\n\t                event: event\n\t            };\n\t\n\t            for (var i = 0, len = touches.length; i < len; i++) {\n\t                var touch = touches[i];\n\t                var pos = eventUtil.clientToLocal(root, touch, {});\n\t                trackItem.points.push([pos.zrX, pos.zrY]);\n\t                trackItem.touches.push(touch);\n\t            }\n\t\n\t            this._track.push(trackItem);\n\t        },\n\t\n\t        _recognize: function (event) {\n\t            for (var eventName in recognizers) {\n\t                if (recognizers.hasOwnProperty(eventName)) {\n\t                    var gestureInfo = recognizers[eventName](this._track, event);\n\t                    if (gestureInfo) {\n\t                        return gestureInfo;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function dist(pointPair) {\n\t        var dx = pointPair[1][0] - pointPair[0][0];\n\t        var dy = pointPair[1][1] - pointPair[0][1];\n\t\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t\n\t    function center(pointPair) {\n\t        return [\n\t            (pointPair[0][0] + pointPair[1][0]) / 2,\n\t            (pointPair[0][1] + pointPair[1][1]) / 2\n\t        ];\n\t    }\n\t\n\t    var recognizers = {\n\t\n\t        pinch: function (track, event) {\n\t            var trackLen = track.length;\n\t\n\t            if (!trackLen) {\n\t                return;\n\t            }\n\t\n\t            var pinchEnd = (track[trackLen - 1] || {}).points;\n\t            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t\n\t            if (pinchPre\n\t                && pinchPre.length > 1\n\t                && pinchEnd\n\t                && pinchEnd.length > 1\n\t            ) {\n\t                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t                !isFinite(pinchScale) && (pinchScale = 1);\n\t\n\t                event.pinchScale = pinchScale;\n\t\n\t                var pinchCenter = center(pinchEnd);\n\t                event.pinchX = pinchCenter[0];\n\t                event.pinchY = pinchCenter[1];\n\t\n\t                return {\n\t                    type: 'pinch',\n\t                    target: track[0].target,\n\t                    event: event\n\t                };\n\t            }\n\t        }\n\t\n\t        // Only pinch currently.\n\t    };\n\t\n\t    module.exports = GestureMgr;\n\t\n\n\n/***/ },\n/* 150 */\n/*!***********************************!*\\\n  !*** ./~/zrender/lib/core/LRU.js ***!\n  \\***********************************/\n/***/ function(module, exports) {\n\n\t// Simple LRU cache use doubly linked list\n\t// @module zrender/core/LRU\n\t\n\t\n\t    /**\n\t     * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t     * @constructor\n\t     */\n\t    var LinkedList = function() {\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.head = null;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.tail = null;\n\t\n\t        this._len = 0;\n\t    };\n\t\n\t    var linkedListProto = LinkedList.prototype;\n\t    /**\n\t     * Insert a new value at the tail\n\t     * @param  {} val\n\t     * @return {module:zrender/core/LRU~Entry}\n\t     */\n\t    linkedListProto.insert = function(val) {\n\t        var entry = new Entry(val);\n\t        this.insertEntry(entry);\n\t        return entry;\n\t    };\n\t\n\t    /**\n\t     * Insert an entry at the tail\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.insertEntry = function(entry) {\n\t        if (!this.head) {\n\t            this.head = this.tail = entry;\n\t        }\n\t        else {\n\t            this.tail.next = entry;\n\t            entry.prev = this.tail;\n\t            this.tail = entry;\n\t        }\n\t        this._len++;\n\t    };\n\t\n\t    /**\n\t     * Remove entry.\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.remove = function(entry) {\n\t        var prev = entry.prev;\n\t        var next = entry.next;\n\t        if (prev) {\n\t            prev.next = next;\n\t        }\n\t        else {\n\t            // Is head\n\t            this.head = next;\n\t        }\n\t        if (next) {\n\t            next.prev = prev;\n\t        }\n\t        else {\n\t            // Is tail\n\t            this.tail = prev;\n\t        }\n\t        entry.next = entry.prev = null;\n\t        this._len--;\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    linkedListProto.len = function() {\n\t        return this._len;\n\t    };\n\t\n\t    /**\n\t     * @constructor\n\t     * @param {} val\n\t     */\n\t    var Entry = function(val) {\n\t        /**\n\t         * @type {}\n\t         */\n\t        this.value = val;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.next;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.prev;\n\t    };\n\t\n\t    /**\n\t     * LRU Cache\n\t     * @constructor\n\t     * @alias module:zrender/core/LRU\n\t     */\n\t    var LRU = function(maxSize) {\n\t\n\t        this._list = new LinkedList();\n\t\n\t        this._map = {};\n\t\n\t        this._maxSize = maxSize || 10;\n\t    };\n\t\n\t    var LRUProto = LRU.prototype;\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @param  {} value\n\t     */\n\t    LRUProto.put = function(key, value) {\n\t        var list = this._list;\n\t        var map = this._map;\n\t        if (map[key] == null) {\n\t            var len = list.len();\n\t            if (len >= this._maxSize && len > 0) {\n\t                // Remove the least recently used\n\t                var leastUsedEntry = list.head;\n\t                list.remove(leastUsedEntry);\n\t                delete map[leastUsedEntry.key];\n\t            }\n\t\n\t            var entry = list.insert(value);\n\t            entry.key = key;\n\t            map[key] = entry;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @return {}\n\t     */\n\t    LRUProto.get = function(key) {\n\t        var entry = this._map[key];\n\t        var list = this._list;\n\t        if (entry != null) {\n\t            // Put the latest used entry in the tail\n\t            if (entry !== list.tail) {\n\t                list.remove(entry);\n\t                list.insertEntry(entry);\n\t            }\n\t\n\t            return entry.value;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Clear the cache\n\t     */\n\t    LRUProto.clear = function() {\n\t        this._list.clear();\n\t        this._map = {};\n\t    };\n\t\n\t    module.exports = LRU;\n\n\n/***/ },\n/* 151 */\n/*!*******************************************!*\\\n  !*** ./~/zrender/lib/dom/HandlerProxy.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var eventTool = __webpack_require__(/*! ../core/event */ 24);\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t    var Eventful = __webpack_require__(/*! ../mixin/Eventful */ 20);\n\t    var env = __webpack_require__(/*! ../core/env */ 11);\n\t    var GestureMgr = __webpack_require__(/*! ../core/GestureMgr */ 149);\n\t\n\t    var addEventListener = eventTool.addEventListener;\n\t    var removeEventListener = eventTool.removeEventListener;\n\t    var normalizeEvent = eventTool.normalizeEvent;\n\t\n\t    var TOUCH_CLICK_DELAY = 300;\n\t\n\t    var mouseHandlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t\n\t    var touchHandlerNames = [\n\t        'touchstart', 'touchend', 'touchmove'\n\t    ];\n\t\n\t    function eventNameFix(name) {\n\t        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n\t    }\n\t\n\t    function processGesture(proxy, event, stage) {\n\t        var gestureMgr = proxy._gestureMgr;\n\t\n\t        stage === 'start' && gestureMgr.clear();\n\t\n\t        var gestureInfo = gestureMgr.recognize(\n\t            event,\n\t            proxy.handler.findHover(event.zrX, event.zrY, null),\n\t            proxy.dom\n\t        );\n\t\n\t        stage === 'end' && gestureMgr.clear();\n\t\n\t        if (gestureInfo) {\n\t            // eventTool.stop(event);\n\t            var type = gestureInfo.type;\n\t            event.gestureEvent = type;\n\t\n\t            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Prevent mouse event from being dispatched after Touch Events action\n\t     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t     * Result: Blocking Mouse Events for 700ms.\n\t     */\n\t    function setTouchTimer(instance) {\n\t        instance._touching = true;\n\t        clearTimeout(instance._touchTimer);\n\t        instance._touchTimer = setTimeout(function () {\n\t            instance._touching = false;\n\t        }, 700);\n\t    }\n\t\n\t    function useTouchEvent() {\n\t        return env.touchEventsSupported;\n\t    }\n\t\n\t    var domHandlers = {\n\t        /**\n\t         * Mouse move handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mousemove: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            this.trigger('mousemove', event);\n\t        },\n\t\n\t        /**\n\t         * Mouse out handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mouseout: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            var element = event.toElement || event.relatedTarget;\n\t            if (element != this.dom) {\n\t                while (element && element.nodeType != 9) {\n\t                    // rootdommouseOut\n\t                    if (element === this.dom) {\n\t                        return;\n\t                    }\n\t\n\t                    element = element.parentNode;\n\t                }\n\t            }\n\t\n\t            this.trigger('mouseout', event);\n\t        },\n\t\n\t        /**\n\t         * Touch\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchstart: function (event) {\n\t            // Default mouse behaviour should not be disabled here.\n\t            // For example, page may needs to be slided.\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            this._lastTouchMoment = new Date();\n\t\n\t            processGesture(this, event, 'start');\n\t\n\t            // In touch device, trigger `mousemove`(`mouseover`) should\n\t            // be triggered.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            domHandlers.mousedown.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchmove: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            processGesture(this, event, 'change');\n\t\n\t            // Mouse move should always be triggered no matter whether\n\t            // there is gestrue event, because mouse move and pinch may\n\t            // be used at the same time.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchend: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            processGesture(this, event, 'end');\n\t\n\t            domHandlers.mouseup.call(this, event);\n\t\n\t            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n\t            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n\t            // we can conveniently implement \"hover style\" in both PC and touch device just\n\t            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n\t            // to remove \"hover style\" on an element, without any additional code for\n\t            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n\t            // style\" will remain for user view)\n\t\n\t            // click event should always be triggered no matter whether\n\t            // there is gestrue event. System click can not be prevented.\n\t            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t                domHandlers.click.call(this, event);\n\t            }\n\t\n\t            setTouchTimer(this);\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        domHandlers[name] = function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t            this.trigger(name, event);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * dom \n\t     *\n\t     * @inner\n\t     * @param {module:zrender/Handler} instance \n\t     */\n\t    function initDomHandler(instance) {\n\t        for (var i = 0; i < touchHandlerNames.length; i++) {\n\t            var name = touchHandlerNames[i];\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        }\n\t\n\t        for (var i = 0; i < mouseHandlerNames.length; i++) {\n\t            var name = mouseHandlerNames[i];\n\t            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t        }\n\t\n\t        function makeMouseHandler(fn, instance) {\n\t            return function () {\n\t                if (instance._touching) {\n\t                    return;\n\t                }\n\t                return fn.apply(instance, arguments);\n\t            };\n\t        }\n\t    }\n\t\n\t\n\t    function HandlerDomProxy(dom) {\n\t        Eventful.call(this);\n\t\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._touching = false;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._touchTimer;\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:zrender/core/GestureMgr}\n\t         */\n\t        this._gestureMgr = new GestureMgr();\n\t\n\t        this._handlers = {};\n\t\n\t        initDomHandler(this);\n\t\n\t        if (useTouchEvent()) {\n\t            mountHandlers(touchHandlerNames, this);\n\t\n\t            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t            // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t        }\n\t\n\t        // Considering some devices that both enable touch and mouse event (like MS Surface\n\t        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t        // mouse event can not be handle in those devices.\n\t        mountHandlers(mouseHandlerNames, this);\n\t\n\t        function mountHandlers(handlerNames, instance) {\n\t            zrUtil.each(handlerNames, function (name) {\n\t                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t            }, instance);\n\t        }\n\t    }\n\t\n\t    var handlerDomProxyProto = HandlerDomProxy.prototype;\n\t    handlerDomProxyProto.dispose = function () {\n\t        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t\n\t        for (var i = 0; i < handlerNames.length; i++) {\n\t            var name = handlerNames[i];\n\t            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t        }\n\t    };\n\t\n\t    handlerDomProxyProto.setCursor = function (cursorStyle) {\n\t        this.dom.style.cursor = cursorStyle || 'default';\n\t    };\n\t\n\t    zrUtil.mixin(HandlerDomProxy, Eventful);\n\t\n\t    module.exports = HandlerDomProxy;\n\n\n/***/ },\n/* 152 */\n/*!***********************************************!*\\\n  !*** ./~/zrender/lib/graphic/CompoundPath.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CompoundPath to improve performance\n\t\n\t\n\t    var Path = __webpack_require__(/*! ./Path */ 6);\n\t    module.exports = Path.extend({\n\t\n\t        type: 'compound',\n\t\n\t        shape: {\n\t\n\t            paths: null\n\t        },\n\t\n\t        _updatePathDirty: function () {\n\t            var dirtyPath = this.__dirtyPath;\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                // Mark as dirty if any subpath is dirty\n\t                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n\t            }\n\t            this.__dirtyPath = dirtyPath;\n\t            this.__dirty = this.__dirty || dirtyPath;\n\t        },\n\t\n\t        beforeBrush: function () {\n\t            this._updatePathDirty();\n\t            var paths = this.shape.paths || [];\n\t            var scale = this.getGlobalScale();\n\t            // Update path scale\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].path.setScale(scale[0], scale[1]);\n\t            }\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var paths = shape.paths || [];\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].buildPath(ctx, paths[i].shape, true);\n\t            }\n\t        },\n\t\n\t        afterBrush: function () {\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].__dirtyPath = false;\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            this._updatePathDirty();\n\t            return Path.prototype.getBoundingRect.call(this);\n\t        }\n\t    });\n\n\n/***/ },\n/* 153 */\n/*!*************************************************!*\\\n  !*** ./~/zrender/lib/graphic/RadialGradient.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(/*! ../core/util */ 1);\n\t\n\t    var Gradient = __webpack_require__(/*! ./Gradient */ 29);\n\t\n\t    /**\n\t     * x, y, r are all percent from 0 to 1\n\t     * @param {number} [x=0.5]\n\t     * @param {number} [y=0.5]\n\t     * @param {number} [r=0.5]\n\t     * @param {Array.<Object>} [colorStops]\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t        this.x = x == null ? 0.5 : x;\n\t\n\t        this.y = y == null ? 0.5 : y;\n\t\n\t        this.r = r == null ? 0.5 : r;\n\t\n\t        // Can be cloned\n\t        this.type = 'radial';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    RadialGradient.prototype = {\n\t\n\t        constructor: RadialGradient\n\t    };\n\t\n\t    zrUtil.inherits(RadialGradient, Gradient);\n\t\n\t    module.exports = RadialGradient;\n\n\n/***/ },\n/* 154 */\n/*!***************************************************!*\\\n  !*** ./~/zrender/lib/graphic/helper/roundRect.js ***!\n  \\***************************************************/\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            }\n\t            else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                }\n\t                else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                }\n\t                else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                }\n\t                else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            }\n\t            else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y, x + width, y + r2\n\t            );\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y + height, x + width - r3, y + height\n\t            );\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(\n\t                x, y + height, x, y + height - r4\n\t            );\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 155 */\n/*!******************************************************!*\\\n  !*** ./~/zrender/lib/graphic/helper/smoothBezier.js ***!\n  \\******************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(/*! ../../core/vector */ 5);\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t\n\t    /**\n\t     * \n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points \n\t     * @param {number} smooth , 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint \n\t     *                            [[0, 0], [100, 100]], \n\t     *                           \n\t     * @param {Array} \n\t     */\n\t    module.exports = function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [Infinity, Infinity];\n\t            max = [-Infinity, -Infinity];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // \n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            }\n\t            else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                }\n\t                else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t\n\t        return cps;\n\t    };\n\t\n\n\n/***/ },\n/* 156 */\n/*!******************************************************!*\\\n  !*** ./~/zrender/lib/graphic/helper/smoothSpline.js ***!\n  \\******************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Catmull-Rom spline \n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t    var vec2 = __webpack_require__(/*! ../../core/vector */ 5);\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points \n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    module.exports = function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t\n\t            var w = pos - idx;\n\t\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            }\n\t            else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t\n\n\n/***/ },\n/* 157 */\n/*!********************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Arc.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Arc\n\t */\n\t \n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t\n\t        type: 'arc',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        style: {\n\t\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t        }\n\t    });\n\n\n/***/ },\n/* 158 */\n/*!****************************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/BezierCurve.js ***!\n  \\****************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/shape/BezierCurve\n\t */\n\t\n\t\n\t    var curveTool = __webpack_require__(/*! ../../core/curve */ 17);\n\t    var vec2 = __webpack_require__(/*! ../../core/vector */ 5);\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\n\t    var quadraticAt = curveTool.quadraticAt;\n\t    var cubicAt = curveTool.cubicAt;\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\t\n\t    var out = [];\n\t\n\t    function someVectorAt(shape, t, isTangent) {\n\t        var cpx2 = shape.cpx2;\n\t        var cpy2 = shape.cpy2;\n\t        if (cpx2 === null || cpy2 === null) {\n\t            return [\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n\t            ];\n\t        }\n\t        else {\n\t            return [\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n\t            ];\n\t        }\n\t    }\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t\n\t        type: 'bezier-curve',\n\t\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            cpx1: 0,\n\t            cpy1: 0,\n\t            // cpx2: 0,\n\t            // cpy2: 0\n\t\n\t            // Curve show percent, for animating\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var cpx1 = shape.cpx1;\n\t            var cpy1 = shape.cpy1;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (cpx2 == null || cpy2 == null) {\n\t                if (percent < 1) {\n\t                    quadraticSubdivide(\n\t                        x1, cpx1, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    x2 = out[2];\n\t                    quadraticSubdivide(\n\t                        y1, cpy1, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    y2 = out[2];\n\t                }\n\t\n\t                ctx.quadraticCurveTo(\n\t                    cpx1, cpy1,\n\t                    x2, y2\n\t                );\n\t            }\n\t            else {\n\t                if (percent < 1) {\n\t                    cubicSubdivide(\n\t                        x1, cpx1, cpx2, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    cpx2 = out[2];\n\t                    x2 = out[3];\n\t                    cubicSubdivide(\n\t                        y1, cpy1, cpy2, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    cpy2 = out[2];\n\t                    y2 = out[3];\n\t                }\n\t                ctx.bezierCurveTo(\n\t                    cpx1, cpy1,\n\t                    cpx2, cpy2,\n\t                    x2, y2\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (t) {\n\t            return someVectorAt(this.shape, t, false);\n\t        },\n\t\n\t        /**\n\t         * Get tangent at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        tangentAt: function (t) {\n\t            var p = someVectorAt(this.shape, t, true);\n\t            return vec2.normalize(p, p);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 159 */\n/*!***********************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Circle.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/shape/Circle\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t\n\t        type: 'circle',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0\n\t        },\n\t\n\t\n\t        buildPath : function (ctx, shape, inBundle) {\n\t            // Better stroking in ShapeBundle\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\n\t            if (inBundle) {\n\t                ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            }\n\t            // Better stroking in ShapeBundle\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 160 */\n/*!*********************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Line.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Line\n\t */\n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t\n\t        type: 'line',\n\t\n\t        shape: {\n\t            // Start point\n\t            x1: 0,\n\t            y1: 0,\n\t            // End point\n\t            x2: 0,\n\t            y2: 0,\n\t\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var percent = shape.percent;\n\t\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (percent < 1) {\n\t                x2 = x1 * (1 - percent) + x2 * percent;\n\t                y2 = y1 * (1 - percent) + y2 * percent;\n\t            }\n\t            ctx.lineTo(x2, y2);\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} percent\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            return [\n\t                shape.x1 * (1 - p) + shape.x2 * p,\n\t                shape.y1 * (1 - p) + shape.y2 * p\n\t            ];\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 161 */\n/*!************************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Polygon.js ***!\n  \\************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/shape/Polygon\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(/*! ../helper/poly */ 65);\n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t        \n\t        type: 'polygon',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, true);\n\t        }\n\t    });\n\n\n/***/ },\n/* 162 */\n/*!*************************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Polyline.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(/*! ../helper/poly */ 65);\n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t        \n\t        type: 'polyline',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, false);\n\t        }\n\t    });\n\n\n/***/ },\n/* 163 */\n/*!*********************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Rect.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Rect\n\t */\n\t\n\t\n\t    var roundRectHelper = __webpack_require__(/*! ../helper/roundRect */ 154);\n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t\n\t        type: 'rect',\n\t\n\t        shape: {\n\t            // r1r2r3r4\n\t            // r1          [1, 1, 1, 1]\n\t            // r[1]        [1, 1, 1, 1]\n\t            // r[1, 2]     [1, 2, 1, 2]\n\t            // r[1, 2, 3]  [1, 2, 3, 2]\n\t            r: 0,\n\t\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            if (!shape.r) {\n\t                ctx.rect(x, y, width, height);\n\t            }\n\t            else {\n\t                roundRectHelper.buildPath(ctx, shape);\n\t            }\n\t            ctx.closePath();\n\t            return;\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 164 */\n/*!*********************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Ring.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Ring\n\t */\n\t\n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t\n\t        type: 'ring',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            r0: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var PI2 = Math.PI * 2;\n\t            ctx.moveTo(x + shape.r, y);\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\n\t            ctx.moveTo(x + shape.r0, y);\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 165 */\n/*!***********************************************!*\\\n  !*** ./~/zrender/lib/graphic/shape/Sector.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Sector\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(/*! ../Path */ 6).extend({\n\t\n\t        type: 'sector',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r0: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r0 = Math.max(shape.r0 || 0, 0);\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\n\t\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t\n\t            ctx.lineTo(\n\t                Math.cos(endAngle) * r0 + x,\n\t                Math.sin(endAngle) * r0 + y\n\t            );\n\t\n\t            if (r0 !== 0) {\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t            }\n\t\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 166 */\n/*!*******************************************!*\\\n  !*** ./~/zrender/lib/mixin/Animatable.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/mixin/Animatable\n\t */\n\t\n\t\n\t    var Animator = __webpack_require__(/*! ../animation/Animator */ 59);\n\t    var util = __webpack_require__(/*! ../core/util */ 1);\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = __webpack_require__(/*! ../core/log */ 47);\n\t\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t\n\t    Animatable.prototype = {\n\t\n\t        constructor: Animatable,\n\t\n\t        /**\n\t         * \n\t         *\n\t         * @param {string} path a.b.c\n\t         * @param {boolean} [loop] \n\t         * @return {module:zrender/animation/Animator}\n\t         * @example:\n\t         *     el.animate('style', false)\n\t         *         .when(1000, {x: 10} )\n\t         *         .done(function(){ // Animation done })\n\t         *         .start()\n\t         */\n\t        animate: function (path, loop) {\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            }\n\t            else {\n\t                target = el;\n\t            }\n\t\n\t            if (!target) {\n\t                log(\n\t                    'Property \"'\n\t                    + path\n\t                    + '\" is not existed in element '\n\t                    + el.id\n\t                );\n\t                return;\n\t            }\n\t\n\t            var animators = el.animators;\n\t\n\t            var animator = new Animator(target, loop);\n\t\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            })\n\t            .done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t\n\t            animators.push(animator);\n\t\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\n\t\n\t            return animator;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {Object} target\n\t         * @param {number} [time=500] Time in ms\n\t         * @param {string} [easing='linear']\n\t         * @param {number} [delay=0]\n\t         * @param {Function} [callback]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el.animateTo({\n\t         *      position: [10, 10]\n\t         *  }, function () { // done })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t         *  el.animateTo({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100, 'cubicOut', function () { // done })\n\t         */\n\t         // TODO Return animation key\n\t        animateTo: function (target, time, delay, easing, callback) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }\n\t            // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i]\n\t                    .done(done)\n\t                    .start(easing);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {string} path=''\n\t         * @param {Object} source=this\n\t         * @param {Object} target\n\t         * @param {number} [time=500]\n\t         * @param {number} [delay=0]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el._animateToShallow({\n\t         *      position: [10, 10]\n\t         *  })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms\n\t         *  el._animateToShallow({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100)\n\t         */\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (!target.hasOwnProperty(name)) {\n\t                    continue;\n\t                }\n\t\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(\n\t                            path ? path + '.' + name : name,\n\t                            source[name],\n\t                            target[name],\n\t                            time,\n\t                            delay\n\t                        );\n\t                    }\n\t                    else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                }\n\t                else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    }\n\t                    else {  // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false)\n\t                    .when(time == null ? 500 : time, objShallow)\n\t                    .delay(delay || 0);\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    module.exports = Animatable;\n\n\n/***/ },\n/* 167 */\n/*!******************************************!*\\\n  !*** ./~/zrender/lib/mixin/Draggable.js ***!\n  \\******************************************/\n/***/ function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\t\n\t    function Draggable() {\n\t\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);\n\t        // this._dropTarget = null;\n\t        // this._draggingTarget = null;\n\t\n\t        // this._x = 0;\n\t        // this._y = 0;\n\t    }\n\t\n\t    Draggable.prototype = {\n\t\n\t        constructor: Draggable,\n\t\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t\n\t                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n\t            }\n\t        },\n\t\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t\n\t                draggingTarget.drift(dx, dy, e);\n\t                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\t\n\t                var dropTarget = this.findHover(x, y, draggingTarget);\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t\n\t            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\t\n\t            if (this._dropTarget) {\n\t                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n\t            }\n\t\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t\n\t    };\n\t\n\t    module.exports = Draggable;\n\n\n/***/ },\n/* 168 */\n/*!************************************!*\\\n  !*** ./~/zrender/lib/tool/path.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Path = __webpack_require__(/*! ../graphic/Path */ 6);\n\t    var PathProxy = __webpack_require__(/*! ../core/PathProxy */ 28);\n\t    var transformPath = __webpack_require__(/*! ./transformPath */ 169);\n\t    var matrix = __webpack_require__(/*! ../core/matrix */ 19);\n\t\n\t    // command chars\n\t    var cc = [\n\t        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n\t        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n\t    ];\n\t\n\t    var mathSqrt = Math.sqrt;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var PI = Math.PI;\n\t\n\t    var vMag = function(v) {\n\t        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t    };\n\t    var vRatio = function(u, v) {\n\t        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t    };\n\t    var vAngle = function(u, v) {\n\t        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n\t                * Math.acos(vRatio(u, v));\n\t    };\n\t\n\t    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t        var psi = psiDeg * (PI / 180.0);\n\t        var xp = mathCos(psi) * (x1 - x2) / 2.0\n\t                 + mathSin(psi) * (y1 - y2) / 2.0;\n\t        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n\t                 + mathCos(psi) * (y1 - y2) / 2.0;\n\t\n\t        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\t\n\t        if (lambda > 1) {\n\t            rx *= mathSqrt(lambda);\n\t            ry *= mathSqrt(lambda);\n\t        }\n\t\n\t        var f = (fa === fs ? -1 : 1)\n\t            * mathSqrt((((rx * rx) * (ry * ry))\n\t                    - ((rx * rx) * (yp * yp))\n\t                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n\t                    + (ry * ry) * (xp * xp))\n\t                ) || 0;\n\t\n\t        var cxp = f * rx * yp / ry;\n\t        var cyp = f * -ry * xp / rx;\n\t\n\t        var cx = (x1 + x2) / 2.0\n\t                 + mathCos(psi) * cxp\n\t                 - mathSin(psi) * cyp;\n\t        var cy = (y1 + y2) / 2.0\n\t                + mathSin(psi) * cxp\n\t                + mathCos(psi) * cyp;\n\t\n\t        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n\t        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n\t        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n\t        var dTheta = vAngle(u, v);\n\t\n\t        if (vRatio(u, v) <= -1) {\n\t            dTheta = PI;\n\t        }\n\t        if (vRatio(u, v) >= 1) {\n\t            dTheta = 0;\n\t        }\n\t        if (fs === 0 && dTheta > 0) {\n\t            dTheta = dTheta - 2 * PI;\n\t        }\n\t        if (fs === 1 && dTheta < 0) {\n\t            dTheta = dTheta + 2 * PI;\n\t        }\n\t\n\t        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t    }\n\t\n\t    function createPathProxyFromString(data) {\n\t        if (!data) {\n\t            return [];\n\t        }\n\t\n\t        // command string\n\t        var cs = data.replace(/-/g, ' -')\n\t            .replace(/  /g, ' ')\n\t            .replace(/ /g, ',')\n\t            .replace(/,,/g, ',');\n\t\n\t        var n;\n\t        // create pipes so that we can split the data\n\t        for (n = 0; n < cc.length; n++) {\n\t            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t        }\n\t\n\t        // create array\n\t        var arr = cs.split('|');\n\t        // init context point\n\t        var cpx = 0;\n\t        var cpy = 0;\n\t\n\t        var path = new PathProxy();\n\t        var CMD = PathProxy.CMD;\n\t\n\t        var prevCmd;\n\t        for (n = 1; n < arr.length; n++) {\n\t            var str = arr[n];\n\t            var c = str.charAt(0);\n\t            var off = 0;\n\t            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t            var cmd;\n\t\n\t            if (p.length > 0 && p[0] === '') {\n\t                p.shift();\n\t            }\n\t\n\t            for (var i = 0; i < p.length; i++) {\n\t                p[i] = parseFloat(p[i]);\n\t            }\n\t            while (off < p.length && !isNaN(p[off])) {\n\t                if (isNaN(p[0])) {\n\t                    break;\n\t                }\n\t                var ctlPtx;\n\t                var ctlPty;\n\t\n\t                var rx;\n\t                var ry;\n\t                var psi;\n\t                var fa;\n\t                var fs;\n\t\n\t                var x1 = cpx;\n\t                var y1 = cpy;\n\t\n\t                // convert l, H, h, V, and v to L\n\t                switch (c) {\n\t                    case 'l':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'L':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'm':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'l';\n\t                        break;\n\t                    case 'M':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'L';\n\t                        break;\n\t                    case 'h':\n\t                        cpx += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'H':\n\t                        cpx = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'v':\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'V':\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'C':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n\t                        );\n\t                        cpx = p[off - 2];\n\t                        cpy = p[off - 1];\n\t                        break;\n\t                    case 'c':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy\n\t                        );\n\t                        cpx += p[off - 2];\n\t                        cpy += p[off - 1];\n\t                        break;\n\t                    case 'S':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 's':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = cpx + p[off++];\n\t                        y1 = cpy + p[off++];\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'Q':\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'q':\n\t                        x1 = p[off++] + cpx;\n\t                        y1 = p[off++] + cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'T':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 't':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 'A':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                    case 'a':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                }\n\t            }\n\t\n\t            if (c === 'z' || c === 'Z') {\n\t                cmd = CMD.Z;\n\t                path.addData(cmd);\n\t            }\n\t\n\t            prevCmd = cmd;\n\t        }\n\t\n\t        path.toStatic();\n\t\n\t        return path;\n\t    }\n\t\n\t    // TODO Optimize double memory cost problem\n\t    function createPathOptions(str, opts) {\n\t        var pathProxy = createPathProxyFromString(str);\n\t        var transform;\n\t        opts = opts || {};\n\t        opts.buildPath = function (path) {\n\t            path.setData(pathProxy.data);\n\t            transform && transformPath(path, transform);\n\t            // Svg and vml renderer don't have context\n\t            var ctx = path.getContext();\n\t            if (ctx) {\n\t                path.rebuildPath(ctx);\n\t            }\n\t        };\n\t\n\t        opts.applyTransform = function (m) {\n\t            if (!transform) {\n\t                transform = matrix.create();\n\t            }\n\t            matrix.mul(transform, m, transform);\n\t            this.dirty(true);\n\t        };\n\t\n\t        return opts;\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Create a Path object from path string data\n\t         * http://www.w3.org/TR/SVG/paths.html#PathData\n\t         * @param  {Object} opts Other options\n\t         */\n\t        createFromString: function (str, opts) {\n\t            return new Path(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Create a Path class from path string data\n\t         * @param  {string} str\n\t         * @param  {Object} opts Other options\n\t         */\n\t        extendFromString: function (str, opts) {\n\t            return Path.extend(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Merge multiple paths\n\t         */\n\t        // TODO Apply transform\n\t        // TODO stroke dash\n\t        // TODO Optimize double memory cost problem\n\t        mergePath: function (pathEls, opts) {\n\t            var pathList = [];\n\t            var len = pathEls.length;\n\t            for (var i = 0; i < len; i++) {\n\t                var pathEl = pathEls[i];\n\t                if (pathEl.__dirty) {\n\t                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t                }\n\t                pathList.push(pathEl.path);\n\t            }\n\t\n\t            var pathBundle = new Path(opts);\n\t            pathBundle.buildPath = function (path) {\n\t                path.appendPath(pathList);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            };\n\t\n\t            return pathBundle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 169 */\n/*!*********************************************!*\\\n  !*** ./~/zrender/lib/tool/transformPath.js ***!\n  \\*********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var CMD = __webpack_require__(/*! ../core/PathProxy */ 28).CMD;\n\t    var vec2 = __webpack_require__(/*! ../core/vector */ 5);\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t\n\t    var points = [[], [], []];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAtan2 = Math.atan2;\n\t    function transformPath(path, m) {\n\t        var data = path.data;\n\t        var cmd;\n\t        var nPoint;\n\t        var i;\n\t        var j;\n\t        var k;\n\t        var p;\n\t\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var R = CMD.R;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        for (i = 0, j = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            j = i;\n\t            nPoint = 0;\n\t\n\t            switch (cmd) {\n\t                case M:\n\t                    nPoint = 1;\n\t                    break;\n\t                case L:\n\t                    nPoint = 1;\n\t                    break;\n\t                case C:\n\t                    nPoint = 3;\n\t                    break;\n\t                case Q:\n\t                    nPoint = 2;\n\t                    break;\n\t                case A:\n\t                    var x = m[4];\n\t                    var y = m[5];\n\t                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n\t                    // cx\n\t                    data[i++] += x;\n\t                    // cy\n\t                    data[i++] += y;\n\t                    // Scale rx and ry\n\t                    // FIXME Assume psi is 0 here\n\t                    data[i++] *= sx;\n\t                    data[i++] *= sy;\n\t\n\t                    // Start angle\n\t                    data[i++] += angle;\n\t                    // end angle\n\t                    data[i++] += angle;\n\t                    // FIXME psi\n\t                    i += 2;\n\t                    j = i;\n\t                    break;\n\t                case R:\n\t                    // x0, y0\n\t                    p[0] = data[i++];\n\t                    p[1] = data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t                    // x1, y1\n\t                    p[0] += data[i++];\n\t                    p[1] += data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t            }\n\t\n\t            for (k = 0; k < nPoint; k++) {\n\t                var p = points[k];\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t\n\t                v2ApplyTransform(p, p, m);\n\t                // Write back\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = transformPath;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// echarts.simple.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e2f5d11b7ea9dedb1522","/**\n * Export echarts as CommonJS module\n */\nmodule.exports = require('./lib/echarts');\n\nrequire('./lib/chart/line');\nrequire('./lib/chart/bar');\nrequire('./lib/chart/pie');\nrequire('./lib/component/grid');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.simple.js\n// module id = 0\n// module chunks = 2","/**\n * @module zrender/core/util\n */\n\n\n    // mergeDate\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuildInObject(sourceProp)\n                    && !isBuildInObject(targetProp)\n                ) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuildInObject: isBuildInObject,\n        isDom: isDom,\n        retrieve: retrieve,\n        assert: assert,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/util.js\n// module id = 1\n// module chunks = 0 1 2","// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = require('zrender/lib/core/env');\n\n    var GlobalModel = require('./model/Global');\n    var ExtensionAPI = require('./ExtensionAPI');\n    var CoordinateSystemManager = require('./CoordinateSystem');\n    var OptionManager = require('./model/OptionManager');\n\n    var ComponentModel = require('./model/Component');\n    var SeriesModel = require('./model/Series');\n\n    var ComponentView = require('./view/Component');\n    var ChartView = require('./view/Chart');\n    var graphic = require('./util/graphic');\n    var modelUtil = require('./util/model');\n\n    var zrender = require('zrender');\n    var zrUtil = require('zrender/lib/core/util');\n    var colorTool = require('zrender/lib/tool/color');\n    var Eventful = require('zrender/lib/mixin/Eventful');\n    var timsort = require('zrender/lib/core/timsort');\n\n    var each = zrUtil.each;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flag_in_main_process';\n    var HAS_GRADIENT_OR_PATTERN_BG = '_hasGradientOrPatternBg';\n\n\n    var OPTION_UPDATED = '_optionUpdated';\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts (dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = new ExtensionAPI(this);\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        this._zr.animation.on('frame', this._onframe, this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * @param {Object} option\n     * @param {boolean} notMerge\n     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = true;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            this._zr.refreshImmediately();\n            this[OPTION_UPDATED] = false;\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        this._flushPendingActions();\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.time && console.time('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            // console.time && console.timeEnd('update');\n        },\n\n        // PENDING\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        highlight: function (payload) {\n            toggleHighlight.call(this, 'highlight', payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        downplay: function (payload) {\n            toggleHighlight.call(this, 'downplay', payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            updateMethods.update.call(this, payload);\n        }\n    };\n\n    /**\n     * @param {Object} payload\n     * @private\n     */\n    function toggleHighlight(method, payload) {\n        var ecModel = this._model;\n\n        // dispatchAction before setOption\n        if (!ecModel) {\n            return;\n        }\n\n        ecModel.eachComponent(\n            {mainType: 'series', query: payload},\n            function (seriesModel, index) {\n                var chartView = this._chartsMap[seriesModel.__viewId];\n                if (chartView && chartView.__alive) {\n                    chartView[method](\n                        seriesModel, ecModel, this._api, payload\n                    );\n                }\n            },\n            this\n        );\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        this._flushPendingActions();\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {boolean} [silent=false] Whether trigger event.\n     */\n    echartsProto.dispatchAction = function (payload, silent) {\n        var actionWrap = actions[payload.type];\n        if (!actionWrap) {\n            return;\n        }\n\n        var actionInfo = actionWrap.actionInfo;\n        var updateMethod = actionInfo.update || 'update';\n\n        // if (__DEV__) {\n        //     zrUtil.assert(\n        //         !this[IN_MAIN_PROCESS],\n        //         '`dispatchAction` should not be called during main process.'\n        //         + 'unless updateMathod is \"none\".'\n        //     );\n        // }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';\n        for (var i = 0; i < payloads.length; i++) {\n            var batchItem = payloads[i];\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // Highlight and downplay are special.\n            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);\n        }\n\n        if (updateMethod !== 'none' && !isHighlightOrDownplay) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payload.type,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n\n        this._flushPendingActions();\n\n    };\n\n    echartsProto._flushPendingActions = function () {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            this.dispatchAction(payload);\n        }\n    };\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = ComponentModel.parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = viewId;\n            view.__alive = true;\n            view.__id = viewId;\n            view.__model = model;\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                if (previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var actions = [];\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.3.1',\n        dependencies: {\n            zrender: '3.2.1'\n        }\n    };\n\n    function enableConnect(chart) {\n\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n\n    }\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        dom.setAttribute &&\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (zrUtil.isDom(chart)) {\n            chart = echarts.getInstanceByDom(chart);\n        }\n        else if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        return instances[key];\n    };\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n\n    var parseClassType = ComponentModel.parseClassType;\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts, superClass) {\n        var Clazz = ComponentModel;\n        if (superClass) {\n            var classType = parseClassType(superClass);\n            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts, superClass) {\n        var Clazz = ComponentView;\n        if (superClass) {\n            var classType = parseClassType(superClass);\n            Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts, superClass) {\n        var Clazz = SeriesModel;\n        if (superClass) {\n            superClass = 'series.' + superClass.replace('series.', '');\n            var classType = parseClassType(superClass);\n            Clazz = SeriesModel.getClass(classType.main, classType.sub, true);\n        }\n        return Clazz.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts, superClass) {\n        var Clazz = ChartView;\n        if (superClass) {\n            superClass.replace('series.', '');\n            var classType = parseClassType(superClass);\n            Clazz = ChartView.getClass(classType.main, true);\n        }\n        return Clazz.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n    echarts.registerLoading('default', require('./loading/default'));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n\n    // --------\n    // Exports\n    // --------\n    //\n    echarts.List = require('./data/List');\n    echarts.Model = require('./model/Model');\n\n    echarts.graphic = require('./util/graphic');\n    echarts.number = require('./util/number');\n    echarts.format = require('./util/format');\n    echarts.matrix = require('zrender/lib/core/matrix');\n    echarts.vector = require('zrender/lib/core/vector');\n    echarts.color = require('zrender/lib/tool/color');\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits',\n            'reduce', 'filter', 'bind', 'curry', 'isArray',\n            'isString', 'isObject', 'isFunction', 'extend', 'defaults'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/echarts.js\n// module id = 2\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var pathTool = require('zrender/lib/tool/path');\n    var round = Math.round;\n    var Path = require('zrender/lib/graphic/Path');\n    var colorTool = require('zrender/lib/tool/color');\n    var matrix = require('zrender/lib/core/matrix');\n    var vector = require('zrender/lib/core/vector');\n    var Gradient = require('zrender/lib/graphic/Gradient');\n\n    var graphic = {};\n\n    graphic.Group = require('zrender/lib/container/Group');\n\n    graphic.Image = require('zrender/lib/graphic/Image');\n\n    graphic.Text = require('zrender/lib/graphic/Text');\n\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\n\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\n\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\n\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\n\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\n\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\n\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\n\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\n\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\n\n    graphic.CompoundPath = require('zrender/lib/graphic/CompoundPath');\n\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\n\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\n\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            this.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver() {\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut() {\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     */\n    graphic.setHoverStyle = function (el, hoverStyle) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n        // Remove previous bound handlers\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        var animationEnabled = animatableModel\n            && (\n                animatableModel.ifEnableAnimation\n                ? animatableModel.ifEnableAnimation()\n                // Directly use animation property\n                : animatableModel.getShallow('animation')\n            );\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel\n                && animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel\n                && animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel\n                && animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(dataIndex);\n            }\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n                : (el.attr(props), cb && cb());\n        }\n        else {\n            el.attr(props);\n            cb && cb();\n        }\n    }\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} vertex [x, y]\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (vertex, transform, invert) {\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], vertex, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    module.exports = graphic;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/graphic.js\n// module id = 3\n// module chunks = 0 1 2","/**\n * \n * @module echarts/util/number\n */\n\n\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * Fix rounding error of float numbers\n     * @param {number} x\n     * @return {number}\n     */\n    number.round = function (x, precision) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        return +(+x).toFixed(precision);\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n        var dotIndex = str.indexOf('.');\n        if (dotIndex < 0) {\n            return 0;\n        }\n        return str.length - 1 - dotIndex;\n    };\n\n    /**\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number}  precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        return Math.max(\n            -dataQuantity + sizeQuantity,\n            0\n        );\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    /**\n     * @param {string|Date|number} value\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Treat as ISO format. See issue #3623\n            var ret = new Date(value);\n            if (isNaN(+ret)) {\n                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n            }\n            return ret;\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n    };\n\n    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n    /**\n     * find a nice number approximately equal to x. Round the number if round = true, take ceiling if round = false\n     * The primary observation is that the nicest numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     * @param  {number} val\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exp10 = number.quantity(val);\n        var f = val / exp10; // between 1 and 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        return nf * exp10;\n    };\n\n    module.exports = number;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/number.js\n// module id = 4\n// module chunks = 0 1 2","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * \n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} \n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/vector.js\n// module id = 5\n// module chunks = 0 1 2","/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || (\n                lineDash && !ctxLineDash && hasStroke\n            )) {\n                path = this.path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Path.js\n// module id = 6\n// module chunks = 0 1 2","\n\n    var formatUtil = require('./format');\n    var nubmerUtil = require('./number');\n    var Model = require('../model/Model');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            zrUtil.each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n\n    modelUtil.LABEL_OPTIONS = ['position', 'show', 'textStyle', 'distance', 'formatter'];\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return zrUtil.isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && zrUtil.isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n\n            var seriesIndex = this.seriesIndex;\n            var seriesName = this.name;\n\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: seriesIndex,\n                seriesName: seriesName,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: data.getItemVisual(dataIndex, 'color'),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get(['label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (zrUtil.isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        zrUtil.each(newCptOptions, function (cptOption, index) {\n            if (!zrUtil.isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        zrUtil.each(newCptOptions, function (cptOption, index) {\n            if (!zrUtil.isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return zrUtil.isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, goeName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        zrUtil.each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = parsedKey[2];\n\n            if (!mainType || !queryType) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            queryParam[queryType.toLowerCase()] = value;\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/model.js\n// module id = 7\n// module chunks = 0 1 2","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // \n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/BoundingRect.js\n// module id = 8\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('./number');\n    var textContain = require('zrender/lib/contain/text');\n\n    var formatUtil = {};\n    /**\n     * ,\n     * @type {string|number} x\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str) {\n        return str.toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n    };\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        else if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    };\n\n    formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param  {string} tpl\n     * @param  {Array.<Object>|Object} paramsList\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            tpl = tpl.replace(wrapVar(alias),  wrapVar(alias, 0));\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    paramsList[seriesIdx][$vars[k]]\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var y = date.getFullYear();\n        var M = date.getMonth() + 1;\n        var d = date.getDate();\n        var h = date.getHours();\n        var m = date.getMinutes();\n        var s = date.getSeconds();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .toLowerCase()\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    module.exports = formatUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/format.js\n// module id = 9\n// module chunks = 0 1 2","/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazzUtil = require('../util/clazz');\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model \n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         *  Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (!path) {\n                return this.option;\n            }\n\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n\n            var obj = this.option;\n            var parentModel = this.parentModel;\n            for (var i = 0; i < path.length; i++) {\n                // Ignore empty\n                if (!path[i]) {\n                    continue;\n                }\n                // obj could be number/string/... (like 0)\n                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\n                if (obj == null) {\n                    break;\n                }\n            }\n            if (obj == null && parentModel && !ignoreParent) {\n                obj = parentModel.get(path);\n            }\n            return obj;\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = this.parentModel;\n            if (val == null && parentModel && !ignoreParent) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string} path\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = this.get(path, true);\n            var thisParentModel = this.parentModel;\n            var model = new Model(\n                obj, parentModel || (thisParentModel && thisParentModel.getModel(path)),\n                this.ecModel\n            );\n            return model;\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        }\n    };\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, require('./mixin/lineStyle'));\n    mixin(Model, require('./mixin/areaStyle'));\n    mixin(Model, require('./mixin/textStyle'));\n    mixin(Model, require('./mixin/itemStyle'));\n\n    module.exports = Model;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/Model.js\n// module id = 10\n// module chunks = 0 1 2","/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // canvas\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default,\n                // only MS browsers are reliable on pointer events currently.\n                && (browser.edge || (browser.ie && browser.version >= 10))\n        };\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/env.js\n// module id = 11\n// module chunks = 0 1 2","/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = require('./Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var arrayPush = Array.prototype.push;\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var layout = require('../util/layout');\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!this.hasOwnProperty('__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                this.__defaultOption = defaultOption;\n            }\n            return this.__defaultOption;\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n\n    module.exports = ComponentModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/Component.js\n// module id = 12\n// module chunks = 0 1 2","'use strict';\n// Layout helpers for each component positioning\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n    var numberUtil = require('./number');\n    var formatUtil = require('./format');\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n    /**\n     * Position group of component in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     */\n    layout.positionGroup = function (\n        group, positionInfo, containerRect, margin\n    ) {\n        var groupRect = group.getBoundingRect();\n\n        positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {\n            width: groupRect.width,\n            height: groupRect.height\n        });\n\n        positionInfo = layout.getLayoutRect(\n            positionInfo, containerRect, margin\n        );\n\n        group.attr('position', [\n            positionInfo.x - groupRect.x,\n            positionInfo.y - groupRect.y\n        ]);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n        var hNames = ['width', 'left', 'right']; // Order by priority.\n        var vNames = ['height', 'top', 'bottom']; // Order by priority.\n        var hResult = merge(hNames);\n        var vResult = merge(vNames);\n\n        copy(hNames, targetOption, hResult);\n        copy(vNames, targetOption, vResult);\n\n        function merge(names) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/layout.js\n// module id = 13\n// module chunks = 0 1 2","/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = require('../model/Model');\n    var DataDiffer = require('./DataDiffer');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    var transferProperties = function (a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string>} dimensions\n     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n            }\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var size = data.length;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var idList = [];\n        var nameRepeatCount = {};\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var idx = 0; idx < data.length; idx++) {\n            var dataItem = data[idx];\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n            }\n\n            indices.push(idx);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < data.length; i++) {\n            if (!nameList[i]) {\n                if (data[i] && data[i].name != null) {\n                    nameList[i] = data[i].name;\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = data[i] && data[i].id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null) {\n            return NaN;\n        }\n\n        var value = storage[dim] && storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getDataExtent = function (dim, stack) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                value < min && (min = value);\n                value > max && (max = value);\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {number}\n     */\n    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var nearestIdx = -1;\n        if (dimData) {\n            var minDist = Number.MAX_VALUE;\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var diff = value - this.get(dim, i, stack);\n                var dist = Math.abs(diff);\n                if (\n                    diff <= maxDistance\n                    && (dist < minDist\n                        // For the case of two data are same on xAxis, which has sequence data.\n                        // Show the nearest index\n                        // https://github.com/ecomfe/echarts/issues/2869\n                        || (dist === minDist && diff > 0)\n                    )\n                ) {\n                    minDist = dist;\n                    nearestIdx = i;\n                }\n            }\n        }\n        return nearestIdx;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData[this.getRawIndex(idx)];\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        return new DataDiffer(\n            otherList ? otherList.indices : [], this.indices, function (idx) {\n                return otherIdList[idx] || (idx + '');\n            }, function (idx) {\n                return idList[idx] || (idx + '');\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} ignoreParent\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/data/List.js\n// module id = 14\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../util/format');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var colorPaletteMixin = require('./mixin/colorPalette');\n    var env = require('zrender/lib/core/env');\n\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            this._dataBeforeProcessed = this.getInitialData(option, ecModel);\n\n            // If we reverse the order (make this._data firstly, and then make\n            // this._dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause this._data.graph.data !== this._data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this._data = this._dataBeforeProcessed.cloneShallow();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                this._data = data;\n                this._dataBeforeProcessed = data.cloneShallow();\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            return dataType == null ? this._data : this._data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            this._data = data;\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return this._dataBeforeProcessed;\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return [coordDim];\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return dataDim;\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var result = [];\n\n                zrUtil.each(value, function (val, idx) {\n                    var dimInfo = data.getDimensionInfo(idx);\n                    var dimType = dimInfo && dimInfo.type;\n                    var valStr;\n\n                    if (dimType === 'ordinal') {\n                        valStr = val + '';\n                    }\n                    else if (dimType === 'time') {\n                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/mm/dd hh:mm:ss', val);\n                    }\n                    else {\n                        valStr = addCommas(val);\n                    }\n\n                    valStr && result.push(valStr);\n                });\n\n                return result.join(', ');\n            }\n\n            var data = this._data;\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? formatArrayValue(value) : addCommas(value);\n            var name = data.getName(dataIndex);\n            var color = data.getItemVisual(dataIndex, 'color');\n            var colorEl = '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '\"></span>';\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            return !multipleSeries\n                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl\n                    + (name\n                        ? encodeHTML(name) + ' : ' + formattedValue\n                        : formattedValue)\n                  )\n                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);\n        },\n\n        /**\n         * @return {boolean}\n         */\n        ifEnableAnimation: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            this._data = this._dataBeforeProcessed.cloneShallow();\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Array.<number>} data indices.\n         */\n        getAxisTooltipDataIndex: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/Series.js\n// module id = 15\n// module chunks = 0 1 2","\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText  Canvas \n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME \n        var lineHeight = getTextWidth('', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var halfHeight = height / 2 - textHeight / 2;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/text.js\n// module id = 16\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/curve.js\n// module id = 17\n// module chunks = 0 1 2","/**\n * @module zrender/tool/color\n */\n\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();  // dup.\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                ];\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                ];\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return [\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    ];\n                case 'hsla':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    return hsla2rgba(params);\n                case 'hsl':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return hsla2rgba(params);\n                default:\n                    return;\n            }\n        }\n\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        var rgba = [\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n        ];\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n        out = out || [0, 0, 0, 0];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/color.js\n// module id = 18\n// module chunks = 0 1 2","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * \n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/matrix.js\n// module id = 19\n// module chunks = 0 1 2","/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * trigger\n         *\n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} [handler] \n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * \n         *\n         * @param {string} type \n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * context, context\n         * @param {string} type \n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Eventful.js\n// module id = 20\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    /**\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\n            var Clazz = storage[componentTypeMain];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/clazz.js\n// module id = 21\n// module chunks = 0 1 2","\n\n    var OrdinalScale = require('../scale/Ordinal');\n    var IntervalScale = require('../scale/Interval');\n    require('../scale/Time');\n    require('../scale/Log');\n    var Scale = require('../scale/Scale');\n\n    var numberUtil = require('../util/number');\n    var zrUtil = require('zrender/lib/core/util');\n    var textContain = require('zrender/lib/contain/text');\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     */\n    axisHelper.getScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var originalExtent = scale.getExtent();\n        var span = originalExtent[1] - originalExtent[0];\n        if (scale.type === 'ordinal') {\n            // If series has no data, scale extent may be wrong\n            if (!isFinite(span)) {\n                return [0, 0];\n            }\n            else {\n                return originalExtent;\n            }\n        }\n        var min = model.getMin ? model.getMin() : model.get('min');\n        var max = model.getMax ? model.getMax() : model.get('max');\n        var crossZero = model.getNeedCrossZero\n            ? model.getNeedCrossZero() : !model.get('scale');\n        var boundaryGap = model.get('boundaryGap');\n        if (!zrUtil.isArray(boundaryGap)) {\n            boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n        }\n        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n        var fixMin = true;\n        var fixMax = true;\n        // Add boundary gap\n        if (min == null) {\n            min = originalExtent[0] - boundaryGap[0] * span;\n            fixMin = false;\n        }\n        if (max == null) {\n            max = originalExtent[1] + boundaryGap[1] * span;\n            fixMax = false;\n        }\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n        // Evaluate if axis needs cross zero\n        if (crossZero) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var extent = axisHelper.getScaleExtent(axis, model);\n        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;\n        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent(splitNumber, fixMin, fixMax);\n\n        // Use minInterval to constraint the calculated interval.\n        // If calculated interval is less than minInterval. increase the interval quantity until\n        // it is larger than minInterval.\n        // For example:\n        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n        //  an integer axis.\n        var minInterval = model.get('minInterval');\n        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n            var interval = scale.getInterval();\n            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n            // while (interval < minInterval) {\n            //     var quantity = numberUtil.quantity(interval);\n            //     interval = quantity * 10;\n            //     scaleQuantity *= 10;\n            // }\n            extent = scale.getExtent();\n            var origin = (extent[1] + extent[0]) / 2;\n            scale.setExtent(\n                intervalScale * (extent[0] - origin) + origin,\n                intervalScale * (extent[1] - origin) + origin\n            );\n            scale.niceExtent(splitNumber);\n        }\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // axislabelhorizontalvertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val);\n                };\n            })(labelFormatter);\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axis.type === 'category' ? scale.getLabel(tick) : tick,\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    module.exports = axisHelper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/axisHelper.js\n// module id = 22\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * Interface of Coordinate System Class\n     *\n     * create:\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {module:echarts/ExtensionAPI} api\n     *     @return {Object} coordinate system instance\n     *\n     * update:\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {module:echarts/ExtensionAPI} api\n     *\n     * convertToPixel:\n     * convertFromPixel:\n     *     These two methods is also responsible for determine whether this\n     *     coodinate system is applicable to the given `finder`.\n     *     Each coordinate system will be tried, util one returns none\n     *     null/undefined value.\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {Object} finder\n     *     @param {Array|number} value\n     *     @return {Array|number} convert result.\n     *\n     * containPoint:\n     *     @param {Array.<number>} point In pixel coordinate system.\n     *     @return {boolean}\n     */\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/CoordinateSystem.js\n// module id = 23\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n    var env = require('./env');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * domtouch.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // \n        Dispatcher: Eventful\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/event.js\n// module id = 24\n// module chunks = 0 1 2","'use strict';\n// Symbol factory\n\n\n    var graphic = require('./graphic');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME  onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/symbol.js\n// module id = 26\n// module chunks = 0 1 2","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/view/Chart.js\n// module id = 27\n// module chunks = 0 1 2","'use strict';\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n\n        this._len = 0;\n\n        this._ctx = null;\n\n        this._xi = 0;\n        this._yi = 0;\n\n        this._x0 = 0;\n        this._y0 = 0;\n\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            this._len = 0;\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._xi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context  rebuildPath  fill\n         * stroke \n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         *  Path \n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * \n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         *  Path \n         * \n         */\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         *  Float32Array \n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo  subpath, \n                        //  closePath \n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc \n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc \n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/PathProxy.js\n// module id = 28\n// module chunks = 0 1 2","\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Gradient.js\n// module id = 29\n// module chunks = 0 1 2","/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * Complete the dimensions array guessed from the data structure.\n     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n     * @return {Array.<string>}\n     */\n    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n        if (!data) {\n            return dimensions;\n        }\n\n        var value0 = retrieveValue(data[0]);\n        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\n        defaultNames = defaultNames || [];\n        extraPrefix = extraPrefix || 'extra';\n        for (var i = 0; i < dimSize; i++) {\n            if (!dimensions[i]) {\n                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));\n                dimensions[i] = guessOrdinal(data, i)\n                    ? {type: 'ordinal', name: name}\n                    : name;\n            }\n        }\n\n        return dimensions;\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (zrUtil.isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/data/helper/completeDimensions.js\n// module id = 30\n// module chunks = 0 1 2","// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/mixin/makeStyleMapper.js\n// module id = 31\n// module chunks = 0 1 2","/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = require('../util/clazz');\n\n    function Scale() {\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/scale/Scale.js\n// module id = 32\n// module chunks = 0 1 2","\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debugcatchBrushExceptiontrue\n         * 0 : debug\n         * 1 : \n         * 2 : \n         */\n        debugMode: 0,\n\n        // retina \n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/config.js\n// module id = 33\n// module chunks = 0 1 2","/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * \n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         *  index \n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * \n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         *  nextSibling \n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToMap(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromMap(child.id);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * \n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/container/Group.js\n// module id = 34\n// module chunks = 0 1 2","'use strict';\n\n\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var CoordinateSystem = require('../../CoordinateSystem');\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && registeredCoordSys.dimensions) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n        }\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            completeDimensions(dimensions, data, ['x', 'y', 'z']);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            completeDimensions(dimensions, data, ['radius', 'angle', 'value']);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel) {\n            // TODO Region\n            // \n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, ['lng', 'lat', 'value'])\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/helper/createListFromArray.js\n// module id = 35\n// module chunks = 0 1 2","'use strict';\n\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('../coord/cartesian/Grid');\n\n    require('./axis');\n\n    // Grid view\n    echarts.extendComponentView({\n\n        type: 'grid',\n\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({\n                        fill: gridModel.get('backgroundColor')\n                    }, gridModel.getItemStyle()),\n                    silent: true,\n                    z2: -1\n                }));\n            }\n        }\n\n    });\n\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/grid.js\n// module id = 36\n// module chunks = 0 1 2","/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable Painter \n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * true\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * zlevelcanvas\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * \n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * \n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         *  x, y \n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         *  x, y \n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * \n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * \n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO,  bind \n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Displayable.js\n// module id = 37\n// module chunks = 0 1 2","/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var Scale = require('./Scale');\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            var interval = this._interval;\n            var extent = this._extent;\n            var ticks = [];\n\n            // Consider this case: using dataZoom toolbox, zoom and zoom.\n            var safeLimit = 10000;\n\n            if (interval) {\n                var niceExtent = this._niceExtent;\n                var precision = getPrecisionSafe(interval) + 2;\n\n                if (extent[0] < niceExtent[0]) {\n                    ticks.push(extent[0]);\n                }\n                var tick = niceExtent[0];\n\n                while (tick <= niceExtent[1]) {\n                    ticks.push(tick);\n                    // Avoid rounding error\n                    tick = roundingErrorFix(tick + interval, precision);\n                    if (ticks.length > safeLimit) {\n                        return [];\n                    }\n                }\n                // Consider this case: the last item of ticks is smaller\n                // than niceExtent[1] and niceExtent[1] === extent[1].\n                if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceExtent[1])) {\n                    ticks.push(extent[1]);\n                }\n            }\n\n            return ticks;\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} n\n         * @return {number}\n         */\n        getLabel: function (data) {\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         */\n        niceTicks: function (splitNumber) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n            // var niceSpan = numberUtil.nice(span, false);\n            var step = roundingErrorFix(\n                numberUtil.nice(span / splitNumber, true),\n                Math.max(\n                    getPrecisionSafe(extent[0]),\n                    getPrecisionSafe(extent[1])\n                // extent may be [0, 1], and step should have 1 more digits.\n                // To make it safe we add 2 more digits\n                ) + 2\n            );\n\n            var precision = getPrecisionSafe(step) + 2;\n            // Niced extent inside original extent\n            var niceExtent = [\n                roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n                roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n            ];\n\n            this._interval = step;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [splitNumber = 5] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(splitNumber);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/scale/Interval.js\n// module id = 38\n// module chunks = 0 1 2","/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n\n    var graphic = require('../../util/graphic');\n    var Symbol = require('./Symbol');\n\n    /**\n     * @constructor\n     * @alias module:echarts/chart/helper/SymbolDraw\n     * @param {module:zrender/graphic/Group} [symbolCtor]\n     */\n    function SymbolDraw(symbolCtor) {\n        this.group = new graphic.Group();\n\n        this._symbolCtor = symbolCtor || Symbol;\n    }\n\n    var symbolDrawProto = SymbolDraw.prototype;\n\n    function symbolNeedsDraw(data, idx, isIgnore) {\n        var point = data.getItemLayout(idx);\n        // Is an object\n        // if (point && point.hasOwnProperty('point')) {\n        //     point = point.point;\n        // }\n        return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx))\n                    && data.getItemVisual(idx, 'symbol') !== 'none';\n    }\n    /**\n     * Update symbols draw by new data\n     * @param {module:echarts/data/List} data\n     * @param {Array.<boolean>} [isIgnore]\n     */\n    symbolDrawProto.updateData = function (data, isIgnore) {\n        var group = this.group;\n        var seriesModel = data.hostModel;\n        var oldData = this._data;\n\n        var SymbolCtor = this._symbolCtor;\n\n        var seriesScope = {\n            itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n            hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n            symbolRotate: seriesModel.get('symbolRotate'),\n            symbolOffset: seriesModel.get('symbolOffset'),\n            hoverAnimation: seriesModel.get('hoverAnimation'),\n\n            labelModel: seriesModel.getModel('label.normal'),\n            hoverLabelModel: seriesModel.getModel('label.emphasis')\n        };\n\n        data.diff(oldData)\n            .add(function (newIdx) {\n                var point = data.getItemLayout(newIdx);\n                if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n                    symbolEl.attr('position', point);\n                    data.setItemGraphicEl(newIdx, symbolEl);\n                    group.add(symbolEl);\n                }\n            })\n            .update(function (newIdx, oldIdx) {\n                var symbolEl = oldData.getItemGraphicEl(oldIdx);\n                var point = data.getItemLayout(newIdx);\n                if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    group.remove(symbolEl);\n                    return;\n                }\n                if (!symbolEl) {\n                    symbolEl = new SymbolCtor(data, newIdx);\n                    symbolEl.attr('position', point);\n                }\n                else {\n                    symbolEl.updateData(data, newIdx, seriesScope);\n                    graphic.updateProps(symbolEl, {\n                        position: point\n                    }, seriesModel);\n                }\n\n                // Add back\n                group.add(symbolEl);\n\n                data.setItemGraphicEl(newIdx, symbolEl);\n            })\n            .remove(function (oldIdx) {\n                var el = oldData.getItemGraphicEl(oldIdx);\n                el && el.fadeOut(function () {\n                    group.remove(el);\n                });\n            })\n            .execute();\n\n        this._data = data;\n    };\n\n    symbolDrawProto.updateLayout = function () {\n        var data = this._data;\n        if (data) {\n            // Not use animation\n            data.eachItemGraphicEl(function (el, idx) {\n                var point = data.getItemLayout(idx);\n                el.attr('position', point);\n            });\n        }\n    };\n\n    symbolDrawProto.remove = function (enableAnimation) {\n        var group = this.group;\n        var data = this._data;\n        if (data) {\n            if (enableAnimation) {\n                data.eachItemGraphicEl(function (el) {\n                    el.fadeOut(function () {\n                        group.remove(el);\n                    });\n                });\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    };\n\n    module.exports = SymbolDraw;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/helper/SymbolDraw.js\n// module id = 39\n// module chunks = 0 1 2","\n\n    var numberUtil = require('../util/number');\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = require('zrender/lib/core/util');\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            var ret = this._extent.slice();\n            return ret;\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        }\n    };\n\n    module.exports = Axis;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/Axis.js\n// module id = 42\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazz = require('./clazz');\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/util/component.js\n// module id = 43\n// module chunks = 0 1 2","// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/timsort.js\n// module id = 44\n// module chunks = 0 1 2","'use strict';\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            var key = keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/data/DataDiffer.js\n// module id = 45\n// module chunks = 0 1 2","\n\n    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\n        // Encoding visual for all series include which is filtered for legend drawing\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n\n            var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n            var symbolSize = seriesModel.get('symbolSize');\n\n            data.setVisual({\n                legendSymbol: legendSymbol || symbolType,\n                symbol: symbolType,\n                symbolSize: symbolSize\n            });\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof symbolSize === 'function') {\n                    data.each(function (idx) {\n                        var rawValue = seriesModel.getRawValue(idx);\n                        // FIXME\n                        var params = seriesModel.getDataParams(idx);\n                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n                    });\n                }\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var itemSymbolType = itemModel.getShallow('symbol', true);\n                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n                    // If has item symbol\n                    if (itemSymbolType != null) {\n                        data.setItemVisual(idx, 'symbol', itemSymbolType);\n                    }\n                    if (itemSymbolSize != null) {\n                        // PENDING Transform symbolSize ?\n                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n                    }\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/visual/symbol.js\n// module id = 46\n// module chunks = 0 1 2","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/log.js\n// module id = 47\n// module chunks = 0 1 2","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // \n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var width = style.width || image.width;\n                var height = style.height || image.height;\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // \n                if (!image.width || !image.height) {\n                    return;\n                }\n\n                // transform\n                this.setTransform(ctx);\n\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                // \n                if (style.width == null) {\n                    style.width = width;\n                }\n                if (style.height == null) {\n                    style.height = height;\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Image.js\n// module id = 48\n// module chunks = 0 1 2","/**\n * @module echarts/chart/helper/Symbol\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolUtil = require('../../util/symbol');\n    var graphic = require('../../util/graphic');\n    var numberUtil = require('../../util/number');\n\n    function normalizeSymbolSize(symbolSize) {\n        symbolSize = symbolSize instanceof Array\n            ? symbolSize.slice()\n            : [+symbolSize, +symbolSize];\n        symbolSize[0] /= 2;\n        symbolSize[1] /= 2;\n        return symbolSize;\n    }\n\n    /**\n     * @constructor\n     * @alias {module:echarts/chart/helper/Symbol}\n     * @param {module:echarts/data/List} data\n     * @param {number} idx\n     * @extends {module:zrender/graphic/Group}\n     */\n    function Symbol(data, idx, seriesScope) {\n        graphic.Group.call(this);\n\n        this.updateData(data, idx, seriesScope);\n    }\n\n    var symbolProto = Symbol.prototype;\n\n    function driftSymbol(dx, dy) {\n        this.parent.drift(dx, dy);\n    }\n\n    symbolProto._createSymbol = function (symbolType, data, idx) {\n        // Remove paths created before\n        this.removeAll();\n\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // var symbolPath = symbolUtil.createSymbol(\n        //     symbolType, -0.5, -0.5, 1, 1, color\n        // );\n        // If width/height are set too small (e.g., set to 1) on ios10\n        // and macOS Sierra, a circle stroke become a rect, no matter what\n        // the scale is set. So we set width/height as 2. See #4150.\n        var symbolPath = symbolUtil.createSymbol(\n            symbolType, -1, -1, 2, 2, color\n        );\n\n        symbolPath.attr({\n            z2: 100,\n            culling: true,\n            scale: [0, 0]\n        });\n        // Rewrite drift method\n        symbolPath.drift = driftSymbol;\n\n        var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\n        graphic.initProps(symbolPath, {\n            scale: size\n        }, seriesModel, idx);\n        this._symbolType = symbolType;\n\n        this.add(symbolPath);\n    };\n\n    /**\n     * Stop animation\n     * @param {boolean} toLastFrame\n     */\n    symbolProto.stopSymbolAnimation = function (toLastFrame) {\n        this.childAt(0).stopAnimation(toLastFrame);\n    };\n\n    /**\n     * Get symbol path element\n     */\n    symbolProto.getSymbolPath = function () {\n        return this.childAt(0);\n    };\n\n    /**\n     * Get scale(aka, current symbol size).\n     * Including the change caused by animation\n     */\n    symbolProto.getScale = function () {\n        return this.childAt(0).scale;\n    };\n\n    /**\n     * Highlight symbol\n     */\n    symbolProto.highlight = function () {\n        this.childAt(0).trigger('emphasis');\n    };\n\n    /**\n     * Downplay symbol\n     */\n    symbolProto.downplay = function () {\n        this.childAt(0).trigger('normal');\n    };\n\n    /**\n     * @param {number} zlevel\n     * @param {number} z\n     */\n    symbolProto.setZ = function (zlevel, z) {\n        var symbolPath = this.childAt(0);\n        symbolPath.zlevel = zlevel;\n        symbolPath.z = z;\n    };\n\n    symbolProto.setDraggable = function (draggable) {\n        var symbolPath = this.childAt(0);\n        symbolPath.draggable = draggable;\n        symbolPath.cursor = draggable ? 'move' : 'pointer';\n    };\n\n    /**\n     * Update symbol properties\n     * @param  {module:echarts/data/List} data\n     * @param  {number} idx\n     */\n    symbolProto.updateData = function (data, idx, seriesScope) {\n        this.silent = false;\n\n        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n        var seriesModel = data.hostModel;\n        var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n        if (symbolType !== this._symbolType) {\n            this._createSymbol(symbolType, data, idx);\n        }\n        else {\n            var symbolPath = this.childAt(0);\n            graphic.updateProps(symbolPath, {\n                scale: symbolSize\n            }, seriesModel, idx);\n        }\n        this._updateCommon(data, idx, symbolSize, seriesScope);\n        this._seriesModel = seriesModel;\n    };\n\n    // Update common properties\n    var normalStyleAccessPath = ['itemStyle', 'normal'];\n    var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\n    var normalLabelAccessPath = ['label', 'normal'];\n    var emphasisLabelAccessPath = ['label', 'emphasis'];\n\n    symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n        var symbolPath = this.childAt(0);\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // Reset style\n        if (symbolPath.type !== 'image') {\n            symbolPath.useStyle({\n                strokeNoScale: true\n            });\n        }\n\n        seriesScope = seriesScope || null;\n\n        var itemStyle = seriesScope && seriesScope.itemStyle;\n        var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n        var symbolRotate = seriesScope && seriesScope.symbolRotate;\n        var symbolOffset = seriesScope && seriesScope.symbolOffset;\n        var labelModel = seriesScope && seriesScope.labelModel;\n        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n        var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n\n        if (!seriesScope || data.hasItemOption) {\n            var itemModel = data.getItemModel(idx);\n\n            // Color must be excluded.\n            // Because symbol provide setColor individually to set fill and stroke\n            itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n            hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n\n            symbolRotate = itemModel.getShallow('symbolRotate');\n            symbolOffset = itemModel.getShallow('symbolOffset');\n\n            labelModel = itemModel.getModel(normalLabelAccessPath);\n            hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n            hoverAnimation = itemModel.getShallow('hoverAnimation');\n        }\n        else {\n            hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n        }\n\n        var elStyle = symbolPath.style;\n\n        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n        if (symbolOffset) {\n            symbolPath.attr('position', [\n                numberUtil.parsePercent(symbolOffset[0], symbolSize[0]),\n                numberUtil.parsePercent(symbolOffset[1], symbolSize[1])\n            ]);\n        }\n\n        // PENDING setColor before setStyle!!!\n        symbolPath.setColor(color);\n\n        symbolPath.setStyle(itemStyle);\n\n        var opacity = data.getItemVisual(idx, 'opacity');\n        if (opacity != null) {\n            elStyle.opacity = opacity;\n        }\n\n        // Get last value dim\n        var dimensions = data.dimensions.slice();\n        var valueDim;\n        var dataType;\n        while (dimensions.length && (\n            valueDim = dimensions.pop(),\n            dataType = data.getDimensionInfo(valueDim).type,\n            dataType === 'ordinal' || dataType === 'time'\n        )) {} // jshint ignore:line\n\n        if (valueDim != null && labelModel.getShallow('show')) {\n            graphic.setText(elStyle, labelModel, color);\n            elStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(idx, 'normal'),\n                data.get(valueDim, idx)\n            );\n        }\n        else {\n            elStyle.text = '';\n        }\n\n        if (valueDim != null && hoverLabelModel.getShallow('show')) {\n            graphic.setText(hoverItemStyle, hoverLabelModel, color);\n            hoverItemStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(idx, 'emphasis'),\n                data.get(valueDim, idx)\n            );\n        }\n        else {\n            hoverItemStyle.text = '';\n        }\n\n        var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\n        symbolPath.off('mouseover')\n            .off('mouseout')\n            .off('emphasis')\n            .off('normal');\n\n        symbolPath.hoverStyle = hoverItemStyle;\n\n        graphic.setHoverStyle(symbolPath);\n\n        if (hoverAnimation && seriesModel.ifEnableAnimation()) {\n            var onEmphasis = function() {\n                var ratio = size[1] / size[0];\n                this.animateTo({\n                    scale: [\n                        Math.max(size[0] * 1.1, size[0] + 3),\n                        Math.max(size[1] * 1.1, size[1] + 3 * ratio)\n                    ]\n                }, 400, 'elasticOut');\n            };\n            var onNormal = function() {\n                this.animateTo({\n                    scale: size\n                }, 400, 'elasticOut');\n            };\n            symbolPath.on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n    };\n\n    symbolProto.fadeOut = function (cb) {\n        var symbolPath = this.childAt(0);\n        // Avoid mistaken hover when fading out\n        this.silent = true;\n        // Not show text when animating\n        symbolPath.style.text = '';\n        graphic.updateProps(symbolPath, {\n            scale: [0, 0]\n        }, this._seriesModel, this.dataIndex, cb);\n    };\n\n    zrUtil.inherits(Symbol, graphic.Group);\n\n    module.exports = Symbol;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/helper/Symbol.js\n// module id = 49\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var numberUtil = require('../../util/number');\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = require('zrender/lib/core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTick: function () {\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisTick.show')) {\n                return;\n            }\n\n            var axis = axisModel.axis;\n            var tickModel = axisModel.getModel('axisTick');\n            var opt = this.opt;\n\n            var lineStyleModel = tickModel.getModel('lineStyle');\n            var tickLen = tickModel.get('length');\n\n            var tickInterval = getInterval(tickModel, opt.labelInterval);\n            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n            var ticks = axis.scale.getTicks();\n\n            var pt1 = [];\n            var pt2 = [];\n            var matrix = this._transform;\n\n            for (var i = 0; i < ticksCoords.length; i++) {\n                // Only ordinal scale support tick interval\n                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                     continue;\n                }\n\n                var tickCoord = ticksCoords[i];\n\n                pt1[0] = tickCoord;\n                pt1[1] = 0;\n                pt2[0] = tickCoord;\n                pt2[1] = opt.tickDirection * tickLen;\n\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                // Tick line, Not use group transform to have better line draw\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                    // Id for animation\n                    anid: 'tick_' + ticks[i],\n\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.defaults(\n                        lineStyleModel.getLineStyle(),\n                        {\n                            stroke: axisModel.get('axisLine.lineStyle.color')\n                        }\n                    ),\n                    z2: 2,\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @private\n         */\n        axisLabel: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n            if (!show) {\n                return;\n            }\n\n            var axis = axisModel.axis;\n            var labelModel = axisModel.getModel('axisLabel');\n            var textStyleModel = labelModel.getModel('textStyle');\n            var labelMargin = labelModel.get('margin');\n            var ticks = axis.scale.getTicks();\n            var labels = axisModel.getFormattedLabels();\n\n            // Special label rotate.\n            var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n            // To radian.\n            labelRotation = labelRotation * PI / 180;\n\n            var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n            var categoryData = axisModel.get('data');\n\n            var textEls = [];\n            var silent = isSilent(axisModel);\n            var triggerEvent = axisModel.get('triggerEvent');\n\n            for (var i = 0; i < ticks.length; i++) {\n                if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {\n                     continue;\n                }\n\n                var itemTextStyleModel = textStyleModel;\n                if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n                    itemTextStyleModel = new Model(\n                        categoryData[i].textStyle, textStyleModel, axisModel.ecModel\n                    );\n                }\n                var textColor = itemTextStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color');\n\n                var tickCoord = axis.dataToCoord(ticks[i]);\n                var pos = [\n                    tickCoord,\n                    opt.labelOffset + opt.labelDirection * labelMargin\n                ];\n                var labelBeforeFormat = axis.scale.getLabel(ticks[i]);\n\n                var textEl = new graphic.Text({\n\n                    // Id for animation\n                    anid: 'label_' + ticks[i],\n\n                    style: {\n                        text: labels[i],\n                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n                        textFont: itemTextStyleModel.getFont(),\n                        fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n                    },\n                    position: pos,\n                    rotation: labelLayout.rotation,\n                    silent: silent,\n                    z2: 10\n                });\n\n                // Pack data for mouse event\n                if (triggerEvent) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisLabel';\n                    textEl.eventData.value = labelBeforeFormat;\n                }\n\n\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n\n                textEls.push(textEl);\n                this.group.add(textEl);\n\n                textEl.decomposeTransform();\n            }\n\n            function isTwoLabelOverlapped(current, next) {\n                var firstRect = current && current.getBoundingRect().clone();\n                var nextRect = next && next.getBoundingRect().clone();\n                if (firstRect && nextRect) {\n                    firstRect.applyTransform(current.getLocalTransform());\n                    nextRect.applyTransform(next.getLocalTransform());\n                    return firstRect.intersect(nextRect);\n                }\n            }\n            if (axis.type !== 'category') {\n                // If min or max are user set, we need to check\n                // If the tick on min(max) are overlap on their neighbour tick\n                // If they are overlapped, we need to hide the min(max) tick label\n                if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {\n                    var firstLabel = textEls[0];\n                    var nextLabel = textEls[1];\n                    if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n                        firstLabel.ignore = true;\n                    }\n                }\n                if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {\n                    var lastLabel = textEls[textEls.length - 1];\n                    var prevLabel = textEls[textEls.length - 2];\n                    if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n                        lastLabel.ignore = true;\n                    }\n                }\n            }\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (nameLocation === 'middle') {\n                labelLayout = innerTextLayout(\n                    opt,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                style: {\n                    text: truncatedText,\n                    textFont: textFont,\n                    fill: textStyleModel.getTextColor()\n                        || axisModel.get('axisLine.lineStyle.color'),\n                    textAlign: labelLayout.textAlign,\n                    textVerticalAlign: labelLayout.verticalAlign\n                },\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @inner\n     */\n    function innerTextLayout(opt, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            verticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            verticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            verticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            verticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            verticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            verticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    module.exports = AxisBuilder;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/axis/AxisBuilder.js\n// module id = 50\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('./axisHelper');\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj;\n        }\n    }\n    /**\n     * Get categories\n     */\n    function getCategories() {\n        return this.get('type') === 'category'\n            && zrUtil.map(this.get('data'), getName);\n    }\n\n    /**\n     * Format labels\n     * @return {Array.<string>}\n     */\n    function getFormattedLabels() {\n        return axisHelper.getFormattedLabels(\n            this.axis,\n            this.get('axisLabel.formatter')\n        );\n    }\n\n    module.exports = {\n\n        getFormattedLabels: getFormattedLabels,\n\n        getCategories: getCategories\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/axisModelCommonMixin.js\n// module id = 51\n// module chunks = 0 1 2","\n\n    var axisDefault = require('./axisDefault');\n    var zrUtil = require('zrender/lib/core/util');\n    var ComponentModel = require('../model/Component');\n    var layout = require('../util/layout');\n\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n\n            BaseAxisModelClass.extend({\n\n                type: axisName + 'Axis.' + axisType,\n\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode\n                        ? layout.getLayoutParams(option) : {};\n\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n\n                    option.type = axisTypeDefaulter(axisName, option);\n\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n\n                defaultOption: zrUtil.mergeAll(\n                    [\n                        {},\n                        axisDefault[axisType + 'Axis'],\n                        extraDefaultOption\n                    ],\n                    true\n                )\n            });\n        });\n\n        ComponentModel.registerSubTypeDefaulter(\n            axisName + 'Axis',\n            zrUtil.curry(axisTypeDefaulter, axisName)\n        );\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/axisModelCreator.js\n// module id = 52\n// module chunks = 0 1 2","'use strict';\n\n\n    var ComponentModel = require('../../model/Component');\n    var zrUtil = require('zrender/lib/core/util');\n    var axisModelCreator = require('../axisModelCreator');\n\n    var AxisModel = ComponentModel.extend({\n\n        type: 'cartesian2dAxis',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Axis2D}\n         */\n        axis: null,\n\n        /**\n         * @override\n         */\n        init: function () {\n            AxisModel.superApply(this, 'init', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function () {\n            AxisModel.superApply(this, 'mergeOption', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        restoreData: function () {\n            AxisModel.superApply(this, 'restoreData', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        findGridModel: function () {\n            return this.ecModel.queryComponents({\n                mainType: 'grid',\n                index: this.get('gridIndex'),\n                id: this.get('gridId')\n            })[0];\n        }\n\n    });\n\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n\n    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n    zrUtil.merge(AxisModel.prototype, require('../axisModelZoomMixin'));\n\n    var extraOption = {\n        // gridIndex: 0,\n        // gridId: '',\n\n        // Offset is for multiple axis on the same position\n        offset: 0\n    };\n\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\n    module.exports = AxisModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/cartesian/AxisModel.js\n// module id = 53\n// module chunks = 0 1 2","/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nvar factory = exports;\n\n    var layout = require('../../util/layout');\n    var axisHelper = require('../../coord/axisHelper');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Cartesian2D = require('./Cartesian2D');\n    var Axis2D = require('./Axis2D');\n\n    var each = zrUtil.each;\n\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n\n    //  GridModel, AxisModel \n    require('./GridModel');\n\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.findGridModel() === gridModel;\n    }\n\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = axisModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : (rect = singleRect);\n            }\n        }\n        return rect;\n    }\n\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n\n        this._initCartesian(gridModel, ecModel, api);\n\n        this._model = gridModel;\n    }\n\n    var gridProto = Grid.prototype;\n\n    gridProto.type = 'grid';\n\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n\n    gridProto.update = function (ecModel, api) {\n\n        var axesMap = this._axesMap;\n\n        this._updateScale(ecModel, this._model);\n\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                if (axes.hasOwnProperty(idx)) {\n                    var axis = axes[idx];\n                    if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this._model, api);\n    };\n\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api) {\n\n        var gridRect = layout.getLayoutRect(\n            gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n\n        this._rect = gridRect;\n\n        var axesList = this._axesList;\n\n        adjustAxes();\n\n        // Minus label size\n        if (gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        }\n                        else if (axis.position === 'left')  {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n\n            adjustAxes();\n        }\n\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    if (axesMapOnDim.hasOwnProperty(name)) {\n                        return axesMapOnDim[name];\n                    }\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        }\n        else {\n            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n                if (coordList[i].getAxis('x').index === xAxisIndex\n                    || coordList[i].getAxis('y').index === yAxisIndex\n                ) {\n                    return coordList[i];\n                }\n            }\n        }\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertToPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.dataToPoint(value)\n            : target.axis\n            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n            : null;\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertFromPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.pointToData(value)\n            : target.axis\n            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n            : null;\n    };\n\n    /**\n     * @inner\n     */\n    gridProto._findConvertTarget = function (ecModel, finder) {\n        var seriesModel = finder.seriesModel;\n        var xAxisModel = finder.xAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n        var yAxisModel = finder.yAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n        var gridModel = finder.gridModel;\n        var coordsList = this._coordsList;\n        var cartesian;\n        var axis;\n\n        if (seriesModel) {\n            cartesian = seriesModel.coordinateSystem;\n            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n        }\n        else if (xAxisModel && yAxisModel) {\n            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        }\n        else if (xAxisModel) {\n            axis = this.getAxis('x', xAxisModel.componentIndex);\n        }\n        else if (yAxisModel) {\n            axis = this.getAxis('y', yAxisModel.componentIndex);\n        }\n        // Lowest priority.\n        else if (gridModel) {\n            var grid = gridModel.coordinateSystem;\n            if (grid === this) {\n                cartesian = this._coordsList[0];\n            }\n        }\n\n        return {cartesian: cartesian, axis: axis};\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.containPoint = function (point) {\n        var coord = this._coordsList[0];\n        if (coord) {\n            return coord.containPoint(point);\n        }\n    };\n\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n            left: false,\n            right: false,\n            top: false,\n            bottom: false\n        };\n\n        var axesMap = {\n            x: {},\n            y: {}\n        };\n        var axesCount = {\n            x: 0,\n            y: 0\n        };\n\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n\n        this._axesMap = axesMap;\n\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n\n                cartesian.grid = this;\n\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                }\n                else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n\n                var axis = new Axis2D(\n                    axisType, axisHelper.createScaleByModel(axisModel),\n                    [0, 0],\n                    axisModel.get('type'),\n                    axisPosition\n                );\n\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n\n                axis.onZero = axisModel.get('axisLine.onZero');\n\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n\n                // Inject axisModel into axis\n                axis.model = axisModel;\n\n                // Inject grid info axis\n                axis.grid = this;\n\n                // Index of axis, can be used as key\n                axis.index = idx;\n\n                this._axesList.push(axis);\n\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n                 ) {\n                    return;\n                }\n\n                var cartesian = this.getCartesian(\n                    xAxisModel.componentIndex, yAxisModel.componentIndex\n                );\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtent(data.getDataExtent(\n                    dim, axis.scale.type !== 'ordinal'\n                ));\n            });\n        }\n    };\n\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord + coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n        axis.toLocalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord - coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n    }\n\n    var axesTypes = ['xAxis', 'yAxis'];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\n            if (__DEV__) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n                        seriesModel.get(axisType + 'Index'),\n                        seriesModel.get(axisType + 'Id'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            grid.resize(gridModel, api);\n\n            gridModel.coordinateSystem = grid;\n\n            grids.push(grid);\n        });\n\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            var gridModel = xAxisModel.findGridModel();\n\n            if (__DEV__) {\n                if (!gridModel) {\n                    throw new Error(\n                        'Grid \"' + zrUtil.retrieve(\n                            xAxisModel.get('gridIndex'),\n                            xAxisModel.get('gridId'),\n                            0\n                        ) + '\" not found'\n                    );\n                }\n                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n\n            var grid = gridModel.coordinateSystem;\n\n            seriesModel.coordinateSystem = grid.getCartesian(\n                xAxisModel.componentIndex, yAxisModel.componentIndex\n            );\n        });\n\n        return grids;\n    };\n\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\n    require('../../CoordinateSystem').register('cartesian2d', Grid);\n\n    module.exports = Grid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/cartesian/Grid.js\n// module id = 54\n// module chunks = 0 1 2","\n\n    module.exports = function (seriesType, ecModel) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (coordSys) {\n                var dims = coordSys.dimensions;\n\n                if (coordSys.type === 'singleAxis') {\n                    data.each(dims[0], function (x, idx) {\n                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n                        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n                    });\n                }\n                else {\n                    data.each(dims, function (x, y, idx) {\n                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n                        data.setItemLayout(\n                            idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y])\n                        );\n                    }, true);\n                }\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/layout/points.js\n// module id = 55\n// module chunks = 0 1 2","\n    module.exports = {\n        clearColorPalette: function () {\n            this._colorIdx = 0;\n            this._colorNameMap = {};\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = scope._colorIdx || 0;\n            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});\n            if (colorNameMap[name]) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            scope._colorIdx = (colorIdx + 1) % colorPalette.length;\n\n            return color;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/mixin/colorPalette.js\n// module id = 56\n// module chunks = 0 1 2","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/view/Component.js\n// module id = 57\n// module chunks = 0 1 2","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * \n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * \n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender  element  zrender \n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * true\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * (shape) Group \n         * \n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Element.js\n// module id = 58\n// module chunks = 0 1 2","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = (\n                isValueArray\n                && isArrayLike(firstVal[0])\n            )\n            ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * \n         * @param  {number} time ms\n         * @param  {Object} props key-value\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * \n         * @param  {string|Function} easing\n         *         {@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * \n         * @param  {number} time ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animator.js\n// module id = 59\n// module chunks = 0 1 2","\n\n    module.exports = (typeof window !== 'undefined' &&\n                                    (window.requestAnimationFrame\n                                    || window.msRequestAnimationFrame\n                                    || window.mozRequestAnimationFrame\n                                    || window.webkitRequestAnimationFrame))\n                                || function (func) {\n                                    setTimeout(func, 16);\n                                };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/requestAnimationFrame.js\n// module id = 60\n// module chunks = 0 1 2","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/util.js\n// module id = 61\n// module chunks = 0 1 2","/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/guid.js\n// module id = 62\n// module chunks = 0 1 2","\n\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n\n        return this._canvasPattern\n            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n\n    module.exports = Pattern;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Pattern.js\n// module id = 63\n// module chunks = 0 1 2","/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Style.js\n// module id = 64\n// module chunks = 0 1 2","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/poly.js\n// module id = 65\n// module chunks = 0 1 2","/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n *\n * @module echarts/chart/helper/DataSelectable\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = {\n\n        updateSelectedMap: function (targetList) {\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap[target.name] = target;\n                return targetMap;\n            }, {});\n        },\n        /**\n         * @param {string} name\n         */\n        // PENGING If selectedMode is null ?\n        select: function (name) {\n            var targetMap = this._selectTargetMap;\n            var target = targetMap[name];\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                zrUtil.each(targetMap, function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            var target = this._selectTargetMap[name];\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name);\n                return target.selected;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            return target && target.selected;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/helper/selectableMixin.js\n// module id = 66\n// module chunks = 0 1 2","\n    module.exports = function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/processor/dataFilter.js\n// module id = 70\n// module chunks = 0 1 2","// Pick color from palette for each data item\n\n\n    module.exports = function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    // FIXME Performance\n                    var itemModel = dataAll.getItemModel(rawIdx);\n                    var filteredIdx = idxMap[rawIdx];\n\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null\n                        && data.getItemVisual(filteredIdx, 'color', true);\n\n                    if (!singleDataColor) {\n                        var color = itemModel.get('itemStyle.normal.color')\n                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    }\n                    else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/visual/dataColor.js\n// module id = 72\n// module chunks = 0 1 2","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/bbox.js\n// module id = 73\n// module chunks = 0 1 2","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            if (!this._rect) {\n                var style = this.style;\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                this._rect = rect;\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/Text.js\n// module id = 74\n// module chunks = 0 1 2","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/mixin/RectText.js\n// module id = 75\n// module chunks = 0 1 2","/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var zrUtil = require('./core/util');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRendermap\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.2.2';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        //  storage.delFromMap, \n        // FIXME ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * \n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, width, height) {\n            var id = guid();\n            return this.painter.pathToImage(id, e, width, height);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/zrender.js\n// module id = 76\n// module chunks = 0 1 2","\n    var echarts = require('../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n    module.exports = function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent(\n                    {mainType: 'series', subType: seriesType, query: payload},\n                    function (seriesModel) {\n                        if (seriesModel[actionInfo.method]) {\n                            seriesModel[actionInfo.method](payload.name);\n                        }\n                        var data = seriesModel.getData();\n                        // Create selected map\n                        data.each(function (idx) {\n                            var name = data.getName(idx);\n                            selected[name] = seriesModel.isSelected(name) || false;\n                        });\n                    }\n                );\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/action/createDataSelectAction.js\n// module id = 77\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var defaultOption = {\n        show: true,\n        zlevel: 0,                  // \n        z: 0,                       // \n        // \n        inverse: false,\n\n        // \n        name: '',\n        // 'start' | 'middle' | 'end'\n        nameLocation: 'end',\n        // degree\n        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n        nameTruncate: {\n            maxWidth: null,\n            ellipsis: '...',\n            placeholder: '.'\n        },\n        // \n        nameTextStyle: {},\n        // \n        nameGap: 15,\n\n        silent: false, // Default false to support tooltip.\n        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n        tooltip: {\n            show: false\n        },\n\n        // \n        axisLine: {\n            // show\n            show: true,\n            onZero: true,\n            // lineStyle\n            lineStyle: {\n                color: '#333',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        axisTick: {\n            // show\n            show: true,\n            // grid\n            inside: false,\n            // length\n            length: 5,\n            // lineStyle\n            lineStyle: {\n                width: 1\n            }\n        },\n        // axis.axisLabel\n        axisLabel: {\n            show: true,\n            // grid\n            inside: false,\n            rotate: 0,\n            margin: 8,\n            // formatter: null,\n            // TEXTSTYLE\n            textStyle: {\n                fontSize: 12\n            }\n        },\n        // \n        splitLine: {\n            // show\n            show: true,\n            // lineStylelineStyle\n            lineStyle: {\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        splitArea: {\n            // show\n            show: false,\n            // areaStyleareaStyle\n            areaStyle: {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    };\n\n    var categoryAxis = zrUtil.merge({\n        // \n        boundaryGap: true,\n        // splitArea: {\n            // show: false\n        // },\n        splitLine: {\n            show: false\n        },\n        // \n        axisTick: {\n            // If tick is align with label when boundaryGap is true\n            // Default with axisTick\n            alignWithLabel: false,\n            interval: 'auto'\n        },\n        // axis.axisLabel\n        axisLabel: {\n            interval: 'auto'\n        }\n    }, defaultOption);\n\n    var valueAxis = zrUtil.merge({\n        // \n        boundaryGap: [0, 0],\n        // ,  'dataMin' \n        // min: null,\n        //  'dataMax' \n        // max: null,\n        // Readonly prop, specifies start value of the range when using data zoom.\n        // rangeStart: null\n        // Readonly prop, specifies end value of the range when using data zoom.\n        // rangeEnd: null\n        // 0_min_max\n        // scale: false,\n        // 5\n        splitNumber: 5\n        // Minimum interval\n        // minInterval: null\n    }, defaultOption);\n\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n        scale: true,\n        min: 'dataMin',\n        max: 'dataMax'\n    }, valueAxis);\n    var logAxis = zrUtil.defaults({\n        logBase: 10\n    }, valueAxis);\n    logAxis.scale = true;\n\n    module.exports = {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/axisDefault.js\n// module id = 81\n// module chunks = 0 1 2","\n\n    module.exports = {\n\n        /**\n         * @public\n         * @return {Array.<number|string|Date>}\n         */\n        getMin: function () {\n            var option = this.option;\n            var min = option.rangeStart != null ? option.rangeStart : option.min;\n            // In case of axis.type === 'time', Date should be converted to timestamp.\n            // In other cases, min/max should be a number or null/undefined or 'dataMin/Max'.\n            if (min instanceof Date) {\n                min = +min;\n            }\n            return min;\n        },\n\n        /**\n         * @public\n         * @return {Array.<number|string|Date>}\n         */\n        getMax: function () {\n            var option = this.option;\n            var max = option.rangeEnd != null ? option.rangeEnd : option.max;\n            // In case of axis.type === 'time', Date should be converted to timestamp.\n            // In other cases, min/max should be a number or null/undefined or 'dataMin/Max'.\n            if (max instanceof Date) {\n                max = +max;\n            }\n            return max;\n        },\n\n        /**\n         * @public\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * @public\n         * @param {number} rangeStart\n         * @param {number} rangeEnd\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * @public\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/axisModelZoomMixin.js\n// module id = 82\n// module chunks = 0 1 2","\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/line.js\n// module id = 84\n// module chunks = 0 1 2","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/quadratic.js\n// module id = 85\n// module chunks = 0 1 2","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/windingLine.js\n// module id = 86\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/LinearGradient.js\n// module id = 87\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = this.origin;\n\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n    /**\n     * transformcontext\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n\n    var tmpTransform = [];\n\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Transformable.js\n// module id = 88\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\n    ];\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/ExtensionAPI.js\n// module id = 89\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    require('../coord/cartesian/Grid');\n\n    require('./bar/BarSeries');\n    require('./bar/BarView');\n\n    var barLayoutGrid = require('../layout/barGrid');\n    var echarts = require('../echarts');\n\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n\n    // In case developer forget to include grid component\n    require('../component/grid');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/bar.js\n// module id = 90\n// module chunks = 0 1 2","'use strict';\n\n\n    var SeriesModel = require('../../model/Series');\n    var createListFromArray = require('../helper/createListFromArray');\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.bar',\n\n        dependencies: ['grid', 'polar'],\n\n        getInitialData: function (option, ecModel) {\n            if (__DEV__) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'cartesian2d') {\n                    throw new Error('Bar only support cartesian2d coordinateSystem');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [NaN, NaN];\n        },\n\n        brushSelector: 'rect',\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            // stack: null\n\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // 0\n            barMinHeight: 0,\n\n            // barMaxWidth: null,\n            // \n            // barWidth: null,\n            // 30%\n            // barGap: '30%',\n            // 20%\n            // barCategoryGap: '20%',\n            // label: {\n            //     normal: {\n            //         show: false\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    // color: ''\n                },\n                emphasis: {}\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/bar/BarSeries.js\n// module id = 91\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n\n    zrUtil.extend(require('../../model/Model').prototype, require('./barItemStyle'));\n\n    function fixLayoutWithLineWidth(layout, lineWidth) {\n        var signX = layout.width > 0 ? 1 : -1;\n        var signY = layout.height > 0 ? 1 : -1;\n        // In case width or height are too small.\n        lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));\n        layout.x += signX * lineWidth / 2;\n        layout.y += signY * lineWidth / 2;\n        layout.width -= signX * lineWidth;\n        layout.height -= signY * lineWidth;\n    }\n\n    module.exports = require('../../echarts').extendChartView({\n\n        type: 'bar',\n\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n            if (coordinateSystemType === 'cartesian2d') {\n                this._renderOnCartesian(seriesModel, ecModel, api);\n            }\n\n            return this.group;\n        },\n\n        dispose: zrUtil.noop,\n\n        _renderOnCartesian: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var isHorizontal = baseAxis.isHorizontal();\n\n            var enableAnimation = seriesModel.get('animation');\n\n            var barBorderWidthQuery = ['itemStyle', 'normal', 'barBorderWidth'];\n\n            function createRect(dataIndex, isUpdate) {\n                var layout = data.getItemLayout(dataIndex);\n                var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;\n                fixLayoutWithLineWidth(layout, lineWidth);\n\n                var rect = new graphic.Rect({\n                    shape: zrUtil.extend({}, layout)\n                });\n                // Animation\n                if (enableAnimation) {\n                    var rectShape = rect.shape;\n                    var animateProperty = isHorizontal ? 'height' : 'width';\n                    var animateTarget = {};\n                    rectShape[animateProperty] = 0;\n                    animateTarget[animateProperty] = layout[animateProperty];\n                    graphic[isUpdate? 'updateProps' : 'initProps'](rect, {\n                        shape: animateTarget\n                    }, seriesModel, dataIndex);\n                }\n                return rect;\n            }\n            data.diff(oldData)\n                .add(function (dataIndex) {\n                    // \n                    if (!data.hasValue(dataIndex)) {\n                        return;\n                    }\n\n                    var rect = createRect(dataIndex);\n\n                    data.setItemGraphicEl(dataIndex, rect);\n\n                    group.add(rect);\n\n                })\n                .update(function (newIndex, oldIndex) {\n                    var rect = oldData.getItemGraphicEl(oldIndex);\n                    // \n                    if (!data.hasValue(newIndex)) {\n                        group.remove(rect);\n                        return;\n                    }\n                    if (!rect) {\n                        rect = createRect(newIndex, true);\n                    }\n\n                    var layout = data.getItemLayout(newIndex);\n                    var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;\n                    fixLayoutWithLineWidth(layout, lineWidth);\n\n                    graphic.updateProps(rect, {\n                        shape: layout\n                    }, seriesModel, newIndex);\n\n                    data.setItemGraphicEl(newIndex, rect);\n\n                    // Add back\n                    group.add(rect);\n                })\n                .remove(function (idx) {\n                    var rect = oldData.getItemGraphicEl(idx);\n                    if (rect) {\n                        // Not show text when animating\n                        rect.style.text = '';\n                        graphic.updateProps(rect, {\n                            shape: {\n                                width: 0\n                            }\n                        }, seriesModel, idx, function () {\n                            group.remove(rect);\n                        });\n                    }\n                })\n                .execute();\n\n            this._updateStyle(seriesModel, data, isHorizontal);\n\n            this._data = data;\n        },\n\n        _updateStyle: function (seriesModel, data, isHorizontal) {\n            function setLabel(style, model, color, labelText, labelPositionOutside) {\n                graphic.setText(style, model, color);\n                style.text = labelText;\n                if (style.textPosition === 'outside') {\n                    style.textPosition = labelPositionOutside;\n                }\n            }\n\n            data.eachItemGraphicEl(function (rect, idx) {\n                var itemModel = data.getItemModel(idx);\n                var color = data.getItemVisual(idx, 'color');\n                var opacity = data.getItemVisual(idx, 'opacity');\n                var layout = data.getItemLayout(idx);\n                var itemStyleModel = itemModel.getModel('itemStyle.normal');\n\n                var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n                rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n\n                rect.useStyle(zrUtil.defaults(\n                    {\n                        fill: color,\n                        opacity: opacity\n                    },\n                    itemStyleModel.getBarItemStyle()\n                ));\n\n                var labelPositionOutside = isHorizontal\n                    ? (layout.height > 0 ? 'bottom' : 'top')\n                    : (layout.width > 0 ? 'left' : 'right');\n\n                var labelModel = itemModel.getModel('label.normal');\n                var hoverLabelModel = itemModel.getModel('label.emphasis');\n                var rectStyle = rect.style;\n                if (labelModel.get('show')) {\n                    setLabel(\n                        rectStyle, labelModel, color,\n                        zrUtil.retrieve(\n                            seriesModel.getFormattedLabel(idx, 'normal'),\n                            seriesModel.getRawValue(idx)\n                        ),\n                        labelPositionOutside\n                    );\n                }\n                else {\n                    rectStyle.text = '';\n                }\n                if (hoverLabelModel.get('show')) {\n                    setLabel(\n                        hoverStyle, hoverLabelModel, color,\n                        zrUtil.retrieve(\n                            seriesModel.getFormattedLabel(idx, 'emphasis'),\n                            seriesModel.getRawValue(idx)\n                        ),\n                        labelPositionOutside\n                    );\n                }\n                else {\n                    hoverStyle.text = '';\n                }\n                graphic.setHoverStyle(rect, hoverStyle);\n            });\n        },\n\n        remove: function (ecModel, api) {\n            var group = this.group;\n            if (ecModel.get('animation')) {\n                if (this._data) {\n                    this._data.eachItemGraphicEl(function (el) {\n                        // Not show text when animating\n                        el.style.text = '';\n                        graphic.updateProps(el, {\n                            shape: {\n                                width: 0\n                            }\n                        }, ecModel, el.dataIndex, function () {\n                            group.remove(el);\n                        });\n                    });\n                }\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/bar/BarView.js\n// module id = 92\n// module chunks = 0 1 2","\n\n\n    var getBarItemStyle = require('../../model/mixin/makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            // Compatitable with 2\n            ['stroke', 'barBorderColor'],\n            ['lineWidth', 'barBorderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/bar/barItemStyle.js\n// module id = 93\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n    var PRIORITY = echarts.PRIORITY;\n\n    require('./line/LineSeries');\n    require('./line/LineView');\n\n    echarts.registerVisual(zrUtil.curry(\n        require('../visual/symbol'), 'line', 'circle', 'line'\n    ));\n    echarts.registerLayout(zrUtil.curry(\n        require('../layout/points'), 'line'\n    ));\n\n    // Down sample after filter\n    echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(\n        require('../processor/dataSample'), 'line'\n    ));\n\n    // In case developer forget to include grid component\n    require('../component/grid');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/line.js\n// module id = 96\n// module chunks = 0 1 2","'use strict';\n\n\n    var createListFromArray = require('../helper/createListFromArray');\n    var SeriesModel = require('../../model/Series');\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.line',\n\n        dependencies: ['grid', 'polar'],\n\n        getInitialData: function (option, ecModel) {\n            if (__DEV__) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {\n                    throw new Error('Line not support coordinateSystem besides cartesian and polar');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // stack: null\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // polarIndex: 0,\n\n            // If clip the overflow value\n            clipOverflow: true,\n\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // itemStyle: {\n            //     normal: {},\n            //     emphasis: {}\n            // },\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            // areaStyle: {},\n            // false, 'start', 'end', 'middle'\n            step: false,\n\n            // Disabled if step is true\n            smooth: false,\n            smoothMonotone: null,\n            // \n            symbol: 'emptyCircle',\n            // \n            symbolSize: 4,\n            // \n            symbolRotate: null,\n\n            //  symbol,  tooltip hover \n            showSymbol: true,\n            // \n            showAllSymbol: false,\n\n            // \n            connectNulls: false,\n\n            // 'average', 'max', 'min', 'sum'\n            sampling: 'none',\n\n            animationEasing: 'linear',\n\n            // Disable progressive\n            progressive: 0,\n            hoverLayerThreshold: Infinity\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/line/LineSeries.js\n// module id = 97\n// module chunks = 0 1 2","'use strict';\n// FIXME step not support polar\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var SymbolDraw = require('../helper/SymbolDraw');\n    var Symbol = require('../helper/Symbol');\n    var lineAnimationDiff = require('./lineAnimationDiff');\n    var graphic = require('../../util/graphic');\n    var modelUtil = require('../../util/model');\n\n    var polyHelper = require('./poly');\n\n    var ChartView = require('../../view/Chart');\n\n    function isPointsSame(points1, points2) {\n        if (points1.length !== points2.length) {\n            return;\n        }\n        for (var i = 0; i < points1.length; i++) {\n            var p1 = points1[i];\n            var p2 = points2[i];\n            if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n                return;\n            }\n        }\n        return true;\n    }\n\n    function getSmooth(smooth) {\n        return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);\n    }\n\n    function getAxisExtentWithGap(axis) {\n        var extent = axis.getGlobalExtent();\n        if (axis.onBand) {\n            // Remove extra 1px to avoid line miter in clipped edge\n            var halfBandWidth = axis.getBandWidth() / 2 - 1;\n            var dir = extent[1] > extent[0] ? 1 : -1;\n            extent[0] += dir * halfBandWidth;\n            extent[1] -= dir * halfBandWidth;\n        }\n        return extent;\n    }\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n    /**\n     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n     * @param {module:echarts/data/List} data\n     * @param {Array.<Array.<number>>} points\n     * @private\n     */\n    function getStackedOnPoints(coordSys, data) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        return data.mapArray([valueDim], function (val, idx) {\n            var stackedOnSameSign;\n            var stackedOn = data.stackedOn;\n            // Find first stacked value with same sign\n            while (stackedOn &&\n                sign(stackedOn.get(valueDim, idx)) === sign(val)\n            ) {\n                stackedOnSameSign = stackedOn;\n                break;\n            }\n            var stackedData = [];\n            stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n            stackedData[1 - baseDataOffset] = stackedOnSameSign\n                ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n            return coordSys.dataToPoint(stackedData);\n        }, true);\n    }\n\n    function createGridClipShape(cartesian, hasAnimation, seriesModel) {\n        var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n        var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n        var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n\n        var x = Math.min(xExtent[0], xExtent[1]);\n        var y = Math.min(yExtent[0], yExtent[1]);\n        var width = Math.max(xExtent[0], xExtent[1]) - x;\n        var height = Math.max(yExtent[0], yExtent[1]) - y;\n        var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;\n        // Expand clip shape to avoid clipping when line value exceeds axis\n        var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n        if (isHorizontal) {\n            y -= expandSize;\n            height += expandSize * 2;\n        }\n        else {\n            x -= expandSize;\n            width += expandSize * 2;\n        }\n\n        var clipPath = new graphic.Rect({\n            shape: {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n            graphic.initProps(clipPath, {\n                shape: {\n                    width: width,\n                    height: height\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createPolarClipShape(polar, hasAnimation, seriesModel) {\n        var angleAxis = polar.getAngleAxis();\n        var radiusAxis = polar.getRadiusAxis();\n\n        var radiusExtent = radiusAxis.getExtent();\n        var angleExtent = angleAxis.getExtent();\n\n        var RADIAN = Math.PI / 180;\n\n        var clipPath = new graphic.Sector({\n            shape: {\n                cx: polar.cx,\n                cy: polar.cy,\n                r0: radiusExtent[0],\n                r: radiusExtent[1],\n                startAngle: -angleExtent[0] * RADIAN,\n                endAngle: -angleExtent[1] * RADIAN,\n                clockwise: angleAxis.inverse\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: -angleExtent[1] * RADIAN\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createClipShape(coordSys, hasAnimation, seriesModel) {\n        return coordSys.type === 'polar'\n            ? createPolarClipShape(coordSys, hasAnimation, seriesModel)\n            : createGridClipShape(coordSys, hasAnimation, seriesModel);\n    }\n\n    function turnPointsIntoStep(points, coordSys, stepTurnAt) {\n        var baseAxis = coordSys.getBaseAxis();\n        var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\n        var stepPoints = [];\n        for (var i = 0; i < points.length - 1; i++) {\n            var nextPt = points[i + 1];\n            var pt = points[i];\n            stepPoints.push(pt);\n\n            var stepPt = [];\n            switch (stepTurnAt) {\n                case 'end':\n                    stepPt[baseIndex] = nextPt[baseIndex];\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n                    break;\n                case 'middle':\n                    // default is start\n                    var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n                    var stepPt2 = [];\n                    stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n                    stepPoints.push(stepPt);\n                    stepPoints.push(stepPt2);\n                    break;\n                default:\n                    stepPt[baseIndex] = pt[baseIndex];\n                    stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n            }\n        }\n        // Last points\n        points[i] && stepPoints.push(points[i]);\n        return stepPoints;\n    }\n\n    function clamp(number, extent) {\n        return Math.max(Math.min(number, extent[1]), extent[0]);\n    }\n\n    function getVisualGradient(data, coordSys) {\n        var visualMetaList = data.getVisual('visualMeta');\n        if (!visualMetaList || !visualMetaList.length || !data.count()) {\n            // When data.count() is 0, gradient range can not be calculated.\n            return;\n        }\n\n        var visualMeta;\n        for (var i = visualMetaList.length - 1; i >= 0; i--) {\n            // Can only be x or y\n            if (visualMetaList[i].dimension < 2) {\n                visualMeta = visualMetaList[i];\n                break;\n            }\n        }\n        if (!visualMeta || coordSys.type !== 'cartesian2d') {\n            if (__DEV__) {\n                console.warn('Visual map on line style only support x or y dimension.');\n            }\n            return;\n        }\n\n        var dimension = visualMeta.dimension;\n        var dimName = data.dimensions[dimension];\n        var dataExtent = data.getDataExtent(dimName);\n\n        var stops = visualMeta.stops;\n\n        var colorStops = [];\n        if (stops[0].interval) {\n            stops.sort(function (a, b) {\n                return a.interval[0] - b.interval[0];\n            });\n        }\n\n        var firstStop = stops[0];\n        var lastStop = stops[stops.length - 1];\n        // Interval can be infinity in piecewise case\n        var min = firstStop.interval ? clamp(firstStop.interval[0], dataExtent) : firstStop.value;\n        var max = lastStop.interval ? clamp(lastStop.interval[1], dataExtent) : lastStop.value;\n        var stopsSpan = max - min;\n\n        // In the piecewise case data out of visual range\n        // ----dataMin----dataMax-----visualMin----visualMax\n        if (stopsSpan === 0) {\n            return data.getItemVisual(0, 'color');\n        }\n        for (var i = 0; i < stops.length; i++) {\n            // Piecewise\n            if (stops[i].interval) {\n                if (stops[i].interval[1] === stops[i].interval[0]) {\n                    continue;\n                }\n                colorStops.push({\n                    // Make sure offset is between 0 and 1\n                    offset: (clamp(stops[i].interval[0], dataExtent) - min) / stopsSpan,\n                    color: stops[i].color\n                }, {\n                    offset: (clamp(stops[i].interval[1], dataExtent) - min) / stopsSpan,\n                    color: stops[i].color\n                });\n            }\n            // Continous\n            else {\n                // if (i > 0 && stops[i].value === stops[i - 1].value) {\n                //     continue;\n                // }\n                colorStops.push({\n                    offset: (stops[i].value - min) / stopsSpan,\n                    color: stops[i].color\n                });\n            }\n        }\n\n        var gradient = new graphic.LinearGradient(\n            0, 0, 0, 0, colorStops, true\n        );\n        var axis = coordSys.getAxis(dimName);\n\n        var start = axis.toGlobalCoord(axis.dataToCoord(min));\n        var end = axis.toGlobalCoord(axis.dataToCoord(max));\n        // zrUtil.each(colorStops, function (colorStop) {\n        //     // Make sure each offset has rounded px to avoid not sharp edge\n        //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n        // });\n\n        gradient[dimName] = start;\n        gradient[dimName + '2'] = end;\n\n        return gradient;\n    }\n\n    module.exports = ChartView.extend({\n\n        type: 'line',\n\n        init: function () {\n            var lineGroup = new graphic.Group();\n\n            var symbolDraw = new SymbolDraw();\n            this.group.add(symbolDraw.group);\n\n            this._symbolDraw = symbolDraw;\n            this._lineGroup = lineGroup;\n        },\n\n        render: function (seriesModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var group = this.group;\n            var data = seriesModel.getData();\n            var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n            var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n\n            var points = data.mapArray(data.getItemLayout, true);\n\n            var isCoordSysPolar = coordSys.type === 'polar';\n            var prevCoordSys = this._coordSys;\n\n            var symbolDraw = this._symbolDraw;\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n\n            var lineGroup = this._lineGroup;\n\n            var hasAnimation = seriesModel.get('animation');\n\n            var isAreaChart = !areaStyleModel.isEmpty();\n            var stackedOnPoints = getStackedOnPoints(coordSys, data);\n\n            var showSymbol = seriesModel.get('showSymbol');\n\n            var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol')\n                && this._getSymbolIgnoreFunc(data, coordSys);\n\n            // Remove temporary symbols\n            var oldData = this._data;\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            // Remove previous created symbols if showSymbol changed to false\n            if (!showSymbol) {\n                symbolDraw.remove();\n            }\n\n            group.add(lineGroup);\n\n            // FIXME step not support polar\n            var step = !isCoordSysPolar && seriesModel.get('step');\n            // Initialization animation or coordinate system changed\n            if (\n                !(polyline && prevCoordSys.type === coordSys.type && step === this._step)\n            ) {\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                if (step) {\n                    // TODO If stacked series is not step\n                    points = turnPointsIntoStep(points, coordSys, step);\n                    stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                }\n\n                polyline = this._newPolyline(points, coordSys, hasAnimation);\n                if (isAreaChart) {\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n            }\n            else {\n                if (isAreaChart && !polygon) {\n                    // If areaStyle is added\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                else if (polygon && !isAreaChart) {\n                    // If areaStyle is removed\n                    lineGroup.remove(polygon);\n                    polygon = this._polygon = null;\n                }\n\n                // Update clipPath\n                lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));\n\n                // Always update, or it is wrong in the case turning on legend\n                // because points are not changed\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                // Stop symbol animation and sync with line points\n                // FIXME performance?\n                data.eachItemGraphicEl(function (el) {\n                    el.stopAnimation(true);\n                });\n\n                // In the case data zoom triggerred refreshing frequently\n                // Data may not change if line has a category axis. So it should animate nothing\n                if (!isPointsSame(this._stackedOnPoints, stackedOnPoints)\n                    || !isPointsSame(this._points, points)\n                ) {\n                    if (hasAnimation) {\n                        this._updateAnimation(\n                            data, stackedOnPoints, coordSys, api, step\n                        );\n                    }\n                    else {\n                        // Not do it in update with animation\n                        if (step) {\n                            // TODO If stacked series is not step\n                            points = turnPointsIntoStep(points, coordSys, step);\n                            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                        }\n\n                        polyline.setShape({\n                            points: points\n                        });\n                        polygon && polygon.setShape({\n                            points: points,\n                            stackedOnPoints: stackedOnPoints\n                        });\n                    }\n                }\n            }\n\n            var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n\n            polyline.useStyle(zrUtil.defaults(\n                // Use color in lineStyle first\n                lineStyleModel.getLineStyle(),\n                {\n                    fill: 'none',\n                    stroke: visualColor,\n                    lineJoin: 'bevel'\n                }\n            ));\n\n            var smooth = seriesModel.get('smooth');\n            smooth = getSmooth(seriesModel.get('smooth'));\n            polyline.setShape({\n                smooth: smooth,\n                smoothMonotone: seriesModel.get('smoothMonotone'),\n                connectNulls: seriesModel.get('connectNulls')\n            });\n\n            if (polygon) {\n                var stackedOn = data.stackedOn;\n                var stackedOnSmooth = 0;\n\n                polygon.useStyle(zrUtil.defaults(\n                    areaStyleModel.getAreaStyle(),\n                    {\n                        fill: visualColor,\n                        opacity: 0.7,\n                        lineJoin: 'bevel'\n                    }\n                ));\n\n                if (stackedOn) {\n                    var stackedOnSeries = stackedOn.hostModel;\n                    stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n                }\n\n                polygon.setShape({\n                    smooth: smooth,\n                    stackedOnSmooth: stackedOnSmooth,\n                    smoothMonotone: seriesModel.get('smoothMonotone'),\n                    connectNulls: seriesModel.get('connectNulls')\n                });\n            }\n\n            this._data = data;\n            // Save the coordinate system for transition animation when data changed\n            this._coordSys = coordSys;\n            this._stackedOnPoints = stackedOnPoints;\n            this._points = points;\n            this._step = step;\n        },\n\n        dispose: function () {},\n\n        highlight: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n            if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (!symbol) {\n                    // Create a temporary symbol if it is not exists\n                    var pt = data.getItemLayout(dataIndex);\n                    symbol = new Symbol(data, dataIndex);\n                    symbol.position = pt;\n                    symbol.setZ(\n                        seriesModel.get('zlevel'),\n                        seriesModel.get('z')\n                    );\n                    symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n                    symbol.__temp = true;\n                    data.setItemGraphicEl(dataIndex, symbol);\n\n                    // Stop scale animation\n                    symbol.stopSymbolAnimation(true);\n\n                    this.group.add(symbol);\n                }\n                symbol.highlight();\n            }\n            else {\n                // Highlight whole series\n                ChartView.prototype.highlight.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        downplay: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n            if (dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (symbol) {\n                    if (symbol.__temp) {\n                        data.setItemGraphicEl(dataIndex, null);\n                        this.group.remove(symbol);\n                    }\n                    else {\n                        symbol.downplay();\n                    }\n                }\n            }\n            else {\n                // Downplay whole series\n                ChartView.prototype.downplay.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolyline: function (points) {\n            var polyline = this._polyline;\n            // Remove previous created polyline\n            if (polyline) {\n                this._lineGroup.remove(polyline);\n            }\n\n            polyline = new polyHelper.Polyline({\n                shape: {\n                    points: points\n                },\n                silent: true,\n                z2: 10\n            });\n\n            this._lineGroup.add(polyline);\n\n            this._polyline = polyline;\n\n            return polyline;\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} stackedOnPoints\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolygon: function (points, stackedOnPoints) {\n            var polygon = this._polygon;\n            // Remove previous created polygon\n            if (polygon) {\n                this._lineGroup.remove(polygon);\n            }\n\n            polygon = new polyHelper.Polygon({\n                shape: {\n                    points: points,\n                    stackedOnPoints: stackedOnPoints\n                },\n                silent: true\n            });\n\n            this._lineGroup.add(polygon);\n\n            this._polygon = polygon;\n            return polygon;\n        },\n        /**\n         * @private\n         */\n        _getSymbolIgnoreFunc: function (data, coordSys) {\n            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n            // `getLabelInterval` is provided by echarts/component/axis\n            if (categoryAxis && categoryAxis.isLabelIgnored) {\n                return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n            }\n        },\n\n        /**\n         * @private\n         */\n        // FIXME Two value axis\n        _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n            var seriesModel = data.hostModel;\n\n            var diff = lineAnimationDiff(\n                this._data, data,\n                this._stackedOnPoints, stackedOnPoints,\n                this._coordSys, coordSys\n            );\n\n            var current = diff.current;\n            var stackedOnCurrent = diff.stackedOnCurrent;\n            var next = diff.next;\n            var stackedOnNext = diff.stackedOnNext;\n            if (step) {\n                // TODO If stacked series is not step\n                current = turnPointsIntoStep(diff.current, coordSys, step);\n                stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n                next = turnPointsIntoStep(diff.next, coordSys, step);\n                stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n            }\n            // `diff.current` is subset of `current` (which should be ensured by\n            // turnPointsIntoStep), so points in `__points` can be updated when\n            // points in `current` are update during animation.\n            polyline.shape.__points = diff.current;\n            polyline.shape.points = current;\n\n            graphic.updateProps(polyline, {\n                shape: {\n                    points: next\n                }\n            }, seriesModel);\n\n            if (polygon) {\n                polygon.setShape({\n                    points: current,\n                    stackedOnPoints: stackedOnCurrent\n                });\n                graphic.updateProps(polygon, {\n                    shape: {\n                        points: next,\n                        stackedOnPoints: stackedOnNext\n                    }\n                }, seriesModel);\n            }\n\n            var updatedDataInfo = [];\n            var diffStatus = diff.status;\n\n            for (var i = 0; i < diffStatus.length; i++) {\n                var cmd = diffStatus[i].cmd;\n                if (cmd === '=') {\n                    var el = data.getItemGraphicEl(diffStatus[i].idx1);\n                    if (el) {\n                        updatedDataInfo.push({\n                            el: el,\n                            ptIdx: i    // Index of points\n                        });\n                    }\n                }\n            }\n\n            if (polyline.animators && polyline.animators.length) {\n                polyline.animators[0].during(function () {\n                    for (var i = 0; i < updatedDataInfo.length; i++) {\n                        var el = updatedDataInfo[i].el;\n                        el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n                    }\n                });\n            }\n        },\n\n        remove: function (ecModel) {\n            var group = this.group;\n            var oldData = this._data;\n            this._lineGroup.removeAll();\n            this._symbolDraw.remove(true);\n            // Remove temporary created elements when highlighting\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            this._polyline =\n            this._polygon =\n            this._coordSys =\n            this._points =\n            this._stackedOnPoints =\n            this._data = null;\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/line/LineView.js\n// module id = 98\n// module chunks = 0 1 2","\n\n    // var arrayDiff = require('zrender/lib/core/arrayDiff');\n    // 'zrender/core/arrayDiff' has been used before, but it did\n    // not do well in performance when roam with fixed dataZoom window.\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n\n    function getStackedOnPoint(coordSys, data, idx) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        var stackedOnSameSign;\n        var stackedOn = data.stackedOn;\n        var val = data.get(valueDim, idx);\n        // Find first stacked value with same sign\n        while (stackedOn &&\n            sign(stackedOn.get(valueDim, idx)) === sign(val)\n        ) {\n            stackedOnSameSign = stackedOn;\n            break;\n        }\n        var stackedData = [];\n        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n        stackedData[1 - baseDataOffset] = stackedOnSameSign\n            ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n        return coordSys.dataToPoint(stackedData);\n    }\n\n    // function convertToIntId(newIdList, oldIdList) {\n    //     // Generate int id instead of string id.\n    //     // Compare string maybe slow in score function of arrDiff\n\n    //     // Assume id in idList are all unique\n    //     var idIndicesMap = {};\n    //     var idx = 0;\n    //     for (var i = 0; i < newIdList.length; i++) {\n    //         idIndicesMap[newIdList[i]] = idx;\n    //         newIdList[i] = idx++;\n    //     }\n    //     for (var i = 0; i < oldIdList.length; i++) {\n    //         var oldId = oldIdList[i];\n    //         // Same with newIdList\n    //         if (idIndicesMap[oldId]) {\n    //             oldIdList[i] = idIndicesMap[oldId];\n    //         }\n    //         else {\n    //             oldIdList[i] = idx++;\n    //         }\n    //     }\n    // }\n\n    function diffData(oldData, newData) {\n        var diffResult = [];\n\n        newData.diff(oldData)\n            .add(function (idx) {\n                diffResult.push({cmd: '+', idx: idx});\n            })\n            .update(function (newIdx, oldIdx) {\n                diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx});\n            })\n            .remove(function (idx) {\n                diffResult.push({cmd: '-', idx: idx});\n            })\n            .execute();\n\n        return diffResult;\n    }\n\n    module.exports = function (\n        oldData, newData,\n        oldStackedOnPoints, newStackedOnPoints,\n        oldCoordSys, newCoordSys\n    ) {\n        var diff = diffData(oldData, newData);\n\n        // var newIdList = newData.mapArray(newData.getId);\n        // var oldIdList = oldData.mapArray(oldData.getId);\n\n        // convertToIntId(newIdList, oldIdList);\n\n        // // FIXME One data ?\n        // diff = arrayDiff(oldIdList, newIdList);\n\n        var currPoints = [];\n        var nextPoints = [];\n        // Points for stacking base line\n        var currStackedPoints = [];\n        var nextStackedPoints = [];\n\n        var status = [];\n        var sortedIndices = [];\n        var rawIndices = [];\n        var dims = newCoordSys.dimensions;\n        for (var i = 0; i < diff.length; i++) {\n            var diffItem = diff[i];\n            var pointAdded = true;\n\n            // FIXME, animation is not so perfect when dataZoom window moves fast\n            // Which is in case remvoing or add more than one data in the tail or head\n            switch (diffItem.cmd) {\n                case '=':\n                    var currentPt = oldData.getItemLayout(diffItem.idx);\n                    var nextPt = newData.getItemLayout(diffItem.idx1);\n                    // If previous data is NaN, use next point directly\n                    if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n                        currentPt = nextPt.slice();\n                    }\n                    currPoints.push(currentPt);\n                    nextPoints.push(nextPt);\n\n                    currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n                    nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n\n                    rawIndices.push(newData.getRawIndex(diffItem.idx1));\n                    break;\n                case '+':\n                    var idx = diffItem.idx;\n                    currPoints.push(\n                        oldCoordSys.dataToPoint([\n                            newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)\n                        ])\n                    );\n\n                    nextPoints.push(newData.getItemLayout(idx).slice());\n\n                    currStackedPoints.push(\n                        getStackedOnPoint(oldCoordSys, newData, idx)\n                    );\n                    nextStackedPoints.push(newStackedOnPoints[idx]);\n\n                    rawIndices.push(newData.getRawIndex(idx));\n                    break;\n                case '-':\n                    var idx = diffItem.idx;\n                    var rawIndex = oldData.getRawIndex(idx);\n                    // Data is replaced. In the case of dynamic data queue\n                    // FIXME FIXME FIXME\n                    if (rawIndex !== idx) {\n                        currPoints.push(oldData.getItemLayout(idx));\n                        nextPoints.push(newCoordSys.dataToPoint([\n                            oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)\n                        ]));\n\n                        currStackedPoints.push(oldStackedOnPoints[idx]);\n                        nextStackedPoints.push(\n                            getStackedOnPoint(\n                                newCoordSys, oldData, idx\n                            )\n                        );\n\n                        rawIndices.push(rawIndex);\n                    }\n                    else {\n                        pointAdded = false;\n                    }\n            }\n\n            // Original indices\n            if (pointAdded) {\n                status.push(diffItem);\n                sortedIndices.push(sortedIndices.length);\n            }\n        }\n\n        // Diff result may be crossed if all items are changed\n        // Sort by data index\n        sortedIndices.sort(function (a, b) {\n            return rawIndices[a] - rawIndices[b];\n        });\n\n        var sortedCurrPoints = [];\n        var sortedNextPoints = [];\n\n        var sortedCurrStackedPoints = [];\n        var sortedNextStackedPoints = [];\n\n        var sortedStatus = [];\n        for (var i = 0; i < sortedIndices.length; i++) {\n            var idx = sortedIndices[i];\n            sortedCurrPoints[i] = currPoints[idx];\n            sortedNextPoints[i] = nextPoints[idx];\n\n            sortedCurrStackedPoints[i] = currStackedPoints[idx];\n            sortedNextStackedPoints[i] = nextStackedPoints[idx];\n\n            sortedStatus[i] = status[idx];\n        }\n\n        return {\n            current: sortedCurrPoints,\n            next: sortedNextPoints,\n\n            stackedOnCurrent: sortedCurrStackedPoints,\n            stackedOnNext: sortedNextStackedPoints,\n\n            status: sortedStatus\n        };\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/line/lineAnimationDiff.js\n// module id = 99\n// module chunks = 0 1 2","// Poly path support NaN point\n\n\n    var Path = require('zrender/lib/graphic/Path');\n    var vec2 = require('zrender/lib/core/vector');\n\n    var vec2Min = vec2.min;\n    var vec2Max = vec2.max;\n\n    var scaleAndAdd = vec2.scaleAndAdd;\n    var v2Copy = vec2.copy;\n\n    // Temporary variable\n    var v = [];\n    var cp0 = [];\n    var cp1 = [];\n\n    function isPointNull(p) {\n        return isNaN(p[0]) || isNaN(p[1]);\n    }\n\n    function drawSegment(\n        ctx, points, start, segLen, allLen,\n        dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls\n    ) {\n        var prevIdx = 0;\n        var idx = start;\n        for (var k = 0; k < segLen; k++) {\n            var p = points[idx];\n            if (idx >= allLen || idx < 0) {\n                break;\n            }\n            if (isPointNull(p)) {\n                if (connectNulls) {\n                    idx += dir;\n                    continue;\n                }\n                break;\n            }\n\n            if (idx === start) {\n                ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n                v2Copy(cp0, p);\n            }\n            else {\n                if (smooth > 0) {\n                    var nextIdx = idx + dir;\n                    var nextP = points[nextIdx];\n                    if (connectNulls) {\n                        // Find next point not null\n                        while (nextP && isPointNull(points[nextIdx])) {\n                            nextIdx += dir;\n                            nextP = points[nextIdx];\n                        }\n                    }\n\n                    var ratioNextSeg = 0.5;\n                    var prevP = points[prevIdx];\n                    var nextP = points[nextIdx];\n                    // Last point\n                    if (!nextP || isPointNull(nextP)) {\n                        v2Copy(cp1, p);\n                    }\n                    else {\n                        // If next data is null in not connect case\n                        if (isPointNull(nextP) && !connectNulls) {\n                            nextP = p;\n                        }\n\n                        vec2.sub(v, nextP, prevP);\n\n                        var lenPrevSeg;\n                        var lenNextSeg;\n                        if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n                            var dim = smoothMonotone === 'x' ? 0 : 1;\n                            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n                            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n                        }\n                        else {\n                            lenPrevSeg = vec2.dist(p, prevP);\n                            lenNextSeg = vec2.dist(p, nextP);\n                        }\n\n                        // Use ratio of seg length\n                        ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n\n                        scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n                    }\n                    // Smooth constraint\n                    vec2Min(cp0, cp0, smoothMax);\n                    vec2Max(cp0, cp0, smoothMin);\n                    vec2Min(cp1, cp1, smoothMax);\n                    vec2Max(cp1, cp1, smoothMin);\n\n                    ctx.bezierCurveTo(\n                        cp0[0], cp0[1],\n                        cp1[0], cp1[1],\n                        p[0], p[1]\n                    );\n                    // cp0 of next segment\n                    scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n                }\n                else {\n                    ctx.lineTo(p[0], p[1]);\n                }\n            }\n\n            prevIdx = idx;\n            idx += dir;\n        }\n\n        return k;\n    }\n\n    function getBoundingBox(points, smoothConstraint) {\n        var ptMin = [Infinity, Infinity];\n        var ptMax = [-Infinity, -Infinity];\n        if (smoothConstraint) {\n            for (var i = 0; i < points.length; i++) {\n                var pt = points[i];\n                if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; }\n                if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; }\n                if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; }\n                if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; }\n            }\n        }\n        return {\n            min: smoothConstraint ? ptMin : ptMax,\n            max: smoothConstraint ? ptMax : ptMin\n        };\n    }\n\n    module.exports = {\n\n        Polyline: Path.extend({\n\n            type: 'ec-polyline',\n\n            shape: {\n                points: [],\n\n                smooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            style: {\n                fill: null,\n\n                stroke: '#000'\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n\n                var i = 0;\n                var len = points.length;\n\n                var result = getBoundingBox(points, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    i += drawSegment(\n                        ctx, points, i, len, len,\n                        1, result.min, result.max, shape.smooth,\n                        shape.smoothMonotone, shape.connectNulls\n                    ) + 1;\n                }\n            }\n        }),\n\n        Polygon: Path.extend({\n\n            type: 'ec-polygon',\n\n            shape: {\n                points: [],\n\n                // Offset between stacked base points and points\n                stackedOnPoints: [],\n\n                smooth: 0,\n\n                stackedOnSmooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n                var stackedOnPoints = shape.stackedOnPoints;\n\n                var i = 0;\n                var len = points.length;\n                var smoothMonotone = shape.smoothMonotone;\n                var bbox = getBoundingBox(points, shape.smoothConstraint);\n                var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    var k = drawSegment(\n                        ctx, points, i, len, len,\n                        1, bbox.min, bbox.max, shape.smooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    drawSegment(\n                        ctx, stackedOnPoints, i + k - 1, k, len,\n                        -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    i += k + 1;\n\n                    ctx.closePath();\n                }\n            }\n        })\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/line/poly.js\n// module id = 100\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('./pie/PieSeries');\n    require('./pie/PieView');\n\n    require('../action/createDataSelectAction')('pie', [{\n        type: 'pieToggleSelect',\n        event: 'pieselectchanged',\n        method: 'toggleSelected'\n    }, {\n        type: 'pieSelect',\n        event: 'pieselected',\n        method: 'select'\n    }, {\n        type: 'pieUnSelect',\n        event: 'pieunselected',\n        method: 'unSelect'\n    }]);\n\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n\n    echarts.registerLayout(zrUtil.curry(\n        require('./pie/pieLayout'), 'pie'\n    ));\n\n    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/pie.js\n// module id = 101\n// module chunks = 0 1 2","'use strict';\n\n\n    var List = require('../../data/List');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n\n    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n\n    var PieSeries = require('../../echarts').extendSeriesModel({\n\n        type: 'series.pie',\n\n        // Overwrite\n        init: function (option) {\n            PieSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this._dataBeforeProcessed;\n            };\n\n            this.updateSelectedMap(option.data);\n\n            this._defaultLabelLine(option);\n        },\n\n        // Overwrite\n        mergeOption: function (newOption) {\n            PieSeries.superCall(this, 'mergeOption', newOption);\n            this.updateSelectedMap(this.option.data);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        // Overwrite\n        getDataParams: function (dataIndex) {\n            var data = this._data;\n            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n            var sum = data.getSum('value');\n            // FIXME toFixed?\n            //\n            // Percent is 0 if sum is 0\n            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\n            params.$vars.push('percent');\n            return params;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // \n            center: ['50%', '50%'],\n            radius: [0, '75%'],\n            // \n            clockwise: true,\n            startAngle: 90,\n            // 0\n            minAngle: 0,\n            // \n            selectedOffset: 10,\n\n            // If use strategy to avoid label overlapping\n            avoidLabelOverlap: true,\n            // singlemultiple\n            // selectedMode: false,\n            // 'radius' | 'area'\n            // roseType: null,\n\n            label: {\n                normal: {\n                    // If rotate around circle\n                    rotate: false,\n                    show: true,\n                    // 'outer', 'inside', 'center'\n                    position: 'outer'\n                    // formatter: Tooltip.formatter\n                    // textStyle: null      // TEXTSTYLE\n                    // distance: positioninnerlabel()\n                },\n                emphasis: {}\n            },\n            // Enabled when label.normal.position is 'outer'\n            labelLine: {\n                normal: {\n                    show: true,\n                    // \n                    length: 15,\n                    // \n                    length2: 15,\n                    smooth: false,\n                    lineStyle: {\n                        // color: ,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 1\n                },\n                emphasis: {}\n            },\n\n            animationEasing: 'cubicOut',\n\n            data: []\n        }\n    });\n\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\n    module.exports = PieSeries;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/pie/PieSeries.js\n// module id = 102\n// module chunks = 0 1 2","\n\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n\n        data.each(function (idx) {\n            toggleItemSelected(\n                data.getItemGraphicEl(idx),\n                data.getItemLayout(idx),\n                seriesModel.isSelected(data.getName(idx)),\n                selectedOffset,\n                hasAnimation\n            );\n        });\n    }\n\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [dx * offset, dy * offset];\n\n        hasAnimation\n            // animateTo will stop revious animation like update transition\n            ? el.animate()\n                .when(200, {\n                    position: position\n                })\n                .start('bounceOut')\n            : el.attr('position', position);\n    }\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var sector = new graphic.Sector({\n            z2: 2\n        });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var piePieceProto = PiePiece.prototype;\n\n    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        return {\n            fill: textStyleModel.getTextColor()\n                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            opacity: data.getItemVisual(idx, 'opacity'),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(\n                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n            )\n        };\n    }\n\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n\n        var sector = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n            sector.shape.endAngle = layout.startAngle;\n            graphic.updateProps(sector, {\n                shape: {\n                    endAngle: layout.endAngle\n                }\n            }, seriesModel, idx);\n        }\n        else {\n            graphic.updateProps(sector, {\n                shape: sectorShape\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        sector.useStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'bevel',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle()\n            )\n        );\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        // Toggle selected\n        toggleItemSelected(\n            this,\n            data.getItemLayout(idx),\n            itemModel.get('selected'),\n            seriesModel.get('selectedOffset'),\n            seriesModel.get('animation')\n        );\n\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r + 10\n                }\n            }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r\n                }\n            }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n            sector\n                .on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    piePieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n                ]\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textVerticalAlign: labelLayout.verticalAlign,\n                textAlign: labelLayout.textAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({\n            smooth: smooth\n        });\n    };\n\n    zrUtil.inherits(PiePiece, graphic.Group);\n\n\n    // Pie view\n    var Pie = require('../../view/Chart').extend({\n\n        type: 'pie',\n\n        init: function () {\n            var sectorGroup = new graphic.Group();\n            this._sectorGroup = sectorGroup;\n        },\n\n        render: function (seriesModel, ecModel, api, payload) {\n            if (payload && (payload.from === this.uid)) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var group = this.group;\n\n            var hasAnimation = ecModel.get('animation');\n            var isFirstRender = !oldData;\n\n            var onSectorClick = zrUtil.curry(\n                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n            );\n\n            var selectedMode = seriesModel.get('selectedMode');\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    if (isFirstRender) {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n\n                    selectedMode && piePiece.on('click', onSectorClick);\n\n                    data.setItemGraphicEl(idx, piePiece);\n\n                    group.add(piePiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            if (hasAnimation && isFirstRender && data.count() > 0) {\n                var shape = data.getItemLayout(0);\n                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\n                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                group.setClipPath(this._createClipPath(\n                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n                ));\n            }\n\n            this._data = data;\n        },\n\n        dispose: function () {},\n\n        _createClipPath: function (\n            cx, cy, r, startAngle, clockwise, cb, seriesModel\n        ) {\n            var clipPath = new graphic.Sector({\n                shape: {\n                    cx: cx,\n                    cy: cy,\n                    r0: 0,\n                    r: r,\n                    startAngle: startAngle,\n                    endAngle: startAngle,\n                    clockwise: clockwise\n                }\n            });\n\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n                }\n            }, seriesModel, cb);\n\n            return clipPath;\n        },\n\n        /**\n         * @implement\n         */\n        containPoint: function (point, seriesModel) {\n            var data = seriesModel.getData();\n            var itemLayout = data.getItemLayout(0);\n            if (itemLayout) {\n                var dx = point[0] - itemLayout.cx;\n                var dy = point[1] - itemLayout.cy;\n                var radius = Math.sqrt(dx * dx + dy * dy);\n                return radius <= itemLayout.r && radius >= itemLayout.r0;\n            }\n        }\n\n    });\n\n    module.exports = Pie;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/pie/PieView.js\n// module id = 103\n// module chunks = 0 1 2","'use strict';\n// FIXME emphasis label position is not same with normal label position\n\n\n    var textContain = require('zrender/lib/contain/text');\n\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n\n        // \n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start\n                    && j + 1 < end\n                    && list[j + 1].y > list[j].y + list[j].height\n                ) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n\n            shiftUp(end - 1, delta / 2);\n        }\n\n        // \n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0\n                    && list[j].y > list[j - 1].y + list[j - 1].height\n                ) {\n                    break;\n                }\n            }\n        }\n\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0\n                ? isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0                     // \n                : isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0;                    // \n\n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = (deltaY < r + length)\n                    ? Math.sqrt(\n                          (r + length + length2) * (r + length + length2)\n                          - deltaY * deltaY\n                      )\n                    : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX + 10;\n                }\n\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            }\n            else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            }\n            else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                }\n                else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n\n    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n\n            cx = layout.cx;\n            cy = layout.cy;\n\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            }\n            else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n                    var y3 = y2;\n\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n                }\n\n                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n            }\n            var font = labelModel.getModel('textStyle').getFont();\n\n            var labelRotate = labelModel.get('rotate')\n                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal')\n                        || data.getName(idx);\n            var textRect = textContain.getBoundingRect(\n                text, font, textAlign, 'top'\n            );\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                font: font,\n                rotation: labelRotate\n            };\n\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/pie/labelLayout.js\n// module id = 104\n// module chunks = 0 1 2","// TODO minAngle\n\n\n\n    var numberUtil = require('../../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = require('./labelLayout');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n\n    module.exports = function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n\n            if (!zrUtil.isArray(radius)) {\n                radius = [0, radius];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [center, center];\n            }\n\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n\n            var data = seriesModel.getData();\n\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\n            var clockwise = seriesModel.get('clockwise');\n\n            var roseType = seriesModel.get('roseType');\n\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n\n            var currentAngle = startAngle;\n\n            var dir = clockwise ? 1 : -1;\n            data.each('value', function (value, idx) {\n                var angle;\n                // FIXME  2.0  roseType  area \n                if (roseType !== 'area') {\n                    angle = sum === 0 ? unitRadian : (value * unitRadian);\n                }\n                else {\n                    angle = PI2 / (data.count() || 1);\n                }\n\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                }\n                else {\n                    valueSumLargerThanMinAngle += value;\n                }\n\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType\n                        ? numberUtil.linearMap(value, extent, [r0, r])\n                        : r\n                });\n\n                currentAngle = endAngle;\n            }, true);\n\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 1e-3) {\n                    var angle = PI2 / data.count();\n                    data.each(function (idx) {\n                        var layout = data.getItemLayout(idx);\n                        layout.startAngle = startAngle + dir * idx * angle;\n                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                    });\n                }\n                else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        var layout = data.getItemLayout(idx);\n                        var angle = layout.angle === minAngle\n                            ? minAngle : value * unitRadian;\n                        layout.startAngle = currentAngle;\n                        layout.endAngle = currentAngle + dir * angle;\n                        currentAngle += angle;\n                    });\n                }\n            }\n\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/chart/pie/pieLayout.js\n// module id = 105\n// module chunks = 0 1 2","'use strict';\n// TODO boundaryGap\n\n\n    require('../coord/cartesian/AxisModel');\n\n    require('./axis/AxisView');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/axis.js\n// module id = 106\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var AxisBuilder = require('./AxisBuilder');\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n    var selfBuilderAttrs = [\n        'splitArea', 'splitLine'\n    ];\n\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n\n    var AxisView = require('../../echarts').extendComponentView({\n\n        type: 'axis',\n\n        render: function (axisModel, ecModel) {\n\n            this.group.removeAll();\n\n            var oldAxisGroup = this._axisGroup;\n            this._axisGroup = new graphic.Group();\n\n            this.group.add(this._axisGroup);\n\n            if (!axisModel.get('show')) {\n                return;\n            }\n\n            var gridModel = axisModel.findGridModel();\n\n            var layout = layoutAxis(gridModel, axisModel);\n\n            var axisBuilder = new AxisBuilder(axisModel, layout);\n\n            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n            this._axisGroup.add(axisBuilder.getGroup());\n\n            zrUtil.each(selfBuilderAttrs, function (name) {\n                if (axisModel.get(name + '.show')) {\n                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n                }\n            }, this);\n\n            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitLine: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            var splitLineModel = axisModel.getModel('splitLine');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var lineColors = lineStyleModel.get('color');\n\n            var lineInterval = getInterval(splitLineModel, labelInterval);\n\n            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n            var isHorizontal = axis.isHorizontal();\n\n            var lineCount = 0;\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitLineModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var p1 = [];\n            var p2 = [];\n            // Simple optimization\n            // Batching the lines if color are the same\n            var lineStyle = lineStyleModel.getLineStyle();\n            for (var i = 0; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                if (isHorizontal) {\n                    p1[0] = tickCoord;\n                    p1[1] = gridRect.y;\n                    p2[0] = tickCoord;\n                    p2[1] = gridRect.y + gridRect.height;\n                }\n                else {\n                    p1[0] = gridRect.x;\n                    p1[1] = tickCoord;\n                    p2[0] = gridRect.x + gridRect.width;\n                    p2[1] = tickCoord;\n                }\n\n                var colorIndex = (lineCount++) % lineColors.length;\n                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line_' + ticks[i],\n\n                    shape: {\n                        x1: p1[0],\n                        y1: p1[1],\n                        x2: p2[0],\n                        y2: p2[1]\n                    },\n                    style: zrUtil.defaults({\n                        stroke: lineColors[colorIndex]\n                    }, lineStyle),\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitArea: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            var splitAreaModel = axisModel.getModel('splitArea');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n            var areaColors = areaStyleModel.get('color');\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitAreaModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\n            var count = 0;\n\n            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\n            var areaStyle = areaStyleModel.getAreaStyle();\n            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n            for (var i = 1; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                var x;\n                var y;\n                var width;\n                var height;\n                if (axis.isHorizontal()) {\n                    x = prevX;\n                    y = gridRect.y;\n                    width = tickCoord - x;\n                    height = gridRect.height;\n                }\n                else {\n                    x = gridRect.x;\n                    y = prevY;\n                    width = gridRect.width;\n                    height = tickCoord - y;\n                }\n\n                var colorIndex = (count++) % areaColors.length;\n                this._axisGroup.add(new graphic.Rect({\n                    anid: 'area_' + ticks[i],\n\n                    shape: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    style: zrUtil.defaults({\n                        fill: areaColors[colorIndex]\n                    }, areaStyle),\n                    silent: true\n                }));\n\n                prevX = x + width;\n                prevY = y + height;\n            }\n        }\n    });\n\n    AxisView.extend({\n        type: 'xAxis'\n    });\n    AxisView.extend({\n        type: 'yAxis'\n    });\n\n    /**\n     * @inner\n     */\n    function layoutAxis(gridModel, axisModel) {\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\n        var axisOffset = axisModel.get('offset') || 0;\n\n        var posMap = {\n            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n        };\n\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n        // Tick and label direction, x y is axisDim\n        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        if (axis.onZero) {\n            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n        }\n\n        if (axisModel.getModel('axisTick').get('inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (axisModel.getModel('axisLabel').get('inside')) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n\n        // Special label rotation\n        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n\n        return layout;\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component/axis/AxisView.js\n// module id = 107\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Axis = require('../Axis');\n    var axisLabelInterval = require('./axisLabelInterval');\n\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n\n    Axis2D.prototype = {\n\n        constructor: Axis2D,\n\n        /**\n         * Index of axis, can be used as key\n         */\n        index: 0,\n        /**\n         * If axis is on the zero position of the other axis\n         * @type {boolean}\n         */\n        onZero: false,\n\n        /**\n         * Axis model\n         * @param {module:echarts/coord/cartesian/AxisModel}\n         */\n        model: null,\n\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n\n        getGlobalExtent: function () {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            return ret;\n        },\n\n        /**\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                labelInterval = this._labelInterval = axisLabelInterval(this);\n            }\n            return labelInterval;\n        },\n\n        /**\n         * If label is ignored.\n         * Automatically used when axis is category and label can not be all shown\n         * @param  {number}  idx\n         * @return {boolean}\n         */\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return ((typeof labelInterval === 'function')\n                    && !labelInterval(idx, this.scale.getLabel(idx)))\n                    || idx % (labelInterval + 1);\n            }\n        },\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var localCoord = axis.toLocalCoord(80);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toLocalCoord: null,\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var globalCoord = axis.toLocalCoord(40);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toGlobalCoord: null\n\n    };\n    zrUtil.inherits(Axis2D, Axis);\n\n    module.exports = Axis2D;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/cartesian/Axis2D.js\n// module id = 117\n// module chunks = 0 1 2","'use strict';\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n\n        this._dimList = [];\n\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n\n    Cartesian.prototype = {\n\n        constructor: Cartesian,\n\n        type: 'cartesian',\n\n        /**\n         * Get axis\n         * @param  {number|string} dim\n         * @return {module:echarts/coord/Cartesian~Axis}\n         */\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n\n        /**\n         * Get axes list\n         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n         */\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n\n        /**\n         * Get axes list by given scale type\n         */\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(\n                this.getAxes(),\n                function (axis) {\n                    return axis.scale.type === scaleType;\n                }\n            );\n        },\n\n        /**\n         * Add axis\n         * @param {module:echarts/coord/Cartesian.Axis}\n         */\n        addAxis: function (axis) {\n            var dim = axis.dim;\n\n            this._axes[dim] = axis;\n\n            this._dimList.push(dim);\n        },\n\n        /**\n         * Convert data to coord in nd space\n         * @param {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n\n        /**\n         * Convert coord in nd space to data\n         * @param  {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n\n            var output = input instanceof Array ? [] : {};\n\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n\n                output[dim] = axis[method](input[dim]);\n            }\n\n            return output;\n        }\n    };\n\n    module.exports = Cartesian;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/cartesian/Cartesian.js\n// module id = 118\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Cartesian = require('./Cartesian');\n\n    function Cartesian2D(name) {\n\n        Cartesian.call(this, name);\n    }\n\n    Cartesian2D.prototype = {\n\n        constructor: Cartesian2D,\n\n        type: 'cartesian2d',\n\n        /**\n         * @type {Array.<string>}\n         * @readOnly\n         */\n        dimensions: ['x', 'y'],\n\n        /**\n         * Base axis will be used on stacking.\n         *\n         * @return {module:echarts/coord/cartesian/Axis2D}\n         */\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0]\n                || this.getAxesByScale('time')[0]\n                || this.getAxis('x');\n        },\n\n        /**\n         * If contain point\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0]))\n                && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n\n        /**\n         * If contain data\n         * @param {Array.<number>} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0])\n                && this.getAxis('y').containData(data[1]);\n        },\n\n        /**\n         * Convert series data to an array of points\n         * @param {module:echarts/data/List} data\n         * @param {boolean} stack\n         * @return {Array}\n         *  Return array of points. For example:\n         *  `[[10, 10], [20, 20], [30, 30]]`\n         */\n        dataToPoints: function (data, stack) {\n            return data.mapArray(['x', 'y'], function (x, y) {\n                return this.dataToPoint([x, y]);\n            }, stack, this);\n        },\n\n        /**\n         * @param {Array.<number>} data\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n\n        /**\n         * @param {Array.<number>} point\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n\n        /**\n         * Get other axis\n         * @param {module:echarts/coord/cartesian/Axis2D} axis\n         */\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n    };\n\n    zrUtil.inherits(Cartesian2D, Cartesian);\n\n    module.exports = Cartesian2D;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/cartesian/Cartesian2D.js\n// module id = 119\n// module chunks = 0 1 2","'use strict';\n// Grid \n//  Cartesian2D \n\n\n    require('./AxisModel');\n    var ComponentModel = require('../../model/Component');\n\n    module.exports = ComponentModel.extend({\n\n        type: 'grid',\n\n        dependencies: ['xAxis', 'yAxis'],\n\n        layoutMode: 'box',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Grid}\n         */\n        coordinateSystem: null,\n\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            // If grid size contain label\n            containLabel: false,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/cartesian/GridModel.js\n// module id = 120\n// module chunks = 0 1 2","'use strict';\n/**\n * Helper function for axisLabelInterval calculation\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('../axisHelper');\n\n    module.exports = function (axis) {\n        var axisModel = axis.model;\n        var labelModel = axisModel.getModel('axisLabel');\n        var labelInterval = labelModel.get('interval');\n        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n            return labelInterval === 'auto' ? 0 : labelInterval;\n        }\n\n        return axisHelper.getAxisLabelInterval(\n            zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis),\n            axisModel.getFormattedLabels(),\n            labelModel.getModel('textStyle').getFont(),\n            axis.isHorizontal()\n        );\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/coord/cartesian/axisLabelInterval.js\n// module id = 121\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var parsePercent = numberUtil.parsePercent;\n\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n    }\n\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n\n    function calBarWidthAndOffset(barSeries, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n\n        zrUtil.each(barSeries, function (seriesModel, idx) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category'\n                ? baseAxis.getBandWidth()\n                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\n            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n                bandWidth: bandWidth,\n                remainedWidth: bandWidth,\n                autoWidthCount: 0,\n                categoryGap: '20%',\n                gap: '30%',\n                stacks: {}\n            };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n\n            var stackId = getSeriesStackId(seriesModel);\n\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n\n            var barWidth = parsePercent(\n                seriesModel.get('barWidth'), bandWidth\n            );\n            var barMaxWidth = parsePercent(\n                seriesModel.get('barMaxWidth'), bandWidth\n            );\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n            // TODO\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            (barGap != null) && (columnsOnAxis.gap = barGap);\n            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n\n        var result = {};\n\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\n            result[coordSysName] = {};\n\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (!column.width && maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n\n        var barWidthAndOffset = calBarWidthAndOffset(\n            zrUtil.filter(\n                ecModel.getSeriesByType(seriesType),\n                function (seriesModel) {\n                    return !ecModel.isSeriesFiltered(seriesModel)\n                        && seriesModel.coordinateSystem\n                        && seriesModel.coordinateSystem.type === 'cartesian2d';\n                }\n            )\n        );\n\n        var lastStackCoords = {};\n        var lastStackCoordsOrigin = {};\n\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\n            var valueAxisStart = baseAxis.onZero\n                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n                : valueAxis.getGlobalExtent()[0];\n\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n\n            data.each(valueAxis.dim, function (value, idx) {\n                // \n                if (isNaN(value)) {\n                    return;\n                }\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                    lastStackCoordsOrigin[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n                var x;\n                var y;\n                var width;\n                var height;\n\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoordOrigin;\n                    height = columnWidth;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += width;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                }\n                else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoordOrigin;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += height;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n\n        }, this);\n    }\n\n    module.exports = barLayoutGrid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/layout/barGrid.js\n// module id = 122\n// module chunks = 0 1 2","\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/loading/default.js\n// module id = 123\n// module chunks = 0 1 2","/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var Model = require('./Model');\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = require('./Component');\n\n    var globalDefault = require('./globalDefault');\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption();\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            //  component model  merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION \n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap[mainType], newCptOptionList\n                );\n\n                makeKeyInfo(mainType, mapResult);\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap[mainType] = [];\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap[mainType][index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.series);\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap[mainType];\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap[mainType];\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts;\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap[mainType];\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q.hasOwnProperty(indexAttr)\n                        || q.hasOwnProperty(idAttr)\n                        || q.hasOwnProperty(nameAttr)\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                each(componentsMap, function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap[mainType], cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.series[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.series.slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.series, cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.series, cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.series);\n\n            var componentTypes = [];\n            each(componentsMap, function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap[componentType], function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            //  component model  merge  model \n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap[type] || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function makeKeyInfo(mainType, mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = {};\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && (idMap[existCpt.id] = item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && (idMap[opt.id] = item);\n\n            // Complete subType\n            if (isObject(opt)) {\n                var subType = determineSubType(mainType, opt, item.exist);\n                item.keyInfo = {mainType: mainType, subType: subType};\n            }\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-';\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap[keyInfo.id]);\n            }\n\n            idMap[keyInfo.id] = item;\n        });\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Series has not been initialized yet.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n\n    module.exports = GlobalModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/Global.js\n// module id = 124\n// module chunks = 0 1 2","/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            //  timeline options  media baseOption\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // resetclone\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // proformed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // mediaDefault\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/OptionManager.js\n// module id = 125\n// module chunks = 0 1 2","\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // \n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // \n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // \n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        //  Grid \n        // grid: {},\n        // \n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: true,\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        hoverLayerThreshold: 3000\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/globalDefault.js\n// module id = 126\n// module chunks = 0 1 2","\n    module.exports = {\n        getAreaStyle: require('./makeStyleMapper')(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/mixin/areaStyle.js\n// module id = 127\n// module chunks = 0 1 2","\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/mixin/boxLayout.js\n// module id = 128\n// module chunks = 0 1 2","\n    var getItemStyle = require('./makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes) {\n            var style = getItemStyle.call(this, excludes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/mixin/itemStyle.js\n// module id = 129\n// module chunks = 0 1 2","\n    var getLineStyle = require('./makeStyleMapper')(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/mixin/lineStyle.js\n// module id = 130\n// module chunks = 0 1 2","\n\n    var textContain = require('zrender/lib/contain/text');\n\n    function getShallow(model, path) {\n        return model && model.getShallow(path);\n    }\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @return {string}\n         */\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (ecModel && ecModel.get('textStyle.color'));\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            var ecModel = this.ecModel;\n            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n            return [\n                // FIXME in node-canvas fontWeight is before fontStyle\n                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n            ].join(' ');\n        },\n\n        getTextRect: function (text) {\n            var textStyle = this.get('textStyle') || {};\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                textStyle.align,\n                textStyle.baseline\n            );\n        },\n\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(\n                text, containerWidth, this.getFont(), ellipsis, options\n            );\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/model/mixin/textStyle.js\n// module id = 131\n// module chunks = 0 1 2","// Compatitable with 2.0\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var compatStyle = require('./helper/compatStyle');\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            compatStyle(seriesOpt);\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/preprocessor/backwardCompat.js\n// module id = 132\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n\n    module.exports = function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    }\n                    else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/preprocessor/helper/compatStyle.js\n// module id = 133\n// module chunks = 0 1 2","\n    var samplers = {\n        average: function (frame) {\n            var sum = 0;\n            var count = 0;\n            for (var i = 0; i < frame.length; i++) {\n                if (!isNaN(frame[i])) {\n                    sum += frame[i];\n                    count++;\n                }\n            }\n            // Return NaN if count is 0\n            return count === 0 ? NaN : sum / count;\n        },\n        sum: function (frame) {\n            var sum = 0;\n            for (var i = 0; i < frame.length; i++) {\n                // Ignore NaN\n                sum += frame[i] || 0;\n            }\n            return sum;\n        },\n        max: function (frame) {\n            var max = -Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] > max && (max = frame[i]);\n            }\n            return max;\n        },\n        min: function (frame) {\n            var min = Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] < min && (min = frame[i]);\n            }\n            return min;\n        },\n        // TODO\n        // Median\n        nearest: function (frame) {\n            return frame[0];\n        }\n    };\n\n    var indexSampler = function (frame, value) {\n        return Math.round(frame.length / 2);\n    };\n    module.exports = function (seriesType, ecModel, api) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var sampling = seriesModel.get('sampling');\n            var coordSys = seriesModel.coordinateSystem;\n            // Only cartesian2d support down sampling\n            if (coordSys.type === 'cartesian2d' && sampling) {\n                var baseAxis = coordSys.getBaseAxis();\n                var valueAxis = coordSys.getOtherAxis(baseAxis);\n                var extent = baseAxis.getExtent();\n                // Coordinste system has been resized\n                var size = extent[1] - extent[0];\n                var rate = Math.round(data.count() / size);\n                if (rate > 1) {\n                    var sampler;\n                    if (typeof sampling === 'string') {\n                        sampler = samplers[sampling];\n                    }\n                    else if (typeof sampling === 'function') {\n                        sampler = sampling;\n                    }\n                    if (sampler) {\n                        data = data.downSample(\n                            valueAxis.dim, 1 / rate, sampler, indexSampler\n                        );\n                        seriesModel.setData(data);\n                    }\n                }\n            }\n        }, this);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/processor/dataSample.js\n// module id = 134\n// module chunks = 0 1 2","/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n    var numberUtil = require('../util/number');\n\n    // Use some method of IntervalScale\n    var IntervalScale = require('./Interval');\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [approxTickNum = 10] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            intervalScaleProto.niceExtent.call(this, splitNumber, fixMin, fixMax);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = fixMin;\n            originalScale.__fixMax = fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/scale/Log.js\n// module id = 135\n// module chunks = 0 1 2","/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/scale/Ordinal.js\n// module id = 136\n// module chunks = 0 1 2","/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n\n    var IntervalScale = require('./Interval');\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME \n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        // Overwrite\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date);\n        },\n\n        // Overwrite\n        niceExtent: function (approxTickNum, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(approxTickNum);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        // Overwrite\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var niceExtent = [\n                mathCeil(extent[0] / interval) * interval,\n                mathFloor(extent[1] / interval) * interval\n            ];\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function () {\n        return new TimeScale();\n    };\n\n    module.exports = TimeScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/scale/Time.js\n// module id = 137\n// module chunks = 0 1 2","\n    var Gradient = require('zrender/lib/graphic/Gradient');\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/visual/seriesColor.js\n// module id = 138\n// module chunks = 0 1 2","'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n\n            this._hovered = hovered;\n\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = null;\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * cursor style\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * \n         *\n         * @private\n         * @param {Object} targetEl \n         * @param {string} eventName \n         * @param {Object} event \n         */\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\n            var el = targetEl;\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                if (!list[i].silent\n                 && list[i] !== exclude\n                 // getDisplayList may include ignored item in VML mode\n                 && !list[i].ignore\n                 && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hovered;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Handler.js\n// module id = 139\n// module chunks = 0 1 2","/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Layer.js\n// module id = 140\n// module chunks = 0 1 2","'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n\n    var Layer = require('./Layer');\n\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.isBuildin) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // \n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n        }\n\n        this.pathToImage = this._createPathToImage();\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n        },\n\n        /**\n         * \n         * @param {boolean} [paintAll=false] displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.isBuildin && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuildinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuildinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.isBuildin) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         *  zlevel \n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.isBuildin = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(\n                        layer.dom,\n                        prevDom.nextSibling\n                    );\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n\n            layersMap[zlevel] = layer;\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuildinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (! layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuildinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // \n            this.eachBuildinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * hover\n         */\n        clear: function () {\n            this.eachBuildinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * zlevel\n         *\n         * @param {string} zlevel\n         * @param {Object} config \n         * @param {string} [config.clearColor=0] \n         * @param {string} [config.motionBlur=false] \n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 alpha\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {number} zlevel zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * \n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * \n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            return imageLayer.dom;\n        },\n        /**\n         * \n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * \n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        _pathToImage: function (id, path, width, height, dpr) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [0, 0, 0];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                id: id,\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        },\n\n        _createPathToImage: function () {\n            var me = this;\n\n            return function (id, e, width, height) {\n                return me._pathToImage(\n                    id, e, width, height, me.dpr\n                );\n            };\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Painter.js\n// module id = 141\n// module chunks = 0 1 2","'use strict';\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n    var env = require('./core/env');\n\n    var Group = require('./container/Group');\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // idmap\n        this._elements = {};\n\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [update=false] \n         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n         *\n         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * \n         * GroupShapeShape\n         * zlevel > z > \n         * @param {boolean} [includeIgnore=false]  ignore \n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var clipPath = el.clipPath;\n            if (clipPath) {\n                // clipPath  group \n                clipPath.parent = el;\n                clipPath.updateTransform();\n\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                    clipPaths.push(clipPath);\n                }\n                else {\n                    clipPaths = [clipPath];\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {string|Array.<string>} [elId] Storage\n         */\n        delRoot: function (elId) {\n            if (elId == null) {\n                // elId\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n\n            var el;\n            if (typeof(elId) == 'string') {\n                el = this._elements[elId];\n            }\n            else {\n                el = elId;\n            }\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n\n            this._elements[el.id] = el;\n\n            return this;\n        },\n\n        get: function (elId) {\n            return this._elements[elId];\n        },\n\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Storage\n         */\n        dispose: function () {\n            this._elements =\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/Storage.js\n// module id = 142\n// module chunks = 0 1 2","'use strict';\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = require('./requestAnimationFrame');\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         *  clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         *  animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * \n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * \n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * \n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * \n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * \n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * animator\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] \n         * @param  {Function} [options.getter=null]\n         *         gettergetter\n         * @param  {Function} [options.setter=null]\n         *         settersetter\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Animation.js\n// module id = 143\n// module chunks = 0 1 2","/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n\n        // \n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            var percent = (globalTime - this._startTime) / this._life;\n\n            // \n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n\n            this._needsRemove = false;\n        },\n\n        fire: function(eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/Clip.js\n// module id = 144\n// module chunks = 0 1 2","/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // t^3\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // t^4\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // t^5\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // sin(t)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 2^t\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // sqrt(1-t^2)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/animation/easing.js\n// module id = 145\n// module chunks = 0 1 2","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/arc.js\n// module id = 146\n// module chunks = 0 1 2","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/cubic.js\n// module id = 147\n// module chunks = 0 1 2","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // \n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc \n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                //  subpath \n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE  L, C, Q  NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    //  arc \n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // \n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr scale, x\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        //  subpath \n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/contain/path.js\n// module id = 148\n// module chunks = 0 1 2","'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = require('./event');\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/GestureMgr.js\n// module id = 149\n// module chunks = 0 1 2","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function() {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function(val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function(entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function(entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function() {\n        return this._len;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function(val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function(maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     */\n    LRUProto.put = function(key, value) {\n        var list = this._list;\n        var map = this._map;\n        if (map[key] == null) {\n            var len = list.len();\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n            }\n\n            var entry = list.insert(value);\n            entry.key = key;\n            map[key] = entry;\n        }\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function(key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function() {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/core/LRU.js\n// module id = 150\n// module chunks = 0 1 2","\n\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null),\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        if (gestureInfo) {\n            // eventTool.stop(event);\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n    function useTouchEvent() {\n        return env.touchEventsSupported;\n    }\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // rootdommouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        }\n    };\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        for (var i = 0; i < touchHandlerNames.length; i++) {\n            var name = touchHandlerNames[i];\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        }\n\n        for (var i = 0; i < mouseHandlerNames.length; i++) {\n            var name = mouseHandlerNames[i];\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        }\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (useTouchEvent()) {\n            mountHandlers(touchHandlerNames, this);\n\n            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n            // addEventListener(root, 'mouseout', this._mouseoutHandler);\n        }\n\n        // Considering some devices that both enable touch and mouse event (like MS Surface\n        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n        // mouse event can not be handle in those devices.\n        mountHandlers(mouseHandlerNames, this);\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/dom/HandlerProxy.js\n// module id = 151\n// module chunks = 0 1 2","// CompoundPath to improve performance\n\n\n    var Path = require('./Path');\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/CompoundPath.js\n// module id = 152\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/RadialGradient.js\n// module id = 153\n// module chunks = 0 1 2","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/roundRect.js\n// module id = 154\n// module chunks = 0 1 2","/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothBezier.js\n// module id = 155\n// module chunks = 0 1 2","/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/helper/smoothSpline.js\n// module id = 156\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Arc.js\n// module id = 157\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/BezierCurve.js\n// module id = 158\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Circle.js\n// module id = 159\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Line.js\n// module id = 160\n// module chunks = 0 1 2","/**\n * \n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polygon.js\n// module id = 161\n// module chunks = 0 1 2","/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Polyline.js\n// module id = 162\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // r1r2r3r4\n            // r1          [1, 1, 1, 1]\n            // r[1]        [1, 1, 1, 1]\n            // r[1, 2]     [1, 2, 1, 2]\n            // r[1, 2, 3]  [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Rect.js\n// module id = 163\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Ring.js\n// module id = 164\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/graphic/shape/Sector.js\n// module id = 165\n// module chunks = 0 1 2","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * \n         *\n         * @param {string} path a.b.c\n         * @param {boolean} [loop] \n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Animatable.js\n// module id = 166\n// module chunks = 0 1 2","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    module.exports = Draggable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/mixin/Draggable.js\n// module id = 167\n// module chunks = 0 1 2","\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/path.js\n// module id = 168\n// module chunks = 0 1 2","\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i++] += x;\n                    // cy\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/zrender/lib/tool/transformPath.js\n// module id = 169\n// module chunks = 0 1 2"],"sourceRoot":""}